<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【stm32单片机】[操作系统][RT-Thread][1]内核与线程</title>
      <link href="/posts/64776/"/>
      <url>/posts/64776/</url>
      
        <content type="html"><![CDATA[<h1 id="裸机开发与操作系统的区别"><a class="markdownIt-Anchor" href="#裸机开发与操作系统的区别"></a> 裸机开发与操作系统的区别</h1><h2 id="裸机开发"><a class="markdownIt-Anchor" href="#裸机开发"></a> 裸机开发</h2><ul><li>单一任务（阻塞式）</li><li>手动分配资源</li><li>缺乏抽象层</li><li>灵活性、实时性较高</li></ul><h2 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h2><ul><li>多任务调度</li><li>自动资源管理</li><li>硬件抽象层</li></ul><h1 id="rt-thread的线程"><a class="markdownIt-Anchor" href="#rt-thread的线程"></a> RT-Thread的线程</h1><h2 id="线程的概念"><a class="markdownIt-Anchor" href="#线程的概念"></a> 线程的概念</h2><p>在RT-thread中，线程是最小的工作单元。每个线程负责一个任务。RT-Thread根据线程的优先级决定哪个任务先完成.。</p><p>RT-Thread 支持多达 256 个优先级。0是最高的优先级。</p><h2 id="线程的组成部分"><a class="markdownIt-Anchor" href="#线程的组成部分"></a> 线程的组成部分</h2><ol><li>线程控制块：线程的名字，线程要执行的任务，线程的优先级，线程的状态</li><li>线程栈：保存临时数据</li><li>入口函数：线程的任务内容</li></ol><h2 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h2><p>线程有五种工作状态：</p><ol><li>初始状态：线程创建还未使用</li><li>就绪状态：线程准备好，但是没有拿到资源</li><li>运行状态：线程正在执行任务，占用CPU</li><li>挂起状态：线程暂时停止工作</li><li>关闭状态：线程的任务完成了，线程结束，不再使用</li></ol><h2 id="线程的优先级"><a class="markdownIt-Anchor" href="#线程的优先级"></a> 线程的优先级</h2><p>RT-Thread支持256个优先级</p><h2 id="时间片"><a class="markdownIt-Anchor" href="#时间片"></a> 时间片</h2><p>时间片是线程允许工作的时间。如果多个线程的优先级相同，则根据”时间片“，执行完任务A后再执行任务B，轮询进行。</p><h1 id="rt-thread工程"><a class="markdownIt-Anchor" href="#rt-thread工程"></a> RT-Thread工程</h1><h2 id="rt-thread项目创建"><a class="markdownIt-Anchor" href="#rt-thread项目创建"></a> RT-Thread项目创建</h2><img src="/posts/64776/image-20241017014526806.png" class="" title="image-20241017014526806"><p>RT-Thread工程创建完毕，硬件底层还没有初始化，需要我们自己进行配置</p><p>点击CubeMX_Setting进行联调</p><img src="/posts/64776/image-20241017014950565.png" class="" title="image-20241017014950565"><p>CubeMX完成RCC、时钟树、串口、工程选项等关键配置后，生成代码，关闭CubeMX</p><p>在RT-Thread Studio中生成了CubemxI相关文件</p><p>进行编译后，出现一个小bug</p><img src="/posts/64776/image-20241017020104564.png" class="" title="image-20241017020104564"><p>这个时候，需要我们将API更换掉</p><p>对cubemx文件夹下的main.c进行分析，发现被进行了弱定义</p><img src="/posts/64776/image-20241017020406174.png" class="" title="image-20241017020406174"><p>转到RT-thread重定义的main.c</p><p>结论：RT-Thread对Hal库进行了硬件层的抽象</p><img src="/posts/64776/image-20241017020503940.png" class="" title="image-20241017020503940"><p>RT-Thread初始化默认集成了Shell</p><img src="/posts/64776/image-20241017021855733.png" class="" title="image-20241017021855733"><h2 id="创建线程"><a class="markdownIt-Anchor" href="#创建线程"></a> 创建线程</h2><p>函数API</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> (*entry)(<span class="type">void</span> *parameter),</span></span><br><span class="line"><span class="params">                             <span class="type">void</span>       *parameter,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint8_t</span>  priority,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint32_t</span> tick)</span></span><br></pre></td></tr></tbody></table></figure><p>程序实现</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建线程*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义入口函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span>  *parameter)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        rt_kprintf(<span class="string">"Thread1 is running, count:%d\n"</span>,count);</span><br><span class="line">        count++;</span><br><span class="line">        rt_thread_delay(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*创建线程1*/</span></span><br><span class="line">    <span class="comment">//tid为线程id，线程名称为thread1,入口函数为thread1_entry，入口参数为RT_NULL即无入口参数</span></span><br><span class="line">    <span class="comment">//堆栈空间设置为1024</span></span><br><span class="line">    <span class="comment">//优先级为20</span></span><br><span class="line">    <span class="comment">//时间片为10</span></span><br><span class="line">    tid1 = rt_thread_create(<span class="string">"thread1"</span>,</span><br><span class="line">                             thread1_entry,RT_NULL,</span><br><span class="line">                             <span class="number">1024</span>,<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*启动线程*/</span></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL){<span class="comment">//判断身份id是否为空</span></span><br><span class="line">        rt_thread_startup(tid1);<span class="comment">//激活线程</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>编译后烧写</p><p>实验结果：线程在循环运行</p><img src="/posts/64776/image-20241017023340933.png" class="" title="image-20241017023340933"><blockquote><p>rt_thread_delay()的作用：</p><ul><li>休眠当前进程，释放CPU资源</li><li>将任务挂起</li></ul><p>rt_thread_delay(1000)即任务以1000ms周期运行</p><p>注意：</p><ul><li>时间片是允许运行的时间</li><li>rt_thread_delay作用是运行的周期，并且是非阻塞的。</li></ul></blockquote><p>多线程创建</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建线程*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid1 = RT_NULL;<span class="comment">//储存线程信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid2 = RT_NULL;<span class="comment">//储存线程信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程1入口函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span>  *parameter)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        rt_kprintf(<span class="string">"Thread1 is running, count:%d\n"</span>,count);</span><br><span class="line">        count++;</span><br><span class="line">        rt_thread_delay(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*线程2入口函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span>  *parameter)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        rt_kprintf(<span class="string">"Thread2 is running, count:%d\n"</span>,count);</span><br><span class="line">        count++;</span><br><span class="line">        rt_thread_delay(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*创建线程1*/</span></span><br><span class="line">    tid1 = rt_thread_create(<span class="string">"thread1"</span>,</span><br><span class="line">                             thread1_entry,RT_NULL,</span><br><span class="line">                             <span class="number">1024</span>,<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建线程1*/</span></span><br><span class="line">    tid2 = rt_thread_create(<span class="string">"thread2"</span>,</span><br><span class="line">                             thread2_entry,RT_NULL,</span><br><span class="line">                             <span class="number">1024</span>,<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*启动线程*/</span></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL){rt_thread_startup(tid1);}<span class="comment">//线程1不为空，激活线程</span></span><br><span class="line">    <span class="keyword">if</span>(tid2 != RT_NULL){rt_thread_startup(tid2);}<span class="comment">//线程2不为空，激活线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】-Hal库-嵌入式-6-PWM、输入捕获</title>
      <link href="/posts/12030/"/>
      <url>/posts/12030/</url>
      
        <content type="html"><![CDATA[<h1 id="按键状态机与回调函数的封装思想"><a class="markdownIt-Anchor" href="#按键状态机与回调函数的封装思想"></a> # 按键状态机与回调函数的封装思想</h1><h1 id="一-pwm配置"><a class="markdownIt-Anchor" href="#一-pwm配置"></a> 一、PWM配置</h1><blockquote><p>生成频率为1000HZ的PWM信号，占空比可调</p></blockquote><h2 id="1-cubemx配置"><a class="markdownIt-Anchor" href="#1-cubemx配置"></a> 1. CubeMX配置</h2><ul><li>选择Internal(内部时钟)</li></ul><img src="/posts/12030/image-20241015222342274.png" class="" title="image-20241015222342274"><p>根据CubeMX的芯片引脚图，选中引脚后的相关外设提示，可以便捷的配置定时器的作用通道</p><img src="/posts/12030/image-20241015222740979.png" class="" title="image-20241015222216707"><p>定时器PWM相关配置项</p><p>这里50有误，应该改为500——&gt;对应50%的占空比</p><img src="/posts/12030/image-20241015223259551.png" class="" title="image-20241015223259551"><h1 id="二-输入捕获"><a class="markdownIt-Anchor" href="#二-输入捕获"></a> 二、输入捕获</h1><h2 id="1-cubemx配置-2"><a class="markdownIt-Anchor" href="#1-cubemx配置-2"></a> 1. CubeMX配置</h2><img src="/posts/12030/image-20241015230019438.png" class="" title="image-20241015230019438"><p><strong>Slave Mode</strong>: Reset Mode</p><ul><li><p><strong>从模式 (Slave Mode)</strong>：在定时器中，“Slave Mode” 是指定时器可以被外部信号触发或由另一个定时器控制。定时器可以通过外部输入或其他定时器的输出信号来复位、启动或停止。</p></li><li><p><strong>Reset Mode</strong>：在从模式的复位模式下，每当触发事件发生时，定时器的计数器（CNT寄存器）会被重置。这对于需要周期性重置定时器的应用很有用。</p></li></ul><p><strong>Trigger Source</strong>: TI1FP1</p><ul><li><strong>触发源 (Trigger Source)</strong>：TI1FP1 通常表示 “Timer Input 1 Filtered Pin 1”，即定时器通道1的输入引脚（TI1）的滤波信号。这个触发源指示定时器使用来自外部引脚的输入信号作为触发源。</li><li>TI1FP1 作为触发源意味着定时器的操作（如复位）将根据 TI1 引脚接收到的信号进行控制。</li></ul><p><strong>Clock Source</strong>: Internal Clock</p><ul><li><p><strong>时钟源 (Clock Source)</strong>：内部时钟意味着定时器使用微控制器内部的时钟源作为定时器的时间基准。通常，内部时钟是处理器的时钟或系统时钟（如 <code>HCLK</code> 或 <code>PCLK</code>）。</p></li><li><p>使用内部时钟意味着定时器的计数将基于微控制器的时钟频率进行递增，直到外部触发信号（例如 TI1FP1）复位它。</p></li></ul><p><strong>Channel1</strong>: Input Capture direct mode</p><ul><li><p><strong>通道1 (Channel 1)</strong>：配置为输入捕获模式意味着定时器的通道1正在监视一个外部信号（通过 TI1 引脚），并在检测到信号变化（如上升沿或下降沿）时捕获当前计数器值。</p></li><li><p><strong>Direct mode</strong>：直通模式表示信号直接进入输入捕获模块，而<mark>没有通过滤波器或其他复杂处理</mark>。这通常用于<mark>快速响应</mark>的<mark>输入捕获</mark>操作。</p></li></ul><blockquote><p>思考：为什么输入捕获要设置为从模式？</p></blockquote><img src="/posts/12030/image-20241015230241742.png" class="" title="image-20241015230241742"><img src="/posts/12030/image-20241016190503917.png" class="" title="image-20241016190503917"><p>DMA转运TIM通道1数据</p><img src="/posts/12030/image-20241015230459480.png" class="" title="image-20241015230459480"><p>继续配置PA15</p><img src="/posts/12030/image-20241015230709867.png" class="" title="image-20241015230709867"><blockquote><p>问题：通过输入捕获测出来频率可能为4000</p><p>解决方法：使用不同的定时器通道进行输入捕获</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[Hal库][嵌入式][5]IIC,RTC</title>
      <link href="/posts/27956/"/>
      <url>/posts/27956/</url>
      
        <content type="html"><![CDATA[<h1 id="iic模块"><a class="markdownIt-Anchor" href="#iic模块"></a> IIC模块</h1><h2 id="一-mcp4017"><a class="markdownIt-Anchor" href="#一-mcp4017"></a> 一、MCP4017</h2><p>MCP4017 是一款由 Microchip Technology 公司生产的数字电位器。它是一种电子元件，通常用于调整电压、增益或信号强度，类似于传统的机械电位器，但可以通过数字控制来调节。</p><p>以下是 MCP4017 的一些主要特点：</p><ol><li><strong>数字电位器</strong>：MCP4017 是一个单通道的 7 位数字电位器，分辨率为 128 个不同的电阻值（2^7 = 128 步）。</li><li><strong>I²C 接口</strong>：它使用 I²C 通信协议进行控制，通过两个引脚（SCL 和 SDA）与主设备通信。I²C 是一种广泛使用的双线通信协议，适合用于低速设备。</li><li><strong>低功耗</strong>：MCP4017 设计为低功耗设备，适合需要节能的应用场景。</li><li><strong>电阻范围</strong>：MCP4017 提供了不同的电阻范围，常见的型号包括 5kΩ、10kΩ、50kΩ 和 100kΩ 等。用户可以通过 I²C 指令在这些范围内调节电阻值。</li><li><strong>非易失性存储器</strong>：该器件不带非易失性存储器（EEPROM），因此每次上电后，电位器的默认设置是中间值（即 64/128 的位置）。</li><li><strong>应用场景</strong>：MCP4017 常用于音频调节、信号处理、传感器校准等需要精确调节电阻的场合。</li></ol><h2 id="二-阅读芯片手册"><a class="markdownIt-Anchor" href="#二-阅读芯片手册"></a> 二、阅读芯片手册</h2><p>I2C地址：0101111</p><img src="/posts/27956/image-20241007234812331.png" class="" title="image-20241007234812331"><h2 id="三-hal库api"><a class="markdownIt-Anchor" href="#三-hal库api"></a> 三、Hal库API</h2><h2 id="四-cubemx配置"><a class="markdownIt-Anchor" href="#四-cubemx配置"></a> 四、CubeMX配置</h2><blockquote><h2 id="rtc"><a class="markdownIt-Anchor" href="#rtc"></a> RTC :</h2><p>STM32 的 <strong>RTC</strong>（实时时钟）是集成在 STM32 微控制器中的一个外设，用于保持时间和日期信息，即使在主系统电源断电时也能继续工作。STM32 的 RTC 是独立的、低功耗的，可以通过外部备用电源（如纽扣电池）或内置备用电源来运行。</p><h3 id="stm32-rtc-的主要功能"><a class="markdownIt-Anchor" href="#stm32-rtc-的主要功能"></a> STM32 RTC 的主要功能：</h3><ol><li><strong>实时时钟</strong>：提供年、月、日、星期、小时、分钟、秒的时间和日期计时功能。</li><li><strong>闹钟功能</strong>：STM32 的 RTC 可以设置定时闹钟，在指定时间触发事件，常用于定时唤醒或触发任务。</li><li><strong>时间戳</strong>：能够记录事件发生时的精确时间，例如在外部中断或特定事件发生时。</li><li><strong>周期性唤醒</strong>：RTC 支持通过定时唤醒系统进入低功耗模式，如待机模式或休眠模式，帮助实现低功耗设计。</li><li><strong>低功耗</strong>：RTC 在超低功耗模式下运行，可以使用独立的低速时钟源（如 LSE，外部 32.768 kHz 晶振）或内部低速时钟（LSI）。</li></ol><h3 id="rtc-的时钟源"><a class="markdownIt-Anchor" href="#rtc-的时钟源"></a> RTC 的时钟源</h3><p>STM32 的 RTC 通常依赖于一个低速的时钟源来保持准确的时间。常见的时钟源有：</p><ul><li><strong>LSE (Low-Speed External)</strong>：外部 32.768 kHz 晶振，精度高，适合精确计时。</li><li><strong>LSI (Low-Speed Internal)</strong>：内部低速 RC 振荡器，功耗低，但精度较差。</li></ul><h3 id="常见应用场景"><a class="markdownIt-Anchor" href="#常见应用场景"></a> 常见应用场景：</h3><ul><li><strong>电子钟表、日历</strong>：嵌入式系统中经常需要长时间保持准确时间的设备。</li><li><strong>低功耗设计</strong>：通过 RTC 实现系统定时唤醒和进入低功耗模式，节省电池能量。</li><li><strong>时间戳记录</strong>：在数据记录系统或日志系统中，RTC 用于标记数据生成的时间。</li></ul></blockquote><h3 id="配置rtc"><a class="markdownIt-Anchor" href="#配置rtc"></a> 配置RTC</h3><img src="/posts/27956/image-20241008003141122.png" class="" title="image-20241008003141122"><ul><li>Activate Clock Source：激活时钟源</li><li>Activate Calendar：激活日历</li></ul><h3 id="配置时钟树"><a class="markdownIt-Anchor" href="#配置时钟树"></a> 配置时钟树</h3><img src="/posts/27956/image-20241008003433105.png" class="" title="image-20241008003433105"><img src="/posts/27956/image-20241008003518489.png" class="" title="image-20241008003518489"><p>Asynchronous Predivider和Synchronous Predivider是用来分频的两个寄存器，RTC的时钟源（LSE、LSI或HSE/32）需要经过这些分频器后，才能提供给RTC时钟</p><ul><li>Asynchronous Predivider value：异步预分器值，125，通常用于降低功耗，</li><li>Synchronous Predivider value：同步预分频器值，6000，用于精确调节RTC的计时</li></ul><p>6000 x 125 = 750KHz，速度最快，精度最高</p><img src="/posts/27956/image-20241008003736355.png" class="" title="image-20241008003736355"><ul><li>二进制</li><li>时、分、秒</li></ul><h2 id="五-编写底层驱动"><a class="markdownIt-Anchor" href="#五-编写底层驱动"></a> 五、编写底层驱动</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_app.h"</span></span></span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef time;<span class="comment">//定义时间结构体</span></span><br><span class="line">RTC_DataTypeDef date;<span class="comment">//定义日期结构体</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    HAL_RTC_GetTime(&amp;hrtc,&amp;time,RTC_FORMAT_BIN);</span><br><span class="line">    HAL_RTC_GetDate(&amp;hrtc,&amp;date,RTC_FORMAT_BIN);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"bsp_system.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_proc</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>HAL库源码</strong></p><p>1.RTC数据类型</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Time structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint8_t</span> Hours;            <span class="comment">/*!&lt; Specifies the RTC Time Hour.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the RTC_HourFormat_12 is selected.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the RTC_HourFormat_24 is selected */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Minutes;          <span class="comment">/*!&lt; Specifies the RTC Time Minutes.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Seconds;          <span class="comment">/*!&lt; Specifies the RTC Time Seconds.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> TimeFormat;       <span class="comment">/*!&lt; Specifies the RTC AM/PM Time.</span></span><br><span class="line"><span class="comment">                                 This parameter can be a value of @ref RTC_AM_PM_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> SubSeconds;     <span class="comment">/*!&lt; Specifies the RTC_SSR RTC Sub Second register content.</span></span><br><span class="line"><span class="comment">                                 This parameter corresponds to a time unit range between [0-1] Second</span></span><br><span class="line"><span class="comment">                                 with [1 Sec / SecondFraction +1] granularity */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> SecondFraction;  <span class="comment">/*!&lt; Specifies the range or granularity of Sub Second register content</span></span><br><span class="line"><span class="comment">                                 corresponding to Synchronous pre-scaler factor value (PREDIV_S)</span></span><br><span class="line"><span class="comment">                                 This parameter corresponds to a time unit range between [0-1] Second</span></span><br><span class="line"><span class="comment">                                 with [1 Sec / SecondFraction +1] granularity.</span></span><br><span class="line"><span class="comment">                                 This field will be used only by HAL_RTC_GetTime function */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DayLightSaving;  <span class="comment">/*!&lt; This interface is deprecated. To manage Daylight Saving Time,</span></span><br><span class="line"><span class="comment">                                 please use HAL_RTC_DST_xxx functions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> StoreOperation;  <span class="comment">/*!&lt; This interface is deprecated. To manage Daylight Saving Time,</span></span><br><span class="line"><span class="comment">                                 please use HAL_RTC_DST_xxx functions */</span></span><br><span class="line">} RTC_TimeTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Date structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint8_t</span> WeekDay;  <span class="comment">/*!&lt; Specifies the RTC Date WeekDay.</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_WeekDay_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Month;    <span class="comment">/*!&lt; Specifies the RTC Date Month (in BCD format).</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_Month_Date_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Date;     <span class="comment">/*!&lt; Specifies the RTC Date.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Year;     <span class="comment">/*!&lt; Specifies the RTC Date Year.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */</span></span><br><span class="line">} RTC_DateTypeDef;</span><br></pre></td></tr></tbody></table></figure><p>2.RTC函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, <span class="type">uint32_t</span> Format)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">uint32_t</span> tmpreg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_RTC_FORMAT(Format));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get subseconds structure field from the corresponding register*/</span></span><br><span class="line">  sTime-&gt;SubSeconds = READ_REG(hrtc-&gt;Instance-&gt;SSR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get SecondFraction structure field from the corresponding register field*/</span></span><br><span class="line">  sTime-&gt;SecondFraction = (<span class="type">uint32_t</span>)(READ_REG(hrtc-&gt;Instance-&gt;PRER) &amp; RTC_PRER_PREDIV_S);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TR register */</span></span><br><span class="line">  tmpreg = (<span class="type">uint32_t</span>)(READ_REG(hrtc-&gt;Instance-&gt;TR) &amp; RTC_TR_RESERVED_MASK);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fill the structure fields with the read parameters */</span></span><br><span class="line">  sTime-&gt;Hours = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_HT | RTC_TR_HU)) &gt;&gt; RTC_TR_HU_Pos);</span><br><span class="line">  sTime-&gt;Minutes = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_MNT | RTC_TR_MNU)) &gt;&gt; RTC_TR_MNU_Pos);</span><br><span class="line">  sTime-&gt;Seconds = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_ST | RTC_TR_SU)) &gt;&gt; RTC_TR_SU_Pos);</span><br><span class="line">  sTime-&gt;TimeFormat = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_PM)) &gt;&gt; RTC_TR_PM_Pos);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the input parameters format */</span></span><br><span class="line">  <span class="keyword">if</span> (Format == RTC_FORMAT_BIN)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">/* Convert the time structure parameters to Binary format */</span></span><br><span class="line">    sTime-&gt;Hours = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Hours);</span><br><span class="line">    sTime-&gt;Minutes = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Minutes);</span><br><span class="line">    sTime-&gt;Seconds = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Seconds);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HAL_OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>枚举类型：HAL_StatusTypeDef</strong></p><blockquote><p>typedef enum<br>{<br>HAL_OK       = 0x00U,<br>HAL_ERROR    = 0x01U,<br>HAL_BUSY     = 0x02U,<br>HAL_TIMEOUT  = 0x03U<br>} HAL_StatusTypeDef;</p></blockquote><p>Hal库封装的一个典型思想</p></blockquote><h2 id="多串口重定向-适合项目复用"><a class="markdownIt-Anchor" href="#多串口重定向-适合项目复用"></a> 多串口重定向-适合项目复用</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> {</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">512</span>];<span class="comment">//创建字符缓冲区</span></span><br><span class="line">    va_list arg;<span class="comment">//创建可变参数列表</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    va_start(arg, format);<span class="comment">// 初始化可变参数列表，获取my_printf传入的可变参数</span></span><br><span class="line">    len = vsnprintf(buffer, <span class="keyword">sizeof</span>(buffer), format, arg);<span class="comment">// 将格式化后的可变参数传入缓存区</span></span><br><span class="line">    va_end(arg);<span class="comment">// 结束可变参数列表</span></span><br><span class="line">    HAL_UART_Transmit(huart, (<span class="type">uint8_t</span> *)buffer, (<span class="type">uint16_t</span>)len, <span class="number">0xFF</span>); <span class="comment">// 将字符缓存数组发送出去</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[Hal库][嵌入式][4]ADC采集系统</title>
      <link href="/posts/26676/"/>
      <url>/posts/26676/</url>
      
        <content type="html"><![CDATA[<h1 id="vscode配置stm32编译调试环境"><a class="markdownIt-Anchor" href="#vscode配置stm32编译调试环境"></a> <strong># <mark>VsCode配置STM32编译调试环境</mark></strong></h1><p><a href="https://www.bilibili.com/video/BV1BJeJehEkb/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7026df729530ac261e29b43864230918">【保姆】vscode配置单片机编译调试烧录环境（以STM32为例）_哔哩哔哩_bilibili</a></p><h1 id="一-adc采集系统"><a class="markdownIt-Anchor" href="#一-adc采集系统"></a> 一、ADC采集系统</h1><h2 id="1-adc通道外部电路"><a class="markdownIt-Anchor" href="#1-adc通道外部电路"></a> 1. ADC通道(外部电路)</h2><img src="/posts/26676/image-20241001005738016.png" class="" title="image-20241001005738016"><h2 id="2-功能要求"><a class="markdownIt-Anchor" href="#2-功能要求"></a> 2. 功能要求</h2><img src="/posts/26676/image-20241001005805205.png" class="" title="image-20241001005805205"><h2 id="3-动态窗口"><a class="markdownIt-Anchor" href="#3-动态窗口"></a> 3. <mark>动态窗口</mark></h2><img src="/posts/26676/image-20241001005817305.png" class="" title="image-20241001005817305"><p><strong>"动态"的含义：3秒的实时采集<mark>窗口</mark>随着时间自行移动，adc采集的值动态实时更新在3s的窗口数据内</strong></p><img src="/posts/26676/image-20241001010344145.png" class="" title="image-20241001010344145"><h1 id="二-功能实现"><a class="markdownIt-Anchor" href="#二-功能实现"></a> 二、功能实现</h1><h2 id="1-adc解算"><a class="markdownIt-Anchor" href="#1-adc解算"></a> 1. ADC解算</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//双通道DMA</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">adc_proc</span><span class="params">()</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) </span><br><span class="line">{</span><br><span class="line">adc_value[<span class="number">0</span>] += (<span class="type">float</span>)dma_buff[<span class="number">0</span>][i]; </span><br><span class="line">adc_value[<span class="number">1</span>] += (<span class="type">float</span>)dma_buff[<span class="number">1</span>][i];</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10进制模拟量电压</span></span><br><span class="line"><span class="comment">//adc_value[0] = adc_value[0] / 30 *3.3f / 4096; </span></span><br><span class="line"><span class="comment">//adc_value[1] = adc_value[1] / 30 *3.3f / 4096;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不对分辨率和参考电压进行解算</span></span><br><span class="line">    <span class="comment">//16进制数字量电压</span></span><br><span class="line">adc_value[<span class="number">0</span>] = adc_value[<span class="number">0</span>] / (<span class="number">30</span>+<span class="number">1</span>);</span><br><span class="line">adc_value[<span class="number">1</span>] = adc_value[<span class="number">1</span>] / (<span class="number">30</span>+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-lcd底层实现"><a class="markdownIt-Anchor" href="#2-lcd底层实现"></a> 2. LCD底层实现</h2><h3 id="21-变量定义"><a class="markdownIt-Anchor" href="#21-变量定义"></a> 2.1 <strong>变量定义</strong></h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> lcd_disp_mode;<span class="comment">//lcd显示模式</span></span><br><span class="line"><span class="type">uint16_t</span> ph_value;<span class="comment">//PH值</span></span><br><span class="line"><span class="type">uint16_t</span> pd_value;<span class="comment">//PD值</span></span><br></pre></td></tr></tbody></table></figure><p>参数界面</p><img src="/posts/26676/image-20240929225356591.png" class="" title="image-20240929225356591"><p>记录界面</p><img src="/posts/26676/image-20240929225307555.png" class="" title="image-20240929225307555"><h3 id="22-lcd进程"><a class="markdownIt-Anchor" href="#22-lcd进程"></a> 2.2 <strong>LCD进程</strong></h3><p>由于4T官方提供的LCD底层驱动，当显示的数据位数增加时，显示的位数会增加，但是当位数减小时，却不能对旧的数据进行清空。</p><p>所以这里用“空格”来覆盖刷新，达到位数减小显示缩减的效果。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span>(lcd_disp_mode){</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            LCD_Sprintf(Line1,<span class="string">"        DATA"</span>);</span><br><span class="line">            LCD_Sprintf(Line3,<span class="string">"   R37:%d    "</span>,(<span class="type">int</span>)adc_value[<span class="number">0</span>]);</span><br><span class="line">            LCD_Sprintf(Line4,<span class="string">"   R38:%d    "</span>,(<span class="type">int</span>)adc_value[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="lcd背光-问题"><a class="markdownIt-Anchor" href="#lcd背光-问题"></a> #<mark>LCD背光 问题</mark></h3><p><strong>现象：如图所示，只有在对LCD写入的片段，LCD才有正常的背景</strong></p><img src="/posts/26676/3ee14bc0dc0d49a3647ae193e51b544.jpg" class="" title="3ee14bc0dc0d49a3647ae193e51b544"><p><strong>原因：未对LCD进行初始化清屏</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">system_init();</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_Clear(Black);</span><br><span class="line">LCD_SetTextColor(White);</span><br><span class="line">LCD_SetBackColor(Black);</span><br><span class="line">scheduler_init();</span><br></pre></td></tr></tbody></table></figure><p><strong>来源：lcd.c</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_Clear</span></span><br><span class="line"><span class="comment">* Description    : Clears the hole LCD.</span></span><br><span class="line"><span class="comment">* Input          : Color: the color of the background.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Clear</span><span class="params">(u16 Color)</span></span><br><span class="line">{</span><br><span class="line">    u32 index = <span class="number">0</span>;</span><br><span class="line">    LCD_SetCursor(<span class="number">0x00</span>, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; <span class="number">76800</span>; index++)</span><br><span class="line">    {</span><br><span class="line">        LCD_WR_DATA(Color);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="23-led功能和初始化状态"><a class="markdownIt-Anchor" href="#23-led功能和初始化状态"></a> 2.3 LED功能和初始化状态</h3><img src="/posts/26676/image-20241001001209075.png" class="" title="image-20241001001209075"><h3 id="24-lcd底层完整代码实现"><a class="markdownIt-Anchor" href="#24-lcd底层完整代码实现"></a> 2.4 LCD底层完整代码实现</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"bsp_system.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> lcd_disp_mode;    <span class="comment">// lcd显示模式</span></span><br><span class="line"><span class="type">uint16_t</span> ph_value = <span class="number">2000</span>; <span class="comment">// PH值</span></span><br><span class="line"><span class="type">uint16_t</span> pd_value = <span class="number">1000</span>; <span class="comment">// PD值</span></span><br><span class="line"><span class="type">uint16_t</span> vh_value;        <span class="comment">// PH值</span></span><br><span class="line"><span class="type">uint16_t</span> vd_value;        <span class="comment">// PD值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  格式化字符串并显示在指定的LCD行上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数接受一个行号和一个格式化字符串（类似于printf），</span></span><br><span class="line"><span class="comment"> * 格式化字符串后，将其显示在LCD的指定行上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  Line    要显示字符串的LCD行号。</span></span><br><span class="line"><span class="comment"> * @param  format  格式化字符串，后跟要格式化的参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数内部使用 `vsprintf` 来格式化字符串，然后</span></span><br><span class="line"><span class="comment"> * 调用 `LCD_DisplayStringLine` 在LCD上显示格式化后的字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例用法:</span></span><br><span class="line"><span class="comment"> * @code</span></span><br><span class="line"><span class="comment"> * LcdSprintf(0, "Temperature: %d C", temperature);</span></span><br><span class="line"><span class="comment"> * @endcode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdSprintf</span><span class="params">(<span class="type">uint8_t</span> Line, <span class="type">char</span> *format, ...)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> String[<span class="number">21</span>];                     <span class="comment">// 缓冲区用于存储格式化后的字符串</span></span><br><span class="line">    va_list arg;                         <span class="comment">// 参数列表用于存储可变参数</span></span><br><span class="line">    va_start(arg, format);               <span class="comment">// 使用格式化字符串初始化参数列表</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(String, format, arg);       <span class="comment">// 格式化字符串并存储在缓冲区中</span></span><br><span class="line">    va_end(arg);                         <span class="comment">// 清理参数列表</span></span><br><span class="line">    LCD_DisplayStringLine(Line, String); <span class="comment">// 在LCD的指定行显示格式化后的字符串</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (lcd_disp_mode)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//测量界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        DATA"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   R37:%d    "</span>, (<span class="type">int</span>)adc_value[<span class="number">0</span>]);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   R38:%d    "</span>, (<span class="type">int</span>)adc_value[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//参数界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        PARA"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   PH:%d    "</span>, ph_value);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   PD:%d    "</span>, pd_value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//参数界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        RECD"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   VH:%d    "</span>, vh_value);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   VD:%d    "</span>, vd_value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-按键底层"><a class="markdownIt-Anchor" href="#3-按键底层"></a> 3. 按键底层</h2><p>uwTick：在Systick（系统滴答定时器）中断中自增，可以用作单片机运行的时间戳</p><p><a href="https://cloud.tencent.com/developer/article/1861964">HAL库与Cubemx系列|Systick-系统滴答定时器详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h3 id="31-按键处理进程"><a class="markdownIt-Anchor" href="#31-按键处理进程"></a> 3.1 按键处理进程</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> ph_pd_flag; <span class="comment">//参数修改切换标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键处理函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数用于扫描按键的状态，并更新按键按下和释放的标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// 读取当前按键状态</span></span><br><span class="line">key_val = key_read();</span><br><span class="line"><span class="comment">// 计算按下的按键（当前按下状态与前一状态异或，并与当前状态相与）</span></span><br><span class="line">key_down = key_val &amp; (key_old ^ key_val);</span><br><span class="line"><span class="comment">// 计算释放的按键（当前未按下状态与前一状态异或，并与前一状态相与）</span></span><br><span class="line">key_up = ~key_val &amp; (key_old ^ key_val);</span><br><span class="line"><span class="comment">// 更新前一按键状态</span></span><br><span class="line">key_old = key_val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key_down == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">ph_pd_flag ^= <span class="number">1</span>;<span class="comment">//参数选择标志位取反</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lcd_disp_mode == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">key_tick = uwTick; <span class="comment">//记录按键按下时的时间</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(key_up == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(lcd_disp_mode == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(uwTick - key_tick &gt; <span class="number">2000</span>)</span><br><span class="line">{</span><br><span class="line">key_tick = <span class="number">0</span>;<span class="comment">//清理按键时间戳</span></span><br><span class="line">vd_value = vh_value = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (key_down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span> (++lcd_disp_mode == <span class="number">3</span>)<span class="comment">//模式切换</span></span><br><span class="line">{</span><br><span class="line">lcd_disp_mode = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)<span class="comment">//参数切换界面s</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//创建一个指针，根据参数选择标志位切换指向</span></span><br><span class="line"><span class="comment">//这样，使用逻辑语句和一个指针变量就可以实现对两个参数的地址指向-&gt;数据内容更改</span></span><br><span class="line"><span class="type">uint16_t</span> *p = (ph_pd_flag) ? &amp;ph_value : &amp;pd_value;</span><br><span class="line">*p += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*p &gt; <span class="number">4096</span>)</span><br><span class="line">{</span><br><span class="line">*p = <span class="number">4096</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> *p = (ph_pd_flag) ? &amp;ph_value : &amp;pd_value;</span><br><span class="line">*p -= <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="number">65536</span> - <span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-adc采集"><a class="markdownIt-Anchor" href="#4-adc采集"></a> 4. adc采集</h2><h3 id="41-变量定义"><a class="markdownIt-Anchor" href="#41-变量定义"></a> 4.1 变量定义</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//DMA接收缓存</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];<span class="comment">//ADC采样数组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINDOWS_SIZE 3000 <span class="comment">//动态窗口的大小为3秒</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">adc_data_t</span> adc_buffer[BUFFER_SIZE];<span class="comment">//adc采集周期为100ms,动态窗口大小为3s</span></span><br><span class="line"><span class="type">int</span> buffer_start = <span class="number">0</span>;<span class="comment">//头指针</span></span><br><span class="line"><span class="type">int</span> buffer_end = <span class="number">0</span>;<span class="comment">//尾指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> vd_flag;<span class="comment">//标志位，表示当前窗口内是否检测到突变</span></span><br></pre></td></tr></tbody></table></figure><h3 id="42-添加数据到动态串口缓冲区"><a class="markdownIt-Anchor" href="#42-添加数据到动态串口缓冲区"></a> 4.2 添加数据到动态串口（缓冲区）</h3><p>本例中,ADC采样的环形缓冲区比较特殊，具备动态时间窗口的特性</p><ul><li>和一般的环形缓冲区一样，具备头指针和尾指针的概念，环形存取数据。</li><li>缓冲区具备“时间窗口”的概念，那么就要让缓冲区中最<mark>老</mark>的数据，存在时间不能超过三秒，超过则移除（实际上是写指针移位，相当于队这个无用的数据不再进行读取，环形缓冲区中读取数据，就相当于将这个数据移除缓存区，因为索引指针不会再指向这个数据。）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief添加adc采集数据，当前时间到adc缓冲区(环形)</span></span><br><span class="line"><span class="comment">  * @paramadc采集数据，当前时间，指定的buffer</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_adc_data</span><span class="params">(<span class="type">uint32_t</span> adc,<span class="type">uint32_t</span> current_time,<span class="type">adc_data_t</span> *buffer)</span></span><br><span class="line">{</span><br><span class="line">buffer[buffer_end].timestamp = current_time;<span class="comment">//记录当前时间到尾指针指向的缓冲区</span></span><br><span class="line">buffer[buffer_end].adc = adc;<span class="comment">//记录adc采集值到尾指针指向的缓冲区 </span></span><br><span class="line"></span><br><span class="line">buffer_end = (buffer_end + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//表示尾指针自加，0~30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer_end == buffer_start)<span class="comment">// 如果缓冲区满了，调整buffer_start，使得窗口始终保持在3秒内</span></span><br><span class="line">{</span><br><span class="line">buffer_start = (buffer_start + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//头指针移位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前时间是否超过窗口时间戳3秒，即操作时间超过3秒,// 移除超出3秒窗口的数据</span></span><br><span class="line"><span class="keyword">while</span>((current_time - buffer[buffer_start].timestamp &gt; WINDOWS_SIZE))</span><br><span class="line">{</span><br><span class="line">buffer_start = (buffer_start + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//头指针移位</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="43-检查缓冲区的突变"><a class="markdownIt-Anchor" href="#43-检查缓冲区的突变"></a> 4.3 检查缓冲区的突变</h3><p>对当前窗口进行极大值，极小值的检测。</p><p>注意区分极大值，极小值和最大值最小值的区别。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief检测当前窗口是否发生ADC突变</span></span><br><span class="line"><span class="comment">  * @param突变计数，adc缓冲区</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_adc_sudden_change</span><span class="params">(<span class="type">uint16_t</span> *sudden_change_count,<span class="type">adc_data_t</span> *buffer)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> f_max = buffer[buffer_start].adc;</span><br><span class="line"><span class="comment">// uint16_t f_min = buffer[buffer_end].adc;</span></span><br><span class="line"><span class="type">uint16_t</span> f_min = buffer[buffer_start].adc;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = buffer_start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(index != buffer_end)<span class="comment">//读取完整个环形缓冲区</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//极大值</span></span><br><span class="line"><span class="keyword">if</span>(buffer[index].adc &gt; f_max)</span><br><span class="line">{</span><br><span class="line">f_max = buffer[index].adc;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//极小值</span></span><br><span class="line"><span class="keyword">if</span>(buffer[index].adc &lt; f_min)</span><br><span class="line">{</span><br><span class="line">f_min = buffer[index].adc;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//指针加1</span></span><br><span class="line">index = (index + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> diff = f_max - f_min;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测ADC突变</span></span><br><span class="line"><span class="keyword">if</span>(diff &lt; pd_value)</span><br><span class="line">{</span><br><span class="line">vd_flag = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vd_flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">vd_flag = <span class="number">0</span>;</span><br><span class="line">(*sudden_change_count) ++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ucLed[<span class="number">2</span>] = (diff &gt; pd_value)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="44-adc解析进程"><a class="markdownIt-Anchor" href="#44-adc解析进程"></a> 4.4 ADC解析进程</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_proc</span><span class="params">()</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Time_tick = HAL_GetTick();<span class="comment">//获取当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> vh_flag;<span class="comment">//超限标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对adc1,adc2两个adc通道进行数据采集</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) </span><br><span class="line">{</span><br><span class="line">adc_value[<span class="number">0</span>] += (<span class="type">float</span>)dma_buff[<span class="number">0</span>][i]; <span class="comment">//采集30次</span></span><br><span class="line">adc_value[<span class="number">1</span>] += (<span class="type">float</span>)dma_buff[<span class="number">1</span>][i]; <span class="comment">//采集30次</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">adc_value[<span class="number">0</span>] = adc_value[<span class="number">0</span>] / (<span class="number">30</span> + <span class="number">1</span>); <span class="comment">//采集30后，但是累加值是(30+1)次，因为采集30次之前本身adc_value[0]就有值</span></span><br><span class="line">adc_value[<span class="number">1</span>] = adc_value[<span class="number">1</span>] / (<span class="number">30</span> + <span class="number">1</span>); <span class="comment">//否则会出现如采集到的ADC值大于4096的现象</span></span><br><span class="line"></span><br><span class="line">add_adc_data(adc_value[<span class="number">0</span>],Time_tick,adc_buffer);<span class="comment">//将adc采集值写入缓冲区</span></span><br><span class="line">check_adc_sudden_change(&amp;vd_value,adc_buffer);<span class="comment">//判断是否发生值突变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(adc_value[<span class="number">1</span>] &lt; ph_value) </span><br><span class="line">{</span><br><span class="line">vh_flag = <span class="number">0</span>; <span class="comment">//当adc_value小于参数时，标志位才会置0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vh_flag == <span class="number">0</span>) <span class="comment">// adc_value大于参数且标志位为0</span></span><br><span class="line">{</span><br><span class="line">vh_flag = <span class="number">1</span>;<span class="comment">//标志位置1</span></span><br><span class="line">vh_value++;<span class="comment">//超限次数加1</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-led底层"><a class="markdownIt-Anchor" href="#5-led底层"></a> 5. LED底层</h2><h2 id="51-led显示进程"><a class="markdownIt-Anchor" href="#51-led显示进程"></a> 5.1 LED显示进程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief LED 显示处理函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每次调用该函数时，LED 灯根据 ucLed 数组中的值来决定是开启还是关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 显示当前 Led_Pos 位置的 LED 灯状态</span></span><br><span class="line">    ucLed[<span class="number">0</span>] = (lcd_disp_mode == <span class="number">0</span>);<span class="comment">//当前界面为数据采集时LED1点亮 </span></span><br><span class="line">    ucLed[<span class="number">1</span>] = adc_value[<span class="number">1</span>] &gt; ph_value ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ucLed[2] = (adc_value[0] &gt; pd_value);//放入窗口突变判断中</span></span><br><span class="line">    </span><br><span class="line">    led_disp(ucLed);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-串口通信"><a class="markdownIt-Anchor" href="#6-串口通信"></a> 6. 串口通信</h2><h3 id="61-串口通信进程"><a class="markdownIt-Anchor" href="#61-串口通信进程"></a> 6.1 串口通信进程</h3><blockquote><p><strong><code>sscanf</code></strong>:</p><ul><li><code>sscanf</code> 是一个格式化输入函数，主要用于从字符串中提取数据。</li><li>它按照指定的格式读取输入字符串，并将解析后的数据存储到指定的变量中。</li><li>语法：<code>int sscanf(const char *str, const char *format, ...)</code></li></ul><p><strong><code>strcmp</code></strong>:</p><ul><li><code>strcmp</code> 是一个字符串比较函数，用于比较两个字符串是否相等。</li><li>它返回一个整数，表示两个字符串的字典顺序。</li><li>语法：<code>int strcmp(const char *str1, const char *str2)</code></li><li>返回值：<ul><li>小于 0：<code>str1</code> 小于 <code>str2</code></li><li>等于 0：<code>str1</code> 等于 <code>str2</code></li><li>大于 0：<code>str1</code> 大于 <code>str2</code></li></ul></li></ul><p>总结：</p><p>sscanf：将stream内容取出，并根据入口参数的格式化过滤内容，取出数据</p><p>strcmp：比较两个字符串的内容</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb)) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 从环形缓冲区读取数据到读取缓冲区 </span></span><br><span class="line">ringbuffer_read(&amp;usart_rb, usart_read_buffer, usart_rb.itemCount);</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> value;</span><br><span class="line"><span class="type">uint16_t</span> *p = <span class="literal">NULL</span>;<span class="comment">//创建一个空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析串口数据，如果匹配，那么将解释后的数据存入value中</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sscanf</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"$PD(%hu)"</span>,&amp;value) == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">        <span class="comment">// 指针指向pd_value</span></span><br><span class="line">p = &amp;pd_value;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sscanf</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"$PH(%hu)"</span>,&amp;value) == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">        <span class="comment">// 指针指向ph_value</span></span><br><span class="line">p = &amp;ph_value;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"#VH"</span>) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VH:%d\n"</span>,vh_value);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"#VD"</span>) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VD:%d\n"</span>,vd_value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数范围是否合法</span></span><br><span class="line"><span class="keyword">if</span>(value &lt; <span class="number">4096</span>)</span><br><span class="line">{</span><br><span class="line">        <span class="comment">// 通过指针解引用修改数据</span></span><br><span class="line">*p = value; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(usart_read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * BUUFER_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[RM电控][1]开发板的使用与CAN总线控制3508电机</title>
      <link href="/posts/31666/"/>
      <url>/posts/31666/</url>
      
        <content type="html"><![CDATA[<h1 id="一-a板介绍"><a class="markdownIt-Anchor" href="#一-a板介绍"></a> 一、A板介绍*</h1><ul><li>A板外部晶振为12MHZ，最高主频为168MHZ</li></ul><h1 id="二-can总线通信原理"><a class="markdownIt-Anchor" href="#二-can总线通信原理"></a> 二、CAN总线通信原理</h1><h2 id="1-can总线是什么"><a class="markdownIt-Anchor" href="#1-can总线是什么"></a> 1. CAN总线是什么</h2><h3 id="11-can总线简介"><a class="markdownIt-Anchor" href="#11-can总线简介"></a> 1.1 CAN总线简介</h3><p>​CAN 是 Controller Area Network 的缩写，最初是汽车行业为了减少车身上的线束，而且还能进行大量数据的高速通信，由德国电气商博世公司在1986 年开发出的面向汽车的通信协议。现在，CAN 的高性能和可靠性已被认同，并被广泛地应用于工业自动化、船舶、医疗设备、工业设备等方面。RM的电机（3508、2006、6020）的控制也采用了CAN协议进行通信。<br>CAN 总线由 CAN_H 和 CAN_L 一对差分线构成，各个设备一起挂载在总线上。</p><p>参考文章：<a href="https://blog.csdn.net/weixin_54448108/article/details/125881138">【RoboMaster】从零开始控制RM电机（2）-CAN通信原理及电调通信协议_can通讯 同步触发控制电机-CSDN博客</a></p><h3 id="12-can通信的特点"><a class="markdownIt-Anchor" href="#12-can通信的特点"></a> 1.2 CAN通信的特点</h3><p><strong>1) 多主控制</strong><br>多个单元同时开始发送时，发送高优先级 ID 消息的单元可获得发送权。</p><p><strong>2) 消息的发送</strong></p><p>所有的消息由固定格式发送，标识符（Identifier 以下称为 ID）决定优先级。</p><p><strong>3) 通信速度</strong></p><p>同一CAN总线网络，所有单元必须同一通信速率。</p><h2 id="2-can通信协议"><a class="markdownIt-Anchor" href="#2-can通信协议"></a> 2. CAN通信协议</h2><h3 id="21-帧的种类"><a class="markdownIt-Anchor" href="#21-帧的种类"></a> 2.1 帧的种类</h3><p>CAN通信由五种帧类型</p><img src="/posts/31666/88d8d711fa24f37edff930d2be7b5e5d.png" class="" title="在这里插入图片描述"><p>其中数据帧和遥控帧有标准格式和扩展格式两种格式。</p><p>标准格式有 11 个位的标识符（Identifier: 以下称 ID），扩展格式有 29 个位的 ID。</p><p>控制RM电机使用标准帧。</p><h3 id="22-数据帧"><a class="markdownIt-Anchor" href="#22-数据帧"></a> 2.2 数据帧</h3><p>CAN总线数据帧的帧结构：</p><p>主要处理</p><img src="/posts/31666/7cec510a164a96bf6d346eee189c9cee.png" class="" title="在这里插入图片描述"><ol><li>帧起始<br>表示数据帧开始的段。</li><li>仲裁场<br>表示该帧优先级的段。</li><li>控制场<br>表示数据的字节数及保留位的段。</li><li>数据场<br>数据的内容，可发送 0～8 个字节的数据。</li><li>CRC 场<br>检查帧的传输错误的段。</li><li>应答场<br>表示确认正常接收的段。</li><li>帧结尾<br>表示数据帧结束的段。</li></ol><h5 id="1仲裁场"><a class="markdownIt-Anchor" href="#1仲裁场"></a> (1)仲裁场</h5><p>CAN 的 ID 分为标准 ID 和 拓展 ID 两类，每个设备都有自己独有的ID，CAN通信通过仲裁ID决定优先级。</p><h5 id="2控制场"><a class="markdownIt-Anchor" href="#2控制场"></a> (2)控制场</h5><p>控制场由 6 个位构成，表示数据段的字节数，C620电调的数据段长度为8</p><img src="/posts/31666/b63bd68d7d77e03f2e2bfed4439523e7.png" class="" title="在这里插入图片描述"><h5 id="3数据场"><a class="markdownIt-Anchor" href="#3数据场"></a> (3)数据场</h5><p>如果控制场的DLC表示为DRRR，CAN 总线的一个数据帧中所需要传输的有效数据实际上就是这 8Byte。这8字节的排列顺序为从高到低。</p><img src="/posts/31666/0519eb8c409db49546fc1b6b25fcd174.png" class="" title="在这里插入图片描述"><h1 id="三-电调通信"><a class="markdownIt-Anchor" href="#三-电调通信"></a> 三、电调通信</h1><h2 id="1-m3508m2006电机"><a class="markdownIt-Anchor" href="#1-m3508m2006电机"></a> 1. M3508&amp;M2006电机</h2><p>这两种电机代码通用</p><ul><li>M3508使用C620电调</li><li>M2006使用C610电调</li></ul><h3 id="11-单片机-数据帧-电调"><a class="markdownIt-Anchor" href="#11-单片机-数据帧-电调"></a> 1.1 单片机-&gt;数据帧-&gt;电调</h3><p>单片机向电调发送控制指令控制电调的<mark>电流输出</mark>。</p><p>一个数据帧只能给四个电机发送数据，</p><p>控制前四个电机时将ID设为 0x200</p><p>控制后四个电机时将ID设为 0x1FF</p><img src="/posts/31666/1af85c7b717809c098b68813f8100bb1.png" class="" title="img"><h3 id="12-电调-数据帧-单片机"><a class="markdownIt-Anchor" href="#12-电调-数据帧-单片机"></a> 1.2 电调-&gt;数据帧-&gt;单片机</h3><p>为了实现闭环控制，单片机需要接收电调的反馈报文得到电机的转速、机械转子角度、实时电流数据。</p><p>根据接收到的<mark>ID</mark>判断是哪一个电调的数据，电调反馈报文ID规定为 0x200+电调ID(1-8),如0x201(电调ID为1)。</p><img src="/posts/31666/89de834dbe0df93d0de87c331cc4970f.png" class="" title="在这里插入图片描述"><h2 id="2-gm6020电机"><a class="markdownIt-Anchor" href="#2-gm6020电机"></a> 2. GM6020电机</h2><h3 id="21-发送"><a class="markdownIt-Anchor" href="#21-发送"></a> 2.1 发送</h3><img src="/posts/31666/f5cec08ec56db6f2c90f9cd3b1b886b5.png" class="" title="在这里插入图片描述"><h3 id="22-接收"><a class="markdownIt-Anchor" href="#22-接收"></a> 2.2 接收</h3><img src="/posts/31666/d8dde436c117927177cdeeb6b356c8a7.png" class="" title="在这里插入图片描述"><h2 id="3-cubemx配置can总线协议"><a class="markdownIt-Anchor" href="#3-cubemx配置can总线协议"></a> 3. CubeMX配置CAN总线协议</h2><ul><li>波特率要设置成1M</li></ul><h2 id="4-程序实现"><a class="markdownIt-Anchor" href="#4-程序实现"></a> 4. 程序实现</h2><h3 id="41-can数据帧发送"><a class="markdownIt-Anchor" href="#41-can数据帧发送"></a> 4.1 CAN数据帧发送</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置并发送电机控制命令</span></span><br><span class="line"><span class="comment"> * @param hcan CAN句柄</span></span><br><span class="line"><span class="comment"> * @param STDID 标准ID</span></span><br><span class="line"><span class="comment"> * @param motor1 电机1控制值</span></span><br><span class="line"><span class="comment"> * @param motor2 电机2控制值</span></span><br><span class="line"><span class="comment"> * @param motor3 电机3控制值</span></span><br><span class="line"><span class="comment"> * @param motor4 电机4控制值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_motor_cmd</span><span class="params">(CAN_HandleTypeDef *hcan, <span class="type">uint32_t</span> STDID,</span></span><br><span class="line"><span class="params">                   <span class="type">int16_t</span> motor1, <span class="type">int16_t</span> motor2, <span class="type">int16_t</span> motor3, <span class="type">int16_t</span> motor4)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> send_mail_box;  <span class="comment">// 定义一个变量用于存储发送邮箱编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置发送消息的标识符</span></span><br><span class="line">    CANx_tx_message.StdId = STDID;</span><br><span class="line">    CANx_tx_message.IDE = CAN_ID_STD;  <span class="comment">// 标识符选择位，STD-标准帧</span></span><br><span class="line">    CANx_tx_message.RTR = CAN_RTR_DATA;  <span class="comment">// 定义帧类型</span></span><br><span class="line">    CANx_tx_message.DLC = <span class="number">0x08</span>;  <span class="comment">// 数据帧长度为8位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充要发送的数据</span></span><br><span class="line">    CANx_send_data[<span class="number">0</span>] = motor1 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">1</span>] = motor1;</span><br><span class="line">    CANx_send_data[<span class="number">2</span>] = motor2 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">3</span>] = motor2;</span><br><span class="line">    CANx_send_data[<span class="number">4</span>] = motor3 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">5</span>] = motor3;</span><br><span class="line">    CANx_send_data[<span class="number">6</span>] = motor4 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">7</span>] = motor4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送CAN数据</span></span><br><span class="line">    HAL_CAN_AddTxMessage(hcan, &amp;CANx_tx_message, CANx_send_data, &amp;send_mail_box);  <span class="comment">// hal库CAN发送函数：该函数用于向发送邮箱添加发送报文，并激活发送请求</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="42-can数据帧接收"><a class="markdownIt-Anchor" href="#42-can数据帧接收"></a> 4.2 CAN数据帧接收</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief CAN接收回调函数</span></span><br><span class="line"><span class="comment"> *        处理CAN接收到的数据帧</span></span><br><span class="line"><span class="comment"> * @param hcan CAN句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_CAN_RxFifo0MsgPendingCallback</span><span class="params">(CAN_HandleTypeDef *hcan)</span></span><br><span class="line">{</span><br><span class="line">    CAN_RxHeaderTypeDef RX_Header;  <span class="comment">// 定义数据帧的帧头</span></span><br><span class="line">    <span class="type">uint8_t</span> RX_BUFFER[<span class="number">8</span>];           <span class="comment">// 接收存放数据帧数据的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取CAN接收到的数据帧并存入局部变量</span></span><br><span class="line">    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &amp;RX_Header, RX_BUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断接收的是CAN1还是CAN2</span></span><br><span class="line">    <span class="keyword">if</span> (hcan == &amp;hcan1) {</span><br><span class="line">        <span class="comment">// CAN1：通过反馈数据的ID确定这一组数据存放的地址</span></span><br><span class="line">        i = RX_Header.StdId - Chassis_3508A;</span><br><span class="line">        Motor_measure_fun(&amp;Motor_measure[i], RX_BUFFER);  <span class="comment">// 调用函数把数据存入结构体数组</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (hcan == &amp;hcan2) {</span><br><span class="line">        <span class="comment">// CAN2：通过反馈数据的ID确定这一组数据存放的地址</span></span><br><span class="line">        i = RX_Header.StdId - CAN2_3508_ID1 + <span class="number">7</span>;</span><br><span class="line">        Motor_measure_fun(&amp;Motor_measure[i], RX_BUFFER);  <span class="comment">// 调用函数把数据存入结构体数组</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[Hal库][嵌入式][3]UART、DMA、ADC</title>
      <link href="/posts/24028/"/>
      <url>/posts/24028/</url>
      
        <content type="html"><![CDATA[<h1 id="一-串口中断超时解析"><a class="markdownIt-Anchor" href="#一-串口中断超时解析"></a> 一、串口中断+超时解析</h1><h2 id="1-cubemx配置"><a class="markdownIt-Anchor" href="#1-cubemx配置"></a> 1. CubeMX配置</h2><h2 id="11-属性配置"><a class="markdownIt-Anchor" href="#11-属性配置"></a> 1.1 <strong>属性配置</strong></h2><p>主要配置波特率，其余默认</p><style>.huraludvixti{}</style><img src="/posts/24028/image-20240919224239733.png" class="huraludvixti" alt="image-20240919224239733"><p><strong>中断配置</strong></p><p>Preemption Priority：抢占优先级</p><p>Sub Priority: 子优先级</p><img src="/posts/24028/image-20240919224306805.png" class="" title="image-20240919224306805"><p><strong>串口的DMA设置</strong></p><p>只开接收DMA即可</p><p>DMA的模式：</p><ul><li>Normol</li><li>Circual</li></ul><img src="/posts/24028/image-20240919224441445.png" class="" title="image-20240919224441445"><img src="/posts/24028/image-20240919224501610.png" class="" title="image-20240919224501610"><h2 id="2-驱动程序编写"><a class="markdownIt-Anchor" href="#2-驱动程序编写"></a> 2. 驱动程序编写</h2><h3 id="21-串口重定向"><a class="markdownIt-Anchor" href="#21-串口重定向"></a> 2.1 串口重定向</h3><p><strong>在uasrt.c中进行修改</strong></p><img src="/posts/24028/image-20240919225413251.png" class="" title="image-20240919225413251"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE * str)</span></span><br><span class="line">{</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,(<span class="type">uint8_t</span> *)&amp;ch,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="22-app_uartc-变量定义"><a class="markdownIt-Anchor" href="#22-app_uartc-变量定义"></a> 2.2 <strong>app_uart.c 变量定义</strong></h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> uart_rx_index = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> uart_tx_ticks = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br></pre></td></tr></tbody></table></figure><h3 id="23-中断初始化"><a class="markdownIt-Anchor" href="#23-中断初始化"></a> 2.3 <strong>中断初始化</strong></h3><p>放入Core-&gt;Src-&gt;usart.c中</p><p>在初始化中使能串口中断，往buffer中每次填充一个字节，触发中断回调</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart1,uart_rx_buffer,<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><img src="/posts/24028/image-20240920223856904.png" class="" title="image-20240920223856904"><blockquote><p><mark>Hal库——中断回调函数</mark></p><p>在 STM32 的 HAL（硬件抽象层）库中，<strong>中断回调函数</strong>用于处理各种外设的中断事件。这些回调函数由 HAL 库提供，用户只需实现这些函数以响应特定的中断。</p><h3 id="1-一般函数-vs-回调函数"><a class="markdownIt-Anchor" href="#1-一般函数-vs-回调函数"></a> 1. <strong>一般函数 vs. 回调函数</strong></h3><ul><li><p><strong>逻辑限定普通函数的调用</strong>：</p><ul><li>逻辑条件通常在调用函数之前进行检查，确保在满足特定条件时再执行该函数。</li><li>这种方式在函数内部或外部使用条件语句（如 <code>if</code>）来控制函数的执行。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">normalFunction</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (condition) {  <span class="comment">// 条件检查</span></span><br><span class="line">        normalFunction();  <span class="comment">// 仅在条件满足时调用</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>回调函数</strong>：</p><ul><li>回调函数通过传递函数指针来实现灵活的调用，调用发生在某个事件或特定条件下。</li><li>这种机制允许外部函数（如事件处理或异步操作）在需要时调用传递的回调，而不需要直接控制逻辑。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callbackFunction</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line">        </span><br><span class="line"><span class="type">void</span> <span class="title function_">eventHandler</span><span class="params">(<span class="type">void</span> (*callback)())</span> {</span><br><span class="line">    <span class="comment">// 某个事件发生后调用回调</span></span><br><span class="line">    callback();  <span class="comment">// 不需要在这里检查条件</span></span><br><span class="line">}</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    eventHandler(callbackFunction);  <span class="comment">// 传递回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="2-中断函数-vs-回调函数"><a class="markdownIt-Anchor" href="#2-中断函数-vs-回调函数"></a> 2. <strong>中断函数 vs. 回调函数</strong></h3><ul><li><strong>中断函数</strong>：<ul><li>直接处理外设中断的代码，通常是在中断服务例程 (ISR) 中实现。</li><li>代码较为复杂，涉及中断向量、优先级、屏蔽等设置。</li><li>可能会引入较长的中断处理时间，不适合执行复杂的任务。</li></ul></li><li><strong>回调函数</strong>：<ul><li>是一个更高层次的抽象，允许用户在中断发生时执行特定的处理逻辑。</li><li>HAL 库提供的回调函数允许用户定义中断后要执行的操作，而不需要直接修改中断服务例程。</li><li>更易于维护和调试，因为用户只需关注回调函数的逻辑，而不需要管理中断相关的低层实现。</li></ul></li></ul></blockquote><h3 id="24-回调函数声明"><a class="markdownIt-Anchor" href="#24-回调函数声明"></a> 2.4 回调函数声明</h3><p><strong>弱定义</strong></p><img src="/posts/24028/image-20240915220013260.png" class="" title="image-20240915220013260"><img src="/posts/24028/image-20240920223951975.png" class="" title="image-20240920223951975"><p><strong>自定义回调函数</strong></p><p>可以自行声明与弱定义回调函数同名的函数，会优先执行自定义的函数</p><p>Hal库中各种弱定义都是用__weak修饰的</p><img src="/posts/24028/image-20240915220050996.png" class="" title="image-20240915220050996"><p>过程：串口接收-&gt;触发回调-&gt;进入回调函数</p><p>PS: void HAL_UART_RxCpliCallback(UART_HandleTypeDef *huart) 不要用成 void HAL_UART_TxCpliCallback(UART_HandleTypeDef *huart)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(huart-&gt;Instance == USART1)</span><br><span class="line">    {</span><br><span class="line">        uart_rx_ticks = uwTick;</span><br><span class="line">        uart_rx_index++;<span class="comment">//索引自增</span></span><br><span class="line">        <span class="comment">//每次触发回调，都要重新初始化接收中断，定义接收的位置</span></span><br><span class="line">        HAL_UART_Receive_IT(&amp;huart1,&amp;uart_r_buffer[uart_rx_index],<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="25-串口解析"><a class="markdownIt-Anchor" href="#25-串口解析"></a> 2.5 串口解析</h3><p><strong>超时解析</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(uart_rx_index == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(uwTick - uart_rx_ticks &gt; <span class="number">100</span>)<span class="comment">//时间超过100</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"uart data:%s\n"</span>,uart_rx_buffer);<span class="comment">//发送串口接收内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span> (uart_rx_buffer,<span class="number">0</span>,uart_rx_index);<span class="comment">//清空</span></span><br><span class="line">        uart_rx_index = <span class="number">0</span>;<span class="comment">//指针指令</span></span><br><span class="line">        huart1.pRxBuffPtr = uart_rx_buffer;<span class="comment">//uart1缓存区指针指向buffer</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="无dma和环形缓冲区的问题"><a class="markdownIt-Anchor" href="#无dma和环形缓冲区的问题"></a> <strong># <mark>无DMA和环形缓冲区的问题</mark></strong></h2><blockquote><p><strong>当串口接收速率过快时，如视觉上位机频繁向单片机发送识别到的坐标数据，可能会导致单片机程序阻塞</strong></p><p><mark><strong>1. 串口阻塞的解决方案</strong></mark></p><img src="/posts/24028/image-20240919233036903.png" class="" title="image-20240919233036903"><p>DMA:数据转运</p><p>RingBuffer:环形缓存区</p><p><mark><strong>2. # 环形缓冲区的概念：</strong></mark></p><ul><li>头指针</li><li>尾指针</li></ul></blockquote><h2 id="现象"><a class="markdownIt-Anchor" href="#现象"></a> # 现象：</h2><h3 id="1-串口无解析发送上位机"><a class="markdownIt-Anchor" href="#1-串口无解析发送上位机"></a> 1. 串口无解析发送上位机</h3><p>CubeMX未定义串口引脚，未注意STM32外设引脚可复用问题</p><img src="/posts/24028/image-20240920234311280.png" class="" title="image-20240920234311280"><h3 id="2-回调函数名称错误"><a class="markdownIt-Anchor" href="#2-回调函数名称错误"></a> 2. 回调函数名称错误</h3><img src="/posts/24028/image-20240920231957317.png" class="" title="image-20240920231957317"><h1 id="二-dma空闲中断"><a class="markdownIt-Anchor" href="#二-dma空闲中断"></a> 二、DMA+空闲中断</h1><h2 id="dma的作用"><a class="markdownIt-Anchor" href="#dma的作用"></a> # DMA的作用</h2><blockquote><p>无DMA：数据-&gt;Uart寄存器-&gt;CPU访问Uart寄存器-&gt;执行其他程序部分</p><p>​-------如果串口通信速率过快------&gt;CPU频繁访问Uart寄存器--------&gt;程序阻塞</p><p>有DMA：数据-&gt;Uart-&gt;DMA访问Uart数据-&gt;存放到单片机内存地址</p><p>​CPU与DMA并行工作</p></blockquote><p>在上述配置的基础上对程序文件进行进一步修改。</p><h2 id="空闲中断"><a class="markdownIt-Anchor" href="#空闲中断"></a> # 空闲中断</h2><blockquote><h3 id="1-什么是空闲中断"><a class="markdownIt-Anchor" href="#1-什么是空闲中断"></a> 1. 什么是空闲中断？</h3><p>空闲中断（Idle Line Interrupt）是串口通信（UART）中常用的一种硬件中断机制。它用于检测串口接收线路在一段时间内没有接收到数据时触发。<strong>空闲中断的核心原理是检测 UART 外设的接收线路在数据传输结束后变为“空闲”状态</strong>（即，停止接收数据，线路上没有任何活动）。</p><p>当串口在接收数据时，硬件会自动维护一个“忙状态”标志。所有数据帧（包括起始位、数据位和停止位）都被接收完成后，接收线路进入空闲状态，此时 UART 硬件会触发“空闲中断”。这个中断标志仅在接收数据后首次空闲时触发，而不是每次线路空闲都会触发。因此，空闲中断能够用于判断数据帧的结束或检测数据包的传输完成。(比如，一个数据帧的长度为8个字节，在串口通信时每帧间隔一个字节来发送，在间隔的这个字节，触发空闲中断，进而可以在中断程序中处理数据帧)</p><h3 id="2-空闲中断在串口通信中的作用"><a class="markdownIt-Anchor" href="#2-空闲中断在串口通信中的作用"></a> 2. 空闲中断在串口通信中的作用</h3><p>空闲中断主要用于处理非固定长度的串口数据帧和高效的 DMA（Direct Memory Access，直接内存访问）数据传输。其作用和优势如下：</p><h4 id="21-非固定长度数据包接收"><a class="markdownIt-Anchor" href="#21-非固定长度数据包接收"></a> 2.1 <strong>非固定长度数据包接收</strong></h4><ul><li>当接收的数据是非固定长度时，很难在接收时预先设定要接收的数据长度。这时，可以利用空闲中断判断数据的结束。</li><li>当串口在 DMA 模式下接收数据时，无法使用常规的中断方式逐字节进行处理。使用空闲中断可以更高效地处理数据流，从而判断整个数据包的接收是否完成。</li></ul><h4 id="22-提高串口通信的效率"><a class="markdownIt-Anchor" href="#22-提高串口通信的效率"></a> 2.2 <strong>提高串口通信的效率</strong></h4><ul><li>使用空闲中断能够在 DMA 模式下提高串口通信的效率。当 DMA 缓冲区被填满或者数据接收超时时，空闲中断可以用于自动触发数据处理，避免了使用传统的定时器轮询方式。</li><li>通过判断空闲中断触发时间，可以精确判断数据包的传输完成，不必每次都等待接收缓冲区被填满才进行处理，从而提高系统响应速度。</li></ul><h4 id="23-降低-cpu-占用"><a class="markdownIt-Anchor" href="#23-降低-cpu-占用"></a> 2.3 <strong>降低 CPU 占用</strong></h4><ul><li>使用空闲中断配合 DMA 接收，可以降低 CPU 的使用率。在 DMA 接收过程中，数据自动从串口移入缓冲区，不需要 CPU 的参与，只有在接收结束或空闲中断触发时才进行数据处理。</li><li>对于接收频繁但数量不定的数据流（如传感器数据、通信协议数据包），使用空闲中断能极大地减少 CPU 的负担。</li></ul><h3 id="3-空闲中断在串口通信中的典型应用场景"><a class="markdownIt-Anchor" href="#3-空闲中断在串口通信中的典型应用场景"></a> 3. 空闲中断在串口通信中的典型应用场景</h3><h4 id="31-接收数据包的完整性判断"><a class="markdownIt-Anchor" href="#31-接收数据包的完整性判断"></a> 3.1 <strong>接收数据包的完整性判断</strong></h4><p>对于 UART 接收非固定长度的数据包（如 Modbus、串口通信协议），可以使用空闲中断来判断数据帧的结束。</p><p><strong>典型场景：</strong><br>假设通过 UART 接收的数据包长度不定，当接收到一个完整的数据帧时，串口线路会进入空闲状态，此时触发空闲中断，可以认为本次数据接收结束。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c复制代码// 空闲中断回调函数示例</span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {</span><br><span class="line">    if (__HAL_UART_GET_FLAG(huart, UART_FLAG_</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="1-变量声明"><a class="markdownIt-Anchor" href="#1-变量声明"></a> 1. 变量声明</h2><p><strong>声明 uart_rx_dma_buffer变量，用于数据转运</strong></p><img src="/posts/24028/image-20240919233721950.png" class="" title="image-20240919233721950"><h2 id="2-中断初始化"><a class="markdownIt-Anchor" href="#2-中断初始化"></a> 2. <strong>中断初始化</strong></h2><p>启用DMA相关中断</p><p>关闭DMA<mark>半中断</mark></p><img src="/posts/24028/image-20240919233901381.png" class="" title="image-20240919233901381"><p><strong>PS: 不再适用串口回调，改用DMA的方法</strong></p><img src="/posts/24028/image-20240919234047785.png" class="" title="image-20240919234047785"><h2 id="3-串口中断函数"><a class="markdownIt-Anchor" href="#3-串口中断函数"></a> 3. <strong>串口中断函数</strong></h2><p>每次触发串口中断，触发DMA中断</p><img src="/posts/24028/image-20240920200100912.png" class="" title="image-20240920200100912"><p><strong>取消使用串口中断回调函数</strong></p><img src="/posts/24028/image-20240920200332492.png" class="" title="image-20240920200332492"><p><strong>改用空闲中断回调函数</strong></p><p>PS: 不再需要串口超时解析</p><img src="/posts/24028/image-20240920200417955.png" class="" title="image-20240920200417955"><img src="/posts/24028/image-20240920200913934.png" class="" title="image-20240920200913934"><h2 id="现象-2"><a class="markdownIt-Anchor" href="#现象-2"></a> # 现象：</h2><img src="/posts/24028/image-20240921001109060.png" class="" title="image-20240921001109060"><h2 id="补充中断函数与回调函数的区别"><a class="markdownIt-Anchor" href="#补充中断函数与回调函数的区别"></a> # <mark>补充——中断函数与回调函数的区别</mark></h2><blockquote><p>在嵌入式编程中，HAL（硬件抽象层）库的中断函数和回调函数是常见的机制，尤其是在处理外设操作时。这两者的作用有时容易混淆，但它们的概念和使用场景有所不同。下面详细解释它们的区别：</p><h3 id="1-中断函数interrupt-service-routine-isr"><a class="markdownIt-Anchor" href="#1-中断函数interrupt-service-routine-isr"></a> 1. 中断函数（Interrupt Service Routine, ISR）</h3><p>中断函数是一段处理硬件中断的代码。当外设或处理器触发中断时，处理器会暂停当前的代码执行，转而执行与该中断对应的ISR。一旦中断被处理完毕，程序会恢复到原来的执行状态。</p><ul><li><strong>执行方式</strong>：硬件触发，直接由处理器执行，通常是高优先级。</li><li><strong>响应时间</strong>：要求短小精悍，不能执行耗时的任务，因为会阻塞其他中断。</li><li><strong>位置</strong>：ISR通常定义在HAL库或用户代码中，是一个固定的函数（如<code>TIM_IRQHandler</code>等）。</li><li><strong>调用方式</strong>：自动触发，由硬件中断控制器（NVIC）决定何时调用中断处理函数。</li></ul><h3 id="2-回调函数callback-function"><a class="markdownIt-Anchor" href="#2-回调函数callback-function"></a> 2. 回调函数（Callback Function）</h3><p>回调函数是一个函数指针，通过预先注册到某个模块或API中，等到某个事件发生时，由该模块或API负责调用。HAL库中的回调函数通常是在中断处理完毕后，由ISR或HAL库内部调用，用来进一步处理用户逻辑。</p><ul><li><strong>执行方式</strong>：由程序代码（比如ISR或定时器事件）调用，响应某个事件。</li><li><strong>响应时间</strong>：回调函数不要求像中断处理函数那样必须快速完成，往往用于处理稍复杂的业务逻辑。</li><li><strong>位置</strong>：回调函数通常由用户实现，并由HAL库的中断处理函数或其他机制调用（如<code>HAL_TIM_PeriodElapsedCallback</code>）。</li><li><strong>调用方式</strong>：回调函数不是直接由硬件触发，而是由软件触发，即当中断函数处理完硬件中断后，再调用用户注册的回调函数。</li></ul><h3 id="简单总结区别"><a class="markdownIt-Anchor" href="#简单总结区别"></a> 简单总结区别：</h3><ul><li><strong>触发机制</strong>：中断函数是由硬件事件（如定时器溢出、外部信号等）直接触发，而回调函数是由软件（如ISR）触发。</li><li><strong>职责范围</strong>：中断函数负责处理硬件中断，通常需要快速执行；回调函数则处理用户定义的业务逻辑，通常可以有更多的处理空间和时间。</li><li><strong>优先级</strong>：中断函数的优先级较高，回调函数的执行时间不受硬件中断控制，通常在中断函数结束之后才执行。</li></ul><h3 id="典型应用场景"><a class="markdownIt-Anchor" href="#典型应用场景"></a> 典型应用场景</h3><p>以定时器为例：</p><ul><li>当定时器溢出时，触发一个中断，执行定时器的中断函数<code>TIM_IRQHandler</code>。</li><li>在中断函数内部，可能会调用HAL库的定时器回调函数<code>HAL_TIM_PeriodElapsedCallback</code>，用于用户自定义的定时器周期性任务处理。</li></ul><p>这就是中断函数和回调函数的核心区别。</p></blockquote><h1 id="三-环形缓冲区"><a class="markdownIt-Anchor" href="#三-环形缓冲区"></a> 三、环形缓冲区</h1><h2 id="环形缓冲区的简介"><a class="markdownIt-Anchor" href="#环形缓冲区的简介"></a> # 环形缓冲区的简介</h2><blockquote><p>环形缓存区，也叫环形缓冲区（Ring Buffer）或循环缓冲区，是一种数据结构。它的特点 是缓存区的头和尾是连接在一起的，形成一个环。当数据写入缓冲区时，指针会不断前进，当到达缓冲区的末尾时，会重新回到开头，这样就实现了一个循环。</p><p><strong>环形缓冲区的组成</strong>：</p><ul><li>缓冲区数组：存放数据</li><li>头指针（读指针）</li><li>尾指针（写指针）</li></ul><p>环形缓冲区满足“先进先出的原则”</p><p><strong>环形缓冲区的优势</strong>：</p><ul><li>在普通串口接收中，数据是线性接收的，通常是通过中断或者轮询的方式处理数据。</li><li>而环形缓冲区适用于需要持续接收和处理数据的应用，如串口通信</li><li>环形缓冲区效率和可靠性高，但是需要复杂的管理逻辑</li></ul><p><strong>环形缓冲区的原理及实现</strong>：</p><p><a href="https://blog.csdn.net/2401_86353562/article/details/141830232">环形缓冲区(ring buffer)原理与实现详解-CSDN博客</a></p><img src="/posts/24028/9af5be294e82d063ae8d1eb1d642ed7a.png" class="" title="img"><p><strong>简单代码实现：</strong></p><p>缓冲区结构体定义</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFFER_SIZE (30) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">uint32_t</span> w;</span><br><span class="line">    <span class="type">uint32_t</span> r;</span><br><span class="line">    <span class="type">uint8_t</span> buffer[RINGBUFFER_SIZE];</span><br><span class="line">    <span class="type">uint32_t</span> itemCount;</span><br><span class="line">}<span class="type">ringbuffer_t</span>;</span><br></pre></td></tr></tbody></table></figure><p>初始化环形缓冲区</p><p>置零环形缓冲区中的元素</p><p>这里用到<code>memset</code>函数</p><ul><li>解释：复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</li><li>作用：是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法</li><li>头文件：C中<code>#include&lt;string.h&gt;</code>，C++中<code>#include&lt;cstring&gt;</code></li></ul><p>这里指向的是环形缓冲区内容buffer，为uint8_t类型的数组变量，数组大小为<code>RINGBUFFER_SIZE</code>，使用这段语句将buffer中的内存块内容置零。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ringbuffer_init</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 设置读指针和写指针初始值为0</span></span><br><span class="line">    rb-&gt;r = <span class="number">0</span>;</span><br><span class="line">    rb-&gt;w = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将缓冲区内存清零</span></span><br><span class="line">    <span class="built_in">memset</span>(rb-&gt;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * RINGBUFFER_SIZE);</span><br><span class="line">    <span class="comment">// 初始化项目计数为0</span></span><br><span class="line">    rb-&gt;itemCount = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>检查缓冲区是否已满</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查环形缓冲区是否已满</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">ringbuffer_is_full</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果项目计数等于缓冲区大小，返回1（已满），否则返回0（未满）</span></span><br><span class="line">    <span class="keyword">return</span> (rb-&gt;itemCount == RINGBUFFER_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>检查缓冲区是否为空</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查环形缓冲区是否为空</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">ringbuffer_is_empty</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果项目计数为0，返回1（为空），否则返回0（非空）</span></span><br><span class="line">    <span class="keyword">return</span> (rb-&gt;itemCount == <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>向环形缓冲区写入数据</p><p>这里限制了向环形缓冲区写入数据的个数：即限定在环形缓冲区数组索引大小内</p><p>数据根据写指针当前指向的位置，进行写入。数据完成写入后，写指针递增。如果写指针当前到达缓冲区索引尾部，那么返回索引头部，即指向0</p><p>此段代码管理逻辑中，如果当前的环形缓冲区已经写满，需要经过将缓冲区的数据取出后，才能继续对缓冲区进行写入操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向环形缓冲区写入数据</span></span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">ringbuffer_write</span><span class="params">(<span class="type">ringbuffer_t</span> *rb, <span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果缓冲区已满，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_full(rb))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 将数据写入缓冲区</span></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        rb-&gt;buffer[rb-&gt;w] = *data++;  <span class="comment">// 写入数据并移动写指针</span></span><br><span class="line">        rb-&gt;w = (rb-&gt;w + <span class="number">1</span>) % RINGBUFFER_SIZE;  <span class="comment">// 写指针循环递增</span></span><br><span class="line">        rb-&gt;itemCount++;  <span class="comment">// 增加项目计数</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 写入成功返回0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从缓冲区读取数据</p><p>缓冲区有数据，操作才有效</p><p>数据根据读指针当前指向的位置，进行读取。数据完成读取后，读指针递增。如果读指针当前到达缓冲区索引尾部，那么返回索引头部，即指向0。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从环形缓冲区读取数据</span></span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">ringbuffer_read</span><span class="params">(<span class="type">ringbuffer_t</span> *rb, <span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果缓冲区为空，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_empty(rb))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓冲区读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        *data++ = rb-&gt;buffer[rb-&gt;r];  <span class="comment">// 读取数据并移动读指针</span></span><br><span class="line">        rb-&gt;r = (rb-&gt;r + <span class="number">1</span>) % RINGBUFFER_SIZE;  <span class="comment">// 读指针循环递增</span></span><br><span class="line">        rb-&gt;itemCount--;  <span class="comment">// 减少项目计数</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 读取成功返回0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="1-移植环形缓冲区驱动文件"><a class="markdownIt-Anchor" href="#1-移植环形缓冲区驱动文件"></a> 1. <strong>移植环形缓冲区驱动文件</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ringbuffer_t</span> usart_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> usart_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br></pre></td></tr></tbody></table></figure><ul><li>判断ringbuffer是否满</li><li>写入数据</li><li>清空结构体</li></ul><h2 id="2-空闲中断回调函数"><a class="markdownIt-Anchor" href="#2-空闲中断回调函数"></a> 2. <strong>空闲中断回调函数</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief UART DMA接收完成回调函数 </span></span><br><span class="line"><span class="comment">将接收到的数据写入环形缓冲区，并清空DMA缓冲区</span></span><br><span class="line"><span class="comment">  * @param huart UART句柄 </span></span><br><span class="line"><span class="comment">  * @param Size 接收到的数据大小 </span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//空闲中断回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (huart-&gt;Instance == USART1)  <span class="comment">// 判断是 USART1 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//引入环形缓存区</span></span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line">ringbuffer_write(&amp;usart_rb,uart_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-修改串口解析"><a class="markdownIt-Anchor" href="#2-修改串口解析"></a> 2. <strong>修改串口解析</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb))<span class="keyword">return</span>;</span><br><span class="line">    ringbuffer_read(&amp;usart_rb,usart_read_buffer,usart_rb.itemCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ringbuffer data:%s\n"</span>,usart_read_buffer);</span><br><span class="line">    meset(usart_read_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>)*<span class="number">128</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><mark><strong>STM32串口通信方法总结:</strong></mark></p><ul><li><p>超时解析</p></li><li><p>DMA空闲中断</p></li><li><p>环形缓存区</p></li></ul><h1 id="四-adc和dma"><a class="markdownIt-Anchor" href="#四-adc和dma"></a> 四、ADC和DMA</h1><blockquote><p>STM32的ADC（模数转换器）通道IN11指的是STM32微控制器上一个特定的ADC输入通道。每个STM32芯片的ADC都有多个模拟输入引脚，这些引脚标记为<code>INx</code>（例如IN0、IN1、IN2等），对应不同的GPIO引脚。</p><p>具体到<strong>IN11</strong>，它是ADC的第11个输入通道，通常与一个特定的GPIO引脚连接。该引脚用于将模拟信号输入到ADC进行模数转换。</p><p>CT117E原理图：</p><img src="/posts/24028/image-20240921165117470.png" class="" title="image-20240921165117470"></blockquote><h2 id="1-cubemx配置-2"><a class="markdownIt-Anchor" href="#1-cubemx配置-2"></a> 1. CubeMX配置</h2><h3 id="11-adc通道分配"><a class="markdownIt-Anchor" href="#11-adc通道分配"></a> 1.1 <strong>ADC通道分配：</strong></h3><ul><li>ADC1: IN11</li><li>ADC2: IN15</li></ul><img src="/posts/24028/image-20240920205816075.png" class="" title="image-20240920205816075"><h3 id="12-配置dma"><a class="markdownIt-Anchor" href="#12-配置dma"></a> 1.2 配置DMA</h3><h4 id="121-配置dma通道"><a class="markdownIt-Anchor" href="#121-配置dma通道"></a> 1.2.1 配置DMA通道</h4><img src="/posts/24028/image-20240920205900067.png" class="" title="image-20240920205900067"><h4 id="122-配置为循环模式"><a class="markdownIt-Anchor" href="#122-配置为循环模式"></a> 1.2.2 配置为循环模式</h4><img src="/posts/24028/image-20240921004004318.png" class="" title="image-20240921004004318"><h4 id="123-配置dma速度"><a class="markdownIt-Anchor" href="#123-配置dma速度"></a> 1.2.3 配置DMA速度</h4><p>设置为中、高均可</p><img src="/posts/24028/image-20240920210046359.png" class="" title="image-20240920210046359"><h3 id="13-配置adc属性"><a class="markdownIt-Anchor" href="#13-配置adc属性"></a> 1.3 <strong>配置ADC属性</strong></h3><ul><li>四分频</li><li>DMA使能</li><li>循环使能</li></ul><img src="/posts/24028/image-20240920210259713.png" class="" title="image-20240920210259713"><h3 id="14-配置adc中断"><a class="markdownIt-Anchor" href="#14-配置adc中断"></a> 1.4  <strong>配置ADC中断</strong></h3><p>优先级为2即可</p><img src="/posts/24028/image-20240920210416469.png" class="" title="image-20240920210416469"><h2 id="2-驱动程序编写-2"><a class="markdownIt-Anchor" href="#2-驱动程序编写-2"></a> 2. 驱动程序编写</h2><h3 id="21-创建adc_appc"><a class="markdownIt-Anchor" href="#21-创建adc_appc"></a> 2.1 <strong>创建adc_app.c</strong></h3><p><strong>变量声明</strong></p><img src="/posts/24028/image-20240920211129892.png" class="" title="image-20240920211129892"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//双通道DMA</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure><p><strong>在主程序初始化启用DMA 转运 ADC 数据</strong></p><img src="/posts/24028/image-20240920211606752.png" class="" title="image-20240920211606752"><h3 id="22-定义adc进程"><a class="markdownIt-Anchor" href="#22-定义adc进程"></a> 2.2 <strong>定义ADC进程</strong></h3><img src="/posts/24028/image-20240920211903715.png" class="" title="image-20240920211903715"><ul><li>读取电压dma储存数据</li><li>转换为模拟电压值</li></ul><p>同样的，记得在任务调度器中添加proc</p><h3 id="23-lcd显示"><a class="markdownIt-Anchor" href="#23-lcd显示"></a> 2.3 <strong>lcd显示</strong></h3><img src="/posts/24028/image-20240920212245141.png" class="" title="image-20240920212245141"><h2 id="动态窗口"><a class="markdownIt-Anchor" href="#动态窗口"></a> # <strong><mark>动态窗口</mark></strong></h2><ul><li>使用环形缓存区</li><li>定义结构体</li></ul><img src="/posts/24028/image-20240920214629559.png" class="" title="image-20240920214629559"><img src="/posts/24028/image-20240920214552510.png" class="" title="image-20240920214552510"><h1 id="多串口通信"><a class="markdownIt-Anchor" href="#多串口通信"></a> 多串口通信</h1><h2 id="示例一"><a class="markdownIt-Anchor" href="#示例一"></a> 示例一</h2><p>使用DMA+环形缓冲区+空闲中断回调的方法，使用串口通信，在解析函数中每次解析对象为串口一次性连续接收到的数据。</p><p>所以，在解析函数<code>uart_proc</code>中一次完成对串口数据内容的解析即可，不需要再用状态机的判断逻辑。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"usart_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> uart_rx_index = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> uart_rx_ticks = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_dma_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">ringbuffer_t</span> usart_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"><span class="type">uint8_t</span> usart_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> uart2_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">uint8_t</span> uart2_rx_dma_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">ringbuffer_t</span> usart2_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"><span class="type">uint8_t</span> usart2_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br><span class="line"></span><br><span class="line">DataPacket context; <span class="comment">// 初始化上下文</span></span><br><span class="line"><span class="comment">//串口中断回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//    if(huart-&gt;Instance == USART1)</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        uart_rx_ticks = uwTick;</span></span><br><span class="line"><span class="comment">//        uart_rx_index++;//索引自增</span></span><br><span class="line"><span class="comment">//        //每次触发回调，都要重新初始化接收中断，定义接收的位置</span></span><br><span class="line"><span class="comment">//        HAL_UART_Receive_IT(&amp;huart1,&amp;uart_rx_buffer[uart_rx_index],1);</span></span><br><span class="line"><span class="comment">////printf("test");//排错</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//空闲中断回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"dma data:%s\n"</span>,uart2_rx_dma_buffer);<span class="comment">//发送串口接收内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (huart-&gt;Instance == USART1)  <span class="comment">// 判断是 USART1 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//引入环形缓存区</span></span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line">ringbuffer_write(&amp;usart_rb,uart_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(huart-&gt;Instance == USART2)  <span class="comment">// 判断是 USART2 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart2_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">ringbuffer_write(&amp;usart2_rb,uart2_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart2_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart2_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//    if(uart_rx_index == 0) return;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    if(uwTick - uart_rx_ticks &gt; 100)//时间超过100</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        printf("uart data:%s\n",uart_rx_buffer);//发送串口接收内容</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//        memset (uart_rx_buffer,0,uart_rx_index);//清空</span></span><br><span class="line"><span class="comment">//        uart_rx_index = 0;//指针指令</span></span><br><span class="line"><span class="comment">//        huart1.pRxBuffPtr = uart_rx_buffer;//uart1缓存区指针指向buffer</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">// 如果环形缓冲区为空，直接返回 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb) &amp;&amp; ringbuffer_is_empty(&amp;usart2_rb)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从环形缓冲区读取数据到读取缓冲区 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ringbuffer_read(&amp;usart_rb, usart_read_buffer, usart_rb.itemCount);</span></span><br><span class="line">ringbuffer_read(&amp;usart2_rb, usart2_read_buffer, usart2_rb.itemCount);</span><br><span class="line"><span class="comment">// 打印读取缓冲区中的数据 </span></span><br><span class="line"><span class="comment">//printf("ringbuffer data: %s\n", usart_read_buffer);</span></span><br><span class="line"><span class="comment">// 上位机&lt;test协议&gt;</span></span><br><span class="line"><span class="comment">//printf("{plotter}%s\r\n", usart_read_buffer);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//问题1：用状态机写，会导致无法一次性解码；</span></span><br><span class="line"><span class="comment">//使用串口上位机，发现每次发送串口数据，状态机才会+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(usart_read_buffer[0] == 0xFF &amp;&amp; usart_read_buffer[3] == 0xFB)//帧头帧尾检测</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(usart_read_buffer[1] == 0x2A){</span></span><br><span class="line"><span class="comment">context.data_type = 1;//正数</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else if(usart_read_buffer[1] == 0x2B){</span></span><br><span class="line"><span class="comment">context.data_type = 2;//负数</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">context.data = usart_read_buffer[2];</span></span><br><span class="line"><span class="comment">number_detect = context.data;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parse_buffer(usart_read_buffer,sizeof(usart_read_buffer),&amp;context);</span></span><br><span class="line">parse_buffer(usart2_read_buffer,<span class="keyword">sizeof</span>(usart2_read_buffer),&amp;context);</span><br><span class="line"><span class="comment">//问题2：无memset会怎么样？</span></span><br><span class="line"><span class="comment">//memset(usart_read_buffer, 0, sizeof(uint8_t) * BUUFER_SIZE);</span></span><br><span class="line"><span class="built_in">memset</span>(usart2_read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * BUUFER_SIZE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据帧解析函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_buffer</span><span class="params">(<span class="type">uint8_t</span> *buffer,<span class="type">size_t</span> size,DataPacket* data)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(size &lt; <span class="number">4</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//数据帧长度小于4，返回 0 表示解析失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; buffer[<span class="number">3</span>] == <span class="number">0xFB</span>)<span class="comment">//帧头帧尾检测</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer[<span class="number">1</span>] == <span class="number">0x2A</span>){</span><br><span class="line">data -&gt; data_type = <span class="number">1</span>;<span class="comment">//正数</span></span><br><span class="line">data -&gt; data = buffer[<span class="number">2</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(buffer[<span class="number">1</span>] == <span class="number">0x2B</span>){</span><br><span class="line">data -&gt; data_type = <span class="number">2</span>;<span class="comment">//负数</span></span><br><span class="line">data -&gt; data = buffer[<span class="number">2</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//非正确类型，解析失败</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//解析成功</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//帧头帧尾错误，解析失败</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("%c%c\n", context.state,usart_read_buffer[2]);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[Hal库][嵌入式][1]嵌入式工程模板与“任务调度器”</title>
      <link href="/posts/56683/"/>
      <url>/posts/56683/</url>
      
        <content type="html"><![CDATA[<h1 id="一-任务调度器"><a class="markdownIt-Anchor" href="#一-任务调度器"></a> 一、任务调度器</h1><h2 id="1-调度器结构体"><a class="markdownIt-Anchor" href="#1-调度器结构体"></a> 1. 调度器结构体</h2><p><strong>函数指针和指针函数:</strong><a href="https://blog.csdn.net/baidu_37973494/article/details/83150266">C语言基础知识：函数指针&amp;指针函数（定义格式、作用及用法说明）_指针函数的定义-CSDN博客</a></p><p>PS: 函数指针本身上还是一个指针，和一般指针没有区别，指向函数的执行地址</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调度器类型的结构体类型声明</span></span><br><span class="line"><span class="comment">//任务结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">void</span> (*task_func)(<span class="type">void</span>);<span class="comment">//函数指针</span></span><br><span class="line">    <span class="type">uint32_t</span> rate_ms;<span class="comment">//任务运行周期</span></span><br><span class="line">    <span class="type">uint32_t</span> last_run;<span class="comment">//上次运行时间</span></span><br><span class="line">} <span class="type">scheduler_task_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><code>typedef struct {} scheduler_task_t;</code>是⼀种定义新结构体类型的⽅式，这⾥定义 了⼀个名为  scheduler_task_t 的结构体类型。这个结构体类型包含三个成员。</p><ul><li><p><code>void *task_func(void);</code>定义了一个函数指针，用于储存任务函数的地址，便于进行任务调度</p></li><li><p><code>rate_ms</code>表示任务具体的执行周期</p></li><li><p><code>last_run</code>⽤于存储任务上次运⾏的时间戳（以毫秒为单位）。该成员⽤于 记录任务上⼀次被调度执⾏的时间点，以便计算任务是否需要再次执⾏</p></li></ul><p>静态任务数组，每个任务包括任务函数，执行周期，和上次执行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Led_task</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义调度器类型的变量 任务</span></span><br><span class="line"><span class="comment">//任务数组</span></span><br><span class="line"><span class="comment">//给scheduler_task_t类型变量tasks赋初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">scheduler_task_t</span> tasks[] ={</span><br><span class="line">    {Led_task,<span class="number">1000</span>,<span class="number">0</span>}<span class="comment">//定义一个任务，任务函数为Led_Proc,执行周期为1000毫秒，初始上次运行时间为0</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="2-调度器初始化"><a class="markdownIt-Anchor" href="#2-调度器初始化"></a> 2. 调度器初始化</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">//计算任务数组中任务函数的个数，结果储存在tasks_num中</span></span><br><span class="line">    tasks_num = <span class="keyword">sizeof</span>(tasks)/<span class="keyword">sizeof</span>(<span class="type">scheduler_task_t</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-调度器函数"><a class="markdownIt-Anchor" href="#3-调度器函数"></a> 3. 调度器函数</h2><p>遍历任务数组，检查是否有任务需要进行，如果系统当前时间超过任务的执行周期，那么执行任务变更，并且更新上次运行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_run</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">/*任务轮询*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>; i&lt; tasks_num; i++){</span><br><span class="line">        <span class="comment">//获取当前时间（毫秒）</span></span><br><span class="line">        <span class="type">uint8_t</span> time_now = HAL_GetTick();</span><br><span class="line">        <span class="comment">//检查任务是否到达当前时间点</span></span><br><span class="line">        <span class="keyword">if</span>(time_now &gt;= tasks[i].rate_ms + tasks[i].last_run){</span><br><span class="line">            <span class="comment">//更新任务的上次运行时间，保存时间戳</span></span><br><span class="line">            tasks[i].last_run = time_now;<span class="comment">//保存当前时间</span></span><br><span class="line">            tasks[i].task_func();<span class="comment">//执行对应指向的任务</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习】[1]神经网络的基本概念</title>
      <link href="/posts/23492/"/>
      <url>/posts/23492/</url>
      
        <content type="html"><![CDATA[<h1 id="一-神经网络的基本概念"><a class="markdownIt-Anchor" href="#一-神经网络的基本概念"></a> 一、神经网络的基本概念</h1><h2 id="1-神经元感知器"><a class="markdownIt-Anchor" href="#1-神经元感知器"></a> 1. 神经元（感知器）</h2><p>一种被称为感知器的人工神经元在20世纪五六十年代被科学家Frank提出。通过数学模型，可以认识到<strong>感知器</strong>是一个根据输入与权重来做出决定的设备，随着<strong>权重</strong>和<strong>阈值</strong>的变化，可以得到不同的<strong>决策模型</strong>。当一个感知器计算后得到的值大于阈值时，从神经学的角度来讲这个感知器被激活，反之为0。感知器可以一定程度上模仿人脑做出决策，但是感知器的决策过程全部是线性的，在处理图像处理、语音识别等复杂问题时，难以仅靠线性模型达到良好的识别效果，因此需要在感知器模型种引入非线性部分。</p><h2 id="2-非线性神经元"><a class="markdownIt-Anchor" href="#2-非线性神经元"></a> 2. 非线性神经元</h2><p>为解决复杂的数学模型，引入<strong>激活函数</strong>，激活函数给神经元带来了非线性因素，使得神经网络可以任意逼近任何非线性函数。</p><p>通常将激活函数与线性神经元合并使之成为<strong>非线性神经元</strong></p><p>如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的<a href="https://baike.baidu.com/item/%E6%84%9F%E7%9F%A5%E6%9C%BA/12723581">感知机</a>（Perceptron）。</p><img src="/posts/23492/34d6b14bf4b79175276eac52abacdf94.png" class="" title="img"><p>激活函数可以分为<strong>两大类：</strong></p><img src="/posts/23492/e41598583c8b35dcbb907f9fd66d8351.png" class="" title="img"><ul><li><strong>饱和激活函数：</strong> sigmoid、 tanh…</li><li><strong>非饱和激活函数:</strong> ReLU 、Leaky Relu  、ELU、PReLU、RReLU…</li></ul><p><a href="https://blog.csdn.net/qq_42691298/article/details/126590726">深度学习中常见的10种激活函数（Activation Function）总结_激活函数有哪些-CSDN博客</a></p><h2 id="3常见的激活函数"><a class="markdownIt-Anchor" href="#3常见的激活函数"></a> 3.常见的激活函数</h2><h3 id="31-sigmoid函数"><a class="markdownIt-Anchor" href="#31-sigmoid函数"></a> 3.1 Sigmoid函数</h3><img src="/posts/23492/6c9269a456ee0497c9bb0d1383e51cc8.png" class="" title="img"><img src="/posts/23492/af5f15ef44f1b276c78bec5e140e7082.png" class="" title="img"><h3 id="32-tanh函数"><a class="markdownIt-Anchor" href="#32-tanh函数"></a> 3.2 tanh函数</h3><p><strong>tanh</strong>激活函数的数学表达式为：</p><img src="/posts/23492/70ad61d6f8c019d3dee98ad6ef45cb1a.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/e58d7204fef7f7410e92b4bf82e91938.png" class="" title="img"><h3 id="33-relu函数"><a class="markdownIt-Anchor" href="#33-relu函数"></a> 3.3 ReLU函数</h3><p><strong>ReLU</strong>激活函数的数学表达式为：</p><img src="/posts/23492/ae65877d14768ad1b6789c6ccdcd6e31.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/a2f4f9f3c522518908e20d7865beb48c.png" class="" title="img"><p>什么情况下适合使用ReLU？</p><ul><li><p>ReLU解决了梯度消失的问题，当输入值为正时，神经元不会饱和</p></li><li><p>由于ReLU线性、非饱和的性质，在SGD中能够快速收敛</p></li><li><p>计算复杂度低，不需要进行指数运算</p></li></ul><p>ReLU有哪些缺点？</p><ul><li><p>与Sigmoid一样，其输出不是以0为中心的</p></li><li><p>Dead ReLU 问题。当输入为负时，梯度为0。这个神经元及之后的神经元梯度永远为0，不再对任何数据有所响应，导致相应参数永远不会被更新</p></li><li><p>训练神经网络的时候，一旦学习率没有设置好，第一次更新权重的时候，输入是负值，那么这个含有ReLU的神经节点就会死亡，再也不会被激活。所以，要设置一个合适的较小的学习率，来降低这种情况的发生</p></li></ul><h2 id="4-神经网络的基本架构"><a class="markdownIt-Anchor" href="#4-神经网络的基本架构"></a> 4. 神经网络的基本架构</h2><img src="/posts/23492/bf32fef369b3823adc20dcdf9af603e3.jpg" class="" title="bf32fef369b3823adc20dcdf9af603e3"><ul><li><p>神经网络最左边的称为<strong>输入层</strong>，其中的神经元称为<strong>输入神经元</strong>，原始数据经由该层输入到神经网络进行后续处理。</p></li><li><p>最右边的称为<strong>输出层</strong>，包含输出神经元，该层的输出是神经网络对样本处理后的最终结果，如分类结果。</p></li><li><p>在输入层和输出层之间的是中间层，也称为 <strong>隐藏层</strong>，即既非输入也非输出的神经网络层，一个神经网络可以有一个或者多个隐藏层，隐藏层的主要作用是处理从上一层神经元传递来的信号。</p></li></ul><p>一般的，<strong>输入层</strong>和 <strong>输出层</strong>在整体神经网络的外部，称为可见层。设计神经网络的输入输出通常比较简单，直接，例如，假设我们知道了一朵花的4个明显特征（如花瓣的长度，宽度），可以利用这4个特征确定它是哪一种类的花，由于我们已经知道这朵花的4个特征，那么就需要4个输入神经元，每个数值代表花朵的一种特征的具体数值。<strong>输出层</strong>可以包含一个或者多个神经元，这由我们想要设定的具体花朵类别决定，可以根据输出的数字，确定花朵的类型。我们可以使用每一个<strong>输出神经元</strong>代表一种类型的花，这种方法称为One-Hot，One-Hot是一种常见的输出层编码方法。</p><h2 id="5-梯度下降"><a class="markdownIt-Anchor" href="#5-梯度下降"></a> 5. 梯度下降</h2><p><a href="https://blog.csdn.net/iqdutao/article/details/107174240">机器学习-梯度下降算法原理及公式推导_梯度下降计算公式-CSDN博客</a></p><h2 id="6-反向传播"><a class="markdownIt-Anchor" href="#6-反向传播"></a> 6. 反向传播</h2><p><a href="https://blog.csdn.net/ft_sunshine/article/details/90221691">“反向传播算法”过程及公式推导（超直观好懂的Backpropagation）_反向传播算法(过程及公式推导)-CSDN博客</a></p><p><strong>“正向传播”求损失，“反向传播”回传误差</strong>。同时，神经网络每层的每个神经元都可以<strong>根据误差信号修正每层的权重</strong></p><h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h1><h2 id="一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"><a class="markdownIt-Anchor" href="#一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"></a> 一、输入x是 784长度的向量，什么机制使得输出y变成的长度为10的向量？</h2><p>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的。具体操作通过 <strong>权重矩阵</strong> 和 <strong>偏置向量</strong> 来完成。</p><h3 id="1-全连接层的基本机制"><a class="markdownIt-Anchor" href="#1-全连接层的基本机制"></a> 1. <strong>全连接层的基本机制：</strong></h3><p>全连接层的工作机制可以用矩阵乘法来描述。给定输入向量 x<em>x</em>（长度为784），要转换为长度为10的输出向量，通常通过如下步骤：</p><h4 id="2-步骤"><a class="markdownIt-Anchor" href="#2-步骤"></a> 2. <strong>步骤：</strong></h4><ol><li><p><strong>输入向量 <img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"></strong>：这是一个长度为784的向量，表示神经网络的输入。</p><img src="/posts/23492/image-20240907224042533.png" class="" title="image-20240907224042533"></li><li><p><strong>权重矩阵 <img src="/posts/23492/image-20240907224200098.png" class="" title="image-20240907224200098"></strong>：全连接层会有一个权重矩阵 W<em>W</em>，其维度是 10×78410×784，表示从输入784维向量到输出10维向量的权重连接。每一行表示一个输出神经元与所有输入神经元的权重连接。</p></li><li><p><strong>偏置向量 <img src="/posts/23492/image-20240907224226570.png" class="" title="image-20240907224226570"></strong>：偏置向量 b<em>b</em> 是一个长度为10的向量，表示每个输出神经元的偏置。</p></li><li><p><strong>计算输出向量 <img src="/posts/23492/image-20240907224234671.png" class="" title="image-20240907224234671"></strong>：通过矩阵乘法计算输出向量。输出向量 o<em>o</em> 的维度是10。具体计算方式如下：</p><img src="/posts/23492/image-20240907224051327.png" class="" title="image-20240907224051327"><ul><li>W \cdot x )：矩阵 ( W ) 乘以向量 ( x )，将784维的输入向量映射为10维的输出向量。</li></ul></li></ol><h3 id="3-矩阵乘法具体步骤"><a class="markdownIt-Anchor" href="#3-矩阵乘法具体步骤"></a> 3. <strong>矩阵乘法具体步骤：</strong></h3><ul><li><p>假设输入向量<img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"> 是长度为784的向量：</p><img src="/posts/23492/image-20240907224100515.png" class="" title="image-20240907224100515"></li><li><p>权重矩阵 W<em>W</em> 是一个 10×78410×784 的矩阵：</p><img src="/posts/23492/image-20240907224116095.png" class="" title="image-20240907224116095"></li><li><p>偏置向量 b<em>b</em> 是一个长度为10的向量：</p><img src="/posts/23492/image-20240907224125174.png" class="" title="image-20240907223954313"></li><li><p>输出向量 o<em>o</em> 通过矩阵乘法和加法得到，维度为10：</p><img src="/posts/23492/image-20240907224134345.png" class="" title="image-20240907224134345"></li></ul><p>每一行表示一个输出神经元的结果，最终得到一个长度为10的向量。</p><h3 id="4-激活函数"><a class="markdownIt-Anchor" href="#4-激活函数"></a> 4. <strong>激活函数：</strong></h3><p>在得到长度为10的向量后，通常会将其通过激活函数进行处理。在分类任务中，输出层通常使用 <strong>Softmax</strong> 函数，将每个输出值转换为概率值。Softmax 函数公式为：</p><img src="/posts/23492/image-20240907224012315.png" class="" title="image-20240907224012315"><p>这会将输出向量 o<em>o</em> 转换为一个概率分布，表示输入属于不同类别的概率。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>将784长度的输入向量变为10长度的输出向量的关键步骤是通过 <strong>全连接层的矩阵乘法</strong> 和 <strong>偏置项</strong>，最终计算出长度为10的向量，并通过 <strong>Softmax</strong> 函数将其转换为概率分布，从而实现分类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记,深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[Hal库][2]stm32时钟树</title>
      <link href="/posts/9067/"/>
      <url>/posts/9067/</url>
      
        <content type="html"><![CDATA[<h1 id="一-锁相环的原理与应用"><a class="markdownIt-Anchor" href="#一-锁相环的原理与应用"></a> 一、锁相环的原理与应用</h1><p>参考文章：<a href="https://blog.csdn.net/weixin_46274168/article/details/130437627">【STM32】知识补充 锁相环原理与应用解析_stm32数字锁相-CSDN博客</a></p><h2 id="什么是锁相环-ppl"><a class="markdownIt-Anchor" href="#什么是锁相环-ppl"></a> 什么是锁相环 (PPL)</h2><p>锁相环是一种闭环反馈控制系统. 用于生成与输入信号同步且<a href="https://so.csdn.net/so/search?q=%E7%9B%B8%E4%BD%8D&amp;spm=1001.2101.3001.7020">相位</a>相同的输出信号. 它的核心功能是在输入信号的相位变化时, 自动调整输出信号以保持同步. 这使得锁相环成为了一种理想的频率和相位控制技术.</p><img src="/posts/9067/f9cb0a753bddf1fb37003ddd1310111b.png" class="" title="锁相环原理图"><h2 id="锁相环的基本组成"><a class="markdownIt-Anchor" href="#锁相环的基本组成"></a> 锁相环的基本组成</h2><p>锁相环主要由以下几个部分组成:</p><ul><li>相位比较器 (Phase Detector): 相位比较器负责比较输入信号和反馈信号的相位差, 并将其转换为电压信号</li><li>低通滤波器 (Low-Pass Filter): 低通滤波器对相位比较器的输出信号进行滤波, 以消除高频噪声和相位抖动</li><li>电压控制振荡器 (Voltage-Controlled Oscillator): 根据低通过滤波器的输出电压调整输出信号的频率和相位</li><li>反馈分频器 (Feedback Divider): 反馈分频器对 VCO 的输出信号进行分频处理, 并将其反馈给相位比较器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Opencv】[1]图像处理基本概念</title>
      <link href="/posts/51713/"/>
      <url>/posts/51713/</url>
      
        <content type="html"><![CDATA[<h1 id="opencv中文文档"><a class="markdownIt-Anchor" href="#opencv中文文档"></a> # OpenCV中文文档</h1><p><a href="https://woshicver.com/">https://woshicver.com/</a></p><h1 id="一-图像处理常见基本概念"><a class="markdownIt-Anchor" href="#一-图像处理常见基本概念"></a> 一、图像处理常见基本概念</h1><h2 id="1bgr和rgb格式"><a class="markdownIt-Anchor" href="#1bgr和rgb格式"></a> 1.BGR和RGB格式</h2><blockquote><ul><li><p>BGR和RGB是两种常见的颜色编码格式，它们在像素颜色排列的顺序上有所不同：</p><ol><li><strong>RGB格式</strong>：<ul><li>RGB指的是红色（R）、绿色（G）、蓝色（B）三个颜色通道的顺序。</li><li>在RGB格式中，像素的颜色值按照红、绿、蓝的顺序排列，即最开始的三个字节依次表示红色、绿色和蓝色分量。</li></ul></li><li><strong>BGR格式</strong>：<ul><li>BGR则是蓝色（B）、绿色（G）、红色（R）的顺序。</li><li>在BGR格式中，像素的颜色值按照蓝、绿、红的顺序排列，即最开始的三个字节依次表示蓝色、绿色和红色分量。</li></ul></li></ol><p>这两种格式主要在图像处理中有所区别。例如，<mark>在OpenCV中，默认情况下读取的图像格式是BGR而非RGB</mark>，这意味着你在处理图像数据时需要注意颜色通道的顺序。如果需要与其他软件或标准的RGB格式进行交互，通常需要进行颜色通道的重新排列。</p><p>总结：</p><ul><li><strong>RGB</strong>：红色、绿色、蓝色，像素颜色排列顺序是RGB。</li><li><strong>BGR</strong>：蓝色、绿色、红色，像素颜色排列顺序是BGR。</li></ul></li></ul><p>RGB格式的缺陷：自然条件下截取的图像，容易受到光线的影响，即对亮度比较敏感，RGB的三个分量都会受亮度的影响。</p></blockquote><h2 id="2-hsv格式"><a class="markdownIt-Anchor" href="#2-hsv格式"></a> 2. HSV格式</h2><blockquote><p>在图像处理中使用较多的是 HSV 颜色空间，它比 RGB 更接近人们对彩色的感知经验。非常直观地表达颜色的色调、鲜艳程度和明暗程度，方便进行颜色的对比。</p><p>​    在 HSV 颜色空间下，比 RGB 更容易跟踪某种颜色的物体，常用于分割指定颜色的物体。</p><p>​    HSV 表达彩色图像的方式由三个部分组成：</p><ul><li>Hue（色调、色相），相当于基调，是下图的俯视图得到的圆，圆上不同位置的颜色基调不同，把颜色分成了360°，每个位置有不同的颜色基调；</li><li>Saturation（饱和度、色彩纯净度）：纯度，沿着俯视图得到的圆的半径看，因为圆弧上的点代表该处的颜色的基调，那么半径上就是从纯白色到该基调颜色过渡过程中不同位置的纯度，在圆心处纯度为0，在圆弧上（该色调）纯度为100；</li><li>Value（明度）：亮度，沿着圆柱的高来看，圆柱表面上平行于圆柱轴上的点的颜色基调相同，纯度也相同，但是明暗程度不同。同时，该圆柱的半径也不同，相当于磁盘的柱面。</li></ul><p>​    用下面这个圆柱体来表示 HSV 颜色空间，圆柱体的横截面可以看做是一个极坐标系 ，H 用极坐标的极角表示，S 用极坐标的极轴长度表示，V 用圆柱中轴的高度表示。</p><img src="/posts/51713/a8d376f7eceb5a45001650bde730f019.png" class="" title="img"></blockquote><h2 id="3-分辨率和像素"><a class="markdownIt-Anchor" href="#3-分辨率和像素"></a> 3. 分辨率和像素</h2><p>1、像素是指照片的点数(表示照片是由多少点构成的)，分辨率是指照片像素点的密度(是用单位尺寸内的像素点，一般用每英寸多少点表示–dpi)。照片实际大小是像素决定的。一个像素很大的照片，如果将分辨率设置很大的话，打印出来的照片可能并不大(但是很清晰)。反之，一个像素并不很大的照片，如果将分辨率设置得很小，那么打印出来的照片可能很大(但是不清晰)。</p><p>2、 分辨率指单位长度上的像素值，与打印质量有关，一般使用的量纲为PPI; 总像素指图片的样本精度，与可打印尺寸有关，通常使用“长×宽”的方式表示，乘积就是通常所说的总像素。由于图片的宽高比不同，所以，同一总像素可以有多种规格。</p><h2 id="4-roi区域"><a class="markdownIt-Anchor" href="#4-roi区域"></a> 4. ROI区域</h2><blockquote><p>在计算机视觉和图像处理中，感兴趣区域（Region of Interest, ROI）是指图像中特别关注的部分。ROI 通常用于提取图像中的特定区域进行进一步的处理和分析，比如特征提取、对象识别、图像分割等。</p><h3 id="roi-的主要作用"><a class="markdownIt-Anchor" href="#roi-的主要作用"></a> ROI 的主要作用：</h3><ol><li><strong>减少处理时间</strong>：通过只处理图像中的特定区域，可以显著减少处理时间，提高效率。</li><li><strong>集中处理目标</strong>：可以将处理的焦点集中在图像中最相关的部分，忽略背景或其他不相关的区域。</li><li><strong>提高精度</strong>：在某些情况下，ROI 的提取可以提高图像处理的精度，尤其是在目标对象占据图像较小区域时。</li></ol><h3 id="如何定义和提取-roi"><a class="markdownIt-Anchor" href="#如何定义和提取-roi"></a> 如何定义和提取 ROI：</h3><p>通常，ROI 是一个矩形区域，可以通过指定其左上角和右下角的坐标来定义。在 OpenCV 中，可以通过数组切片的方式来提取 ROI。</p><h4 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码：</h4><p>以下是一个使用 OpenCV 提取 ROI 的简单示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># 读取图像</span><br><span class="line">image = cv2.imread('image.jpg')</span><br><span class="line"></span><br><span class="line"># 定义ROI的坐标（左上角和右下角）</span><br><span class="line">x1, y1 = 100, 100  # 左上角坐标</span><br><span class="line">x2, y2 = 300, 300  # 右下角坐标</span><br><span class="line"></span><br><span class="line"># 提取ROI区域</span><br><span class="line">roi = image[y1:y2, x1:x2]</span><br><span class="line"></span><br><span class="line"># 显示原图和ROI区域</span><br><span class="line">cv2.imshow('Original Image', image)</span><br><span class="line">cv2.imshow('ROI', roi)</span><br><span class="line"></span><br><span class="line"># 等待按键</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明：</h3><ol><li><strong>读取图像</strong>：使用 <code>cv2.imread()</code> 读取图像文件。</li><li><strong>定义 ROI</strong>：通过指定矩形的左上角 <code>(x1, y1)</code> 和右下角 <code>(x2, y2)</code> 坐标来定义感兴趣区域。</li><li><strong>提取 ROI</strong>：使用切片操作 <code>image[y1:y2, x1:x2]</code> 提取 ROI 区域。</li><li><strong>显示图像</strong>：使用 <code>cv2.imshow()</code> 显示原图和提取的 ROI。</li></ol><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><ul><li><strong>坐标有效性</strong>：确保 ROI 的坐标在图像的范围内，否则会导致错误。</li><li><strong>矩形定义</strong>：左上角坐标 <code>(x1, y1)</code> 应小于右下角坐标 <code>(x2, y2)</code>。</li></ul><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h3><ul><li><strong>目标检测</strong>：提取图像中检测到的目标区域进行进一步分析。</li><li><strong>图像分割</strong>：提取图像中特定的分割区域进行处理。</li><li><strong>特征提取</strong>：只对感兴趣的区域进行特征提取，减少计算量。</li></ul><p>通过合理定义和提取 ROI，可以有效地提高图像处理的效率和精度。</p></blockquote><h1 id="二-opencv介绍"><a class="markdownIt-Anchor" href="#二-opencv介绍"></a> 二、OpenCV介绍</h1><blockquote><p>OpenCV（open source computer vision library）是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。<br>它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。<br>OpenCV用C<ins>语言编写，它的主要接口也是C</ins>语言，但是依然保留了大量的C语言接口。</p></blockquote><p>安装opencv</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></tbody></table></figure><h1 id="三-opencv常用接口"><a class="markdownIt-Anchor" href="#三-opencv常用接口"></a> 三、OpenCV常用接口</h1><h2 id="一-图像入门"><a class="markdownIt-Anchor" href="#一-图像入门"></a> 一、图像入门</h2><p>Opencv常见相关功能库：</p><ul><li>numpy</li><li>Matplotlib</li></ul><h3 id="1-读取图像"><a class="markdownIt-Anchor" href="#1-读取图像"></a> 1. 读取图像</h3><p><code>cv2.imread()</code></p><ul><li>cv.IMREAD_COLOR： 加载彩色图像。任何图像的透明度都会被忽视。它是默认标志。</li><li>cv.IMREAD_GRAYSCALE：以灰度模式加载图像</li><li>cv.IMREAD_UNCHANGED：加载图像，包括alpha通道</li></ul><p><strong>注意</strong>： 除了这三个标志，你可以分别简单地传递整数1、0或-1。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以灰度格式加载图像</span></span><br><span class="line">img_file = cv.imread(<span class="string">"123.jpg"</span>,<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="2-显示图像与用户交互"><a class="markdownIt-Anchor" href="#2-显示图像与用户交互"></a> 2. 显示图像与用户交互</h3><p><code>cv2.imshow()</code></p><p>使用函数**cv2.imshow()**在窗口中显示图像。窗口自动适合图像尺寸。</p><p>第一个参数是窗口名称，它是一个字符串。第二个参数是我们的对象。可以根据需要创建任意多个窗口，可以使用不同的窗口名称</p><p><code>cv.waitKey()</code>是一个键盘绑定函数。其参数是以毫秒为单位的时间。该函数等待任何键盘事件指定的毫秒。如果您在这段时间内按下任何键，程序将继续运行。如果<strong>0</strong>被传递，它将无限期地等待一次敲击键。</p><p><code>cv.destroyAllWindows()</code>破坏创建的所有窗口。</p><p><code>cv.destroyWindow()</code>在其中传递确切的窗口名称作为参数。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv.imshow(<span class="string">"img"</span>,img_file)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><p>PS: <code>cv.namedWindow()</code>可以创建一个空窗口</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv.namedWindow(<span class="string">'image'</span>,cv.WINDOW_NORMAL)</span><br><span class="line">cv.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h3 id="3-写入图像"><a class="markdownIt-Anchor" href="#3-写入图像"></a> 3. 写入图像</h3><p><code>cv2.imwrite()</code></p><p>第一个参数是文件名，第二个参数是要保存的图像。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.imwrite(<span class="string">'messigray.png'</span>,img)</span><br></pre></td></tr></tbody></table></figure><p>这会将图像以PNG格式保存在工作目录中。</p><h3 id="示例总结"><a class="markdownIt-Anchor" href="#示例总结"></a> # 示例总结</h3><p><strong>加载灰度图像，显示图像，按s保存图像，按Esc退出</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">img_file = cv.imread(<span class="string">'img.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">'img'</span>,img_file)</span><br><span class="line">key = cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> key == <span class="number">27</span> : <span class="comment"># 按Esc退出</span></span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line"><span class="keyword">elif</span> key == <span class="built_in">ord</span>(<span class="string">'s'</span>): <span class="comment"># 按s保存图像并退出</span></span><br><span class="line">    cv.imwrite(<span class="string">'img_file_save.png'</span>,img_file)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h3 id="matplotlib"><a class="markdownIt-Anchor" href="#matplotlib"></a> # Matplotlib</h3><p>Matplotlib 是 Python 2D-绘图领域使用最广泛的套件。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用matplotlib库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img =  cv.imread(<span class="string">'img.png'</span>,<span class="number">0</span>)</span><br><span class="line">plt.imshow(img, cmap = <span class="string">'gray'</span>, interpolation = <span class="string">'bicubic'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])  <span class="comment"># 隐藏 x 轴和 y 轴上的刻度值</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><h2 id="二-视频入门"><a class="markdownIt-Anchor" href="#二-视频入门"></a> 二、视频入门</h2><h3 id="1-驱动相机读取视频"><a class="markdownIt-Anchor" href="#1-驱动相机读取视频"></a> 1. 驱动相机读取视频</h3><p>可以通过<code>cap.isOpened()</code>方法检查它是否已初始化。如果是<code>True</code>，那么确定。否则，使用<code>cap.open()</code>打开它</p><p><code>cap.read()</code>返回布尔值(<code>True</code>/ <code>False</code>)。如果正确读取了帧，它将为<code>True</code>。因此，你可以通过检查此返回值来检查视频的结尾</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"can't not open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'can not recevie frame'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">'video'</span>,gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) ==  <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">cap.release() <span class="comment"># 释放视频捕获</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><p>注意：waitKey() 传入参数’0’会导致视频显示卡在一帧中</p><blockquote><p>正确使用方法：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) ==  <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure><p>waitKey()相当于一个阻塞式的函数,如<code>delay()</code></p></blockquote><h3 id="2-获取视频格式"><a class="markdownIt-Anchor" href="#2-获取视频格式"></a> 2. 获取视频格式</h3><p>可以使用<code>cap.get(propId)</code>方法访问该视频的某些功能，其中propId是0到18之间的一个数字。每个数字表示视频的属性（如果适用于该视频），并且可以显示完整的详细信息在这里看到：<strong>cv::VideoCapture::get()</strong></p><p>例如，我可以通过<code>cap.get(cv.CAP_PROP_FRAME_WIDTH)</code>和<code>cap.get(cv.CAP_PROP_FRAME_HEIGHT)</code>检查框架的宽度和高度</p><h3 id="3-设置视频格式"><a class="markdownIt-Anchor" href="#3-设置视频格式"></a> 3. 设置视频格式</h3><p>默认情况下，视频的分辨率为640x480，使用<code>cap.set()</code>设置即可</p><ul><li><code>cap.set(cv.CAP_PROP_FOURCC, codec)</code></li><li><code>cap.set(cv.CAP_PROP_FPS, 30)</code> #帧数</li><li><code>cap.set(cv.CAP_PROP_FRAME_WIDTH, 1920)</code>#列 宽度</li><li><code>cap.set(cv.CAP_PROP_FRAME_HEIGHT, 1080)</code> # 行 高度</li></ul><p>PS :  <code>codec = cv.VideoWriter_fourcc('M', 'J', 'P', 'G')</code></p><blockquote><p>**一、简介 **<br><code>cv2.VideoWriter_fourcc</code>是 OpenCV 中用于定义视频编解码器的函数，它将四个字符的编码（FourCC）转换为一个用于视频编码器的整数。FourCC 是一种四字符编码，用于指定视频文件中使用的压缩方式。</p><p><strong>二、语法和参数</strong></p><ol><li>语法<br><code>cv2.VideoWriter_fourcc(c1, c2, c3, c4)</code><br>2.参数<br>c1, c2, c3, c4：表示四个字符的编码，每个字符是一个字符，代表不同的视频编码器。常用的编码器包括：</li></ol><ul><li>‘XVID’：常用于 .avi 格式的视频文件。</li><li>‘MP4V’：常用于 .mp4 格式的视频文件。</li><li>‘MJPG’：适用于使用 Motion JPEG 编码的视频。</li></ul><p>3.返回值</p><p>返回一个整数，该整数用于创建 cv2.VideoWriter 对象时指定视频编码格式。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line">codec = cv.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FOURCC, codec)</span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FPS, <span class="number">30</span>) <span class="comment">#帧数</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_WIDTH, <span class="number">1920</span>) <span class="comment">#列 宽度</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_HEIGHT, <span class="number">1080</span>) <span class="comment"># 行 高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"can't not open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'can not recevie frame'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">'video'</span>,gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) ==  <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">cap.release() <span class="comment"># 释放视频捕获</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h2 id="4-保存视频"><a class="markdownIt-Anchor" href="#4-保存视频"></a> 4. 保存视频</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line">fourcc = cv.VideoWriter_fourcc(*<span class="string">'XVID'</span>)</span><br><span class="line">out = cv.VideoWriter(<span class="string">'output.avi'</span>,fourcc,<span class="number">20.0</span>,(<span class="number">1920</span>,<span class="number">1080</span>))</span><br><span class="line"></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FPS, <span class="number">30</span>) <span class="comment">#帧数</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_WIDTH, <span class="number">1920</span>) <span class="comment">#列 宽度</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_HEIGHT, <span class="number">1080</span>) <span class="comment"># 行 高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"can't open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'not get'</span>)</span><br><span class="line">    </span><br><span class="line">    frame = cv.flip(frame, <span class="number">0</span>)</span><br><span class="line">    out.write(frame)</span><br><span class="line">    cv.imshow(<span class="string">"video"</span>,frame)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h2 id="5-播放视频"><a class="markdownIt-Anchor" href="#5-播放视频"></a> 5. 播放视频</h2><p>跟捕获摄像头一致，只需要修改捕获的对象即可</p><p>如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="string">'vtest.avi'</span>)</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># 如果正确读取帧，ret为True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Can't receive frame (stream end?). Exiting ..."</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">'frame'</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h2 id="三-绘图功能"><a class="markdownIt-Anchor" href="#三-绘图功能"></a> 三、绘图功能</h2><h2 id="四-鼠标事件"><a class="markdownIt-Anchor" href="#四-鼠标事件"></a> 四、鼠标事件</h2><h2 id="五-滑块调参"><a class="markdownIt-Anchor" href="#五-滑块调参"></a> 五、滑块调参</h2><p><code>cv.createTrackbar()</code>：</p><ul><li><p>第一个参数是轨迹栏名称</p></li><li><p>第二个参数是它附加到的窗口名称</p></li><li><p>第三个参数是默认值</p></li><li><p>第四个参数是最大值</p></li><li><p>第五个是执行的回调函数每次跟踪栏值更改</p></li></ul><p>Opencv本身没有提供按钮相关的api，可以利用滑块函数，设定参数值为0/1，达到按钮的效果。</p><p><code>cv.getTrackbarPos()</code></p><ul><li><p>第一个参数是轨迹栏名称</p></li><li><p>第二个参数是窗口名称</p><p>使用<code>cv.getTrackbarPos()</code>函数，在主循环中可以实时响应滑块调节的对应轨道参数值</p></li></ul><p><strong>示例程序</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个黑色的图像，一个窗口</span></span><br><span class="line">img = np.zeros((<span class="number">300</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">'image'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建RGB调整滑块栏</span></span><br><span class="line">cv.createTrackbar(<span class="string">'R'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">'G'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">'B'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 ON/OFF 功能创建开关</span></span><br><span class="line">switch = <span class="string">'0 : OFF \n1 : ON'</span></span><br><span class="line">cv.createTrackbar(switch, <span class="string">'image'</span>,<span class="number">0</span>,<span class="number">1</span>,nothing)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">'image'</span>,img)</span><br><span class="line"></span><br><span class="line">    r = cv.getTrackbarPos(<span class="string">'R'</span>,<span class="string">'image'</span>)</span><br><span class="line">    g = cv.getTrackbarPos(<span class="string">'G'</span>,<span class="string">'image'</span>)</span><br><span class="line">    b = cv.getTrackbarPos(<span class="string">'B'</span>,<span class="string">'image'</span>)</span><br><span class="line">    s = cv.getTrackbarPos(switch,<span class="string">'image'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">        img[:] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img[:] = [b,g,r]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h1 id="四-opencv核心操作"><a class="markdownIt-Anchor" href="#四-opencv核心操作"></a> 四、OpenCV核心操作</h1><h2 id="一-图像的基本操作"><a class="markdownIt-Anchor" href="#一-图像的基本操作"></a> 一、图像的基本操作</h2><h2 id="二-图像的位运算"><a class="markdownIt-Anchor" href="#二-图像的位运算"></a> 二、图像的位运算</h2><h2 id="三-性能优化"><a class="markdownIt-Anchor" href="#三-性能优化"></a> 三、性能优化</h2><h3 id="1-衡量代码性能的方式"><a class="markdownIt-Anchor" href="#1-衡量代码性能的方式"></a> 1. 衡量代码性能的方式</h3><p><code>cv.getTickCount</code>函数返回从参考事件（如打开机器的那一刻）到调用此函数那一刻之间的时钟周期数。因此，如果在函数执行之前和之后调用它，则会获得用于执行函数的时钟周期数。</p><p><code>cv.getTickFrequency</code>函数返回时钟周期的频率或每秒的时钟周期数。因此，要找到执行时间（以秒为单位），你可以执行以下操作：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1 = cv.getTickCount()</span><br><span class="line"><span class="comment"># 你的执行代码</span></span><br><span class="line">e2 = cv.getTickCount()</span><br><span class="line">time = (e2 - e1)/ cv.getTickFrequency()</span><br></pre></td></tr></tbody></table></figure><p>除了OpenCV，Python还提供了一个模块<strong>time</strong>，这有助于衡量执行时间。另一个模块<strong>profile</strong>有助于获取有关代码的详细报告，例如代码中每个函数花费了多少时间，调用了函数的次数等。</p><h3 id="2-opencv默认的性能优化"><a class="markdownIt-Anchor" href="#2-opencv默认的性能优化"></a> 2. OpenCV默认的性能优化</h3><p>许多 OpenCV 函数都是使用 SSE2、 AVX 等进行优化的。 它还包含未优化的代码。因此，如果我们的系统支持这些特性，我们就应该利用它们(几乎所有现代的处理器都支持它们)。在编译时默认启用它。因此，如果启用了 OpenCV，它将运行优化的代码，否则它将运行未优化的代码。可以使用 <strong>cvUseoptimized</strong> 检查是否启用 / 禁用和 <strong>cvSetuseoptimized</strong> 以启用 / 禁用它。让我们看一个简单的例子。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查是否启用了优化</span></span><br><span class="line">In [<span class="number">5</span>]: cv.useOptimized()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="literal">True</span></span><br><span class="line">In [<span class="number">6</span>]: %timeit res = cv.medianBlur(img,<span class="number">49</span>)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">34.9</span> ms per loop</span><br><span class="line"><span class="comment"># 关闭它</span></span><br><span class="line">In [<span class="number">7</span>]: cv.setUseOptimized(<span class="literal">False</span>)</span><br><span class="line">In [<span class="number">8</span>]: cv.useOptimized()</span><br><span class="line">Out[<span class="number">8</span>]: <span class="literal">False</span></span><br><span class="line">In [<span class="number">9</span>]: %timeit res = cv.medianBlur(img,<span class="number">49</span>)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">64.1</span> ms per loop</span><br></pre></td></tr></tbody></table></figure><p>优化的中值滤波比未优化的版本快2倍。如果你检查其来源，可以看到中值滤波是 SIMD 优化。因此，可以使用它在代码顶部启用优化(默认启用的)</p><h3 id="3-性能优化方式"><a class="markdownIt-Anchor" href="#3-性能优化方式"></a> 3. 性能优化方式</h3><blockquote><p>在Python和NumPy中优化性能的技术和编码方法的关键技术：</p><h3 id="1-避免显式循环"><a class="markdownIt-Anchor" href="#1-避免显式循环"></a> 1. <strong>避免显式循环</strong></h3><ul><li><strong>描述</strong>：尽量避免使用<code>for</code>循环，尤其是双重或三重循环。使用NumPy的向量化操作。</li><li><strong>来源</strong>：NumPy User Guide - Array Programming</li></ul><h3 id="2-向量化操作"><a class="markdownIt-Anchor" href="#2-向量化操作"></a> 2. <strong>向量化操作</strong></h3><ul><li><strong>描述</strong>：利用NumPy的数组运算和广播功能来实现高效的向量化操作，避免逐元素计算。</li><li><strong>来源</strong>：NumPy Vectorization</li></ul><h3 id="3-缓存一致性"><a class="markdownIt-Anchor" href="#3-缓存一致性"></a> 3. <strong>缓存一致性</strong></h3><ul><li><strong>描述</strong>：确保数据在内存中的布局有利于CPU缓存，从而提高访问速度。例如，使用行优先的存储方式。</li><li><strong>来源</strong>：Understanding Cache and Memory</li></ul><h3 id="4-避免不必要的数组复制"><a class="markdownIt-Anchor" href="#4-避免不必要的数组复制"></a> 4. <strong>避免不必要的数组复制</strong></h3><ul><li><strong>描述</strong>：尽量使用数组视图而非副本，这样可以减少内存开销。使用<code>np.view()</code>或切片来创建视图。</li><li><strong>来源</strong>：NumPy Views</li></ul><h3 id="5-使用cython和numba"><a class="markdownIt-Anchor" href="#5-使用cython和numba"></a> 5. <strong>使用Cython和Numba</strong></h3><ul><li><p>描述</p><p>：如果在使用NumPy和向量化后代码仍然很慢，可以考虑使用Cython或Numba对性能关键部分进行加速。</p><ul><li><strong>Cython</strong>：允许将Python代码转换为C，以提高性能。</li><li><strong>Numba</strong>：通过JIT编译加速NumPy代码，特别是循环。</li></ul></li><li><p>来源：</p><ul><li><a href="https://cython.readthedocs.io/en/latest/">Cython Documentation</a></li><li>Numba Documentation</li></ul></li></ul><h3 id="6-使用并行计算"><a class="markdownIt-Anchor" href="#6-使用并行计算"></a> 6. <strong>使用并行计算</strong></h3><ul><li><strong>描述</strong>：对于大规模计算任务，可以利用并行处理库（如<code>multiprocessing</code>或<code>joblib</code>）来加速计算。</li><li><strong>来源</strong>：<a href="https://docs.python.org/3/library/multiprocessing.html">Python Multiprocessing</a></li></ul><h3 id="7-profiling和性能分析"><a class="markdownIt-Anchor" href="#7-profiling和性能分析"></a> 7. <strong>Profiling和性能分析</strong></h3><ul><li><strong>描述</strong>：使用性能分析工具（如<code>cProfile</code>和<code>line_profiler</code>）找出性能瓶颈，针对性优化。</li><li>来源：<ul><li><a href="https://docs.python.org/3/library/profile.html">cProfile Documentation</a></li><li><a href="https://github.com/pyutils/line_profiler">line_profiler</a></li></ul></li></ul><h3 id="8-利用科学计算库"><a class="markdownIt-Anchor" href="#8-利用科学计算库"></a> 8. <strong>利用科学计算库</strong></h3><ul><li><strong>描述</strong>：对于特定任务，利用专门的科学计算库（如SciPy、Pandas）进行更高效的数据处理和分析。</li><li><strong>来源</strong>：SciPy Documentation</li></ul></blockquote><h1 id="向量化"><a class="markdownIt-Anchor" href="#向量化"></a> # 向量化</h1><blockquote><p>在Python中，向量化主要是指使用NumPy和其他库（如Pandas和TensorFlow）来处理数组和矩阵数据的能力，从而提高计算效率。以下是一些在Python中向量化的常见用法：</p><h3 id="1-使用numpy进行向量化"><a class="markdownIt-Anchor" href="#1-使用numpy进行向量化"></a> 1. 使用NumPy进行向量化</h3><p>NumPy是Python中用于数值计算的库，它提供了高效的数组操作。通过向量化，你可以避免使用显式的循环，从而提高代码的性能。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个NumPy数组</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素加2</span></span><br><span class="line">b = a + <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出: [3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素平方</span></span><br><span class="line">c = a ** <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出: [ 1  4  9 16 25]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-使用pandas进行向量化"><a class="markdownIt-Anchor" href="#2-使用pandas进行向量化"></a> 2. 使用Pandas进行向量化</h3><p>Pandas是用于数据分析的库，它提供了类似于NumPy的向量化操作，适用于处理DataFrame和Series对象。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Pandas Series</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素乘以3</span></span><br><span class="line">s2 = s * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(s2)  <span class="comment"># 输出: 0    3, 1    6, 2    9, 3   12, 4   15</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-使用tensorflow进行向量化"><a class="markdownIt-Anchor" href="#3-使用tensorflow进行向量化"></a> 3. 使用TensorFlow进行向量化</h3><p>在深度学习中，TensorFlow也广泛使用向量化来进行大规模的矩阵运算。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TensorFlow张量</span></span><br><span class="line">x = tf.constant([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素加5</span></span><br><span class="line">y = x + <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(y.numpy())  <span class="comment"># 输出: [ 6  7  8  9 10]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>向量化通过批量处理数据，减少了循环的使用，从而提高了代码的性能和可读性。在进行数值计算时，推荐尽量使用向量化的方法。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记,计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】PID平衡小车项目实战</title>
      <link href="/posts/25248/"/>
      <url>/posts/25248/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[11]IIC通信(mpu6050)</title>
      <link href="/posts/5621/"/>
      <url>/posts/5621/</url>
      
        <content type="html"><![CDATA[<h1 id="iic通信协议"><a class="markdownIt-Anchor" href="#iic通信协议"></a> IIC通信协议</h1><h2 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h2><ul><li><p>同步时序的稳定性比异步时序更高</p></li><li><p>半双工</p></li><li><p>SCL、SDA两根通信线</p></li><li><p>支持总线挂载（一主多从，多主多从）</p></li></ul><h2 id="硬件电路"><a class="markdownIt-Anchor" href="#硬件电路"></a> 硬件电路</h2><ul><li>所有I2C设备的SCL连接在一起，SDA连接在一起</li><li>设备的SCL和SDA均要配置成开漏输出模式(防止形成短路电流，SDA要么<mark>被上拉</mark>，要么<mark>输出低电平</mark>)，会有“线与”的现象。在多主机的模式下，可以利用线与的特性，实现总线仲裁和时钟同步。</li><li>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</li></ul><img src="/posts/5621/image-20240524211453559.png" class="" title="image-20240524211453559"><hr><img src="/posts/5621/image-20240524212810776.png" class="" title="image-20240524212810776"><p><strong>PS：IIC时序是高位先行，串口是低位先行</strong></p><hr><img src="/posts/5621/image-20240524212934134.png" class="" title="image-20240524212934134"><p><strong>PS：主机接收时，需要释放SDA，即输入模式</strong></p><hr><img src="/posts/5621/image-20240524213709342.png" class="" title="image-20240524213709342"><p><strong>PS:从机的地址可以通过电路改变</strong></p><hr><img src="/posts/5621/image-20240524214219090.png" class="" title="image-20240524214219090"><p><strong><mark>红线处，此时需要从机应答，这里如果但看主机的SDA，应该会释放SDA，即高电平，由于从机要发送应答，根据线与的特性，这里拉低了SDA，所以最后SDA呈现图中所示。</mark></strong></p><hr><img src="/posts/5621/image-20240524214908190.png" class="" title="image-20240524214908190"><p><strong>IIC通信的设备中会有单独一个字节空间存储地址指针，当给IIC设备指定地址写时，地址指针会加一，这时如果使用当前地址读，就是读取指针地址指向的内存。此时序较为少用、</strong></p><hr><img src="/posts/5621/image-20240524215204768.png" class="" title="image-20240524215204768"><p><strong><mark>指定地址读的实现原理：先调用指定地址写，但是不写数据。再次调用当前地址读，这样复合的时序就能完成指定地址读的功能了</mark></strong></p><h1 id="mpu6050"><a class="markdownIt-Anchor" href="#mpu6050"></a> MPU6050</h1><img src="/posts/5621/image-20240524220155605.png" class="" title="image-20240524220155605"><h2 id="姿态角欧拉角"><a class="markdownIt-Anchor" href="#姿态角欧拉角"></a> 姿态角（欧拉角）</h2><img src="/posts/5621/image-20240524220352017.png" class="" title="image-20240524220352017"><p><strong>飞机相对于初始三个轴的夹角：</strong></p><ul><li>俯仰角：Pitch</li><li>滚转：Roll</li><li>偏航：Yaw</li></ul><p>要想获得稳定的欧拉角，就需要进行数据融合，进一步得到姿态角。</p><p><strong>常见的数据融合算法：</strong></p><ul><li>互补滤波</li><li>卡尔曼滤波</li></ul><p>ps:惯性导航领域里，姿态解算</p><h2 id="加速度计结构"><a class="markdownIt-Anchor" href="#加速度计结构"></a> 加速度计结构</h2><img src="/posts/5621/image-20240524220855509.png" class="" title="image-20240524220855509"><p><strong>F=ma(测力计)</strong></p><img src="/posts/5621/image-20240524221000525.png" class="" title="image-20240524221000525"><p><strong><mark>加速度计测得的是静态加速度，只能在物体静止的时候使用</mark></strong></p><h2 id="陀螺仪传感器"><a class="markdownIt-Anchor" href="#陀螺仪传感器"></a> 陀螺仪传感器</h2><img src="/posts/5621/image-20240524221506605.png" class="" title="image-20240524221506605"><p><strong>测得的是角速度，要想得到角度，可以进行求积分</strong></p><p><strong><mark>陀螺仪具有动态稳定性，不具有静态稳定性</mark></strong></p><p><strong><mark>对两种传感器进行互补滤波，就可以得到稳定的姿态角了</mark></strong></p><h2 id="mpu6050的参数"><a class="markdownIt-Anchor" href="#mpu6050的参数"></a> MPU6050的参数</h2><img src="/posts/5621/image-20240524221944683.png" class="" title="image-20240524221944683"><p>eg: mpu6050的从机地址：0x68 ，IIC时序中发送的第一个字节，高七位为从机地址，第八位为读写位。有时候把0XD0当作MPU6050的地址</p><h2 id="硬件结构"><a class="markdownIt-Anchor" href="#硬件结构"></a> 硬件结构</h2><img src="/posts/5621/image-20240525205511856.png" class="" title="image-20240525205511856"><blockquote><p><strong>六轴传感器的缺点：没有稳定的参考方向</strong></p><p>XCL，XDA：挂载磁力计，气压计</p><p>INT引脚：可以配置MPU6050内部一些事件，产生电平跳变</p><p>PS：MPU6050内部包含DMP单元：进行姿态融合和数据结算</p><p>包含稳压电路</p></blockquote><p><mark><strong>传感器内部含有自测单元</strong></mark></p><img src="/posts/5621/image-20240525210718105.png" class="" title="image-20240525210718105"><p>使能自测-&gt;读取数据1-&gt;失能自测-&gt;读取数据2，两个数据相减，得到的数据称作自测响应，自测响应如果在<mark>规定的范围内</mark>，说明芯片性能没问题。</p><hr><p><strong>电荷泵</strong></p><img src="/posts/5621/image-20240525210953979.png" class="" title="image-20240525210953979"><p>是一种<mark>升压电路</mark></p><p>原理：电源和电容串并联的切换（充电-&gt;串联-&gt;相当于电压升高（放电）-&gt;快速切换到并联-&gt;充电-&gt;循环）+ 电容滤波 = 平稳升压</p><img src="/posts/5621/image-20240525211051107.png" class="" title="image-20240525211051107"><hr><p><strong>DMP</strong>（数字运动处理器）</p><img src="/posts/5621/image-20240525211323304.png" class="" title="image-20240525211323304"><p>配合MPU6050官方的DMP库，进行姿态解算。</p><p><mark>引脚说明</mark></p><blockquote><p>FSYNC：帧同步</p></blockquote><blockquote><p>通信接口：用于和STM32通信</p><img src="/posts/5621/image-20240525211535797.png" class="" title="image-20240525211535797"></blockquote><blockquote><p>xxxxxxxxxx&nbsp;python script_name.py --train_data_dir “path/to/train_data” --test_data_dir “path/to/test_data” --img_height 128 --img_width 128 --batch_size 64 --epochs 15python</p><p>​可以拓展连接磁力计</p><img src="/posts/5621/image-20240525211622949.png" class="" title="image-20240525211622949"></blockquote><hr><h2 id="软件iic读写mpu6050"><a class="markdownIt-Anchor" href="#软件iic读写mpu6050"></a> 软件IIC读写MPU6050</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MyIIC.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主机寻址MPU6050*/</span></span><br><span class="line">MyIIC_Init();</span><br><span class="line">MyIIC_Start();</span><br><span class="line">MyIIC_SendByte(<span class="number">0xD0</span>);<span class="comment">//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="type">uint8_t</span> Ack = MyIIC_ReceiveAck();</span><br><span class="line">MyIIC_Stop();</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Ack,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> <img src="/posts/5621/image-20240525224436566.png" class="" title="image-20240525224436566"><hr><p><strong>修改MPU6050地址</strong></p><p>可见，寻址无应答</p><img src="/posts/5621/image-20240526152458852.png" class="" title="image-20240526152458852"><hr><p><strong>读取MPU6050 ID号</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="comment">/*//主机寻址MPU6050</span></span><br><span class="line"><span class="comment">MyIIC_Init();</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(0xD2);//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="comment">uint8_t Ack = MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">OLED_ShowNum(1,1,Ack,3);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//读取MPU6050ID号</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154358599.png" class="" title="image-20240526154358599"><hr><p><strong>写MPU6050</strong>，需要关闭MPU6050的睡眠模式</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//在电源管理器1，写入0x00，接触睡眠模式</span></span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//更改采样频率</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x19</span>);<span class="comment">//读取MPU6050采样频率</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154723015.png" class="" title="image-20240526154723015"><p><strong>PS:某种程度上来说，对寄存器的读写操作可以看作读写一个存储器，但是寄存器能反应硬件电路的状态，对硬件电路进行操作</strong></p><hr><h2 id="mpu6050读取六轴姿态值"><a class="markdownIt-Anchor" href="#mpu6050读取六轴姿态值"></a> MPU6050读取六轴姿态值</h2><p><strong>函数定义</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用指针，实现函数多返回值的操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params"><span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> DataH ,DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">*AccX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">*AccY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">*AccZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">*GyroX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">*GyroY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">*GyroZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int16_t</span> Ax,Ay,Az,Gx,Gy,Gz;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">MPU6050_GetData(&amp;Ax,&amp;Ay,&amp;Az,&amp;Gx,&amp;Gy,&amp;Gz);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">1</span>,Ax,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">1</span>,Ay,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">1</span>,Az,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">8</span>,Gx,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">8</span>,Gy,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">8</span>,Gz,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>加速度计最大量程为16g</strong></p><img src="/posts/5621/image-20240526162104183.png" class="" title="image-20240526162104183"><p>左侧为加速度计，右侧为角速度测量值</p><hr><h2 id="硬件iic读写mpu6050"><a class="markdownIt-Anchor" href="#硬件iic读写mpu6050"></a> 硬件IIC读写MPU6050</h2><p>CR：控制寄存器</p><p>DR：数据寄存器</p><p>SR：状态寄存器</p><p><strong>STM32IIC外设</strong></p><img src="/posts/5621/image-20240526162959527.png" class="" title="image-20240526162959527"><h3 id="多主机模型"><a class="markdownIt-Anchor" href="#多主机模型"></a> 多主机模型</h3><p><strong>一主多从</strong></p><img src="/posts/5621/image-20240526163123491.png" class="" title="image-20240526163123491"><p><strong>多主多从</strong></p><p>固定多主机：</p><img src="/posts/5621/image-20240526163142347.png" class="" title="image-20240526163142347"><p>可变多主机：</p><img src="/posts/5621/image-20240526163226138.png" class="" title="image-20240526163226138"><p><strong>GPIO复用输入和复用输出</strong></p><img src="/posts/5621/image-20240526164412282.png" class="" title="image-20240526164412282"><p><strong>IIC主机发送流程图</strong></p><img src="/posts/5621/image-20240526165109626.png" class="" title="image-20240526165109626"><p><strong>IIC主机接收流程图</strong></p><img src="/posts/5621/image-20240526165718823.png" class="" title="image-20240526165718823"><h3 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h3><blockquote><p><strong>产生起始条件</strong></p><p>void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>生成终止条件</strong></p><p>void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>配置在收到一个字节后，是否给从机应答</strong></p><p>void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>写数据到数据寄存器DR</strong></p><p>void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);</p><p><strong>读取DR的数据，作为返回值</strong></p><p>uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);</p><p><strong>发送7位地址</strong></p><p>void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);</p></blockquote><p><strong>状态监控函数的官方说明</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> ****************************************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                         I2C State Monitoring Functions</span></span><br><span class="line"><span class="comment"> *                       </span></span><br><span class="line"><span class="comment"> ****************************************************************************************   </span></span><br><span class="line"><span class="comment"> * This I2C driver provides three different ways for I2C state monitoring</span></span><br><span class="line"><span class="comment"> *  depending on the application requirements and constraints:</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 1) Basic state monitoring:</span></span><br><span class="line"><span class="comment"> *    Using I2C_CheckEvent() function:</span></span><br><span class="line"><span class="comment"> *    It compares the status registers (SR1 and SR2) content to a given event</span></span><br><span class="line"><span class="comment"> *    (can be the combination of one or more flags).</span></span><br><span class="line"><span class="comment"> *    It returns SUCCESS if the current status includes the given flags </span></span><br><span class="line"><span class="comment"> *    and returns ERROR if one or more flags are missing in the current status.</span></span><br><span class="line"><span class="comment"> *    - When to use:</span></span><br><span class="line"><span class="comment"> *      - This function is suitable for most applications as well as for startup </span></span><br><span class="line"><span class="comment"> *      activity since the events are fully described in the product reference manual </span></span><br><span class="line"><span class="comment"> *      (RM0008).</span></span><br><span class="line"><span class="comment"> *      - It is also suitable for users who need to define their own events.</span></span><br><span class="line"><span class="comment"> *    - Limitations:</span></span><br><span class="line"><span class="comment"> *      - If an error occurs (ie. error flags are set besides to the monitored flags),</span></span><br><span class="line"><span class="comment"> *        the I2C_CheckEvent() function may return SUCCESS despite the communication</span></span><br><span class="line"><span class="comment"> *        hold or corrupted real state. </span></span><br><span class="line"><span class="comment"> *        In this case, it is advised to use error interrupts to monitor the error</span></span><br><span class="line"><span class="comment"> *        events and handle them in the interrupt IRQ handler.</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *        @note </span></span><br><span class="line"><span class="comment"> *        For error management, it is advised to use the following functions:</span></span><br><span class="line"><span class="comment"> *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).</span></span><br><span class="line"><span class="comment"> *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.</span></span><br><span class="line"><span class="comment"> *            Where x is the peripheral instance (I2C1, I2C2 ...)</span></span><br><span class="line"><span class="comment"> *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()</span></span><br><span class="line"><span class="comment"> *            in order to determine which error occurred.</span></span><br><span class="line"><span class="comment"> *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()</span></span><br><span class="line"><span class="comment"> *            and/or I2C_GenerateStop() in order to clear the error flag and source,</span></span><br><span class="line"><span class="comment"> *            and return to correct communication status.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  2) Advanced state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetLastEvent() which returns the image of both status </span></span><br><span class="line"><span class="comment"> *     registers in a single word (uint32_t) (Status Register 2 value is shifted left </span></span><br><span class="line"><span class="comment"> *     by 16 bits and concatenated to Status Register 1).</span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *       - This function is suitable for the same applications above but it allows to</span></span><br><span class="line"><span class="comment"> *         overcome the limitations of I2C_GetFlagStatus() function (see below).</span></span><br><span class="line"><span class="comment"> *         The returned value could be compared to events already defined in the </span></span><br><span class="line"><span class="comment"> *         library (stm32f10x_i2c.h) or to custom values defined by user.</span></span><br><span class="line"><span class="comment"> *       - This function is suitable when multiple flags are monitored at the same time.</span></span><br><span class="line"><span class="comment"> *       - At the opposite of I2C_CheckEvent() function, this function allows user to</span></span><br><span class="line"><span class="comment"> *         choose when an event is accepted (when all events flags are set and no </span></span><br><span class="line"><span class="comment"> *         other flags are set or just when the needed flags are set like </span></span><br><span class="line"><span class="comment"> *         I2C_CheckEvent() function).</span></span><br><span class="line"><span class="comment"> *     - Limitations:</span></span><br><span class="line"><span class="comment"> *       - User may need to define his own events.</span></span><br><span class="line"><span class="comment"> *       - Same remark concerning the error management is applicable for this </span></span><br><span class="line"><span class="comment"> *         function if user decides to check only regular communication flags (and </span></span><br><span class="line"><span class="comment"> *         ignores error flags).</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3) Flag-based state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetFlagStatus() which simply returns the status of </span></span><br><span class="line"><span class="comment"> *     one single flag (ie. I2C_FLAG_RXNE ...). </span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *        - This function could be used for specific applications or in debug phase.</span></span><br><span class="line"><span class="comment"> *        - It is suitable when only one flag checking is needed (most I2C events </span></span><br><span class="line"><span class="comment"> *          are monitored through multiple flags).</span></span><br><span class="line"><span class="comment"> *     - Limitations: </span></span><br><span class="line"><span class="comment"> *        - When calling this function, the Status register is accessed. Some flags are</span></span><br><span class="line"><span class="comment"> *          cleared when the status register is accessed. So checking the status</span></span><br><span class="line"><span class="comment"> *          of one Flag, may clear other ones.</span></span><br><span class="line"><span class="comment"> *        - Function may need to be called twice or more in order to monitor one </span></span><br><span class="line"><span class="comment"> *          single event.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="iic配置占空比的缘由"><a class="markdownIt-Anchor" href="#iic配置占空比的缘由"></a> #IIC配置占空比的缘由</h3><p><strong>上升沿变化较慢，下降沿比较迅速，标准速度下，时钟占空比接近1：1，快速状态，占空比接近2：1</strong></p><img src="/posts/5621/image-20240526174725131.png" class="" title="image-20240526174725131"><p>100KHZ</p><img src="/posts/5621/image-20240526174831972.png" class="" title="image-20240526174831972"><p>400KHZ</p><img src="/posts/5621/image-20240526174841651.png" class="" title="image-20240526174841651"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> *  <span class="number">1</span>) Basic state monitoring</span><br><span class="line"> *******************************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Checks whether the last I2Cx Event is equal to the one passed</span></span><br><span class="line"><span class="comment">  *   as parameter.</span></span><br><span class="line"><span class="comment">  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.</span></span><br><span class="line"><span class="comment">  * @param  I2C_EVENT: specifies the event to be checked. </span></span><br><span class="line"><span class="comment">  *   This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     </span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9</span></span><br><span class="line"><span class="comment">  *     </span></span><br><span class="line"><span class="comment">  * @note: For detailed description of Events, please refer to section </span></span><br><span class="line"><span class="comment">  *    I2C_Events in stm32f10x_i2c.h file.</span></span><br><span class="line"><span class="comment">  *    </span></span><br><span class="line"><span class="comment">  * @retval An ErrorStatus enumeration value:</span></span><br><span class="line"><span class="comment">  * - SUCCESS: Last event is equal to the I2C_EVENT</span></span><br><span class="line"><span class="comment">  * - ERROR: Last event is different from the I2C_EVENT</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解决while死循环等待的问题"><a class="markdownIt-Anchor" href="#解决while死循环等待的问题"></a> 解决WHILE死循环等待的问题</h3><p><strong>多个while,比较危险，一旦通信出现问题，程序直接卡死</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*软件I2C，阻塞式程序</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();//可以加判断，确保时序的正确</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(RegAddress);//指定要写入的寄存器</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(Data);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//硬件IIC，非阻塞式程序</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT ) !=SUCCESS);<span class="comment">//事件监测</span></span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//选择I2C外设，从机地址，从机地址最低位。此函数自带接收应答的功能</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,RegAddress);<span class="comment">//写入DR，需要等待EV8事件</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,Data);</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) !=SUCCESS);<span class="comment">//发送完最后一个字节，需要监测EB8_1事件</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTOP(I2C2,ENABLE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>保护程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Timeout;</span><br><span class="line">Timeout= <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2Cx,I2C_EVENT) != SUCCESS)</span><br><span class="line">{</span><br><span class="line">Timeout--;</span><br><span class="line"><span class="keyword">if</span>(Timeout==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="dmp库"><a class="markdownIt-Anchor" href="#dmp库"></a> DMP库</h1><p>digital motion processor数字运动处理器，mpu6050自带的一个硬件，可以直接输出用于姿态结算的四元数</p><h1 id="卡尔曼滤波"><a class="markdownIt-Anchor" href="#卡尔曼滤波"></a> 卡尔曼滤波</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> IIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[9]DMA数据转运</title>
      <link href="/posts/10712/"/>
      <url>/posts/10712/</url>
      
        <content type="html"><![CDATA[<h1 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h1><blockquote><p><strong>恢复缺省配置</strong></p><p>void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>初始化DMA</strong></p><p>void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>DMA使能</strong></p><p>void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);</p><p><strong>中断输出使能</strong></p><p>void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);</p><p><strong>DMA设置当前数据寄存器</strong></p><p>void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);</p><p><strong>DMA获取当前数据寄存器</strong></p><p>uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>获取DMA标志位状态</strong></p><p>FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);</p><p><strong>清除DMA标志位</strong></p><p>void DMA_ClearFlag(uint32_t DMAy_FLAG);</p><p><strong>获取DMA中断标志位状态</strong></p><p>ITStatus DMA_GetITStatus(uint32_t DMAy_IT);</p><p><strong>清除DMA中断标志位</strong></p><p>void DMA_ClearITPendingBit(uint32_t DMAy_IT);</p><p><strong>开启ADC DMA触发信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p></blockquote><ul><li><p><strong><mark>DMA是AHB总线的设备</mark></strong></p></li><li><p><strong><mark>DMA软件触发和硬件触发不能同时使用，如果同时使用DMA就会连续触发</mark></strong></p></li><li><p>DMA转运有三个条件：1.传输计数器大于0 2.触发源有触发信号 3.DMA使能</p></li></ul><h1 id="一-dma数据转运"><a class="markdownIt-Anchor" href="#一-dma数据转运"></a> 一、DMA数据转运</h1><h2 id="1stm32单片机ram和rom"><a class="markdownIt-Anchor" href="#1stm32单片机ram和rom"></a> 1.stm32单片机RAM和ROM</h2><h3 id="不加const修饰"><a class="markdownIt-Anchor" href="#不加const修饰"></a> 不加const修饰</h3><img src="/posts/10712/image-20240522115326572.png" class="" title="image-20240522115326572"><h3 id="加上const修饰"><a class="markdownIt-Anchor" href="#加上const修饰"></a> 加上const修饰</h3><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> aa =<span class="number">0x66</span>;<span class="comment">//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,aa,<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;aa,<span class="number">8</span>);<span class="comment">//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>现象</strong></p><p>flash里面编译的代码部分，地址位于flah最前面，所以这里变量的显示在靠后的地址</p><img src="/posts/10712/image-20240522115450140.png" class="" title="image-20240522115450140"><h2 id="const关键字节省sram空间"><a class="markdownIt-Anchor" href="#const关键字节省sram空间"></a> const关键字节省SRAM空间</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED字模库，宽8像素，高16像素*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> OLED_F8x16[][<span class="number">16</span>]=</span><br><span class="line">{</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//  0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="结构体访问寄存器ram地址"><a class="markdownIt-Anchor" href="#结构体访问寄存器ram地址"></a> 结构体访问寄存器RAM地址</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR,<span class="number">8</span>);</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522115913765.png" class="" title="image-20240522115913765"><p><strong><mark>外设的起始地址+寄存器的偏移地址=指定寄存器的地址</mark></strong></p><p><strong><mark>使用结构体访问，指定地址对应寄存器，这样，结构体访问就是寄存器的地址</mark></strong></p><h2 id="2dma转运数组"><a class="markdownIt-Anchor" href="#2dma转运数组"></a> 2.DMA转运数组</h2><p><strong>软件触发代码部分</strong></p> <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522143322783.png" class="" title="image-20240522143322783"><h2 id="3dma软件触发"><a class="markdownIt-Anchor" href="#3dma软件触发"></a> 3.DMA软件触发</h2><img src="/posts/10712/image-20240522144732279.png" class="" title="image-20240522144732279"><p><strong>DMA传输计数器软件重装</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyDMA_Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数DMA初始化配置</span></span><br><span class="line"><span class="comment">  * @参数要转运数据的首地址，存储器站点的起始地址，传输次数</span></span><br><span class="line"><span class="comment">  * @返回值</span></span><br><span class="line"><span class="comment">  * @特殊说明</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line">MyDMA_Size=Size;</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=Size;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Enable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=AddrB;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;<span class="comment">//以字节传输</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;</span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=AddrA;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte;<span class="comment">//转运数据宽度为一个字节</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，所以通道可以任意选择</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,MyDMA_Size);</span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"DataA"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">"DataB"</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataA,<span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataB,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">DataA[<span class="number">0</span>]++;</span><br><span class="line">DataA[<span class="number">1</span>]++;</span><br><span class="line">DataA[<span class="number">2</span>]++;</span><br><span class="line">DataA[<span class="number">3</span>]++;</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">MyDMA_Transfer();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522145131191.png" class="" title="image-20240522145131191"><p><strong>将DataA用const修饰</strong></p><p>DataA此时为flash里面的变量，所以地址为08开头</p><img src="/posts/10712/image-20240522145359406.png" class="" title="image-20240522145359406"><h1 id="adc-dma转运"><a class="markdownIt-Anchor" href="#adc-dma转运"></a> ADC+ DMA转运</h1><p><strong>ADC单次扫描，DMA单次转运+软件触发</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD_Value[<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=DISABLE;<span class="comment">//单次模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,<span class="number">4</span>);<span class="comment">//传输次数给4</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里选择了ADC触发DMA，标志位自动清零，所以不需要软件清零</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);//等待转换完成标志位置1</span></span><br><span class="line"><span class="comment">return ADC_GetConversionValue(ADC1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA转运完成总是在ADC完成之后的，所以这里等待DMA状态标志位即可*/</span></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>ADC连续扫描+DMA循环转运模式</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=ENABLE;<span class="comment">//连续模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Circular;<span class="comment">//传输模式，是否使用自动重装,DMA循环模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line"></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思考：</strong></p><ul><li>定时器触发ADC单词转换后通过DMA转运？</li><li>串口发送的数据使用DMA进行存储器到外设的转运</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> DMA数据转运 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[10]串口通信</title>
      <link href="/posts/19202/"/>
      <url>/posts/19202/</url>
      
        <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p><strong>结构体初始化配置</strong></p><p>void USART_DeInit(USART_TypeDef* USARTx);<br>void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);<br>void USART_StructInit(USART_InitTypeDef* USART_InitStruct);</p><p><strong>同步时钟配置</strong></p><p>void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);<br>void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);</p><p><strong>发送数据</strong></p><p>void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);</p><ul><li>写DR寄存器</li></ul><p><strong>接收数据</strong></p><p>uint16_t USART_ReceiveData(USART_TypeDef* USARTx);</p><ul><li>读DR寄存器</li></ul></blockquote><h1 id="microlib"><a class="markdownIt-Anchor" href="#microlib"></a> MicroLIB</h1><p><strong>MicroLIB是Keil为嵌入式平台优化的一个精简库</strong></p><img src="/posts/19202/image-20240520133336274.png" class="" title="image-20240520133336274"><h1 id="多个串口同时使用printf"><a class="markdownIt-Anchor" href="#多个串口同时使用printf"></a> 多个串口同时使用printf</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(String,<span class="string">"Num=%d\r\n"</span>,<span class="number">666</span>);<span class="comment">//sprintf.可以将指定的数据复制到数组中</span></span><br><span class="line">Serial_SendString(String);<span class="comment">//打印字符串</span></span><br></pre></td></tr></tbody></table></figure><h1 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_Prinf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="汉字编码发送"><a class="markdownIt-Anchor" href="#汉字编码发送"></a> 汉字编码发送</h1><img src="/posts/19202/image-20240520135012811.png" class="" title="image-20240520135012811"><p><strong>统一选定为UTF-8编码</strong></p><h1 id="串口接收"><a class="markdownIt-Anchor" href="#串口接收"></a> 串口接收</h1><h2 id="1查询方法"><a class="markdownIt-Anchor" href="#1查询方法"></a> 1.查询方法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">RXData=USART_ReceiveData(USART1);<span class="comment">//读DR可以自动清除标志位</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2中断方法"><a class="markdownIt-Anchor" href="#2中断方法"></a> 2.中断方法</h2><h3 id="子程序"><a class="markdownIt-Anchor" href="#子程序"></a> 子程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxData;</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GerRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> Serial_RxData;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2主程序"><a class="markdownIt-Anchor" href="#2主程序"></a> 2.主程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"RxData:"</span>);</span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_GerRxFlag()==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RXData = Serial_GetRxData();</span><br><span class="line">Serial_SendByte(RXData);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">RXData=USART_ReceiveData(USART1);//读DR可以自动清除标志位</span></span><br><span class="line"><span class="comment">OLED_ShowHexNum(1,1,RXData,2);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="串口数据包"><a class="markdownIt-Anchor" href="#串口数据包"></a> 串口数据包</h1><p><strong>打包多字节为一个数据包，方便发送多字节的数据。将同一批的数据进行打包和分割</strong></p><p><strong>包头、包尾：简易通信协议</strong></p><ul><li>文本数据包</li><li>Hex数据包</li></ul><h2 id="状态机的方法来接收数据包"><a class="markdownIt-Anchor" href="#状态机的方法来接收数据包"></a> 状态机的方法来接收数据包</h2><img src="/posts/19202/image-20240520150733732.png" class="" title="image-20240520150733732"><h2 id="1发送数据包"><a class="markdownIt-Anchor" href="#1发送数据包"></a> 1.发送数据包</h2><img src="/posts/19202/image-20240520152533465.png" class="" title="image-20240520152533465"><h2 id="2接收数据包"><a class="markdownIt-Anchor" href="#2接收数据包"></a> 2.接收数据包</h2><p><strong>串口中断子程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_TxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送数据包*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(<span class="number">0xFF</span>);</span><br><span class="line">Serial_SendArray(Serial_TxPacket,<span class="number">4</span>);</span><br><span class="line">Serial_SendByte(<span class="number">0xFE</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line"><span class="keyword">if</span>(++pRxState&gt;=<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">pRxState=<span class="number">0</span>;</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="number">0xFE</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Serial.h</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_TxPacket[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_RxPacket[];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="小操作"><a class="markdownIt-Anchor" href="#小操作"></a> 小操作</h2><p><strong>按住alt选择一列进行修改</strong></p><img src="/posts/19202/image-20240520154534025.png" class="" title="image-20240520154534025"><h2 id="3文本收发数据包"><a class="markdownIt-Anchor" href="#3文本收发数据包"></a> 3.文本收发数据包</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">100</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'@'</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'\r'</span>)<span class="comment">//第一个包尾</span></span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line">pRxState++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)<span class="comment">//第二个包尾</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="string">'\n'</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">Serial_RxPacket[pRxState]=<span class="string">'\0'</span>;<span class="comment">//字符串结束时加上\0,表示字符串的结束</span></span><br><span class="line">pRxState=<span class="number">0</span>;<span class="comment">//MARK:忘记清零</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="串口下载"><a class="markdownIt-Anchor" href="#串口下载"></a> #串口下载</h1><h2 id="boot引脚"><a class="markdownIt-Anchor" href="#boot引脚"></a> Boot引脚</h2><p>BootLoder的作用相当于刷机</p><h2 id="调试使用"><a class="markdownIt-Anchor" href="#调试使用"></a> 调试使用</h2><img src="/posts/19202/image-20240520163851412.png" class="" title="image-20240520163851412"><p>可以保持跳线帽置1，但是复位后程序丢失，所以仅用来调试</p><h2 id="读flash生成bin文件"><a class="markdownIt-Anchor" href="#读flash生成bin文件"></a> 读FLASH生成bin文件</h2><img src="/posts/19202/image-20240520164112095.png" class="" title="image-20240520164112095"><h2 id="读保护写保护"><a class="markdownIt-Anchor" href="#读保护写保护"></a> 读保护/写保护</h2><img src="/posts/19202/image-20240520164217951.png" class="" title="image-20240520164217951"><h1 id="蓝牙串口通信"><a class="markdownIt-Anchor" href="#蓝牙串口通信"></a> 蓝牙串口通信</h1><p><a href="https://blog.csdn.net/struggle_success/article/details/130440579">电赛|项目|课设：蓝牙模块HC05主从配置与连接_蓝牙 master和 slave 服务-CSDN博客</a></p><p><strong>AT指令集</strong></p><p>AT+NAME = xlg 设置蓝牙名称为xlg</p><p>AT+ROLE=0 蓝牙模式为从模式 AT+ROLE=1 蓝牙模式为主模式<br>AT+CMODE=0 蓝牙连接模式为任意地址连接模式<br>AT+PSWD=1234 蓝牙配对密码为1234<br>AT+UART=9600，0，0 蓝牙通信串口波特率为9600，停止位1位，无校验位<br>AT+RMAAD 清空配对列表</p><p>一、更改波特率<br>AT+UART=a,b,c<br>蓝牙通信串口波特率为a，<br>b:停止位1位，无校验位<br>返回响应为OK</p><p>二、修改蓝牙模块密码</p><p>修改密码的AT指令格式如下：（以修改后的密码为1314为例）</p><pre><code>        AT+PSWD=1314（这里加回车）</code></pre><p>1<br>三、修改蓝牙模块名字</p><p>修改模块名字的AT指令如下：</p><pre><code>            AT+NAME =</code></pre><p>1<br>1， AT+ROLE设置主从模式：<br>AT+ROLE=1是设成主，AT+ROLE=0是设成从，AT+ROLE=2设成回环模式Slave-Loop：被动连接，接收远程蓝 牙主设备数据并将数据原样返回给远程蓝牙<br>AT+ROLE?：查询主从状态<br>2， AT+RESET:HC-05复位</p><p>3， AT+VERSION?：获取HC-05的软件版本号，只能获取，不能修改。</p><p>4， AT+ORGL:恢复出厂默认设置，当把模块设置乱了，使用此命令进行恢复默认值。</p><p>5， AT+ADDR?：获取HC-05的蓝牙地址码，只能获取，不能修改。</p><p>6， AT+NAME？:获取HC-05的名字,AT+NAME=xlg，修改模块的名字为xlg，具体名字自行修改。</p><p>7， AT+CLASS?：设置查询设备的类型，尽量不要去修改此参数。默认是1F00。</p><p>8， AT+IAC?：查询设置查询访问码，默认是9E8B33，尽量不要去修改此参数。</p><p>9， AT+PSWD？:查询设置配对密码,AT+PSWD=”0000”,密码要有双引号,密码是四位数字.</p><p>10， AT+UART：AT+UART？是查询当前模块的波特率，AT+UART=波特率,0,0。</p><p>11， AT+CMODE：AT+CMODE？是查询当前连接模式。AT+CMODE=0，1，2(0——指定蓝牙地址连接模式（指定蓝牙地址由绑定指令设置）1——任意蓝牙地址连接模式（不受绑定指令设置地址的约束）2——回环角色（Slave-Loop）默认连接模式：0)。</p><p>12， AT+BIND:AT+BIND?查询当前绑定地址,AT+BIND=NAP，UAP，LAP(用逗号隔开)。</p><p>13， AT+RMADD:从蓝牙配对列表中删除所有认证设备.</p><p>14， AT+STATE？:获取蓝牙模块工作状态.</p><p>15， AT+LINK=NAP,UAP,LAP：与远程设备建立连接。</p><p>16， AT+DISC:断开连接.</p><p>17， AT+RNAME？NAP，UAP，LAP:获取远程蓝牙设备名称.</p><p>18， AT+ADCN?：获取蓝牙配对列表中认证设备数。</p><p>19， AT+MRAD？获取最近使用过的蓝牙认证设备地址。</p><p>20， AT+INQM:设置查询模式,AT+INQM=1，9，48(1-带RSSI信号强度指示,9-超过9个蓝牙设备响应则终止查询,48-设定超时为48*1.28=61.44秒)</p><p><strong>ps: HC05模块的AT指令，蓝牙命名AT+NAME= 以及密码设置AT+PSWD= 需要加双引号！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 串口 </tag>
            
            <tag> 蓝牙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】红外通信系统</title>
      <link href="/posts/29338/"/>
      <url>/posts/29338/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> # 前言</h1><h2 id="一-红外通信系统"><a class="markdownIt-Anchor" href="#一-红外通信系统"></a> 一、红外通信系统</h2><h3 id="二-红外调制解调的原理"><a class="markdownIt-Anchor" href="#二-红外调制解调的原理"></a> 二、红外调制解调的原理</h3><ul><li>空闲状态：红外LED不亮，接收头输出高电平</li><li>发送低电平：红外LED以38KHz频率闪烁发光，接收头输出低电平</li><li>发送高电平：红外LED不亮，接收头输出高电平<br>总而言之，只有红外LED发送38KHZ的闪烁信号时，红外接收头OUT引脚才会对外输出低电平信号<br>红外发送–红外接收的本质是<mark>调制</mark>和<mark>解调</mark>，在这种条件下，可以过滤掉自然界中的“噪声信号”，只有38KHZ附近的红外信号才能被红外接收头识别转换为对应的低电平。</li></ul><p><strong>转换示意图：</strong><br>1.红外LED发出的信号</p><img src="/posts/29338/c97d453d8866482a8bc0a2191a565288.png" class="" title="在这里插入图片描述"><p>2.红外接收头发出的信号</p><img src="/posts/29338/3d972def937345fdb73a96eb875114b8.png" class="" title="在这里插入图片描述"><p>其中，红外接收头发出的低电平信号的宽度等价于红外LED发送的38KHz信号的时间。</p><h1 id="一-基于ccp1输入捕获模式的解调电路"><a class="markdownIt-Anchor" href="#一-基于ccp1输入捕获模式的解调电路"></a> 一、基于CCP1输入捕获模式的解调电路</h1><h2 id="1-proteus生成基带信号"><a class="markdownIt-Anchor" href="#1-proteus生成基带信号"></a> 1. Proteus生成基带信号</h2><img src="/posts/29338/image-20240511143825355.png" class="" title="image-20240511143825355"><h3 id="11脉冲最小单位"><a class="markdownIt-Anchor" href="#11脉冲最小单位"></a> 1.1脉冲最小单位</h3><img src="/posts/29338/image-20240511143912266.png" class="" title="image-20240511143912266"><h3 id="12特定脉冲序列"><a class="markdownIt-Anchor" href="#12特定脉冲序列"></a> 1.2特定脉冲序列</h3><img src="/posts/29338/image-20240511143937021.png" class="" title="image-20240511143937021"><img src="/posts/29338/image-20240519153450824.png" class="" title="image-20240519153450824"><p><strong>从左往右表示数据从高位到低位，如图所示为01001101</strong></p><h3 id="13仿真结果"><a class="markdownIt-Anchor" href="#13仿真结果"></a> 1.3仿真结果</h3><img src="/posts/29338/image-20240519153542254.png" class="" title="image-20240519153542254"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;<span class="comment">//接收数据储存变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获模式接收信号跳变*/</span></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次接收信号为下跳变</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;</span><br><span class="line">CCP1CON=<span class="number">0X05</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//本次接收信号为上跳变</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0</span> &amp;&amp; CCPR1H == <span class="number">0X00</span>){B=B&lt;&lt;<span class="number">1</span>;}<span class="comment">//'0'</span></span><br><span class="line"><span class="keyword">if</span>(CCPR1L &lt; <span class="number">0X50</span> &amp;&amp; CCPR1H == <span class="number">0X01</span>){B=B&lt;&lt;<span class="number">1</span>;B=B+<span class="number">1</span>;}  <span class="comment">//'1'</span></span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0XA0</span> &amp;&amp; CCPR1H == <span class="number">0X01</span>){PORTB = B;}  <span class="comment">//结束信号，电平宽度匹配时表示完整接收到1Byte数据</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;<span class="comment">//清空寄存器</span></span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;<span class="comment">//中断相关寄存器配置</span></span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line">B=<span class="number">0</span>;TRISB=<span class="number">0</span>; PORTB=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//开启定时器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二-基于ccp1输出比较模式的基带信号生成电路"><a class="markdownIt-Anchor" href="#二-基于ccp1输出比较模式的基带信号生成电路"></a> 二、基于CCP1输出比较模式的基带信号生成电路</h1><h2 id="1mpalb波形显示窗口显示rc2产生的基带信号"><a class="markdownIt-Anchor" href="#1mpalb波形显示窗口显示rc2产生的基带信号"></a> 1.MPALB波形显示窗口，显示RC2产生的基带信号</h2><img src="/posts/29338/image-20240519155221573.png" class="" title="image-20240519155221573"><h2 id="2代码解释"><a class="markdownIt-Anchor" href="#2代码解释"></a> 2.代码解释</h2><p><strong>CCP1模块每次发送1位二进制的负脉冲宽度，每次循环从data左移一位。PIC单片机C语言循环移位语句用汇编语句asm(“rlf _data,f”)，每次将最高位移入CARRY寄存器中，以最高的程序执行效率进行数据移位并生成基带信号的操作，并且每次发送1位二进制负脉冲宽度之后，会发送1位同步头的正脉冲宽度。发送完所有二进制数据之后，发送1位结束头低电平宽度</strong></p><img src="/posts/29338/image-20240519155522173.png" class="" title="image-20240519155522173"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data,data_cnt;<span class="comment">//发送的二进制代码，代码长度</span></span><br><span class="line"><span class="type">char</span> IR_SendSelect;</span><br><span class="line">bit a;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a=!a;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RC7=<span class="number">0</span>;</span><br><span class="line">data_cnt--;<span class="comment">//低电平。二进制代码位数减1</span></span><br><span class="line"><span class="keyword">if</span>(data_cnt == <span class="number">0</span>) <span class="keyword">goto</span> period_delty;<span class="comment">//位数为0，全部发送完，转624us延时</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"rlf _data,f"</span>);<span class="comment">//未发送完，取下一位待发送数据（数据移入CARRY中）</span></span><br><span class="line"><span class="keyword">if</span>(CARRY == <span class="number">1</span>) <span class="keyword">goto</span> data_5eh;<span class="comment">//待发送数据=1</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//待发送数据=0,叠加低电平时长68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;</span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">data_5eh:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X38</span>;<span class="comment">//待发送数据=1,叠加低电平时长138H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">1</span>;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">period_delty:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X70</span>;<span class="comment">//叠加624us的延时参数270H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">2</span>;<span class="comment">//高位字节加2及低位叠加时的进位和</span></span><br><span class="line">data=<span class="number">0B</span>01001101;<span class="comment">//=PORTB //从PORTB取数据</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;</span><br><span class="line">ret_fie:</span><br><span class="line">CCP1M0=<span class="number">0</span>;<span class="comment">//下次匹配时输出高电平</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//叠加同步头的延时参数68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line">CCP1M0=<span class="number">1</span>;<span class="comment">//下次匹配时输出低电平</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">nRBPU=<span class="number">0</span>;<span class="comment">//启用RB弱上拉</span></span><br><span class="line">TRISB=<span class="number">0xFF</span>;<span class="comment">//作输入口</span></span><br><span class="line">TRISC2=<span class="number">0</span>;<span class="comment">//C口定义为输入口，只定义RC2作为输出</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;<span class="comment">//设置预分频比为 = 1:1,开中断</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;<span class="comment">//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line">CCP1CON = <span class="number">0X08</span>;<span class="comment">//CCP1设为匹配时令CCP1/RC2引脚输出高电平</span></span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//启动TMR1</span></span><br><span class="line">data = <span class="number">0B</span>01001101;<span class="comment">//=PORTB;从PORTB取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三-将基带电路与调制电路配合组成简易的红外通信系统"><a class="markdownIt-Anchor" href="#三-将基带电路与调制电路配合组成简易的红外通信系统"></a> 三、将基带电路与调制电路配合，组成简易的红外通信系统</h1><p><strong>如图所示，因为RC2输出的红外基带信号带有毛刺，所以这里改为RC7引脚输出基带信号，这样，就能组成一个完整的红外发送-接收系统，运行仿真，此时红外接收端的LED同与发送端PORTB的逻辑</strong></p><img src="/posts/29338/image-20240519161843951.png" class="" title="image-20240519161843951"><h1 id="四-配合ccp1输出比较和ccp2-pwm输出模式构成载波-调制信号"><a class="markdownIt-Anchor" href="#四-配合ccp1输出比较和ccp2-pwm输出模式构成载波-调制信号"></a> 四、配合CCP1输出比较和CCP2 PWM输出模式，构成载波-调制信号</h1><p><strong>MPLAB仿真观测调制信号，与原基带信号进行对比，验证代码现象</strong></p><p><strong>调制信号在图像上有些地方在同步头结束后为高电平，但在经过红外发送管之后，发送的信号依然对应者基带信号的波形，所以实际上并没有影响</strong></p><img src="/posts/29338/image-20240514130203460.png" class="" title="image-20240514130203460"><h1 id="五-实物测试部分"><a class="markdownIt-Anchor" href="#五-实物测试部分"></a> 五、实物测试部分</h1><h2 id="1红外二极管收发"><a class="markdownIt-Anchor" href="#1红外二极管收发"></a> 1.红外二极管收发</h2><h3 id="使用电压表测试红外接收管压降"><a class="markdownIt-Anchor" href="#使用电压表测试红外接收管压降"></a> <mark>使用电压表测试红外接收管压降</mark></h3><img src="/posts/29338/b8287e8289bf096bd5da1196ff211612.jpg" class="" title="b8287e8289bf096bd5da1196ff211612"><h2 id="2测试红外接收模块是否能被触发"><a class="markdownIt-Anchor" href="#2测试红外接收模块是否能被触发"></a> 2.测试红外接收模块是否能被触发</h2><ul><li><mark><strong>首先测试能否顺利进入中断，用PIC板载LED进行观测，每次进入中断，代表接收到一次38KHZ的红外信号，同时PIC板的八位LED进行取反闪烁</strong></mark></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;</span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line">PORTD^=<span class="number">0xFF</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">if(CCPR1L &gt; 0 &amp;&amp; CCPR1H == 0X00){B=B&lt;&lt;1;}//'0'==0x685</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X01){B=B&lt;&lt;1;B=B+1;}  //'1'==0x12C</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X02){PORTD = B;}  //结束信号==0x270</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;</span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;</span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line">B=<span class="number">0</span>;TRISD=<span class="number">0</span>; PORTD=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3仿真软件测量接收信号时选定捕捉每个bit数据的范围"><a class="markdownIt-Anchor" href="#3仿真软件测量接收信号时选定捕捉每个bit数据的范围"></a> 3.仿真软件测量接收信号时，选定捕捉每个bit数据的范围</h2><h3 id="31-程序调试使得红外传输系统更加精确稳定"><a class="markdownIt-Anchor" href="#31-程序调试使得红外传输系统更加精确稳定"></a> 3.1 程序调试，使得红外传输系统更加精确稳定</h3><p><mark><strong>虽然在红外调制电路代码中，我们指定了每个二进制数据，停止位，起始位的电平长度，但是，因为程序设计以及单片机响应速度的原因，我们并不知道它最终生成信号各个部分的电平宽度具体值，如果将编写好的程序直接拿来用，可能得不到任何想要的现象。因此，要通过测量红外解调电路实际获取到的各个二进制电平的长度（通过LCD1602显示），然后再修改程序，使得红外接收单片机能够稳定接收红外发送单片机发送的信号。</strong></mark></p><p><strong>下面为用于测试接收端接收到各个bit数据电平宽度的代码，如：控制发送端发送的数据为0x00，然后接收端这边进行对’0’的电平宽度测量，显示在LCD1602上，其他任意宽度的bit位也是同理</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;</span><br><span class="line"><span class="type">int</span> Time_Data;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//PORTD^=0xFF;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次捕捉下降沿</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;</span><br><span class="line">CCP1CON=<span class="number">0X05</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>; Time_Data = CCPR1H &lt;&lt; <span class="number">8</span> | CCPR1L;</span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0</span> &amp;&amp; CCPR1H == <span class="number">0X00</span>){LCD1602_WriteNum(<span class="number">1</span>,<span class="number">0</span>,Time_Data,<span class="number">5</span>);CCP1IE=<span class="number">0</span>;}<span class="comment">//55</span></span><br><span class="line"><span class="comment">//if(CCPR1H == 0X01){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//263</span></span><br><span class="line"><span class="comment">//if(CCPR1H == 0X02){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)//本次捕捉下降沿</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;//清零TMR1寄存器值</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//下一次捕捉上升沿</span></span><br><span class="line"><span class="comment">CCP1IF=0;//清除输入捕捉标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;//下一次捕捉下降沿</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">if(CCPR1L &gt; 0 &amp;&amp; CCPR1H == 0X00){B=B&lt;&lt;1;}//0'068</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X01){B=B&lt;&lt;1;B=B+1;}  //'1'==0x12C</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X02){PORTD = B;}  //结束信号==0x270</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISD=<span class="number">0X00</span>;<span class="comment">//数据口</span></span><br><span class="line">    TRISA=<span class="number">0x00</span>;<span class="comment">//RA0配置为输出模式</span></span><br><span class="line">ADCON1=<span class="number">0X07</span>;<span class="comment">//RA端口与AD转换有关！！！，不然无法正常显示LCD1602</span></span><br><span class="line">LCD1602_Init();</span><br><span class="line">LCD1602_WriteString(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"OK"</span>);</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;</span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;</span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line"></span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line"></span><br><span class="line">B=<span class="number">0</span>;TRISD=<span class="number">0</span>; PORTD=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/29338/image-20240514001540423.png" class="" title="image-20240514001540423"><h2 id="发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据"><a class="markdownIt-Anchor" href="#发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据"></a> 发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据</h2><p><strong>如图所示，发送连续三个Byte的一帧数据</strong></p><img src="/posts/29338/image-20240514015916078.png" class="" title="image-20240514015916078"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data,data_cnt;<span class="comment">//发送的二进制代码，代码长度</span></span><br><span class="line"><span class="type">char</span> IR_SendSelect;</span><br><span class="line"><span class="type">char</span> measure_Flag;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1_HighByte;<span class="comment">//CCP1高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1_LowByte;<span class="comment">//CCP1低字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Over_Counter=<span class="number">0</span>;<span class="comment">//溢出计数值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Over_Counter_temp;<span class="comment">//溢出计数暂存值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1IF_TriggerFlag;<span class="comment">//CCP1中断触发标志位</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> TABLE[<span class="number">16</span>]={<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>,<span class="number">0x46</span>};</span><br><span class="line"><span class="type">char</span> Send_Counter;<span class="comment">//发送字节次数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Cycle;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data_new;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Cycle;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data_M;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稳定数据滤波器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">data_filter</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">T_data_new.Data[<span class="number">0</span>]=Over_Counter;</span><br><span class="line">T_data_new.Data[<span class="number">1</span>]=CCP1_HighByte;</span><br><span class="line">T_data_new.Data[<span class="number">2</span>]=CCP1_LowByte;</span><br><span class="line"></span><br><span class="line">T_data_M.Data[i++]= T_data_new.Cycle;</span><br><span class="line">i%=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T_data_M.Data[<span class="number">0</span>]==T_data_M.Data[<span class="number">1</span>] &amp;&amp; T_data_M.Data[<span class="number">1</span>] == T_data_M.Data[<span class="number">2</span>])<span class="comment">//当三次取值相等时，才为有效值</span></span><br><span class="line">{</span><br><span class="line">T_data.Cycle=T_data_new.Cycle;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(measure_Flag == 0)//为周期测量模式</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(TMR1IF==1)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">Over_Counter_temp++;//累加TMR1的溢出次数</span></span><br><span class="line"><span class="comment">TMR1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else if(CCP1IF==1)//判断是不是由CCP1引起的中断</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1IF_TriggerFlag^=1;//标志位取反</span></span><br><span class="line"><span class="comment">if(CCP1IF_TriggerFlag==1)//第一次捕捉到跳变</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;//清除定时器0计数寄存器值</span></span><br><span class="line"><span class="comment">TMR1L=0;</span></span><br><span class="line"><span class="comment">TMR1ON=1;//定时器1开始计时</span></span><br><span class="line"><span class="comment">CCP1IF=0;//清除中断标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else//第二次捕捉到跳变</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CCP1_LowByte=CCPR1L+31;//校准值</span></span><br><span class="line"><span class="comment">CCP1_HighByte=CCPR1H+CARRY;//加上进位标志位</span></span><br><span class="line"><span class="comment">Over_Counter=Over_Counter_temp;//将计数溢出暂存值赋值给显示值</span></span><br><span class="line"><span class="comment">data_filter();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Over_Counter_temp=0;//清除计数溢出暂存值</span></span><br><span class="line"><span class="comment">TMR1H=0;//清除定时器0计数寄存器值</span></span><br><span class="line"><span class="comment">TMR1L=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">LCD1602_WriteCommand(0x80);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[0]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[0]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[1]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[1]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[2]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[2]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData('H');</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TMR1ON=0;//定时器1停止计时</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*PWM,输出比较配置</span></span><br><span class="line"><span class="comment">T2CON=0;PR2=25;TMR2=0;//TMR2初始化，周期26us</span></span><br><span class="line"><span class="comment">CCP2CON=0X0C;</span></span><br><span class="line"><span class="comment">CCPR2L=13;//CCP2初始化，脉宽13us</span></span><br><span class="line"><span class="comment">T1CON=0;//设置预分频比为 = 1:1,开中断</span></span><br><span class="line"><span class="comment">data_cnt = 0x09;//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line"><span class="comment">CCP1CON = 0X08;//CCP1设为匹配时令CCP1/RC2引脚输出电平不变</span></span><br><span class="line"><span class="comment">TMR1ON=1;//启动TMR1</span></span><br><span class="line"><span class="comment">measure_Flag=1;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(measure_Flag == <span class="number">0</span>)<span class="comment">//将测量值发送(PWM(CCP2),输出比较(CCP1))</span></span><br><span class="line">{</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCP1M0==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RC7=<span class="number">0</span>;</span><br><span class="line">CCP2CON=<span class="number">0x00</span>;</span><br><span class="line">data_cnt--;<span class="comment">//低电平。二进制代码位数减1</span></span><br><span class="line"><span class="keyword">if</span>(data_cnt == <span class="number">0</span>){<span class="keyword">goto</span> period_delty;} <span class="comment">//位数为0，全部发送完，转624us延时</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"rlf _data,f"</span>);<span class="comment">//未发送完，取下一位待发送数据（数据移入CARRY中）</span></span><br><span class="line"><span class="keyword">if</span>(CARRY == <span class="number">1</span>) <span class="keyword">goto</span> data_5eh;<span class="comment">//待发送数据=1</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X04</span>;<span class="comment">//待发送数据=0,叠加低电平时长68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">data_5eh:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X18</span>;<span class="comment">//待发送数据=1,叠加低电平时长138H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">4</span>;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">period_delty:</span><br><span class="line">Send_Counter++;</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0XC0</span>;<span class="comment">//叠加624us的延时参数270H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">9</span>;<span class="comment">//高位字节加2及低位叠加时的进位和</span></span><br><span class="line">data=<span class="number">0B</span>10101001;<span class="comment">//=PORTB //从PORTB取数据</span></span><br><span class="line">data_cnt = <span class="number">9</span>;</span><br><span class="line">ret_fie:</span><br><span class="line">CCP1M0=<span class="number">0</span>;<span class="comment">//下次匹配时输出高电平</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCP2CON=<span class="number">0X0C</span>;</span><br><span class="line">RC7=<span class="number">1</span>;TMR2ON=<span class="number">1</span>;<span class="comment">//同步头时间，启动PWM信号输出</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//叠加同步头的延时参数68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line">CCP1M0=<span class="number">1</span>;<span class="comment">//下次匹配时输出低电平</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Send_Counter &gt;= <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">Send_Counter=<span class="number">0</span>;</span><br><span class="line">measure_Flag = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CCP1IF=0;//CCP标志位清零</span></span><br><span class="line"><span class="comment">TMR1IE=1;//定时器1中断使能</span></span><br><span class="line"><span class="comment">TMR1IF=0;//定时器1中断标志位清零</span></span><br><span class="line"><span class="comment">T1CON=0B00000000;//TMR1为定时器，预分频比1:1,不启动定时器1</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//使能CCP1捕捉每一个输入信号的上升沿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">TMR1ON=<span class="number">0</span>;<span class="comment">//关闭定时器1</span></span><br><span class="line">CCP2CON=<span class="number">0X00</span>;<span class="comment">//关闭PWM</span></span><br><span class="line">CCP1CON=<span class="number">0X00</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Send_Counter=<span class="number">0</span>;</span><br><span class="line">nRBPU=<span class="number">0</span>;<span class="comment">//启用RB弱上拉</span></span><br><span class="line">TRISB=<span class="number">0xFF</span>;<span class="comment">//作输入口</span></span><br><span class="line">TRISC7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;<span class="comment">//PWM信号（载波）输出引脚</span></span><br><span class="line">TRISC2=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">TRISD=<span class="number">0X00</span>;<span class="comment">//数据口</span></span><br><span class="line">    TRISA=<span class="number">0x00</span>;<span class="comment">//RA0配置为输出模式</span></span><br><span class="line">ADCON1=<span class="number">0X07</span>;<span class="comment">//RA端口与AD转换有关！！！，不然无法正常显示LCD1602 </span></span><br><span class="line">LCD1602_Init();</span><br><span class="line">LCD1602_WriteString(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CCP中断配置*/</span></span><br><span class="line">GIE=<span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">PEIE=<span class="number">1</span>;<span class="comment">//第二梯队中断打开</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;<span class="comment">//CCP中断打开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*周期测量</span></span><br><span class="line"><span class="comment">CCP1IF=0;//CCP标志位清零</span></span><br><span class="line"><span class="comment">TMR1IE=1;//定时器1中断使能</span></span><br><span class="line"><span class="comment">TMR1IF=0;//定时器1中断标志位清零</span></span><br><span class="line"><span class="comment">T1CON=0B00000000;//TMR1为定时器，预分频比1:1,不启动定时器1</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//使能CCP1捕捉每一个输入信号的上升沿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">T2CON=<span class="number">0</span>;PR2=<span class="number">25</span>;TMR2=<span class="number">0</span>;<span class="comment">//TMR2初始化，周期26us</span></span><br><span class="line">CCP2CON=<span class="number">0X0C</span>;</span><br><span class="line">CCPR2L=<span class="number">13</span>;<span class="comment">//CCP2初始化，脉宽13us</span></span><br><span class="line">T1CON=<span class="number">0</span>;<span class="comment">//设置预分频比为 = 1:1,开中断</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;<span class="comment">//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line">CCP1CON = <span class="number">0X08</span>;<span class="comment">//CCP1设为匹配时令CCP1/RC2引脚输出电平不变</span></span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//启动TMR1</span></span><br><span class="line"></span><br><span class="line">data = PORTB;<span class="comment">//=PORTB;从PORTB取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="猜测同步头的宽窄导致信号处理出现错误数据"><a class="markdownIt-Anchor" href="#猜测同步头的宽窄导致信号处理出现错误数据"></a> 猜测：同步头的宽窄，导致信号处理出现错误数据</h2><img src="/posts/29338/image-20240514130203460.png" class="" title="image-20240514130203460"><p><strong>解决方案：<mark>调整同步头宽度。每Byte数据需要等待一定的时间</mark></strong></p><h2 id="仿真测试结果没有完整移入数据实际上只接收到了7位"><a class="markdownIt-Anchor" href="#仿真测试结果没有完整移入数据实际上只接收到了7位"></a> 仿真测试结果：没有完整移入数据，实际上只接收到了7位</h2><img src="/posts/29338/image-20240514160814051.png" class="" title="image-20240514160814051"><p><strong>更改输入捕获中断内对各个二进制捕获的电平时间范围，使得红外解调的容允值更大，修改后，代码如下</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data_RecByte;</span><br><span class="line"><span class="type">int</span> Time_Data;</span><br><span class="line">bit Data_RecFlag;</span><br><span class="line"><span class="type">char</span> i;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> TABLE[<span class="number">16</span>]={<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>,<span class="number">0x46</span>};</span><br><span class="line">bit Start_Flag;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">5</span>];</span><br><span class="line">}T_Data_Rec;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//PORTD^=0xFF;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)//本次捕捉下降沿</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;</span></span><br><span class="line"><span class="comment">CCP1IF=0; Time_Data = CCPR1H &lt;&lt; 8 | CCPR1L;</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 400  &amp;&amp; Time_Data&lt; 500){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//55</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 800  &amp;&amp; Time_Data&lt; 1000){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//263</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 2300  &amp;&amp; Time_Data&lt; 2600){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line"><span class="comment">if(Time_Data &gt; 2900 ){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次捕捉下降沿</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;<span class="comment">//清零TMR1寄存器值</span></span><br><span class="line">CCP1CON=<span class="number">0X05</span>;<span class="comment">//下一次捕捉上升沿</span></span><br><span class="line">CCP1IF=<span class="number">0</span>;<span class="comment">//清除输入捕捉标志位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//本次捕捉上升沿</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//下一次捕捉下降沿</span></span><br><span class="line">CCP1IF=<span class="number">0</span>;Time_Data = CCPR1H &lt;&lt; <span class="number">8</span> | CCPR1L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;<span class="number">3200</span>){Start_Flag=<span class="number">1</span>;}  <span class="comment">//开始信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Flag)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">400</span>  &amp;&amp; Time_Data &lt;= <span class="number">500</span>){Data_RecByte=Data_RecByte&lt;&lt;<span class="number">1</span>;}<span class="comment">//0'068</span></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">800</span>  &amp;&amp; Time_Data&lt;= <span class="number">1200</span>){Data_RecByte=Data_RecByte&lt;&lt;<span class="number">1</span>;Data_RecByte=Data_RecByte+<span class="number">1</span>;} <span class="comment">//'1'</span></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">2200</span>  &amp;&amp; Time_Data&lt;= <span class="number">2500</span>){T_Data_Rec.Data[i++] = Data_RecByte;Start_Flag=<span class="number">0</span>;}  <span class="comment">//结束信号</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">{</span><br><span class="line">LCD1602_WriteNum(<span class="number">2</span>,<span class="number">0</span>,Time_Data,<span class="number">5</span>);</span><br><span class="line">LCD1602_WriteCommand(<span class="number">0x80</span>);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">0</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">0</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">1</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">1</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">2</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">2</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">3</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">3</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">4</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">4</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(<span class="string">'H'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>最终结果：实现了连续5Byte数据的接收</strong></p><img src="/posts/29338/image-20240514160944486.png" class="" title="image-20240514160944486"><h1 id="自定义通信协议"><a class="markdownIt-Anchor" href="#自定义通信协议"></a> 自定义通信协议</h1><p><strong><mark>在完整的红外传输系统工作在稳定可靠的状态后，我们可以拓展一些功能，如自己定义一个红外传输协议，使得单片机之间的红外通信能够实现更加复杂的功能，一次性能够传输更多的数据。</mark></strong></p><ul><li><p>添加一个起始位，长度位结束位的两倍</p></li><li><p>xxxxxxxxxx&nbsp;#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#include&lt;math.h&gt;​//写一个代码,打印100~200之间的素数//素数-质数//只能被1和他本身整除​//代码优化1：//m=a<em>b;//a和b中一定至少有一个数字是 &lt;=开平方m的//16 = 2</em>8 = 4*4//所以，大于开平方m的就不需要判断是否为m的因子，减少循环执行次数​//sqrt用于计算开平方的函数 -需要用到库函数 math.h//减少了循环的执行次数​//代码优化2：//偶数不可能是素数//修改for (i = 100; i &lt;= 200; i <ins>)为for (i = 101; i &lt;= 200; i += 2)​int main(){    int i, j = 0;​    //判断i是不是质数    for (i = 101; i &lt;= 200; i += 2)    {        int flag = 1;//定义一个参数，检测i是否能被 除了1和它本身的数 整除​        for (j = 2; j &lt;= sqrt(i); j</ins>)        {            if (i % j == 0)            {                flag = 0;//如果能被2到i-1之间的整除，记录flag=0;                //break;            }        }​        if (flag == 1)//不能被2到i-1之间的数整除        {            printf("%d是质数\n", i);//那么i就是质数        }    }    return 0;}c</p><ul><li>起始位：0xC30</li><li>‘0’: 0x204</li><li>‘1’:0x418</li><li>结束位:0x9C0</li></ul></li><li><p>修改同步头宽度，因为在实际使用红外通信时，单片机产生的红外信号可能没有那么理想，红外发射头发送出去的信号会衰减，因此我们可以适当增加同步头宽度，提高红外调制信号的“功率”，使得红外接收头能够正常接收到红外信号</p></li></ul><h1 id="周期信号测量红外收发系统"><a class="markdownIt-Anchor" href="#周期信号测量红外收发系统"></a> 周期信号测量+红外收发系统</h1><img src="/posts/29338/image-20240519165157774.png" class="" title="image-20240519165157774"><h1 id="红外双发双收双工系统"><a class="markdownIt-Anchor" href="#红外双发双收双工系统"></a> 红外双发双收（双工系统）</h1><img src="/posts/29338/image-20240519170223726.png" class="" title="image-20240519170223726"><h1 id="红外双工中继基站系统"><a class="markdownIt-Anchor" href="#红外双工中继基站系统"></a> 红外双工+中继基站系统</h1><p><strong><mark>如图所示，红外收发装置通过中继系统进行数据通信</mark></strong></p><img src="/posts/29338/image-20240519173118590.png" class="" title="image-20240519173118590"><h1 id="心得体会"><a class="markdownIt-Anchor" href="#心得体会"></a> 心得体会</h1><p>我在本次小组任务中，首先学习了红外通信系统的基本组成结构，了解了通信系统中调制/解调的原理以及实现方法。基于对第九章各个例子以及习题的学习以及编写相关代码，我熟悉了CCP模块的输入捕获、输出比较、PWM模式的工作原理。通过将这些模块组合，协同工作，在代码中利用定义的各个“标志位"，配置好了这些CCP各个功能模块协同工作的代码结构。</p><p>在准备进行本次小组任务的工作前，我们首先大概预览了一下本次小组任务需要用到的知识点，因为整个红外通信系统的构成需要多个单片机协同工作，所以必须要循循渐进地进行代码的编写、调试、验证。为了设计出最终包含红外双工通信+中继器的复杂系统，我们首先编写完成了一个简易的红外通信系统，不过这个系统的信号发送端发送的是基带信号，没有经过红外管，直接送给接收端单片机进行信号的解调。虽然我们在发送端设置好了各个不同数据位的电平宽度，比如’0‘，’1‘，’停止位‘的电平宽度有按照一定的比例用于区分，但课本上一开始给的例子，各个数据位电平宽度仅仅在微妙级，不管是仿真还是实物验证接收端都有可能无法解调出正确的信号，因为这些数据位的电平宽度太短，没有明显的区分度，一旦程序运行效率不行或者单片机电路上的微小延迟都有可能造成数据读取的错误。因此，我们等比例放大了每个数据位的电平宽度，以及同步头的宽度（保证调制信号的功率）。这样的话，不同bit的区分度就大大提高了。然后，我们自己再编写一段调试代码，即接收到任意的上边沿+下边沿的输入捕获，输出端改为固定指定的数据位发送，然后在接收端那边通过LCD1602显示实际上捕获到的电平宽度，这样就能知道红外接收端实际容允的电平宽度范围，确保整个红外通信系统的稳定性。</p><p>本次小组任务，更像一个小课程设计，我们设计出了一个功能完备的红外通信系统，在每个阶段的调试过程中，我们遇到了很多的问题，这些问题大多数是由于寄存器的配置引起的（因为单片机中CCP各个模块要协同工作，这就涉及到大量寄存器的状态切换），一旦寄存器配置冲突，而我们又不熟悉寄存器，就无法认识到代码的问题所在。我们通过MPLAB强大轻量化的Debug窗口，以及Proteus的调试功能，反复验证，循序渐进，最终设计出来了一个具备双工通信+中继器（基站）的完备通信系统，并且我们的通信系统可以通过修改代码中的参数实现连续任意位Byte的收发。</p><p>本次小组任务是有挑战性的，但是这也为我们后续学习更多复杂的通信系统打下基础。我们学会了化繁为简，分模块和层次，熟练配置单片机上所有相关功能寄存器的技巧，这不仅是我们单片机编程、电路系统设计技术上的显著提升，也是对理论基础是否扎实的考验。我想，通过本次小组任务，我们可以设计出各种功能强大，效率高的通信系统，利用自身专业编写出完备的通信协议等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HEXO】[2] 多线程部署常见问题</title>
      <link href="/posts/45608/"/>
      <url>/posts/45608/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo更新日志"><a class="markdownIt-Anchor" href="#hexo更新日志"></a> HEXO更新日志</h1><p><strong>2024.5.3</strong></p><ul><li>重要更新：将HEXO博客部署到腾讯云轻量化服务器，极大提升国内访问速度，访问ip地址：<a href="http://122.51.23.7/">Turin’s Blog - 数理照亮世界</a></li><li>优化主页文章卡片界面，参考文章：<a href="https://butterfly.zhheo.com/home.html">首页 | Butterfly主题美化教程 (zhheo.com)</a></li><li>优化网站页面显示效果：透明度。<a href="https://qianchenggit.github.io/2021/10/06/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E4%BD%BF%E7%94%A8%E4%B8%80%E5%9B%BE%E6%B5%81/">博客背景使用一图流 | QianChengGit の小森林</a></li></ul><hr><p>xxxxxxxxxx&nbsp;git remote add [alias] [url]//参数[alias]为别名， [url]为远程仓库的地址bash</p><h1 id="一-hexo部署到云服务器ubuntu系统"><a class="markdownIt-Anchor" href="#一-hexo部署到云服务器ubuntu系统"></a> 一、HEXO部署到云服务器(Ubuntu系统)</h1><p><strong><a href="https://cloud.tencent.com/developer/article/1945550">Hexo部署至服务器（Ubuntu 20.04）-腾讯云开发者社区-腾讯云 (tencent.com)</a></strong></p><p><strong><a href="https://blog.cpen.top/posts/38874.html">04_Hexo-多平台部署-云服务器-GitHub-Gitee | Mycpen</a></strong></p><h1 id="二-ubuntu允许root连接服务器"><a class="markdownIt-Anchor" href="#二-ubuntu允许root连接服务器"></a> 二、Ubuntu允许root连接服务器</h1><p><a href="https://blog.csdn.net/crayon0/article/details/122272001">Linux开启ssh并允许root登录（ubuntu、centos、kalilinux）_ssh允许root远程登录-CSDN博客</a></p><blockquote><p>报错信息 “E45: ‘readonly’ option is set (add ! to override)” 是在使用 Vim 或 Neovim 文本编辑器时可能遇到的一个错误信息。当您尝试将更改写入以只读模式打开的文件时，就会出现这条信息。这种情况可能由几个原因引起，例如，您正在编辑的文件在文件系统级别启用了写保护，或者 Vim 打开了一个它认为不应该修改的文件（例如，系统配置文件或标记为“只读”的文件）。</p><p>要解决这个问题并强制 Vim 或 Neovim 尽管文件处于只读状态也要写入更改，您可以使用 <code>:w!</code> 命令，其中 <code>w</code> 代表“写入”，<code>!</code> 实际上意味着“强制”或“覆盖”。</p><p>下面是如何处理这种情况：</p><h3 id="如果您打算修改文件"><a class="markdownIt-Anchor" href="#如果您打算修改文件"></a> 如果您打算修改文件</h3><ol><li><p><strong>强制保存更改</strong>：如果您知道文件是安全可编辑的，且打算保存更改，可以使用 <code>:w!</code> 命令强制保存更改。这告诉 Vim 覆盖只读限制。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w!</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>更改文件权限</strong>：如果文件是只读的是因为文件系统权限，您可能需要在 Vim 外部更改其权限。例如，在类 Unix 系统（Linux、macOS）上，您可以使用 <code>chmod</code> 命令使文件可写。假设文件名为 <code>example.txt</code>；您可以使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +w example.txt</span><br></pre></td></tr></tbody></table></figure><p>然后，在 Vim 内尝试再次保存文件。</p></li></ol><h3 id="如果文件应保持不变"><a class="markdownIt-Anchor" href="#如果文件应保持不变"></a> 如果文件应保持不变</h3><p>如果文件应该是只读的，且您不小心做了更改或重新考虑了您的编辑，有几个操作您可以执行：</p><ol><li><p><strong>撤销更改</strong>：通过使用 Vim 中的撤销命令 <code>u</code> 手动撤销更改，直到您恢复到文件的原始状态。</p></li><li><p><strong>不保存并退出</strong>：如果您想退出 Vim 而不保存任何更改，可以使用 <code>:q!</code> 命令，它退出 Vim 且不保存。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="理解只读文件"><a class="markdownIt-Anchor" href="#理解只读文件"></a> 理解只读文件</h3><p>在决定覆盖其只读状态之前，了解文件为什么可能处于只读模式是很重要的。文件可以因各种原因而被设置为只读：</p><ul><li>文件可能在文件系统级别被标记为只读，以防止意外更改。</li><li>文件可能属于另一个用户或需要管理员权限才能修改。</li><li>Vim 可能会在检测到文件正在被另一个进程使用时，以只读模式打开文件。</li><li>某些配置或命令（如使用 <code>vim -R &lt;filename&gt;</code> 打开文件）可以指示 Vim 以只读模式打开文件。</li></ul><p>在尝试覆盖文件的只读状态之前，始终确保修改文件是恰当的。</p></blockquote><p><strong>root终端连接效果</strong></p><img src="/posts/45608/image-20240503134748284.png" class="" title="image-20240503134748284"><h2 id="公网ip访问blog网站"><a class="markdownIt-Anchor" href="#公网ip访问blog网站"></a> 公网ip访问Blog网站</h2><img src="/posts/45608/image-20240503135033425.png" class="" title="image-20240503135033425"><p><strong>总结：使用腾讯云服务器（Unbuntu系统）部署Hexo博客，踩雷无数。此次部署博主理解了Linux服务器的详细配置流程，blog网站的访问速度得到了大幅度的提升，免受”科学上网“之苦</strong></p><h1 id="三-问题待解决"><a class="markdownIt-Anchor" href="#三-问题待解决"></a> 三、问题（待解决）</h1><h2 id="一-每次deploy需要输入服务器root密码"><a class="markdownIt-Anchor" href="#一-每次deploy需要输入服务器root密码"></a> 一、每次deploy需要输入服务器root密码</h2><ul><li><p><strong>解决方案：配置SSH公钥</strong></p></li><li><p><strong>参考文章：</strong><a href="https://zhuanlan.zhihu.com/p/549151974">Hexo历险记之八SSH远程链接服务器 - 知乎 (zhihu.com)</a></p></li></ul><p><strong>将git环境下的ssh公钥配置到服务器中的authorized_keys，并且修改sshd_config文件，配置好ssh各项权限</strong></p><img src="/posts/45608/image-20240503153851704.png" class="" title="image-20240503153851704"><p>**最终效果：**免密连接</p><img src="/posts/45608/image-20240503154119191.png" class="" title="image-20240503154119191"><p><strong>PS: 允许不同环境的终端配对的公钥可能不一样，这里使用git bash，要连接的服务器那边就需要使用git bash生成的公钥，才能实现免密登录，这样每次deploy时无需输入密码</strong></p><h2 id="二-blog域名"><a class="markdownIt-Anchor" href="#二-blog域名"></a> 二、Blog域名</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 博客搭建 </category>
          
          <category> Linux </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 博客 </tag>
            
            <tag> github </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS2】“人在回路”---与生成式人工智能交互的视觉医疗机器人</title>
      <link href="/posts/17498/"/>
      <url>/posts/17498/</url>
      
        <content type="html"><![CDATA[<h1 id="人在回路与生成式人工智能交互的视觉服务机器人"><a class="markdownIt-Anchor" href="#人在回路与生成式人工智能交互的视觉服务机器人"></a> “人在回路”—与生成式人工智能交互的视觉服务机器人</h1><p><strong>第一次更新：2024.4.28</strong></p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><ul><li>人在回路（Human-in-the-loop）是一种模式，类似于人机闭环系统或人机互助系统。这种模式被认为是机器学习、人工智能和机器智能的一种可行发展模式，需要人与机器之间的相互作用。在这种模式下，人类始终是模型的一部分，影响着模型的结果，并且需要人类的智能来帮助机器更加智能化。</li><li>ChatGPT是一款强大的基于深度学习的自然语言处理模型，能够生成高质量的自然语言文本。使用ChatGPT+TogetheROS，即ChatRobot将文字描述转化为小车控制指令，根据描述生成特定功能的代码，使机器人按照描述执行相应的任务。–转自NodeHube社区。–转自NobeHube</li></ul><h2 id="项目信息"><a class="markdownIt-Anchor" href="#项目信息"></a> 项目信息：</h2><p><strong>我们的机器人定位为医疗看护机器人（无人车），使用RDK X3 嵌入式AI开发板作为主控，通过Opencv等进行视觉识别，基于类似激光雷达测距的方法实现自主导航运动，满足不同场景下的控制需求。通过ROS2系统使小车与计算机进行通信。</strong></p><p><strong>我们计划使用OpenAI提供的API接口写入小车系统，实现初步的语音交互到控制的过程。基于搭载ROS2系统的RDK X3开发板，使用"人在回路"的模型训练方法，完善机器人行为模型的逻辑，提升机器学习的算法和模型的zhi在后续对GPT接口的开发中，我们设想可以与Chatgpt进行“人在回路”的系统训练，基本实现我们的设想目标。</strong></p><p>基于"人在回路"的模型训练：</p><p><strong>传统的机器人设计，往往是按照设定好的行为逻辑，这种设计过于机械化。而在医疗领域，传统的机器人显然不足以应对以人为核心的服务化需要。所以我们设想，利用“人在回路“的人机闭环互助系统对机器人进行训练，是否可以使得机器人简单地接近于人类的思维模式。应用在医疗服务等领域</strong></p><p><strong>人类能够根据实际情况灵活调整策略和方法，这种能力是当前机器人或人工智能难以完全实现的。通过人在回路，机器人在执行任务时可以依据人类的指示灵活调整其行为和策略，更好地适应复杂多变的环境，这就是我们设计的初步思想，虽然从技术的角度出发还有非常遥远的距离，但是我们可以通过这种方法和思想，逐步完善机器人的基本功能。</strong></p><p><mark><strong>我们将搭载地平线公司的RDK X3作为主控， 配合32位单片机与各类传感器模块进行数据交互，制作一个能够应用于医疗、后勤等领域的复杂多场景的无人车型机器人，能够先实现以下的基本功能：</strong></mark></p><ul><li><p>送药：前期阶段实现小车的所有控制部分，通过Opencv，Openmv组成双摄系统。Opencv负责深度学习相关的视觉识别，Openmv通过SPI协议与单片机进行通信，搭建基础的路径检测控制功能。==实现房号识别，自动药物配送。==中期阶段部署利用Simulink或者Gazebo进行小车的运动仿真。</p></li><li><p>自主导航：通过激光雷达进行SLAM建图，使得机器人具备在不同地环境下进行路径规划避障的功能。</p></li><li><p>语言交互：通过API接口与ChatGPT初步实现计算机的文字交互-&gt;控制小车基本运动-&gt;搭载语音模块控制ChatGPT-&gt;完成更复杂的人机交互系统（图像识别+传感器+语音模块）。</p></li><li><p>环境检测：实现小车上述的基本功能后，进行深度学习相关的视觉开发，使用时下热门的YOLO目标检测算法。能够实现对病人如：跌倒检测（识别人体关节点）等视觉应用。</p></li></ul><h2 id="队伍信息"><a class="markdownIt-Anchor" href="#队伍信息"></a> 队伍信息</h2><p><strong>我们队伍命名为FFT队，FFT即为快速傅立叶变换（Fast Fourier Transform），它是一种算法，在信号处理、图像处理、音频处理等领域广泛使用的技术，在如今5G大规模普及的时代，5G具有mMTC(超大规模机器连接)，eMBB(超低延时)的特点，”物联网“，“边缘计算”，“自动驾驶”等技术得到显著的发展。队伍成员基本为为通信系学生。FFT意为我们队伍追求高效、灵活、准确的开发学习，秉持创新思维、以赛促学的思想，能够将创意与专业知识运用在前沿领域。我们希望基于RDK X3 实现一些基于AI与物联网的idea，利用自身的专业知识，能够在本次项目中通信部分进行着重地设计，提高云平台与机器人的通信效率与可靠性。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> ROS2 </category>
          
          <category> Linux </category>
          
          <category> RDK X3 </category>
          
          <category> 人工智能 </category>
          
          <category> Ubuntu </category>
          
          <category> ROS2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> RDK X3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】[软件操作]仿真调试</title>
      <link href="/posts/45531/"/>
      <url>/posts/45531/</url>
      
        <content type="html"><![CDATA[<h1 id="软键盘"><a class="markdownIt-Anchor" href="#软键盘"></a> 软键盘</h1><img src="/posts/45531/image-20240427152809497.png" class="" title="image-20240427152809497"><h1 id="选择使用按键的属性"><a class="markdownIt-Anchor" href="#选择使用按键的属性"></a> 选择使用按键的属性</h1><img src="/posts/45531/image-20240427152840915.png" class="" title="image-20240427152840915">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> PIC单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PIC单片机 </tag>
            
            <tag> MPLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[8]AD/DA转换</title>
      <link href="/posts/56223/"/>
      <url>/posts/56223/</url>
      
        <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p>void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);</p><p><strong>恢复缺省配置</strong></p><p>void ADC_DeInit(ADC_TypeDef* ADCx);</p><p><strong>ADC初始化</strong></p><p>void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>ADC上电</strong></p><p>void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>开启DMA输出信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>中断输出控制</strong></p><p>void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);</p><ul><li>用于控制某个中断能否通往NVIC</li></ul><p><strong>复位校准</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取复位校准状态</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>开始校准</strong></p><p>void ADC_StartCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取开始校准状态</strong></p><p>FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);</p><p><strong>ADC软件触发的函数</strong></p><p>void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>ADC获取软件转换状态</strong></p><p>FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);</p><ul><li><p>实际上是获取CR2的SWSTART这一位,但是SWSTART在开始ADC转换后直接清除，所以并不能通过这个函数获得是否开始转换的信息</p><img src="/posts/56223/image-20240423220300035.png" class="" title="image-20240423220300035"></li></ul><p><strong><mark>如何获取ADC是否开启的状态？</mark></strong></p><p><strong>获取标志位状态</strong></p><p>FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);</p><ul><li>可以调用这个函数,ADC_FLAG选择EOC,判断EOC标志位是否置1</li></ul><p><strong>每隔几个通道间断一次</strong></p><p>void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);</p><p><strong>是否启动间断模式</strong></p><p>void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC规则组通道配置</strong></mark></p><p>void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);</p><ul><li>ADCx</li><li>ADC_Channel：指定的通道</li><li>Rank：序列的位置</li><li>ADC_SampleTime：指定通道的采样时间</li></ul><p><strong>ADC外部触发转换控制（是否允许外部触发转换）</strong></p><p>void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC获取转换值</strong></mark></p><p>uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);</p><ul><li>获取AD转换的数据寄存器，读取转换结果</li></ul><p><strong>ADC获取双模式转换值</strong></p><p>uint32_t ADC_GetDualModeConversionValue(void);</p><p><strong>是否启动模拟看门狗</strong></p><p>void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);</p><p><strong>配置高低阈值</strong></p><p>void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);</p><p><strong>配置看门的通道</strong></p><p>void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);</p><p><strong>ADC温度传感器、内部参考电压控制</strong></p><p>void ADC_TempSensorVrefintCmd(FunctionalState NewState);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> AD/DA转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[7]编码器接口测速</title>
      <link href="/posts/37664/"/>
      <url>/posts/37664/</url>
      
        <content type="html"><![CDATA[<h2 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h2><blockquote><p><strong>定时器编码器配置</strong></p><p>void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,<br>uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);</p><ul><li>TIMx:选择定时器</li><li>TIM_EncoderMode: 选择编码器模式，T1单独计数，T2单独计数，T1/T2同时计数</li></ul><img src="/posts/37664/image-20240420235549817.png" class="" title="image-20240420235549817"><ul><li>TIM_IC1Polarity：电平极性</li><li>TIM_IC2Polarity：电平极性  可以通过配置这两个参数，设置正相和反相</li></ul><img src="/posts/37664/image-20240420235814820.png" class="" title="image-20240420235814820"></blockquote><h2 id="编码器测计数"><a class="markdownIt-Anchor" href="#编码器测计数"></a> 编码器测计数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM3);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">1</span><span class="number">-1</span>;<span class="comment">//PSC 不分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">65536</span> - <span class="number">1</span>;<span class="comment">//ARR </span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line">TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获单元配置*/</span></span><br><span class="line"><span class="comment">/**通道1配置**/</span></span><br><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">    TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="comment">//给结构体赋初始值，防止出现不确定的状态</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发  TIM_EncoderInterfaceConfig重复配置了相同的寄存器</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line">    <span class="comment">/**通道2配置**/</span> <span class="comment">//注意：这里不需要再定义新的结构体。因为上一次的值已经写入硬件寄存器</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_2;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置编码器接口*/</span></span><br><span class="line">    TIM_EncoderInterfaceConfig(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//定时器3 ，T1T2同时使用，极性相同(上升沿/下降沿两个都是有效的)，即为正相</span></span><br><span class="line">    <span class="comment">//若要反相，那么一个配置位上升沿，一个配置为下降沿有效</span></span><br><span class="line">TIM_Cmd(TIM3,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//int16_t 表示有符号数，能把unint16_相比最高位变为了符号位,这里利用到了补码的特性</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> TIM_GetCounter(TIM3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="编码器测速"><a class="markdownIt-Anchor" href="#编码器测速"></a> 编码器测速</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 输入捕获 </tag>
            
            <tag> 输出比较 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】方波发生器-电子琴</title>
      <link href="/posts/46544/"/>
      <url>/posts/46544/</url>
      
        <content type="html"><![CDATA[<h1 id="如何得到精准的250us定时"><a class="markdownIt-Anchor" href="#如何得到精准的250us定时"></a> 如何得到精准的250us定时？</h1><p><strong>先确认大概的定时器计数器值，再利用跑马表调整误差</strong></p><img src="/posts/46544/image-20240416182439723.png" class="" title="image-20240416182439723">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> PIC单片机 </category>
          
          <category> 项目设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PIC单片机 </tag>
            
            <tag> MPLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】[软件操作]-跑马表</title>
      <link href="/posts/15341/"/>
      <url>/posts/15341/</url>
      
        <content type="html"><![CDATA[<h1 id="如何打开stop-watch窗口"><a class="markdownIt-Anchor" href="#如何打开stop-watch窗口"></a> 如何打开Stop Watch窗口？</h1><blockquote><p><strong>在DEBUG下选mplab sim后，再点DEBUGSETTING来设好频率，设好后点stopwatch</strong></p></blockquote><h1 id="跑马表仿真测试"><a class="markdownIt-Anchor" href="#跑马表仿真测试"></a> 跑马表仿真测试</h1><p><mark>在中断<strong>对应</strong>的位置打上断点，点击仿真运行，即可通过跑马表查看每次进中断的运行时间</mark></p><img src="/posts/15341/image-20240405155601030.png" class="" title="image-20240405155601030"><h1 id="车辆里程表"><a class="markdownIt-Anchor" href="#车辆里程表"></a> 车辆里程表</h1><h2 id="proteus仿真"><a class="markdownIt-Anchor" href="#proteus仿真"></a> proteus仿真</h2><p><mark>可以通过工具栏<strong>调试</strong>选项</mark>，查看各个所需的调试窗口，运行调试工具。</p><p>ps:<strong>step into</strong>可以跳过断点</p><img src="/posts/15341/image-20240405170845407.png" class="" title="image-20240405170845407"><p>第二次进中断，LED灯点亮</p><img src="/posts/15341/image-20240405171351683.png" class="" title="image-20240405171351683"><p>ps:<strong>cof为仿真文件,hex为下载文件</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> PIC单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PIC单片机 </tag>
            
            <tag> MPLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】[2]中断系统</title>
      <link href="/posts/18816/"/>
      <url>/posts/18816/</url>
      
        <content type="html"><![CDATA[<h2 id="保护现场"><a class="markdownIt-Anchor" href="#保护现场"></a> 保护现场</h2><img src="/posts/18816/image-20240327212904491.png" class="" title="image-20240327212904491">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> PIC单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PIC单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单片机】串口通信</title>
      <link href="/posts/25165/"/>
      <url>/posts/25165/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯部分"><a class="markdownIt-Anchor" href="#蓝桥杯部分"></a> 蓝桥杯部分</h1><h2 id="1串口底层"><a class="markdownIt-Anchor" href="#1串口底层"></a> 1.串口底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字节发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line">SBUF=dat;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Send_String</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(*dat != <span class="string">'\0'</span>)<span class="comment">//当字符不为空时，继续发送</span></span><br><span class="line">SendByte(*dat++);<span class="comment">//发送后指针dat加1，指向下一个字节</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2单片机发送字符串给上位机"><a class="markdownIt-Anchor" href="#2单片机发送字符串给上位机"></a> 2.单片机发送字符串给上位机</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0x7F</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0xF0</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL0 = <span class="number">0x18</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF0 = <span class="number">0</span>;<span class="comment">//清除TF0标志</span></span><br><span class="line">TR0 = <span class="number">1</span>;<span class="comment">//定时器0开始计时</span></span><br><span class="line">ET0 = <span class="number">1</span>;    <span class="comment">//定时器中断0打开</span></span><br><span class="line">EA = <span class="number">1</span>;     <span class="comment">//总中断打开</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay500ms</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">23</span>;</span><br><span class="line">j = <span class="number">205</span>;</span><br><span class="line">k = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (--k);</span><br><span class="line">} <span class="keyword">while</span> (--j);</span><br><span class="line">} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"></span><br><span class="line">Uart1_Init();</span><br><span class="line"></span><br><span class="line">Delay500ms();<span class="comment">//mark:初始化后若立即发送数据，第一个字节会重复发送，所以先延时500ms,等待UART稳定工作，再发送字符串</span></span><br><span class="line"></span><br><span class="line">Uart1_SendString(<span class="string">"Hello UART"</span>);<span class="comment">//字符串发送数据在开启定时器中断时容易被打断,第一个字节刚好卡在没发完的时刻,造成死循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行任务</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//Key_Proc();</span></span><br><span class="line"><span class="comment">//Nixie_Proc();</span></span><br><span class="line"><span class="comment">//LED_Proc();</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3上位机发送字符串给单片机"><a class="markdownIt-Anchor" href="#3上位机发送字符串给单片机"></a> 3.上位机发送字符串给单片机</h2><p><strong><mark>PS:按键4可发送单片机接收到的字符串给上位机</mark></strong></p><h3 id="串口处理模块"><a class="markdownIt-Anchor" href="#串口处理模块"></a> 串口处理模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData[Uart_RecData_Index]=SBUF;</span><br><span class="line">Uart_RecData_Index++;</span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="按键程序"><a class="markdownIt-Anchor" href="#按键程序"></a> 按键程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Key_Down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">Uart_SendDataFlag=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中断程序"><a class="markdownIt-Anchor" href="#中断程序"></a> 中断程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData[Uart_RecData_Index]=SBUF;</span><br><span class="line">Uart_RecData_Index++;</span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Uart_Timer==<span class="number">100</span>){Uart_Timer=<span class="number">0</span>;}</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">10</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Uart_SendDataFlag==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_SendDataFlag=<span class="number">0</span>;</span><br><span class="line">Uart1_SendString(Uart_RecData);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4上位机发送数据控制单片机led"><a class="markdownIt-Anchor" href="#4上位机发送数据控制单片机led"></a> 4.上位机发送数据控制单片机LED</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Uart_Timer)<span class="keyword">return</span>;</span><br><span class="line">Uart_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if(Uart_RecData[Uart_RecData_Index-1]==0x0a &amp;&amp; Uart_RecData[Uart_RecData_Index-2]==0x0d) //0x0a--&gt;'\n' 0x0d--&gt;'\r'</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//if(Uart_RecData_Index==9 &amp;&amp; Uart_RecData[0]=='L' &amp;&amp; Uart_RecData[1]=='E' &amp;&amp; Uart_RecData[2]=='D' &amp;&amp; Uart_RecData[3]=='1' &amp;&amp; Uart_RecData[4]=='='&amp;&amp;Uart_RecData[5]=='1')</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//ucLED[0]=1;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="keyword">if</span>(Uart_RecData[Uart_RecData_Index<span class="number">-1</span>]==<span class="number">0x0a</span> &amp;&amp; Uart_RecData[Uart_RecData_Index<span class="number">-2</span>]==<span class="number">0x0d</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Uart_RecData_Index==<span class="number">8</span> &amp;&amp; Uart_RecData[<span class="number">0</span>]==<span class="string">'L'</span> &amp;&amp; Uart_RecData[<span class="number">1</span>]==<span class="string">'E'</span> &amp;&amp; Uart_RecData[<span class="number">2</span>]==<span class="string">'D'</span> &amp;&amp; Uart_RecData[<span class="number">3</span>]==<span class="string">'1'</span> &amp;&amp; Uart_RecData[<span class="number">4</span>]==<span class="string">'='</span>&amp;&amp;Uart_RecData[<span class="number">5</span>]==<span class="string">'1'</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2串口优化"><a class="markdownIt-Anchor" href="#2串口优化"></a> 2.串口优化</h2><h3 id="putchar重定向"><a class="markdownIt-Anchor" href="#putchar重定向"></a> putchar重定向</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> <span class="title function_">putchar</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">    SBUF=ch; <span class="comment">///将dat数据</span></span><br><span class="line">    <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">    TI=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>(ch);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【蓝桥杯单片机】考点复盘1</title>
      <link href="/posts/5903/"/>
      <url>/posts/5903/</url>
      
        <content type="html"><![CDATA[<h1 id="一-led模块"><a class="markdownIt-Anchor" href="#一-led模块"></a> 一、LED模块</h1><h2 id="1led底层代码"><a class="markdownIt-Anchor" href="#1led底层代码"></a> 1.LED底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Led_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr, enable)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp = <span class="number">0x00</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span> (enable)</span><br><span class="line">        temp |= <span class="number">0x01</span> &lt;&lt; addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp &amp;= ~(<span class="number">0x01</span> &lt;&lt; addr);</span><br><span class="line">   <span class="keyword">if</span> (temp != temp_old)</span><br><span class="line">    {</span><br><span class="line">        P0 = ~temp;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0x80</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式"><a class="markdownIt-Anchor" href="#2基本调用方式"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ucLED[n]=x;</span><br><span class="line"></span><br><span class="line">中断程序</span><br><span class="line">{</span><br><span class="line">    Led_Disp(Nixie_Pos,ucLED[Nixie_Pos]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二-按键模块"><a class="markdownIt-Anchor" href="#二-按键模块"></a> 二、按键模块</h1><h2 id="1按键底层代码"><a class="markdownIt-Anchor" href="#1按键底层代码"></a> 1.按键底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Read</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp = <span class="number">0</span>;</span><br><span class="line">    ET0 = <span class="number">0</span>;</span><br><span class="line">    P44 = <span class="number">0</span>;P42 = <span class="number">1</span>;P35 = <span class="number">1</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">7</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">0</span>;P35 = <span class="number">1</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">11</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">1</span>;P35 = <span class="number">0</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">15</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">1</span>;P35 = <span class="number">1</span>;P34 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">19</span>;</span><br><span class="line">    P3 = <span class="number">0xff</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式-2"><a class="markdownIt-Anchor" href="#2基本调用方式-2"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(Key_Down)<span class="comment">//下降沿</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">case</span> X:</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="23-模式切换"><a class="markdownIt-Anchor" href="#23-模式切换"></a> <strong>2.3</strong> <strong>模式切换</strong></h4><img src="/posts/5903/clip_image002.jpg" class="" title="img"><p>第十届省赛真题</p><img src="/posts/5903/clip_image004.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="24-参数设置"><a class="markdownIt-Anchor" href="#24-参数设置"></a> <strong>2.4</strong> <strong>参数设置</strong></h4><img src="/posts/5903/clip_image006.jpg" class="" title="img"><p>第九届省赛真题</p><img src="/posts/5903/clip_image008.jpg" class="" title="img"><p>第八届省赛真题</p><h4 id="25-参数保存"><a class="markdownIt-Anchor" href="#25-参数保存"></a> <strong>2.5</strong> <strong>参数保存</strong></h4><img src="/posts/5903/clip_image010.jpg" class="" title="img"><p>第五届省赛真题</p><img src="/posts/5903/clip_image012.jpg" class="" title="img"><p>第十一届省赛真题</p><h4 id="26-特定使能"><a class="markdownIt-Anchor" href="#26-特定使能"></a> <strong>2.6</strong> <strong>特定使能</strong></h4><img src="/posts/5903/clip_image014.jpg" class="" title="img"><p>第十一届省赛真题</p><h4 id="27-长按跳转-松手返回"><a class="markdownIt-Anchor" href="#27-长按跳转-松手返回"></a> <strong>2.7</strong> <strong>长按跳转 松手返回</strong></h4><img src="/posts/5903/clip_image016.jpg" class="" title="img"><p>第八届省赛真题</p><h4 id="28-键盘输入"><a class="markdownIt-Anchor" href="#28-键盘输入"></a> <strong>2.8</strong> <strong>键盘输入</strong></h4><img src="/posts/5903/clip_image017.png" class="" title="img"><p>模拟训练二</p><h4 id="29-长按短按-效果不同"><a class="markdownIt-Anchor" href="#29-长按短按-效果不同"></a> <strong>2.9</strong> <strong>长按短按 效果不同</strong></h4><img src="/posts/5903/clip_image019.jpg" class="" title="img"><h1 id="三-数码管模块"><a class="markdownIt-Anchor" href="#三-数码管模块"></a> 三、数码管模块</h1><h2 id="1数码管底层代码"><a class="markdownIt-Anchor" href="#1数码管底层代码"></a> 1.数码管底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg_dula[] = {<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0xff</span>};</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg_wela[] = {<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Seg_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> wela,dula,point)</span></span><br><span class="line">{</span><br><span class="line">    P0 = <span class="number">0xff</span>;</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xe0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line"></span><br><span class="line">    P0 = seg_wela[wela];</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xc0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">    </span><br><span class="line">    P0 = seg_dula[dula];</span><br><span class="line">    <span class="keyword">if</span>(point)</span><br><span class="line">        P0 &amp;= <span class="number">0x7f</span>;</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xe0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>; </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式-3"><a class="markdownIt-Anchor" href="#2基本调用方式-3"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Seg_Buf[X] = Y;</span><br><span class="line">Seg_Point[X] = Y;</span><br></pre></td></tr></tbody></table></figure><h4 id="33-显示整数变量"><a class="markdownIt-Anchor" href="#33-显示整数变量"></a> <strong>3.3</strong> <strong>显示整数变量</strong></h4><img src="/posts/5903/clip_image002-1711183567913-109.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="34-显示小数点变量"><a class="markdownIt-Anchor" href="#34-显示小数点变量"></a> <strong>3.4</strong> <strong>显示小数点变量</strong></h4><img src="/posts/5903/clip_image004-1711183567913-110.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="35-不同状态显示不同内容"><a class="markdownIt-Anchor" href="#35-不同状态显示不同内容"></a> <strong>3.5</strong> <strong>不同状态显示不同内容</strong></h4><img src="/posts/5903/clip_image006-1711183567914-112.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="36-高位熄灭"><a class="markdownIt-Anchor" href="#36-高位熄灭"></a> <strong>3.6</strong> <strong>高位熄灭</strong></h4><img src="/posts/5903/clip_image008-1711183567913-111.jpg" class="" title="img"><p>第十届省赛真题</p><h4 id="37-选中单元闪烁"><a class="markdownIt-Anchor" href="#37-选中单元闪烁"></a> <strong>3.7</strong> <strong>选中单元闪烁</strong></h4><img src="/posts/5903/clip_image010-1711183567914-113.jpg" class="" title="img"><p>第八届省赛真题</p><h1 id="四-继电器蜂鸣器"><a class="markdownIt-Anchor" href="#四-继电器蜂鸣器"></a> 四、继电器蜂鸣器</h1><h2 id="1底层代码"><a class="markdownIt-Anchor" href="#1底层代码"></a> 1.底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_1 = <span class="number">0x00</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old_1 = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Beep</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        temp_1 |= <span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp_1 &amp;= ~<span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">    {</span><br><span class="line">        P0 = temp_1;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old_1 = temp_1;        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Relay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        temp_1 |= <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp_1 &amp;= ~<span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">    {</span><br><span class="line">        P0 = temp_1;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old_1 = temp_1;        </span><br><span class="line">    }   </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>…</p><h1 id="ne555"><a class="markdownIt-Anchor" href="#ne555"></a> NE555</h1><p>绑定定时器0，应采用计数器模式</p><h1 id="超声波"><a class="markdownIt-Anchor" href="#超声波"></a> #超声波</h1><h2 id="1超声波底层代码"><a class="markdownIt-Anchor" href="#1超声波底层代码"></a> 1.超声波底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">()</span>        <span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">()</span> <span class="comment">//超声波初始化函数 产生8个40Mhz的方波信号</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        Tx = <span class="number">1</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">        Tx = <span class="number">0</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0f</span>;<span class="comment">//配置定时器1计时模式</span></span><br><span class="line">    TH1 = TL1 = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    TR1 = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (TF1 == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    TR1 = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(TF1 == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = TH1 &lt;&lt; <span class="number">8</span> | TL1;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        TF1 = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2pca写法"><a class="markdownIt-Anchor" href="#2pca写法"></a> 2.PCA写法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    CMOD =  <span class="number">0x00</span>;<span class="comment">//配置PCA工作模式</span></span><br><span class="line">    CH = CL = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    CR = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (CF == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    CR = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(CF == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = CH &lt;&lt; <span class="number">8</span> | CL;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        CF = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="串口"><a class="markdownIt-Anchor" href="#串口"></a> #串口</h1><h2 id="1串口底层"><a class="markdownIt-Anchor" href="#1串口底层"></a> 1.串口底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span>     <span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">    SCON = <span class="number">0x50</span>;        <span class="comment">//8位数据,可变波特率</span></span><br><span class="line">    AUXR |= <span class="number">0x01</span>;       <span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">    AUXR |= <span class="number">0x04</span>;       <span class="comment">//定时器时钟1T模式</span></span><br><span class="line">    T2L = <span class="number">0xC7</span>;     <span class="comment">//设置定时初始值</span></span><br><span class="line">    T2H = <span class="number">0xFE</span>;     <span class="comment">//设置定时初始值</span></span><br><span class="line">    AUXR |= <span class="number">0x10</span>;       <span class="comment">//定时器2开始计时</span></span><br><span class="line">    ES = <span class="number">1</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字节发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line">    SBUF=dat;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">    TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Send_String</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(*dat != <span class="string">'\0'</span>)<span class="comment">//当字符不为空时，继续发送</span></span><br><span class="line">        SendByte(*dat++);<span class="comment">//发送后指针dat加1，指向下一个字节</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口1中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1Server</span><span class="params">()</span> interrupt 4</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(RI == <span class="number">1</span>) <span class="comment">//串口接收数据</span></span><br><span class="line">    {</span><br><span class="line">        Uart_Recv[Uart_Recv_Index] = SBUF;</span><br><span class="line">        Uart_Recv_Index++;</span><br><span class="line">        RI = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-串口接收数据"><a class="markdownIt-Anchor" href="#2-串口接收数据"></a> **2. **串口接收数据</h2><p><strong>模拟题</strong></p><hr><img src="/posts/5903/clip_image002-1711190784499-119.jpg" class="" title="img"><hr><img src="/posts/5903/clip_image004-1711190784499-120.jpg" class="" title="img"><h2 id="3-串口发送数据"><a class="markdownIt-Anchor" href="#3-串口发送数据"></a> **3. **串口发送数据</h2><p><strong>模拟题</strong></p><hr><img src="/posts/5903/clip_image005.jpg" class="" title="img"><hr><img src="/posts/5903/clip_image006-1711190784499-121.jpg" class="" title="img"><ul><li><strong>内存溢出：idata/xdata/data/code</strong></li></ul><h2 id="第三部分-大模板"><a class="markdownIt-Anchor" href="#第三部分-大模板"></a> <mark>第三部分 大模板</mark></h2><h3 id="一-头文件声明区域"><a class="markdownIt-Anchor" href="#一-头文件声明区域"></a> 一、头文件声明区域</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件声明区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC15F2K60S2.H&gt;</span><span class="comment">//单片机寄存器专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span><span class="comment">//初始化底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Led.h&gt;</span><span class="comment">//Led底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span><span class="comment">//按键底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Seg.h&gt;</span><span class="comment">//数码管底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span><span class="comment">//串口底层驱动专用头文件</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="二-变量声明区域"><a class="markdownIt-Anchor" href="#二-变量声明区域"></a> 二、变量声明区域</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 变量声明区 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Val,Key_Down,Key_Old,Key_Up;<span class="comment">//按键专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Slow_Down;<span class="comment">//按键减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Buf[<span class="number">8</span>] = {<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Point[<span class="number">8</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管小数点数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Pos;<span class="comment">//数码管扫描专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Seg_Slow_Down;<span class="comment">//数码管减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLed[<span class="number">8</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//Led显示数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Slow_Down;<span class="comment">//串口减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Recv[<span class="number">10</span>];<span class="comment">//串口接收数据储存数组 默认10个字节 若接收数据较长 可更改最大字节数</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Recv_Index;<span class="comment">//串口接收数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Send[<span class="number">10</span>];<span class="comment">//串口接收数据储存数组 默认10个字节 若发送数据较长 可更改最大字节数</span></span><br></pre></td></tr></tbody></table></figure><h3 id="三-按键处理函数"><a class="markdownIt-Anchor" href="#三-按键处理函数"></a> 三、按键处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 键盘处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Key_Slow_Down) <span class="keyword">return</span>;<span class="comment">//作用：使得程序在每次定时扫描过程只执行一次，即Key_Slow_Down=0时立即置1，向下执行。</span></span><br><span class="line"></span><br><span class="line">  Key_Slow_Down = <span class="number">1</span>;<span class="comment">//键盘减速程序</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  Key_Val = Key_Read();<span class="comment">//实时读取键码值</span></span><br><span class="line"></span><br><span class="line">  Key_Down = Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//捕捉按键下降沿</span></span><br><span class="line"></span><br><span class="line">  Key_Up = ~Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//捕捉按键上降沿</span></span><br><span class="line"></span><br><span class="line">  Key_Old = Key_Val;<span class="comment">//辅助扫描变量</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="四-信息处理函数"><a class="markdownIt-Anchor" href="#四-信息处理函数"></a> 四、信息处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信息处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Seg_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Seg_Slow_Down) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Seg_Slow_Down = <span class="number">1</span>;<span class="comment">//数码管减速程序</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="五-其他显示函数"><a class="markdownIt-Anchor" href="#五-其他显示函数"></a> 五、其他显示函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 其他显示函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Led_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="六-串口处理函数"><a class="markdownIt-Anchor" href="#六-串口处理函数"></a> 六、串口处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Uart_Slow_Down) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Uart_Slow_Down = <span class="number">1</span>;<span class="comment">//串口减速程序 </span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="七-定时器初始化函数"><a class="markdownIt-Anchor" href="#七-定时器初始化函数"></a> 七、定时器初始化函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器0中断初始化函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0Init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  AUXR &amp;= <span class="number">0x7F</span>;    <span class="comment">//定时器时钟12T模式</span></span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;    <span class="comment">//设置定时器模式</span></span><br><span class="line"></span><br><span class="line">  TL0 = <span class="number">0x18</span>;   <span class="comment">//设置定时初始值</span></span><br><span class="line"></span><br><span class="line">  TH0 = <span class="number">0xFC</span>;   <span class="comment">//设置定时初始值</span></span><br><span class="line"></span><br><span class="line">  TF0 = <span class="number">0</span>;     <span class="comment">//清除TF0标志</span></span><br><span class="line"></span><br><span class="line">  TR0 = <span class="number">1</span>;     <span class="comment">//定时器0开始计时</span></span><br><span class="line"></span><br><span class="line">  ET0 = <span class="number">1</span>;   <span class="comment">//定时器中断0打开</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;   <span class="comment">//总中断打开</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="八-中断服务函数"><a class="markdownIt-Anchor" href="#八-中断服务函数"></a> 八、中断服务函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器0中断服务函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0Server</span><span class="params">()</span> interrupt 1</span><br><span class="line"></span><br><span class="line">{  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Key_Slow_Down == <span class="number">10</span>) Key_Slow_Down = <span class="number">0</span>;<span class="comment">//键盘减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Seg_Slow_Down == <span class="number">500</span>) Seg_Slow_Down = <span class="number">0</span>;<span class="comment">//数码管减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Uart_Slow_Down == <span class="number">200</span>) Uart_Slow_Down = <span class="number">0</span>;<span class="comment">//串口减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Seg_Pos == <span class="number">8</span>) Seg_Pos = <span class="number">0</span>;<span class="comment">//数码管显示专用</span></span><br><span class="line"></span><br><span class="line">  Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">  Led_Disp(Seg_Pos,ucLed[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="九-串口服务函数"><a class="markdownIt-Anchor" href="#九-串口服务函数"></a> 九、串口服务函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口1中断服务函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1Server</span><span class="params">()</span> interrupt 4</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(RI == <span class="number">1</span>) <span class="comment">//串口接收数据</span></span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line">      Uart_Recv[Uart_Recv_Index] = SBUF;</span><br><span class="line">  Uart_Recv_Index++;</span><br><span class="line">      RI = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="十-主函数"><a class="markdownIt-Anchor" href="#十-主函数"></a> 十、主函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  System_Init();</span><br><span class="line"></span><br><span class="line">  Timer0Init();</span><br><span class="line"></span><br><span class="line">  UartInit();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    Key_Proc();</span><br><span class="line"></span><br><span class="line">    Seg_Proc();</span><br><span class="line"></span><br><span class="line">    Led_Proc();</span><br><span class="line"></span><br><span class="line">    Uart_Proc();</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
          <category> 蓝桥杯 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> STC15 </tag>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[6]输入捕获和输出比较</title>
      <link href="/posts/64385/"/>
      <url>/posts/64385/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><p>另外它们的CH1到CH4，4个通道的引脚，也是公用的</p><p>所以对于同一个定时器，输入捕获和输出比较只能用其中一个。</p><h2 id="一-输出比较"><a class="markdownIt-Anchor" href="#一-输出比较"></a> 一、输出比较</h2><img src="/posts/64385/image-20240317124437632.png" class="" title="image-20240317124437632"><img src="/posts/64385/image-20240317124510956.png" class="" title="image-20240317124510956"><p><strong>根据CNT和CCR的大小关系，从通道引脚输出高低电平</strong></p><h2 id="二-输入捕获"><a class="markdownIt-Anchor" href="#二-输入捕获"></a> 二、输入捕获</h2><img src="/posts/64385/image-20240317124716864.png" class="" title="image-20240317124716864"><img src="/posts/64385/image-20240317124815682.png" class="" title="image-20240317124815682"><p>输入滤波器：可以对毛刺信号进行滤波</p><p>交叉输入的作用？</p><p>TRC?</p><p>CNT计数器是由内部的标准时钟进行驱动的，可以用于测量外部检测两个上升沿的时间间隔，</p><p>所以需要在检测到一个上升沿过后，清零CNT，这样在第二次上升沿后，CNT值就是测周法的N，可以通过主从触发模式，自动完成。</p><p><strong>总结：</strong></p><p>输入捕获类似于外部中断。都是检测边沿，然后执行相应的动嘴，而在输入捕获中。检测到指定电平跳变后，CNT的值所存到CCR中。</p><ul><li><p>输出比较。引脚是输出端口，根据CNT和CCR的大小关系执行输出的动作。</p></li><li><p>输入捕获。引脚是输入端口，接收到输入信号，执行锁存的动作。</p></li></ul><p><strong>#主从触发模式：</strong></p><p>将主从触发模式和PWMI模式相结合，可以让硬件自动测量频率和占空比，软件无需进行干预。</p><h2 id="三-频率测量"><a class="markdownIt-Anchor" href="#三-频率测量"></a> 三、频率测量</h2><img src="/posts/64385/image-20240317125647320.png" class="" title="image-20240317125647320"><p><strong>PS：STM32测频率只能测量数字信号，若测量正选波，可以用运放电路搭建一个比较器。若测量的信号电压较高，需要考虑隔离的问题，比如隔离放大器，电压互感器等元件。总而言之，要用STM32测量频率，只能用数字信号，高电平3.3V，低电平0V</strong></p><p><strong>#区别</strong></p><ul><li><p>测频法：规定时间，记录上升沿次数，<mark>适合测量高频信号</mark>。在计次N过少时，误差会比较大。</p><p>​测频法自带均值滤波，得到的其实是平均频率。</p></li><li><p>测周法：从待测频率的第一个上升沿开始，以一个标准的频率计次，记录计数器的次数，直到检测到待测频率信号的第二个上升沿。<mark>适合测量低频信号</mark>，低频信号，周期长，计次多，有利于减小误差。</p><p>一般情况下，待测信号几百几千HZ以上，测周法更新更快，又因为测周法只测量一个周期，所以结果容易收到噪声的影响，波动较大。</p></li><li><p>两种方法都会出现正负1误差</p></li></ul><p>#<strong>中界频率</strong></p><ul><li>用于界定选用测频法还是测周法的频率</li></ul><h2 id="四-输入捕获通道"><a class="markdownIt-Anchor" href="#四-输入捕获通道"></a> 四、输入捕获通道</h2><img src="/posts/64385/image-20240317133236546.png" class="" title="image-20240317133236546"><p><mark>fDTS是滤波器的采样时钟来源。TI1是输入信号，TI1F是滤波后的信号，CCMR1寄存器中的ICF位可以控制滤波器的参数</mark></p><p>​ICF相关定义</p><img src="/posts/64385/image-20240317133728716.png" class="" title="image-20240317133728716"><p>滤波之后的信号通过后续的边沿检测器，并且可以通过CCIP选择极性。最终得到TI1FP1的触发信号，进入通道1后续的捕获电路。同样的，通道2也是一样的流程，不过图中省略了。</p><p>CC1E位，控制输出使能或失能。</p><p><strong>如何自动清零CNT？</strong></p><h3 id="主从触发模式"><a class="markdownIt-Anchor" href="#主从触发模式"></a> 主从触发模式</h3><img src="/posts/64385/image-20240317134635166.png" class="" title="image-20240317134635166"><ul><li><p>主模式可以将定时器内部的信号，映射到TRGO引脚，用于触发别的外设</p></li><li><p>从模式接收其他外设或者自身外设的一些信号，用于控制自身定时器的运行。</p></li></ul><p><strong>这里将TI1FP1作为触发源，从模式执行Reset操作，这样就可以实现CNT自动清零。</strong></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><h3 id="输入捕获基本结构"><a class="markdownIt-Anchor" href="#输入捕获基本结构"></a> 输入捕获基本结构</h3><img src="/posts/64385/image-20240317135641144.png" class="" title="image-20240317135641144"><p>这个结构只使用了一个通道，只能用于测量频率。</p><p>先转运CNT，再对CNT进行清零。</p><p>使用从模式自动清零CNT，只能用通道1和通道2。</p><h3 id="pwmi基本结构"><a class="markdownIt-Anchor" href="#pwmi基本结构"></a> PWMI基本结构</h3><img src="/posts/64385/image-20240317140209540.png" class="" title="image-20240317140209540"><p>开始，第一个上升沿，CCR1捕获并且清零CNT，CNT++。第一个下降沿，CCR2捕获CNT，但不会执行CNT清零。第二个上升沿，CCR1捕获CNT，同时CNT清零。</p><p>这样CCR1值就是整个周期的计数值，CCR2就是高电平期间的计数值。这样可以同时得到PWM的频率和占空比。</p><p>这里也可以配置两个通道同时捕获第二个引脚的输入，使用TI2FP1和TI2FP2两个引脚。</p><h1 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> 代码部分</h1><blockquote><hr><p><strong>单独修改PSR值</strong></p><p>void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)</p><ul><li>TIMx：定时器</li><li>Prescaler：PSR值</li><li>TIM_PSCReloadMode：指定定时器预分频器的重装模式<ul><li>@arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event. 在更新事件中 重装<ul><li><pre><code>@arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately. 立即重装</code></pre></li></ul></li></ul></li></ul><hr><p><strong>输入捕获</strong></p><p>void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);</p><p>输入捕获函数，4个通道共用一个函数</p><hr><p><strong>给输入捕获结构体赋初值</strong></p><p>void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);</p><hr><p><strong>选择输入触发源TIGI</strong></p><p>void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><p>配置从模式的输入触发源</p><hr><p><strong>选择输出触发源TRGO</strong></p><p>void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><p>配置主模式的输出触发源</p><hr><p><strong>配置从模式</strong></p><p>void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);</p><img src="/posts/64385/image-20240317150206255.png" class="" title="image-20240317150206255"><p><mark>ps:这三个从模式是给编码器接口用的，会有另外的函数进行配置</mark></p><hr><p><strong>配置通道1234的定时器</strong></p><p>void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);</p><hr><p><strong>读取4个通道的CCR</strong></p><p>uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);</p><p><strong>对于写4个通道CCR的函数</strong></p><p>void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);<br>void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);<br>void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);<br>void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);</p><p><mark>输入捕获模式下，CCR是只读的，要用GetCapture读出</mark></p><hr><p><strong><mark>TIM_PWMIConfig(TIM3,&amp;TIM_ICInitStructure);//标准库中已将上述注释部分封装好,即会将以及配置号的部分，再配置另外的通道将参数进行相反的设置</mark></strong></p><hr></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 输入捕获 </tag>
            
            <tag> 输出比较 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【蓝桥杯单片机】第九届省赛题</title>
      <link href="/posts/25039/"/>
      <url>/posts/25039/</url>
      
        <content type="html"><![CDATA[<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1><img src="/posts/25039/image-20240308235630315.png" class="" title="image-20240308235630315"><h2 id="题目分析思路"><a class="markdownIt-Anchor" href="#题目分析思路"></a> 题目分析（思路）</h2><ol><li><p>首先，定义按键所控制的相关变量</p></li><li><p>编写数码管显示的逻辑，以”设置状态为准“，测试按键是否能正常控制相关参数(工作模式、流转间隔)</p><ul><li>因为一共有四个工作模式，流转间隔定义为一个数组，存放各个元素的流转时长</li></ul></li><li><p>将工作模式1的相关逻辑（LED流转方式）编写出来</p><ul><li>这里使用一个指针用于LED的点亮(LED_OFF)，另一个用于LED的熄灭(LED_ON)</li></ul></li><li><p>将工作模式，流转间隔的逻辑与LED工作模式1关联，测试按键功能是否正常，LED是否能被流转间隔控制</p></li><li><p>如果以上程序测试正确，编写其他三个工作模式的LED模块</p><ul><li>此时进行程序测试，功能正常，但是切换其他流转模式会有上一个模式的LED”残留“ (如双LED模式切换到单LED模式时)，因此需要进行LED的复位（在按键控制模块中编写）</li></ul></li><li><p>修改完毕后，编写亮度控制，此时注意到，一个定时器0无法满足对LED扫描的同时进行亮度控制，因此再调用定时器1，用于LED的<strong>扫描指针偏移</strong>，以及LED的<strong>PWM控制亮度</strong>。</p><ul><li>这里修改完程序后，发现数码管闪烁，这是因为定时器1的频率较高，会打断主函数中数码管显示模块，因此将Nixie_Proc()函数放入定时器1中进行运行</li></ul></li><li><p>当以上各个功能全部测试完毕后，调用EEPROM模块，保存流转间隔</p></li></ol><h1 id="程序部分"><a class="markdownIt-Anchor" href="#程序部分"></a> 程序部分</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Work_Mode;<span class="comment">//工作模式参数 0-模式1 1-模式2 2-模式3 3-模式4</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Set_Mode;<span class="comment">// 0-数码管熄灭 1-模式编号 2-流转间隔</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_FlashFlag;<span class="comment">//闪烁标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Timer_800ms;<span class="comment">//0.8s定时（闪烁用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> LED_Flow_Timer_Set[]={<span class="number">400</span>,<span class="number">400</span>,<span class="number">400</span>,<span class="number">400</span>};<span class="comment">//流转间隔参数,控制流转速度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> LED_Flow_Timer;<span class="comment">//流转定时</span></span><br><span class="line">bit LED_Enable=<span class="number">0</span>;<span class="comment">//LED流转使能位，1时LED流转使能，默认LED流转启动</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Level_ShowFlag;<span class="comment">//按下按键4显示LED亮度等级</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_OFF=<span class="number">7</span>;<span class="comment">//LED熄灭指针</span></span><br><span class="line"><span class="comment">/*LED亮度控制相关参数*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Count;<span class="comment">//LED显示周期</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Level;<span class="comment">//LED等级</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Pos;<span class="comment">//LED扫描位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键扫描模块*/</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键4按下*/</span></span><br><span class="line"><span class="keyword">if</span>(Key_Old==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">LED_Level_ShowFlag=<span class="number">1</span>;<span class="comment">//显示LED亮度等级</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_Level_ShowFlag=<span class="number">0</span>;<span class="comment">//松开，LED亮度等级标志位失效</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键控制模块*/</span></span><br><span class="line"><span class="keyword">switch</span>(Key_Down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:<span class="comment">//按键7，用于控制LED的启动和暂停</span></span><br><span class="line">LED_Enable^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:<span class="comment">//按键6，控制设置界面</span></span><br><span class="line"><span class="keyword">if</span>(++Set_Mode==<span class="number">3</span>)</span><br><span class="line">Set_Mode=<span class="number">0</span>;</span><br><span class="line">EEPROM_Write(LED_Flow_Timer_Set,<span class="number">0x00</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//按键5</span></span><br><span class="line"><span class="keyword">if</span>(Set_Mode==<span class="number">2</span>)<span class="comment">//设置界面位于“流转间隔“对应”运行模式“的流转间隔+100ms</span></span><br><span class="line">{</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]+=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer_Set[Work_Mode]&gt;=<span class="number">1300</span>)</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]=<span class="number">400</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Set_Mode==<span class="number">1</span>)<span class="comment">//设置界面位于“运行模式”运行模式切换</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Work_Mode==<span class="number">4</span>)</span><br><span class="line">Work_Mode=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每次模式切换，对LED指针进行复位*/</span></span><br><span class="line"><span class="keyword">if</span>(Work_Mode==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为4</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为1</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">7</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为2</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为3</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">3</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span>(Set_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]-=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer_Set[Work_Mode]&lt;=<span class="number">300</span>)</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]=<span class="number">1200</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Set_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--Work_Mode==<span class="number">255</span>)</span><br><span class="line">Work_Mode=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每次模式切换，对LED指针进行复位*/</span></span><br><span class="line"><span class="keyword">if</span>(Work_Mode==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">7</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line">LED_Level=<span class="number">4</span>-((AD_Read(<span class="number">0x01</span>))/<span class="number">64</span>);</span><br><span class="line"><span class="keyword">switch</span>(Set_Mode)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Level_ShowFlag)</span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Level;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">17</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=Nixie_FlashFlag?Work_Mode:<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=(LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>)?LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>:<span class="number">10</span>;<span class="comment">//高位熄灭</span></span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Flow_Timer_Set[Work_Mode]%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=Work_Mode;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(Nixie_FlashFlag)</span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=(LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>)?LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>:<span class="number">10</span>;<span class="comment">//高位熄灭</span></span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Flow_Timer_Set[Work_Mode]%<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer)<span class="keyword">return</span>;</span><br><span class="line">LED_Flow_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*LED工作模式控制模块*/</span></span><br><span class="line"><span class="keyword">switch</span>(Work_Mode)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)<span class="comment">//LED流转使能位有效</span></span><br><span class="line">{</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(++LED_ON==<span class="number">8</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">0</span>;LED_OFF=<span class="number">7</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--LED_ON==<span class="number">255</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">7</span>;LED_OFF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++LED_ON==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">0</span>;LED_OFF=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--LED_ON==<span class="number">255</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">3</span>;LED_OFF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer1_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//125微秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0xBF</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL1 = <span class="number">0x83</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH1 = <span class="number">0xFF</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF1 = <span class="number">0</span>;<span class="comment">//清除TF1标志</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">ET1 = <span class="number">1</span>; <span class="comment">//定时器i打开</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">EEPROM_Read(LED_Flow_Timer_Set,<span class="number">0x00</span>,<span class="number">4</span>);<span class="comment">//读取AT24C02中的数据</span></span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">Timer1_Init();</span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行任务</span></span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line"><span class="comment">//Nixie_Proc();</span></span><br><span class="line">LED_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">300</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line"><span class="keyword">if</span>(++LED_Flow_Timer&gt;=LED_Flow_Timer_Set[Work_Mode]){LED_Flow_Timer=<span class="number">0</span>;}<span class="comment">//控制LED流转速度</span></span><br><span class="line"><span class="keyword">if</span>(++LED_Count==<span class="number">13</span>){LED_Count=<span class="number">0</span>;}<span class="comment">//LED亮起的周期（PWM周期），12MS</span></span><br><span class="line"><span class="keyword">if</span>(++Timer_800ms==<span class="number">800</span>){Timer_800ms=<span class="number">0</span>;Nixie_FlashFlag^=<span class="number">1</span>;}</span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer1_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 3</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++LED_Pos==<span class="number">8</span>){LED_Pos=<span class="number">0</span>;}<span class="comment">//LED每1ms完成一次扫描</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(LED_Count&lt;((LED_Level<span class="number">-1</span>)*<span class="number">3</span>))<span class="comment">//LED占空比</span></span><br><span class="line">{</span><br><span class="line">LED_Disp(LED_Pos,ucLED[LED_Pos]);<span class="comment">//LED点亮，1ms</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_Disp(LED_Pos,<span class="number">0</span>);<span class="comment">//LED熄灭,1ms</span></span><br><span class="line">}</span><br><span class="line">Nixie_Proc();<span class="comment">//如果数码管放置在主程序中，由于定时器1频率高，优先级高，主函数会被频繁打断出现闪烁现象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
          <category> 蓝桥杯 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> STC15 </tag>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单片机】SPI协议</title>
      <link href="/posts/23815/"/>
      <url>/posts/23815/</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h1><h3 id="什么是spi"><a class="markdownIt-Anchor" href="#什么是spi"></a> 什么是SPI？</h3><p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一 种同步串行接口技术，是一种高速的，全双工，同步的通信总线。</p><p><strong>SPI优点</strong>:支持全双工通信 通信简单 数据传输速率块</p><p><strong>缺点</strong> :没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据 可靠性上有一定的缺陷。</p><p><strong>特点</strong>:</p><ol><li>高速、同步、全双工、非差分、总线式</li><li>主从机通信模式</li></ol><h1 id="蓝桥杯相关暂未使用spi"><a class="markdownIt-Anchor" href="#蓝桥杯相关暂未使用spi"></a> 蓝桥杯相关（暂未使用SPI）</h1><h2 id="ds1302时钟芯片底层"><a class="markdownIt-Anchor" href="#ds1302时钟芯片底层"></a> DS1302（时钟芯片）底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ds1302.h"</span></span></span><br><span class="line">sbit SCK=P1^<span class="number">7</span>;</span><br><span class="line">sbit SDA=P2^<span class="number">3</span>;</span><br><span class="line">sbit RST = P1^<span class="number">3</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302</span><span class="params">(<span class="type">unsigned</span>  <span class="type">char</span> temp)</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)     </span><br><span class="line">{ </span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">SDA=temp&amp;<span class="number">0x01</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">SCK=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302_Byte</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address,<span class="type">unsigned</span> <span class="type">char</span> dat )</span>     </span><br><span class="line">{</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>; _nop_();  </span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> Write_Ds1302(dat);</span><br><span class="line"> RST=<span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_Ds1302_Byte</span> <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address )</span></span><br><span class="line">{</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> i,temp=<span class="number">0x00</span>;</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>;_nop_();</span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) </span><br><span class="line"> {</span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(SDA)</span><br><span class="line"> temp|=<span class="number">0x80</span>;</span><br><span class="line"> SCK=<span class="number">1</span>;</span><br><span class="line">} </span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line">SCK=<span class="number">1</span>;_nop_();</span><br><span class="line">SDA=<span class="number">0</span>;_nop_();</span><br><span class="line">SDA=<span class="number">1</span>;_nop_();</span><br><span class="line"><span class="keyword">return</span> (temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写"><a class="markdownIt-Anchor" href="#基于底层的时序编写"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Set_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0</span>);<span class="comment">//关闭写保护</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x84</span>-i*<span class="number">2</span>,ucRtc[i]);<span class="comment">//给ds1302写入数据,0x84时 0x82分 0x80秒</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">1</span>);<span class="comment">//打开写保护</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">ucRtc[i] = Read_Ds1302_Byte(<span class="number">0x85</span>-i*<span class="number">2</span>);<span class="comment">//读取ds1302的数据</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0</span>);<span class="comment">//关闭写保护</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8c</span>,ucDate[<span class="number">0</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x88</span>,ucDate[<span class="number">1</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x86</span>,ucDate[<span class="number">2</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">ucDate[<span class="number">0</span>] = Read_Ds1302_Byte(<span class="number">0x8d</span>);</span><br><span class="line">ucDate[<span class="number">1</span>] = Read_Ds1302_Byte(<span class="number">0x89</span>);</span><br><span class="line">ucDate[<span class="number">2</span>] = Read_Ds1302_Byte(<span class="number">0x87</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="超声波底层"><a class="markdownIt-Anchor" href="#超声波底层"></a> 超声波底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ultrasonic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit TX = P1^<span class="number">0</span>;</span><br><span class="line">sbit RX = P1^<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//超声波初始化函数 产生8个40Mhz的方波信号</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        TX=<span class="number">1</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">        TX=<span class="number">0</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写-2"><a class="markdownIt-Anchor" href="#基于底层的时序编写-2"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Ut_Wave_Data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;</span><br><span class="line">    TL1=TH1=<span class="number">0</span>;</span><br><span class="line">    Ut_Wave_Init();</span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((RX==<span class="number">1</span>) &amp;&amp; (TF1==<span class="number">0</span>));<span class="comment">//等待超声波返回或定时器溢出</span></span><br><span class="line"></span><br><span class="line">    TR1=<span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(TF1==<span class="number">0</span>)<span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = TH1&lt;&lt;<span class="number">8</span> | TL1;</span><br><span class="line">        <span class="keyword">return</span> (time *<span class="number">0.017</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        TF1=<span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单片机】OneWire通信协议</title>
      <link href="/posts/46163/"/>
      <url>/posts/46163/</url>
      
        <content type="html"><![CDATA[<h3 id="一-onewire单总线协议"><a class="markdownIt-Anchor" href="#一-onewire单总线协议"></a> 一、OneWire（单总线）协议</h3><p>•单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线</p><p>•一根通信线：DQ</p><p>•异步、半双工</p><p>•单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线</p><h3 id="二-单总线电路规范"><a class="markdownIt-Anchor" href="#二-单总线电路规范"></a> 二、单总线电路规范</h3><p>•设备的DQ均要配置成开漏输出模式</p><p>•DQ添加一个上拉电阻，阻值一般为4.7KΩ左右</p><p>•若此总线的从机采取寄生供电，则主机还应配一个强上拉输出电路</p><img src="/posts/46163/image-20240302232447437.png" class="" title="image-20240302232447437"><h3 id="三-单总线的时序结构"><a class="markdownIt-Anchor" href="#三-单总线的时序结构"></a> 三、单总线的时序结构</h3><img src="/posts/46163/image-20240302232633388.png" class="" title="image-20240302232633388"><img src="/posts/46163/image-20240302232648244.png" class="" title="image-20240302232648244"><img src="/posts/46163/image-20240302232700200.png" class="" title="image-20240302232700200"><img src="/posts/46163/image-20240302232708528.png" class="" title="image-20240302232708528"><hr><h1 id="蓝桥杯相关"><a class="markdownIt-Anchor" href="#蓝桥杯相关"></a> 蓝桥杯相关</h1><h2 id="onewire底层"><a class="markdownIt-Anchor" href="#onewire底层"></a> OneWire底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"onewire.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"reg52.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit DQ = P1^<span class="number">4</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线内部延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_OneWire</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>  </span><br><span class="line">{</span><br><span class="line">t *= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线写操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_DS18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">DQ = dat&amp;<span class="number">0x01</span>;</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线读操作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_DS18B20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(DQ)</span><br><span class="line">{</span><br><span class="line">dat |= <span class="number">0x80</span>;</span><br><span class="line">}    </span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//DS18B20初始化</span></span><br><span class="line">bit <span class="title function_">init_ds18b20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  bit initflag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">12</span>);</span><br><span class="line">  DQ = <span class="number">0</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">80</span>);</span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">10</span>); </span><br><span class="line">    initflag = DQ;     </span><br><span class="line">  Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> initflag;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ds18b20温度读取时序"><a class="markdownIt-Anchor" href="#ds18b20温度读取时序"></a> DS18B20温度读取时序</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基于底层编写*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">ds18b20_read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> low,high;<span class="comment">//高八位，低八位，DS18B20温度数据是十六位二进制</span></span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0x44</span>);<span class="comment">//ds18b20开始温度转换</span></span><br><span class="line">    </span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0xbe</span>);<span class="comment">//ds18b20开始温度读取</span></span><br><span class="line">low=Read_DS18B20();</span><br><span class="line">high=Read_DS18B20();</span><br><span class="line"><span class="keyword">return</span>((high &lt;&lt; <span class="number">8</span> )| low) /<span class="number">16.0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单片机】IIC通信协议</title>
      <link href="/posts/19787/"/>
      <url>/posts/19787/</url>
      
        <content type="html"><![CDATA[<h3 id="一-单片机通信基础概念"><a class="markdownIt-Anchor" href="#一-单片机通信基础概念"></a> 一、单片机通信基础概念</h3><p><strong>全双工和半双工的区别：</strong></p><p>一、全双工（Full Duplex）通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。</p><p>二、半双工（Half Duplex）数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。</p><p><strong>MCU中常见的通信协议：</strong></p><img src="/posts/19787/5490adeb2e9d43dcae940a3b83a35b73.png" class="" title="在这里插入图片描述"><h3 id="二-推挽输出和开漏输出"><a class="markdownIt-Anchor" href="#二-推挽输出和开漏输出"></a> 二、推挽输出和开漏输出</h3><p><strong>推挽输出：</strong></p><blockquote><p>推挽输出结构是由两个MOS或者<a href="https://so.csdn.net/so/search?q=%E4%B8%89%E6%9E%81%E7%AE%A1&amp;spm=1001.2101.3001.7020">三极管</a>收到互补控制的信号控制，两个管子时钟一个在导通，一个在截止，如图1所示：</p></blockquote><img src="/posts/19787/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdHRsZV9veA==,size_16,color_FFFFFF,t_70.png" class="" title="图1 推挽输出结构"><p>特点:</p><ul><li>推挽输出可以输出高电平和低电平，在两种电平下都具有驱动能力。</li><li>相比于后面介绍的开漏输出，输出高电平时的驱动能力强很多</li><li>缺点：推挽输出不能实现" 线与"。</li></ul><p><strong>开漏输出：</strong></p><blockquote><p>常说的与推挽输出相对的就是开漏输出，抽象地说就是COMS反相器去掉了NMOS部分，PMOS管漏极输出，即开漏输出。PMOS管由高电平导通输出低电平，高电平没有驱动能力，需要借助“上拉电阻” (一般上拉电阻值较大，即弱上拉模式)<a href="https://blog.csdn.net/monkey_d_xue/article/details/129802153">什么是弱上拉?</a></p></blockquote><img src="/posts/19787/20201208174916607.png" class="" title="图4 OD"><h5 id="开漏输出的另一个优点在于可以实现线与功能所谓的线与指的是多个信号线直接连接在一起只有当所有信号全部为高电平时合在一起的总线为高电平只要有任意一个或者多个信号为低电平则总线为低电平这就是为什么后面用到iic通信当一个信号线为低电平要释放总线"><a class="markdownIt-Anchor" href="#开漏输出的另一个优点在于可以实现线与功能所谓的线与指的是多个信号线直接连接在一起只有当所有信号全部为高电平时合在一起的总线为高电平只要有任意一个或者多个信号为低电平则总线为低电平这就是为什么后面用到iic通信当一个信号线为低电平要释放总线"></a> <strong>开漏输出的另一个优点在于可以实现"线与"功能，所谓的"线与"指的是多个信号线直接连接在一起，只有当所有信号全部为高电平时，合在一起的总线为高电平；只要有任意一个或者多个信号为低电平，则总线为低电平(这就是为什么后面用到IIC通信,当一个信号线为低电平,要"释放总线")。</strong></h5><h5 id="而推挽输出就不行如果高电平和低电平连在一起会出现电流倒灌损坏器件"><a class="markdownIt-Anchor" href="#而推挽输出就不行如果高电平和低电平连在一起会出现电流倒灌损坏器件"></a> <strong>而推挽输出就不行，如果高电平和低电平连在一起，会出现电流倒灌，损坏器件</strong></h5><p><mark><strong>IIC为什么要开漏输出模式？</strong></mark></p><ul><li>输出端浮空，电平易受外界干扰，不稳定</li></ul><h3 id="三-i2c总线介绍"><a class="markdownIt-Anchor" href="#三-i2c总线介绍"></a> 三、I2C总线介绍：</h3><ul><li>I2C总线（Inter IC BUS）是由Philips公司开发的一种通用数据总线</li><li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</li><li>同步、半双工，带数据应答</li><li>通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度</li></ul><h3 id="四-i2c电路规范"><a class="markdownIt-Anchor" href="#四-i2c电路规范"></a> 四、I2C电路规范</h3><ul><li><p>所有I2C设备的SCL连在一起，SDA连在一起</p></li><li><p>设备的SCL和SDA均要配置成开漏输出模式</p></li><li><p>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</p></li><li><p>开漏输出和上拉电阻的共同作用实现了“线与”的功能，此设计主要是为了解决多机通信互相干扰的问题</p></li></ul><h3 id="五-i2c时序结构"><a class="markdownIt-Anchor" href="#五-i2c时序结构"></a> 五、I2C时序结构</h3><hr><img src="/posts/19787/1baf27e6e69a429394f21dd1a30900f1.png" class="" title="在这里插入图片描述"><img src="/posts/19787/115006bca35b4b2a8193651f437b65fc.png" class="" title="在这里插入图片描述"><img src="/posts/19787/a1ec063743594e96bb853e3fe69a3800.png" class="" title="在这里插入图片描述"><img src="/posts/19787/image-20240302223549490.png" class="" title="image-20240302223549490"><img src="/posts/19787/72b48d4af46f41ec9fe40720751e4a39.png" class="" title="在这里插入图片描述"><img src="/posts/19787/image-20240302225440107.png" class="" title="image-20240302225440107"><hr><p><strong>总结：IIC的 时序模块</strong></p><ul><li>起始条件</li><li>中止条件</li><li>发送一个字节</li><li>接收一个字节</li><li>接收应答</li><li>发送应答</li></ul><h1 id="蓝桥杯相关"><a class="markdownIt-Anchor" href="#蓝桥杯相关"></a> 蓝桥杯相关</h1><h2 id="iic模块"><a class="markdownIt-Anchor" href="#iic模块"></a> IIC模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iic.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME 5</span></span><br><span class="line"><span class="comment">// I2C总线内部延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        _nop_();</span><br><span class="line">    } <span class="keyword">while</span> (i--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线启动信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应答或非应答信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendAck</span><span class="params">(bit ackbit)</span></span><br><span class="line">{</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = ackbit;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答</span></span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    <span class="keyword">return</span> ackbit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线发送一个字节数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        <span class="keyword">if</span> (byt &amp; <span class="number">0x80</span>)</span><br><span class="line">            SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SDA = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        byt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线接收一个字节数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i, da;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        da &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SDA)</span><br><span class="line">            da |= <span class="number">1</span>;</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> da;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="adda转换模块"><a class="markdownIt-Anchor" href="#adda转换模块"></a> AD/DA转换模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">AD_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line">    </span><br><span class="line">    IIC_Start();       <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr); <span class="comment">//主机发送一个字节(要操作数据的地址),对应AD转换的通道</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    </span><br><span class="line">    IIC_Start(); <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x91</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    temp = IIC_RecByte(); <span class="comment">//从机送出数据,主机读入的数据用变量存储</span></span><br><span class="line">    IIC_SendAck(<span class="number">1</span>);<span class="comment">//主机发送应答,1表示完成数据的接收,从机停止发送数据</span></span><br><span class="line">    IIC_Stop();<span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DA_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>);<span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x41</span>); <span class="comment">//主机发送一个字节(要操作数据的地址),对应DA转换的通道</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(Data); <span class="comment">//主机送出DA输出的数据字节</span></span><br><span class="line">    IIC_WaitAck(); <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_Stop(); <span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="at24c02epprom模块"><a class="markdownIt-Anchor" href="#at24c02epprom模块"></a> AT24C02（EPPROM）模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环发送数据字节,存入AT24C02</span></span><br><span class="line">    {</span><br><span class="line">        IIC_SendByte(*EEPROM_String++);<span class="comment">//发送数据字节,要存入AT24C02的数据,字节个数为num</span></span><br><span class="line">        IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">        IIC_Delay(<span class="number">200</span>);<span class="comment">//延时200ms,保证从机(AT24C02能够完整收到数据)</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答  </span></span><br><span class="line"></span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA1</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环接收数据字节,存入EEPROM_String指向的地址</span></span><br><span class="line">    {</span><br><span class="line">        *EEPROM_String++=IIC_RecByte();<span class="comment">//指针移位读取数据到对应的地址中</span></span><br><span class="line">        <span class="keyword">if</span>(num)<span class="comment">//判断是否读取完数据</span></span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">0</span>);<span class="comment">//发送应答0,表示继续接收数据</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">1</span>);<span class="comment">//发送应答1,表示停止接收数据</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】AT24C02(EEPROM储存)</title>
      <link href="/posts/4799/"/>
      <url>/posts/4799/</url>
      
        <content type="html"><![CDATA[<p>2.26更新</p><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><h2 id="前置概念"><a class="markdownIt-Anchor" href="#前置概念"></a> #前置概念</h2><blockquote><p>所用外设：</p><p><mark>AT24C02(EEPROM储存) 使用IIC协议</mark></p></blockquote><h3 id="一-单片机通信协议本文以iic为重点"><a class="markdownIt-Anchor" href="#一-单片机通信协议本文以iic为重点"></a> 一、单片机通信协议（本文以IIC为重点）</h3><p><strong>全双工和半双工的区别：</strong></p><p>一、全双工（Full Duplex）通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。</p><p>二、半双工（Half Duplex）数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。</p><p><strong>MCU中常见的通信协议：</strong></p><img src="/posts/4799/5490adeb2e9d43dcae940a3b83a35b73.png" class="" title="在这里插入图片描述"><h3 id="二-推挽输出和开漏输出"><a class="markdownIt-Anchor" href="#二-推挽输出和开漏输出"></a> 二、推挽输出和开漏输出</h3><p><strong>推挽输出：</strong></p><ul><li>推挽输出可以输出高电平和低电平，在两种电平下都具有驱动能力。</li><li>相比于后面介绍的开漏输出，输出高电平时的驱动能力强很多</li><li>缺点：推挽输出不能实现" 线与"。</li></ul><p><strong>开漏输出：</strong></p><ul><li>常说的与推挽输出相对的就是开漏输出，抽象地说就是COMS反相器去掉了NMOS部分，PMOS管漏极输出，即开漏输出。PMOS管由高电平导通输出低电平，高电平没有驱动能力，需要借助“上拉电阻” (一般上拉电阻值较大，即弱上拉模式)<a href="https://blog.csdn.net/monkey_d_xue/article/details/129802153">什么是弱上拉?</a></li></ul><p><mark><strong>IIC为什么要开漏输出模式？</strong></mark></p><ul><li>输出端浮空，电平易受外界干扰，不稳定</li></ul><h3 id="三-i2c总线介绍"><a class="markdownIt-Anchor" href="#三-i2c总线介绍"></a> 三、I2C总线介绍：</h3><ul><li>I2C总线（Inter IC BUS）是由Philips公司开发的一种通用数据总线</li><li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</li><li>同步、半双工，带数据应答</li><li>通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度</li></ul><h3 id="四-i2c电路规范"><a class="markdownIt-Anchor" href="#四-i2c电路规范"></a> 四、I2C电路规范</h3><ul><li><p>所有I2C设备的SCL连在一起，SDA连在一起</p></li><li><p>设备的SCL和SDA均要配置成开漏输出模式</p></li><li><p>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</p></li><li><p>开漏输出和上拉电阻的共同作用实现了“线与”的功能，此设计主要是为了解决多机通信互相干扰的问题</p></li></ul><h3 id="五-i2c时序结构"><a class="markdownIt-Anchor" href="#五-i2c时序结构"></a> 五、I2C时序结构</h3><hr><img src="/posts/4799/1baf27e6e69a429394f21dd1a30900f1.png" class="" title="在这里插入图片描述"><img src="/posts/4799/115006bca35b4b2a8193651f437b65fc.png" class="" title="在这里插入图片描述"><img src="/posts/4799/a1ec063743594e96bb853e3fe69a3800.png" class="" title="在这里插入图片描述"><img src="/posts/4799/image-20240302223549490.png" class="" title="image-20240302223549490"><img src="/posts/4799/72b48d4af46f41ec9fe40720751e4a39.png" class="" title="在这里插入图片描述"><img src="/posts/4799/image-20240302225440107.png" class="" title="image-20240302225440107"><hr><p><strong>总结：IIC的工作模块</strong></p><ul><li>起始条件</li><li>中止条件</li><li>发送一个字节</li><li>接收一个字节</li><li>接收应答</li><li>发送应答</li></ul><hr><h2 id="存储器at24c02"><a class="markdownIt-Anchor" href="#存储器at24c02"></a> #存储器/AT24C02</h2><h3 id="一-ram和rom"><a class="markdownIt-Anchor" href="#一-ram和rom"></a> 一、RAM和ROM</h3><blockquote><p>**RAM : 易失性存储器 (高速存储） **</p><p><mark>单片机内RAM为中间数据存储器</mark></p></blockquote><ul><li>SRAM：静态RAM，电脑中的CPU，高速缓存，容量少，成本高</li><li>DRAM：动态RAM，使用电容存储，电容容值小，需要补电能，成本相较于SRAM更低，容量更大</li><li>掉电丢失</li></ul><blockquote><p><strong>ROM:非易失性存储器</strong></p><p><mark>单片机内ROM为指令存储器</mark></p></blockquote><ul><li>Mask ROM(掩膜ROM），只能读，不能写</li><li>PROM：可编程ROM，可以写，但是只能写入一次</li><li>EPROM：可擦除可编程ROM，可以编程，也可以清除（30分钟紫外线）</li><li>E2PROM： 电可擦除可编程ROM，5V电可擦除，掉电不丢失</li><li>Flash（闪存）：</li><li>硬盘、软盘、光盘等：磁介质、光信号</li></ul><hr><img src="/posts/4799/image-20240302224153992.png" class="" title="image-20240302224153992"><blockquote><p>单片机烧录的由来：早期通过编程储存数据，实际上是将特殊的二极管击穿，相当于“烧毁”（PROM）</p></blockquote><hr><h3 id="二-at24c02"><a class="markdownIt-Anchor" href="#二-at24c02"></a> 二、AT24C02</h3><img src="/posts/4799/image-20240302224329935.png" class="" title="image-20240302224329935"><img src="/posts/4799/7b07f23e9e7640f1b8db85bc873a9e36.png" class="" title="在这里插入图片描述"><h1 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> 代码部分</h1><h2 id="一-给at24c02写入数据"><a class="markdownIt-Anchor" href="#一-给at24c02写入数据"></a> 一、给AT24C02写入数据</h2><blockquote><p><strong>实现：AT24C02掉电不丢失</strong></p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LCD1602.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AT24C02.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Hello World"</span>);</span><br><span class="line"><span class="comment">//AT24C02_WriteByte(1,123);</span></span><br><span class="line">Delay(<span class="number">5</span>);<span class="comment">//AT21C02写一个序列的有效停止条件开始至内部写周期结束的时间</span></span><br><span class="line">Data=AT24C02_ReadByte(<span class="number">1</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,Data,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完善代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LCD1602.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AT24C02.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum;</span><br><span class="line"><span class="comment">//unsigned char Num; 这里要用到整型</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key();</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">Num--;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">AT24C02_WriteByte(<span class="number">0</span>,Num%<span class="number">256</span>);<span class="comment">//低八位</span></span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">1</span>,Num/<span class="number">256</span>);<span class="comment">//高八位</span></span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"Write OK"</span>);<span class="comment">//完成写入数据，提示</span></span><br><span class="line">Delay(<span class="number">1000</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"        "</span>);<span class="comment">//延时清除</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">4</span>)<span class="comment">//读的时候不需要Delay</span></span><br><span class="line">{</span><br><span class="line">Num=AT24C02_ReadByte(<span class="number">0</span>);</span><br><span class="line">Num|=AT24C02_ReadByte(<span class="number">1</span>)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"Read OK"</span>);<span class="comment">//完成读取数据，提示</span></span><br><span class="line">Delay(<span class="number">1000</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"        "</span>);<span class="comment">//延时清除</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为什么要写:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AT24C02_WriteByte(<span class="number">0</span>,Num%<span class="number">256</span>);<span class="comment">//低八位</span></span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">1</span>,Num/<span class="number">256</span>);<span class="comment">//高八位</span></span><br></pre></td></tr></tbody></table></figure><p>因为：int类型最高65535,对应的二进制为16位</p><h2 id="二-定时器扫描按键"><a class="markdownIt-Anchor" href="#二-定时器扫描按键"></a> 二、定时器扫描按键</h2><blockquote><p><strong>实验：定时器按键扫描，<mark>实现键值的数码管显示</mark></strong></p><p><strong>实验结果：如果直接让Nixie在判断键码后显示Keynum值，只能显示一瞬间，数码管的显示方式不同于LCD1602，所以需要一个缓存量Temp</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*错误写法*/</span><br><span class="line">Temp=Key();</span><br><span class="line">if(KeyNum)//显示结果只在一瞬间显示</span><br><span class="line">{</span><br><span class="line">Nixie(1,KeyNum);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*正确写法*/</span><br><span class="line">if(Temp)</span><br><span class="line">{</span><br><span class="line">KeyNum=Temp;</span><br><span class="line">}</span><br><span class="line">Nixie(1,KeyNum);</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>实验：定时器按键扫描实列2</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;REGX52.H&gt;</span><br><span class="line">#include "Key.h"</span><br><span class="line">#include "AT24C02.h"</span><br><span class="line">#include "Timer0.h"</span><br><span class="line">#include "Nixie.h"</span><br><span class="line">#include "Delay.h"</span><br><span class="line">unsigned char KeyNum;</span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line">Timer0_Init();</span><br><span class="line">while(1)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key();</span><br><span class="line">if(KeyNum)</span><br><span class="line">{</span><br><span class="line">Nixie_SetBuf(1,KeyNum);</span><br><span class="line">Nixie_SetBuf(2,KeyNum);</span><br><span class="line">Nixie_SetBuf(3,KeyNum);</span><br><span class="line">Delay(1000);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Timer0_Routine() interrupt 1 //中断子程序</span><br><span class="line">{</span><br><span class="line">static unsigned int T0Count1,T0Count2;//静态局部变量，保证退出函数之后不销毁</span><br><span class="line">TL0 = 0x66;//设置定时初始值</span><br><span class="line">TH0 = 0xFC;//设置定时初始值</span><br><span class="line">T0Count1++;//每次进入中断子程序，秒控制器自加一</span><br><span class="line">if(T0Count1&gt;=20)//每隔20ms，按键函数会被调用一次</span><br><span class="line">{</span><br><span class="line">T0Count1=0;</span><br><span class="line">Key_Loop(); </span><br><span class="line">}</span><br><span class="line">T0Count2++;</span><br><span class="line">if(T0Count2&gt;=2)</span><br><span class="line">{</span><br><span class="line"> T0Count2=0;</span><br><span class="line"> Nixie_Loop();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>实验结果：</strong></p><img src="/posts/4799/cd3ca4af62f4478d9e79c4a31087a160.jpeg" class="" title="请添加图片描述"><img src="/posts/4799/858d834686d84ec7b7dab21610cca5db.jpeg" class="" title="请添加图片描述"><p><strong><mark>这时，按下按键，数码管显示会延时一秒改变，可见，使用定时器扫描按键，不会被延时函数影响，相较于延时函数使单片机的工作更具有可靠性</mark></strong></p></blockquote><hr><blockquote><p><strong>秒表源代码：</strong><br>操作方式：</p><ul><li>按键1暂停</li><li>按键2清零</li><li>按键3通过AT24C02写入数据</li><li>按键4通过AT24C02读取数据</li></ul></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AT24C02.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Timer0.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Nixie.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Min,Sec,MiniSec;<span class="comment">//单位：分，秒，1/100s=10ms</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> RunFlag;<span class="comment">//启动暂定标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">P2_5=<span class="number">0</span>;<span class="comment">//蜂鸣器关闭</span></span><br><span class="line">Timer0_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key();</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RunFlag=!RunFlag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">Min=<span class="number">0</span>;Sec=<span class="number">0</span>;MiniSec=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">AT24C02_WriteByte(<span class="number">0</span>,Min);</span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">1</span>,Sec);</span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">2</span>,MiniSec);</span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">Min=AT24C02_ReadByte(<span class="number">0</span>);</span><br><span class="line">Sec=AT24C02_ReadByte(<span class="number">1</span>);</span><br><span class="line">MiniSec=AT24C02_ReadByte(<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Nixie_SetBuf(<span class="number">1</span>,Min/<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">2</span>,Min%<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">3</span>,<span class="number">11</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">4</span>,Sec/<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">5</span>,Sec%<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">6</span>,<span class="number">11</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">7</span>,MiniSec/<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">8</span>,MiniSec%<span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sec_Loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RunFlag)</span><br><span class="line">{</span><br><span class="line">MiniSec++;</span><br><span class="line"><span class="keyword">if</span>(MiniSec&gt;=<span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">MiniSec=<span class="number">0</span>;</span><br><span class="line">Sec++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Sec&gt;=<span class="number">60</span>)</span><br><span class="line">{</span><br><span class="line">Sec=<span class="number">0</span>;</span><br><span class="line">Min++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Min&gt;=<span class="number">60</span>)</span><br><span class="line">{</span><br><span class="line">Min=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 <span class="comment">//中断子程序</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count1,T0Count2,T0Count3;<span class="comment">//静态局部变量，保证退出函数之后不销毁</span></span><br><span class="line">TL0 = <span class="number">0x66</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T0Count1++;<span class="comment">//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"><span class="keyword">if</span>(T0Count1&gt;=<span class="number">20</span>)<span class="comment">//每隔20ms，按键函数会被调用一次</span></span><br><span class="line">{</span><br><span class="line">T0Count1=<span class="number">0</span>;</span><br><span class="line">Key_Loop(); </span><br><span class="line">}</span><br><span class="line">T0Count2++;</span><br><span class="line"><span class="keyword">if</span>(T0Count2&gt;=<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"> T0Count2=<span class="number">0</span>;</span><br><span class="line"> Nixie_Loop();</span><br><span class="line">}</span><br><span class="line">T0Count3++;</span><br><span class="line"><span class="keyword">if</span>(T0Count3&gt;=<span class="number">10</span>)<span class="comment">//10ms</span></span><br><span class="line">{</span><br><span class="line"> T0Count3=<span class="number">0</span>;</span><br><span class="line"> Sec_Loop();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>题外话: 6-1矩阵键盘密码锁：为什么密码不能设置为0开头?<br>因为0开头代表八进制,比如0123实际上对应的十进制数是83</p></blockquote><hr><h1 id="蓝桥杯stc15拓展"><a class="markdownIt-Anchor" href="#蓝桥杯stc15拓展"></a> #蓝桥杯(STC15)拓展</h1><p><strong>IIC通信底层</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iic.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME 5</span></span><br><span class="line"><span class="comment">// I2C总线内部延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        _nop_();</span><br><span class="line">    } <span class="keyword">while</span> (i--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线启动信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应答或非应答信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendAck</span><span class="params">(bit ackbit)</span></span><br><span class="line">{</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = ackbit;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答</span></span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    <span class="keyword">return</span> ackbit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线发送一个字节数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        <span class="keyword">if</span> (byt &amp; <span class="number">0x80</span>)</span><br><span class="line">            SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SDA = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        byt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线接收一个字节数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i, da;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        da &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SDA)</span><br><span class="line">            da |= <span class="number">1</span>;</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> da;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基于IIC底层，编写AT24C02函数模块*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 写入EEPROM</span></span><br><span class="line"><span class="comment">  * @param  需要写的字符串，写入的地址，写入数量</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">IIC_Start();<span class="comment">//发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line">    </span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//写入要储存的数据地址,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        IIC_SendByte(*EEPROM_String++);<span class="comment">//要存入AT24C02的数据,按位存</span></span><br><span class="line">        IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line">        IIC_Delay(<span class="number">200</span>);</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//停止IIC命令</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 读取EEPROM数据,替换需要读取字符串的数据</span></span><br><span class="line"><span class="comment">  * @param  需要读取的字符串，写入的地址，写入数量</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//写入要读取的数据地址,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答  </span></span><br><span class="line"></span><br><span class="line">    IIC_Start();<span class="comment">//发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA1</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        *EEPROM_String++=IIC_RecByte();<span class="comment">//按位取数据</span></span><br><span class="line">        <span class="keyword">if</span>(num)<span class="comment">//未取完数据</span></span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">1</span>);<span class="comment">//主机接收完数据，发送应答</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//停止IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[5]定时器控制PWM</title>
      <link href="/posts/32351/"/>
      <url>/posts/32351/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>配置结构体初始化输出比较单元</strong></p><p>void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);<br>void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);<br>void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);<br>void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);</p><p><strong>设置结构体初始值</strong></p><p>void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);</p><hr><p><strong>*配置强制输出</strong></p><p>void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);</p><p><strong>*配置影子寄存器</strong></p><p>void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);</p><p><strong>*配置快速使能</strong></p><p>xxxxxxxxxx&nbsp;typedef struct//typedef为成员列表提供了一个GPIO_InitTypeDef的名字{}GPIO_InitTypeDef;c</p><p><strong>*清除REF信号</strong></p><p>void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);<br>void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);<br>void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);<br>void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);</p><p><strong>配置输出极性</strong></p><blockquote><p>带N即高级定时器里互补通道的配置</p><p>OC4无互补通道</p><p>结构体初始化中也可以设置极性</p></blockquote><p>void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);<br>void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);<br>void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);<br>void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);<br>void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);<br>void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);<br>void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);</p><p>void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);<br>void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);</p><p><strong>单独修改输出使能参数</strong></p><p>void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);<br>void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);</p><p><strong>单独更改输出比较模式</strong></p><p>void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);</p><p><strong>单独更改CCR寄存器的函数</strong></p><p>void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);<br>void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);<br>void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);<br>void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);</p><p><strong>高级定时器，使能PWM，否则无法正常输出</strong></p><p>void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 定时器 </tag>
            
            <tag> PWM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【蓝桥杯单片机】程序模板设计</title>
      <link href="/posts/18220/"/>
      <url>/posts/18220/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p><strong>为了确保程序的准确性，总结了以下要点</strong></p><ol><li><mark>保证程序<strong>逻辑正确</strong>，其次再是“基于现象上”的正确，保证程序不会出现<strong>隐性问题</strong></mark></li><li><mark>在逻辑正确的前提下，保证数据读取的<strong>实时性</strong>，尽量优化代码执行效率</mark></li><li><mark>对数据的处理，在确保程序完全正常运行的前提下，最大限度地提高内存空间的<strong>利用率</strong></mark></li><li><mark>编写程序时，先写主框架，验证逻辑后，再依次验证其他模块</mark></li></ol><h1 id="数码管led模块工作原理"><a class="markdownIt-Anchor" href="#数码管led模块工作原理"></a> 数码管/LED模块工作原理</h1><p><mark>例如：数码管的段选/位选输出由两个74HC573锁存器控制</mark></p><img src="/posts/18220/image-20240301234539921.png" class="" title="image-20240301234539921"><blockquote><p><strong>锁存器送出数据的过程</strong></p><ol><li><p>P0输出8位数据</p></li><li><p>锁存器不使能，Q0~Q7为之前的数据，D0 ~ D7等待被送出</p></li><li><p>锁存器使能，数据送出，Q0~Q7即为P00 ~ P07的信号</p><p>注意：OE此处默认接GND</p></li></ol></blockquote><blockquote><p>**如何控制锁存器送出数据的顺序/使锁存器单个送出数据? **</p><ul><li>由一个或非门(U25)的四个输出控制四个锁存器的输入使能信号(Y7C~Y4C)</li></ul><img src="/posts/18220/image-20240301235153721.png" class="" title="image-20240301235153721"><ul><li>或非门的输入Y7 ~ Y4由一个译码器的输出控制，或非门的一端WR默认为低电平，那么这里的或非门就相当于一个输入为Y（n）的非门</li><li>其中74HC138(U24)的输入为P2口的P27~P25</li><li>通过推导可知，P27 ~ P25对应的三位二进制数即为后面会使能的锁存器，即111使得Y7=0，继而使得与非门输出Y7C=1，使得控制数码管段选的锁存器使能，送出数据。</li></ul><img src="/posts/18220/image-20240301235438487.png" class="" title="image-20240301235438487"><p>总结：P27~P25对应组成的二进制值即为使能的锁存器, LED/数码管/外设控制都是由锁存器控制，锁存器的输入共用<mark>P0口</mark>，这样通过多个锁存器，以及逻辑电路，节省了单片机的IO口</p></blockquote><h1 id="程序设计与分析"><a class="markdownIt-Anchor" href="#程序设计与分析"></a> 程序设计与分析</h1><h2 id="ct107d初始化"><a class="markdownIt-Anchor" href="#ct107d初始化"></a> CT107D初始化</h2><p><strong><mark>上电时，默认所有IO口为高电平，未被使能过的锁存器默认输出低电平，这会导致全部LED被点亮，有源蜂鸣器响(也是低电平有效),这就需要我们写一个程序初始化函数，关闭这些影响后续功能的现象</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief系统初始化函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">System_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*关闭LED*/</span></span><br><span class="line">P0 = <span class="number">0xFF</span>;</span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0x80</span>;    <span class="comment">//100X XXXX 锁存器Y4C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*关闭蜂鸣器*/</span></span><br><span class="line">P0=<span class="number">0x00</span>;<span class="comment">//锁存器输出会经过ULN2003，相当于反相器，预载值应为全低电平，这样最终输出的是高电平</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xA0</span>;    <span class="comment">//101X XXXX 锁存器Y5C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注意：锁存器输出会经过ULN2003，相当于(增强驱动能力)反相器，预载值(P2)应为全低电平，这样最终输出的是高电平。</strong></p><p>ULN2003：<a href="https://blog.csdn.net/qq_38410730/article/details/79787766">【常用芯片】ULN2003工作原理及中文资料（实例：STM32驱动28BYJ48步进电机）_uln2003驱动板说明书-CSDN博客</a></p><p><strong>由于单片机的引脚输出电流太低了，无法驱动大部分的设备。而ULN2003只相当于是一个开关，设备（负载）的供电是在外围电路上，而它能够通过微弱的单片机输出电流来控制外围电路的开闭。这某种程度上也可以说是，放大电流，增加驱动能力</strong></p><img src="/posts/18220/image-20240302002932910.png" class="" title="image-20240302002932910"><img src="/posts/18220/image-20240302003020482.png" class="" title="image-20240302003020482"><h2 id="led模块"><a class="markdownIt-Anchor" href="#led模块"></a> LED模块</h2><p>原理图</p><img src="/posts/18220/image-20240302002203560.png" class="" title="image-20240302002203560"><img src="/posts/18220/image-20240302002230011.png" class="" title="image-20240302002230011"><h2 id="led蜂鸣器继电器"><a class="markdownIt-Anchor" href="#led蜂鸣器继电器"></a> LED/蜂鸣器/继电器</h2><p>ps:~(0x01&lt;&lt;addr); 一定要加括号，否则会出现逻辑错误，如 0000 0001–&gt; 1110 1111 变成 1111 1110 – &gt; 1110 0000 ，最终经过一系列运行导致<mark>LED亮度降低</mark>(待考究)。</p><p>ps:<mark>一定要仔细注意逻辑，不能记忆性写程序！</mark></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  LED控制函数</span></span><br><span class="line"><span class="comment">  * @param  LED位，使能标志位</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_1;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old_1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Disp</span><span class="params">(<span class="type">unsigned</span> addr,enable)</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp=<span class="number">0x00</span>;   <span class="comment">// led暂存值</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old=<span class="number">0xFF</span>; <span class="comment">//上下两个变量应当赋不想等的初值</span></span><br><span class="line"><span class="keyword">if</span>(enable)<span class="comment">//LED使能时</span></span><br><span class="line">{</span><br><span class="line">temp|=<span class="number">0x01</span>&lt;&lt;addr; <span class="comment">//点亮第一位, 即 0x01&lt;&lt;0 temp=xxxx xxx1</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">temp&amp;=~(<span class="number">0x01</span>&lt;&lt;addr); <span class="comment">//熄灭第一位，即~ (0x01&lt;&lt;0) temp=xxxx xxx0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(temp!=temp_old) <span class="comment">// temp的值发生变化时（即外部调用此函数，想要改变LED的状态），才会对P0进行赋值操作，因为P0口负责多个锁存器的预载值，LED一般是静态的，不应该对P0进行反复赋值</span></span><br><span class="line">{</span><br><span class="line">P0=~temp; <span class="comment">//低电平有效，故按位取反</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0x80</span>;    <span class="comment">//100X XXXX 锁存器（Y4C使能）</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//000 x xxxx</span></span><br><span class="line">temp_old=temp;<span class="comment">//记录当前的led暂存值</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Beep</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">temp_1 |= <span class="number">0x40</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp_1 &amp;= ~<span class="number">0x40</span>;</span><br><span class="line"><span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">{</span><br><span class="line">P0 = temp_1;</span><br><span class="line">P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>; <span class="comment">//锁存器（Y5C使能）</span></span><br><span class="line">P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">temp_old_1 = temp_1;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Relay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">temp_1 |= <span class="number">0x10</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp_1 &amp;= ~<span class="number">0x10</span>;</span><br><span class="line"><span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">{</span><br><span class="line">P0 = temp_1;</span><br><span class="line">P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;<span class="comment">//锁存器（Y5C使能）</span></span><br><span class="line">P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">temp_old_1 = temp_1;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>PS:按位取或/按位取与，通常用于对单个BIT位进行操作</strong></p><h2 id="数码管模块"><a class="markdownIt-Anchor" href="#数码管模块"></a> 数码管模块</h2><p>ps:<strong><mark>蓝桥杯单片机开发板使用的是共阳极数码管，注意段码和位码，以及Disp函数的逻辑</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//共阳极数码管</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_seg[] = <span class="comment">//段码</span></span><br><span class="line">{</span><br><span class="line"><span class="number">0xc0</span>, <span class="comment">//0</span></span><br><span class="line"><span class="number">0xf9</span>, <span class="comment">//1</span></span><br><span class="line"><span class="number">0xa4</span>, <span class="comment">//2</span></span><br><span class="line"><span class="number">0xb0</span>, <span class="comment">//3</span></span><br><span class="line"><span class="number">0x99</span>, <span class="comment">//4</span></span><br><span class="line"><span class="number">0x92</span>, <span class="comment">//5</span></span><br><span class="line"><span class="number">0x82</span>, <span class="comment">//6</span></span><br><span class="line"><span class="number">0xf8</span>, <span class="comment">//7</span></span><br><span class="line"><span class="number">0x80</span>, <span class="comment">//8</span></span><br><span class="line"><span class="number">0x90</span>, <span class="comment">//9</span></span><br><span class="line"><span class="number">0xFF</span>, <span class="comment">//熄灭&lt;10&gt;</span></span><br><span class="line"><span class="number">0x88</span>, <span class="comment">//A &lt;11&gt;</span></span><br><span class="line"><span class="number">0x83</span>, <span class="comment">//b&lt;12&gt;</span></span><br><span class="line"><span class="number">0xc6</span>, <span class="comment">//C&lt;13&gt;</span></span><br><span class="line"><span class="number">0xa1</span>, <span class="comment">//d&lt;14&gt;</span></span><br><span class="line"><span class="number">0x86</span>, <span class="comment">//E&lt;15&gt;</span></span><br><span class="line"><span class="number">0x8e</span>  <span class="comment">//F&lt;16&gt;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Location[] =  <span class="comment">//位码</span></span><br><span class="line">{</span><br><span class="line"><span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x02</span>,</span><br><span class="line"><span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x08</span>,</span><br><span class="line"><span class="number">0x10</span>,</span><br><span class="line"><span class="number">0x20</span>,</span><br><span class="line"><span class="number">0x40</span>,</span><br><span class="line"><span class="number">0x80</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief数码管点亮函数</span></span><br><span class="line"><span class="comment">  * @param  位选，段选，小数点</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,Seg,Point)</span></span><br><span class="line">{</span><br><span class="line">P0=<span class="number">0xFF</span>; <span class="comment">//段码，数码管熄灭，消影</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xE0</span>;    <span class="comment">//111X XXXX 锁存器 Y7C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//关闭锁存器</span></span><br><span class="line"></span><br><span class="line">P0=Nixie_Location[Location];<span class="comment">//位选预载值</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xC0</span>;    <span class="comment">//101X XXXX 锁存器 Y5C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//关闭锁存器</span></span><br><span class="line"></span><br><span class="line">P0=Nixie_seg[Seg];<span class="comment">//段选预载值</span></span><br><span class="line">    <span class="comment">//这里的Point即为数码管‘点’的使能位，实质上‘点’对应的是数码管段码的BIT7，最高位</span></span><br><span class="line"><span class="keyword">if</span>(Point){P0 &amp;= <span class="number">0x7F</span>;}    <span class="comment">//错误写法：P0|=0x80; 共阳极数码管！，逻辑0点亮！</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xE0</span>;   <span class="comment">//111X XXXX 锁存器 Y7C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//关闭锁存器</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定时器模块"><a class="markdownIt-Anchor" href="#定时器模块"></a> 定时器模块</h2><p><strong><mark>注意，STC15单片机的定时器是支持自动重装载的，这里不需要在中断子程序中赋初值，否则会出现定时器定时值的混乱</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief定时器初始化</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0x7F</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0xF0</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL0 = <span class="number">0x18</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF0 = <span class="number">0</span>;<span class="comment">//清除TF0标志</span></span><br><span class="line">TR0 = <span class="number">1</span>;<span class="comment">//定时器0开始计时</span></span><br><span class="line">ET0 = <span class="number">1</span>;<span class="comment">//定时器中断0打开</span></span><br><span class="line">EA  = <span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">PT0 = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void Timer0_Server(void)  interrupt 1</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="按键模块"><a class="markdownIt-Anchor" href="#按键模块"></a> 按键模块</h2><p>ps:<strong><mark>键值读取函数中定义局部变量temp一定要赋初值！！！否则会出现在没有按键按下时键值读取异常值的情况。</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief矩阵按键读取函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/*矩阵按键模式*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp=<span class="number">0</span>;<span class="comment">//局部变量初始化为0</span></span><br><span class="line">    ET0=<span class="number">0</span>;<span class="comment">//串口使用屏蔽</span></span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">4</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">5</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">6</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">7</span>;}</span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">8</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">9</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">10</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">11</span>;}</span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">12</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">13</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">14</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">15</span>;}</span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">16</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">17</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">18</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">19</span>;}</span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//串口使用打开</span></span><br><span class="line">    P3=<span class="number">0xff</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief独立按键读取函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/*独立按键模式*/</span></span><br><span class="line"><span class="comment">/*unsigned char Key_Read(void)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(P33==0){temp=4;}</span></span><br><span class="line"><span class="comment">if(P32==0){temp=5;}</span></span><br><span class="line"><span class="comment">if(P31==0){temp=6;}</span></span><br><span class="line"><span class="comment">if(P30==0){temp=7;}</span></span><br><span class="line"><span class="comment">return temp;</span></span><br><span class="line"><span class="comment">}*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="主函数模块"><a class="markdownIt-Anchor" href="#主函数模块"></a> 主函数模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信息（数码管）显示处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*其他信息处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行程序模块</span></span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line">Nixie_Proc();</span><br><span class="line">LED_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="超声波模块使用pca"><a class="markdownIt-Anchor" href="#超声波模块使用pca"></a> 超声波模块（使用PCA）</h2><p><strong>ps:<mark>返回值的单位是cm,可以根据题目要求更改底层</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ultrasound.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"intrins.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit Tx = P1^<span class="number">0</span>;</span><br><span class="line">sbit Rx = P1^<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">()</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">38</span>;</span><br><span class="line"><span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">()</span> <span class="comment">//超声波模块初始化</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">Tx = <span class="number">1</span>;</span><br><span class="line">Delay12us();</span><br><span class="line">Tx = <span class="number">0</span>;</span><br><span class="line">Delay12us();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    CCON =  <span class="number">0x00</span>;<span class="comment">// 初始化PCA控制寄存器，PCA定时器停止，清除CF</span></span><br><span class="line">    CH = CL = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    EA=<span class="number">0</span>;<span class="comment">//总中断关闭</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">    CR = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (CF == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    CR = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(CF == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = CH &lt;&lt; <span class="number">8</span> | CL;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        CF = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="串口模块putchar重定向"><a class="markdownIt-Anchor" href="#串口模块putchar重定向"></a> 串口模块（putchar重定向）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* putchar重定向 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">putchar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">SBUF= ch;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line"><span class="keyword">return</span> (ch);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="串口中断服务程序"><a class="markdownIt-Anchor" href="#串口中断服务程序"></a> 串口中断服务程序</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart_Server</span><span class="params">()</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI == <span class="number">1</span> &amp;&amp; Uart_RecData_Index &lt;<span class="number">8</span>)</span><br><span class="line">    {</span><br><span class="line">        Uart_RecData[Uart_RecData_Index++]=SBUF;</span><br><span class="line">        RI=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Uart_RecData_Index == <span class="number">6</span>)</span><br><span class="line">    {</span><br><span class="line">        Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定时器使用注意事项"><a class="markdownIt-Anchor" href="#定时器使用注意事项"></a> 定时器使用注意事项：</h2><ul><li>定时器0：主要工作定时器.NE555方波发生器</li><li>定时器1：一般用于PWM,使用NE555时,主要定时器选为定时器1</li><li>定时器2：串口中断1绑定</li><li>PCA：用于超声波模块</li></ul><h1 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> #补充</h1><h2 id="一-iic模块"><a class="markdownIt-Anchor" href="#一-iic模块"></a> 一、IIC模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  程序说明: IIC总线驱动程序</span></span><br><span class="line"><span class="comment">  软件环境: Keil uVision 4.10 </span></span><br><span class="line"><span class="comment">  硬件环境: CT107单片机综合实训平台 8051，12MHz</span></span><br><span class="line"><span class="comment">  日    期: 2011-8-9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iic.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"intrins.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Photo_Res_Channel 0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Adj_Res_Channel 0x43</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//总线引脚定义</span></span><br><span class="line">sbit SDA = P2^<span class="number">1</span>;  <span class="comment">/* 数据线 */</span></span><br><span class="line">sbit SCL = P2^<span class="number">0</span>;  <span class="comment">/* 时钟线 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">do</span>{_nop_();}</span><br><span class="line">    <span class="keyword">while</span>(i--);        </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay200us</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span>;</span><br><span class="line">j = <span class="number">82</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//总线启动条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//总线停止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应答</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendAck</span><span class="params">(bit ackbit)</span></span><br><span class="line">{</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = ackbit;  <span class="comment">// 0：应答，1：非应答</span></span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>; </span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答</span></span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL  = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    <span class="keyword">return</span> ackbit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过I2C总线发送数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL  = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        <span class="keyword">if</span>(byt &amp; <span class="number">0x80</span>) SDA  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> SDA  = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        byt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    SCL  = <span class="number">0</span>;  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//从I2C总线上接收数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i, da;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    {   </span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">IIC_Delay(DELAY_TIME);</span><br><span class="line">da &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(SDA) da |= <span class="number">1</span>;</span><br><span class="line">SCL = <span class="number">0</span>;</span><br><span class="line">IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> da;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于iic的adda转换"><a class="markdownIt-Anchor" href="#基于iic的adda转换"></a> 基于IIC的AD/DA转换</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">AD_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line">    </span><br><span class="line">    IIC_Start();       <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr); <span class="comment">//主机发送一个字节(要操作数据的地址),对应AD转换的通道</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    </span><br><span class="line">    IIC_Start(); <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x91</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    temp = IIC_RecByte(); <span class="comment">//从机送出数据,主机读入的数据用变量存储</span></span><br><span class="line">    IIC_SendAck(<span class="number">1</span>);<span class="comment">//主机不发送应答,1表示完成数据的接收,从机停止发送数据</span></span><br><span class="line">    IIC_Stop();<span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DA_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>);<span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x41</span>); <span class="comment">//主机发送一个字节(要操作数据的地址),对应DA转换的通道</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(Data); <span class="comment">//主机送出DA输出的数据字节</span></span><br><span class="line">    IIC_WaitAck(); <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_Stop(); <span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于iic的at24c02epprom储存器"><a class="markdownIt-Anchor" href="#基于iic的at24c02epprom储存器"></a> 基于IIC的AT24C02(EPPROM)储存器</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环发送数据字节,存入AT24C02</span></span><br><span class="line">    {</span><br><span class="line">        IIC_SendByte(*EEPROM_String++);<span class="comment">//发送数据字节,要存入AT24C02的数据,字节个数为num</span></span><br><span class="line">        IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">        IIC_Delay(<span class="number">200</span>);<span class="comment">//延时200ms,保证从机(AT24C02能够完整收到数据)</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答  </span></span><br><span class="line"></span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA1</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环接收数据字节,存入EEPROM_String指向的地址</span></span><br><span class="line">    {</span><br><span class="line">        *EEPROM_String++=IIC_RecByte();<span class="comment">//指针移位读取数据到对应的地址中</span></span><br><span class="line">        <span class="keyword">if</span>(num)<span class="comment">//判断是否读取完数据</span></span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">0</span>);<span class="comment">//发送应答0,表示继续接收数据</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">1</span>);<span class="comment">//发送应答1,表示停止接收数据</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二-onewire模块"><a class="markdownIt-Anchor" href="#二-onewire模块"></a> 二、onewire模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"onewire.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"reg52.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit DQ = P1^<span class="number">4</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线内部延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_OneWire</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>  </span><br><span class="line">{</span><br><span class="line">t *= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线写操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_DS18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">DQ = dat&amp;<span class="number">0x01</span>;</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线读操作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_DS18B20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(DQ)</span><br><span class="line">{</span><br><span class="line">dat |= <span class="number">0x80</span>;</span><br><span class="line">}    </span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//DS18B20初始化</span></span><br><span class="line">bit <span class="title function_">init_ds18b20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  bit initflag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">12</span>);</span><br><span class="line">  DQ = <span class="number">0</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">80</span>);</span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">10</span>); </span><br><span class="line">    initflag = DQ;     </span><br><span class="line">  Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> initflag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">rd_temperature</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> low,high;</span><br><span class="line">init_ds18b20();<span class="comment">//初始化ds18b20;</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//跳过ROM指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0x44</span>);<span class="comment">//开始温度转换</span></span><br><span class="line"></span><br><span class="line">init_ds18b20();<span class="comment">//初始化ds18b20;</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//跳过ROM指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0xBe</span>);<span class="comment">//开始温度读取</span></span><br><span class="line"></span><br><span class="line">low = Read_DS18B20();</span><br><span class="line">high = Read_DS18B20();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (high &lt;&lt; <span class="number">8</span> | low)/<span class="number">16.0</span>;<span class="comment">//二进制转十进制</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ds1302模块"><a class="markdownIt-Anchor" href="#ds1302模块"></a> #DS1302模块</h2><h3 id="ds1302时钟芯片底层"><a class="markdownIt-Anchor" href="#ds1302时钟芯片底层"></a> DS1302（时钟芯片）底层</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ds1302.h"</span></span></span><br><span class="line">sbit SCK=P1^<span class="number">7</span>;</span><br><span class="line">sbit SDA=P2^<span class="number">3</span>;</span><br><span class="line">sbit RST = P1^<span class="number">3</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302</span><span class="params">(<span class="type">unsigned</span>  <span class="type">char</span> temp)</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)     </span><br><span class="line">{ </span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">SDA=temp&amp;<span class="number">0x01</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">SCK=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302_Byte</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address,<span class="type">unsigned</span> <span class="type">char</span> dat )</span>     </span><br><span class="line">{</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>; _nop_();  </span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> Write_Ds1302(dat);</span><br><span class="line"> RST=<span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_Ds1302_Byte</span> <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address )</span></span><br><span class="line">{</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> i,temp=<span class="number">0x00</span>;</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>;_nop_();</span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) </span><br><span class="line"> {</span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(SDA)</span><br><span class="line"> temp|=<span class="number">0x80</span>;</span><br><span class="line"> SCK=<span class="number">1</span>;</span><br><span class="line">} </span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line">SCK=<span class="number">1</span>;_nop_();</span><br><span class="line">SDA=<span class="number">0</span>;_nop_();</span><br><span class="line">SDA=<span class="number">1</span>;_nop_();</span><br><span class="line"><span class="keyword">return</span> (temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写"><a class="markdownIt-Anchor" href="#基于底层的时序编写"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Set_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x00</span>);<span class="comment">//关闭写保护</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x84</span>-i*<span class="number">2</span>,ucRtc[i]);<span class="comment">//给ds1302写入数据,0x84时 0x82分 0x80秒</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x80</span>);<span class="comment">//打开写保护</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">ucRtc[i] = Read_Ds1302_Byte(<span class="number">0x85</span>-i*<span class="number">2</span>);<span class="comment">//读取ds1302的数据</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x00</span>);<span class="comment">//关闭写保护</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8c</span>,ucDate[<span class="number">0</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x88</span>,ucDate[<span class="number">1</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x86</span>,ucDate[<span class="number">2</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x80</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">ucDate[<span class="number">0</span>] = Read_Ds1302_Byte(<span class="number">0x8d</span>);</span><br><span class="line">ucDate[<span class="number">1</span>] = Read_Ds1302_Byte(<span class="number">0x89</span>);</span><br><span class="line">ucDate[<span class="number">2</span>] = Read_Ds1302_Byte(<span class="number">0x87</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li><p><strong>程序模板使用到的模块：</strong></p><ul><li>系统初始化、按键、数码管、LED（继电器、蜂鸣器）</li><li>串口(定时器2)、超声波(PCA)，NE555(定时器0（计数器模式))，定时器1</li><li>IIC（AD/DA转换、AT24C02存储器）、OneWire（ds18b20温度读取）</li><li>DS1302时钟芯片</li></ul></li><li><p><strong>单片机程序设计，模块化，可读性强，执行效率高，占用储存空间小，以及契合硬件电路底层原理是最重要的思路</strong></p></li><li><p><strong>后续设计功能更复杂，更强的单片机/嵌入式系统时，就要拓展相关的知识面，进一步提升对单片机/各种芯片/电路的认识。</strong></p></li></ul><h1 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h1><h2 id="eeprom存入多字节大小变量"><a class="markdownIt-Anchor" href="#eeprom存入多字节大小变量"></a> EEPROM存入多字节大小变量</h2><h3 id="方法一-多个变量值传递"><a class="markdownIt-Anchor" href="#方法一-多个变量值传递"></a> 方法一 多个变量值传递</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> change_counter=<span class="number">0</span>;<span class="comment">//参数更改计次</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> EEPROM_Data[<span class="number">2</span>]={<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//EEPROM流数组，存储int类型</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EEPROM_Read(EEPROM_Data,<span class="number">0x00</span>,<span class="number">2</span>);<span class="comment">//EEPROM初始化读取</span></span><br><span class="line">change_counter=EEPROM_Data[<span class="number">0</span>] | EEPROM_Data[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>;<span class="comment">//将EEPROM数据流转存入整型变量</span></span><br></pre></td></tr></tbody></table></figure><p><strong><mark>缺点：浪费了内存空间，逻辑繁琐</mark></strong></p><h3 id="方法二-联合体"><a class="markdownIt-Anchor" href="#方法二-联合体"></a> 方法二 联合体</h3><p><strong><mark>使用联合体，联合体内的元素公用一段内存空间。指定的变量只有在调用时才会使用内存空间，节省资源同时逻辑简洁直观</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> change_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Temp[<span class="number">2</span>];</span><br><span class="line">}EEPROM_DATA;</span><br></pre></td></tr></tbody></table></figure><p><strong>对比</strong></p><blockquote><p><strong>方法一</strong></p><blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.change_counter++;<span class="comment">//参数改变次数加一</span></span><br><span class="line"><span class="comment">/*将整数型变量存入数组中*/</span></span><br><span class="line">EEPROM_Data[<span class="number">0</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(change_counter &amp; <span class="number">0xFF</span>);<span class="comment">//低八位写入</span></span><br><span class="line">EEPROM_Data[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(change_counter&gt;&gt;<span class="number">8</span> &amp; <span class="number">0xFF</span>);<span class="comment">//高八位写入</span></span><br><span class="line">EEPROM_Write(&amp;EEPROM_Data[<span class="number">0</span>],<span class="number">0x00</span>,<span class="number">2</span>);<span class="comment">//将EEPROM数据流存入AT24C02</span></span><br></pre></td></tr></tbody></table></figure></blockquote><p><strong>方法二</strong></p><blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EEPROM_Data.change_counter++;</span><br><span class="line">EEPROM_Write(&amp;EEPROM_Data.Temp[<span class="number">0</span>],<span class="number">0x00</span>,<span class="number">2</span>);<span class="comment">//将EEPROM数据流写入AT24C02</span></span><br></pre></td></tr></tbody></table></figure></blockquote></blockquote><h2 id="eeprom"><a class="markdownIt-Anchor" href="#eeprom"></a> EEPROM</h2><p><strong>EEPROM读取数据需要在开中断之前，本身时序较长，容易被打断</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">EEPROM_Read(EEPROM_Data_T.Temp,<span class="number">0x00</span>,<span class="number">2</span>);<span class="comment">//EEPROM</span></span><br><span class="line"></span><br><span class="line">System_Init();<span class="comment">//系统初始化，关闭LED、继电器、蜂鸣器                                                                         </span></span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">Uart1_Init();<span class="comment">//串口初始化</span></span><br><span class="line">Ultrasound_Init();<span class="comment">//超声波初始化</span></span><br><span class="line">rd_temperature();<span class="comment">//读取上电的默认温度</span></span><br><span class="line">Delay(<span class="number">750</span>);<span class="comment">//延时750ms,等待温度读取正常稳定</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line">Nixie_Proc();</span><br><span class="line">LED_Proc();</span><br><span class="line">Uart_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
          <category> 蓝桥杯 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> STC15 </tag>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】[1] 文件寄存器RAM</title>
      <link href="/posts/52613/"/>
      <url>/posts/52613/</url>
      
        <content type="html"><![CDATA[<h2 id="课堂记录"><a class="markdownIt-Anchor" href="#课堂记录"></a> 课堂记录</h2><img src="/posts/52613/image-20240229103029035.png" class="" title="image-20240229103029035"><h2 id="配置位"><a class="markdownIt-Anchor" href="#配置位"></a> 配置位</h2><img src="/posts/52613/image-20240229205150184.png" class="" title="image-20240229205150184">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> PIC单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PIC单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[4]定时器中断</title>
      <link href="/posts/57601/"/>
      <url>/posts/57601/</url>
      
        <content type="html"><![CDATA[<ul><li><p>打开RCC内部时钟</p></li><li><p>选择时基单元时钟源</p></li><li><p>配置时基单元</p></li><li><p>配置输出中断控制，允许更新中断输出到NVIC</p></li><li><p>配置NVIC，打开定时器通道，并分配一个优先级</p></li><li><p>运行控制</p></li></ul><h1 id="相关函数"><a class="markdownIt-Anchor" href="#相关函数"></a> 相关函数</h1><blockquote><ul><li>恢复缺省配置</li></ul><p>TIM_DeInit(TIM_TypeDef* TIMx);</p><ul><li>时基单元初始化</li></ul><p>TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</p><blockquote><p>TIMx：选择定时器</p><p>TIM_TimeBaseInitStruct：结构体，定时器有关的配置</p></blockquote><ul><li>结构体初始化</li></ul><p>TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</p><ul><li>使能计数器，对应<mark>运行控制</mark></li></ul><p>TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);</p><ul><li>中断输出使能控制</li></ul><p>TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState); 使能中断输出</p><blockquote><p>uint16_t TIM 选择中断输出</p><p>NewState：使能状态</p></blockquote><p><strong>时基单元的时钟选择部分函数：</strong></p><ul><li>选择内部时钟</li></ul><p>void TIM_InternalClockConfig(TIM_TypeDef* TIMx);</p><ul><li>选择ITRX其他定时器的时钟</li></ul><p>void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><blockquote><p>TIMx 选择要配置的寄存器</p><p>TIM_InputTriggerSource 选择接入的寄存器</p></blockquote><ul><li>选择TIX捕获通道的时钟</li></ul><p>void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,uint16_t TIM_ICPolarity, uint16_t ICFilter);</p><blockquote><p>TIM_TIxExternalCLKSource,uint16_t  选择TIX具体的引脚</p><p>TIM_ICPolarity 输入的极性</p><p>ICFilter 滤波器</p></blockquote><ul><li>选择ETR通过外部时钟模式1输入的时钟</li></ul><p>void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,  uint16_t ExtTRGFilter);</p><blockquote><p>TIM_ExtTRGPrescaler 可以对ETR外部时钟再次分频</p><p>ExtTRGPolarity/ExtTRGFilter 极性/滤波器</p></blockquote><ul><li>选择ETR通过外部时钟模式1输入的时钟</li></ul><p>void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);</p><blockquote><p>同TIM_ETRClockMode1Config(</p></blockquote><ul><li>单独配置ETR引脚的预分频器、极性、滤波器这些参数</li></ul><p>void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,<br>uint16_t ExtTRGFilter);</p></blockquote><p><strong>初始化后，像自动重装值和预分频值等等，可能需要修改，有一些函数可以单独修改这些参数</strong></p><blockquote><ul><li>单独修改预分频值</li></ul><p>void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);</p><blockquote><p>uint16_t Prescaler 要写入的预分频值</p><p>PSCReloadMode 写入的模式</p></blockquote><ul><li>改变计数器的计数模式</li></ul><p>void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);</p><blockquote><p>TIM_CounterMode 计数器的计数模式</p></blockquote><ul><li>自动重装器<mark>预装功能</mark>配置</li></ul><p>void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);</p><blockquote><p>NewState 使能状态</p></blockquote><ul><li>给计数器写入一个值</li></ul><p>xxxxxxxxxx&nbsp;python script_name.py --train_data_dir “path/to/train_data” --test_data_dir “path/to/test_data” --img_height 128 --img_width 128 --batch_size 64 --epochs 15python</p><ul><li>给自动重装器写入一个值</li></ul><p>void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);</p><ul><li>获取当前计数器的值</li></ul><p>uint16_t TIM_GetCounter(TIM_TypeDef* TIMx);</p><ul><li>获取当前预分频器的值</li></ul><p>uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);</p><ul><li>获取/清除标志位相关函数</li></ul><p>FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);<br>void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);<br>ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);<br>void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);</p></blockquote><h2 id="编写定时器初始化框架"><a class="markdownIt-Anchor" href="#编写定时器初始化框架"></a> 编写定时器初始化框架</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="滤波原理"><a class="markdownIt-Anchor" href="#滤波原理"></a> 滤波原理</h2><img src="/posts/57601/image-20240229000125982.png" class="" title="image-20240229000125982"><ul><li><p>在一个固定的时钟频率f下进行采样，如果连续N个采样点都是相同的电平，说明信号稳定，如果N个采样点抖动，就让输出保持不变，这样就能保证输出信号在一定程度上被滤波保护。</p></li><li><p>采样点数越多，滤波效果越好，但是同时信号延迟越大</p></li><li><p>采样频率的来源？</p><ul><li>由内部时钟直接而来</li><li>也可是内部时钟+一个时钟分频而来</li></ul></li></ul><p><strong>TIM_Clock_Division_CKD的取值</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define TIM_CKD_DIV1                       ((uint16_t)0x0000)//1分频</span><br><span class="line">#define TIM_CKD_DIV2                       ((uint16_t)0x0100)</span><br><span class="line">#define TIM_CKD_DIV4                       ((uint16_t)0x0200)</span><br></pre></td></tr></tbody></table></figure><h2 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> 代码部分</h2><h3 id="一-定时器中断内部时钟"><a class="markdownIt-Anchor" href="#一-定时器中断内部时钟"></a> 一、定时器中断（内部时钟）</h3><p><strong>定时器底层程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line"><span class="comment">/*时基单元关键寄存器*/</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">7200</span> - <span class="number">1</span>;<span class="comment">//ARR ， 对72MHZ进行7200分频 也就是10MHZ</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">10000</span> - <span class="number">1</span>;<span class="comment">//PSC，计数器重装载值，10000次清零,控制ARR和PSC可以控制计数频率</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"><span class="comment">//1--&gt;注意：更新中断和更新事件同时发生，初始化会立刻进入中断</span></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//2--&gt;手动清理中断标志位</span></span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//中断配置，选择更新中断,使能</span></span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel= TIM2_IRQn;<span class="comment">//定时器通道设置，选择TIM2_IRQn</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd= ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//定时器初始化</span></span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断服务程序模板</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);//清除标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Encoder.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Num;<span class="comment">//定义一个16位的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Num:"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"CNT:"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);<span class="comment">//计时的值</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);<span class="comment">//CNT计数器的值</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)<span class="comment">//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);<span class="comment">//清除标志位</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二-外部时钟"><a class="markdownIt-Anchor" href="#二-外部时钟"></a> 二、外部时钟</h3><p><strong>定时器底层程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA时钟</span></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIM_InternalClockConfig(TIM2);//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line">TIM_ETRClockMode2Config(TIM2,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted,<span class="number">0x00</span>);<span class="comment">//通过ETR引脚的外部时钟模式2配置</span></span><br><span class="line"><span class="comment">//定时器选择    不需要分频    外部触发的极性：不反相     外部触发滤波器,决定F和N，这里不需要滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line"><span class="comment">/**时基单元关键寄存器**/</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">1</span> - <span class="number">1</span>;<span class="comment">//ARR ， 对72MHZ进行7200分频 也就是10MHZ</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">10</span> - <span class="number">1</span>;<span class="comment">//PSC，计数器重装载值，10000次清零,控制ARR和PSC可以控制计数频率</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"><span class="comment">//1--&gt;注意：更新中断和更新事件同时发生，初始化会立刻进入中断</span></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//2--&gt;手动清理中断标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//中断配置，选择更新中断,使能</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel= TIM2_IRQn;<span class="comment">//定时器通道设置，选择TIM2_IRQn</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd= ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//NVIC初始化</span></span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//CNT值封装函数</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">Timer_GetCounter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> TIM_GetCounter(TIM2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);//清除标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Encoder.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Num=<span class="number">0</span>;<span class="comment">//定义一个16位的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Num:"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"CNT:"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);<span class="comment">//计时的值</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Timer_GetCounter(),<span class="number">5</span>);<span class="comment">//CNT计数器的值</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)<span class="comment">//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);<span class="comment">//清除标志位</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><mark><strong>什么时候可以使用浮空输入？</strong></mark></p><p>如果外部输入的信号功率很小时，内部的上拉电阻可能影响到外部输入信号，这时候就使用浮空输入模式，防止影响外部输入电平。</p><h1 id="高级定时器"><a class="markdownIt-Anchor" href="#高级定时器"></a> 高级定时器</h1><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p><strong>没有初始化重复计数器造成定时器计数出现计数缓慢，被其他中断程序干扰的现象</strong></p><p><strong>解决方法：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在,</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[3]EXTI外部中断</title>
      <link href="/posts/44123/"/>
      <url>/posts/44123/</url>
      
        <content type="html"><![CDATA[<h1 id="stm32的中断结构"><a class="markdownIt-Anchor" href="#stm32的中断结构"></a> stm32的中断结构</h1><img src="/posts/44123/image-20240228002139630.png" class="" title="image-20240228002139630"><h2 id="nvic"><a class="markdownIt-Anchor" href="#nvic"></a> NVIC</h2><p><a href="https://blog.csdn.net/liuqi3256797/article/details/89891621">STM32中的NVIC详解_stm32 nvic-CSDN博客</a></p><h2 id="exti"><a class="markdownIt-Anchor" href="#exti"></a> EXTI</h2><img src="/posts/44123/image-20240228002339511.png" class="" title="image-20240228002339511"><img src="/posts/44123/image-20240228002507136.png" class="" title="image-20240228002507136"><h2 id="一-对射式红外传感器计次"><a class="markdownIt-Anchor" href="#一-对射式红外传感器计次"></a> 一、对射式红外传感器计次</h2><h3 id="红外传感器底层程序"><a class="markdownIt-Anchor" href="#红外传感器底层程序"></a> 红外传感器底层程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count;<span class="comment">//全局变量，用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：计数传感器初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*外部中断的定义*/</span></span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);<span class="comment">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO初始化*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//将PB14引脚初始化为上拉输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*AFIO选择中断引脚*/</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);<span class="comment">//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*EXTI初始化*/</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">EXTI_InitStructure.EXTI_Line = EXTI_Line14;<span class="comment">//选择配置外部中断的14号线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;<span class="comment">//指定外部中断线使能</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;<span class="comment">//指定外部中断线为中断模式</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//指定外部中断线为下降沿触发</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);<span class="comment">//将结构体变量交给EXTI_Init，配置EXTI外设</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//配置NVIC为分组2</span></span><br><span class="line"><span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line"><span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line"><span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line"><span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;<span class="comment">//选择配置NVIC的EXTI15_10线</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：获取计数传感器的计数值</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：计数值，范围：0~65535</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：EXTI15_10外部中断函数</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span></span><br><span class="line"><span class="comment">  *           函数名为预留的指定名称，可以从启动文件复制</span></span><br><span class="line"><span class="comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//每次进入中断服务程序，中断标志位都会置1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line14) == SET)<span class="comment">//判断是否是外部中断14号线触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">CountSensor_Count ++;<span class="comment">//计数值自增一次</span></span><br><span class="line">}</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line14);<span class="comment">//清除外部中断14号线的中断标志位</span></span><br><span class="line"><span class="comment">//中断标志位必须清除</span></span><br><span class="line"><span class="comment">//否则中断将连续不断地触发，导致主程序卡死</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="xxxxxxxxxx-typedef-structtypedef为成员列表提供了一个gpio_inittypedef的名字gpio_inittypedefc"><a class="markdownIt-Anchor" href="#xxxxxxxxxx-typedef-structtypedef为成员列表提供了一个gpio_inittypedef的名字gpio_inittypedefc"></a> xxxxxxxxxx&nbsp;typedef struct//typedef为成员列表提供了一个GPIO_InitTypeDef的名字{}GPIO_InitTypeDef;c</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Count:"</span>);</span><br><span class="line">CountSensor_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">7</span>,CountSensor_Get(),<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="二-旋转编码器"><a class="markdownIt-Anchor" href="#二-旋转编码器"></a> 二、旋转编码器</h2><h3 id="底层程序"><a class="markdownIt-Anchor" href="#底层程序"></a> 底层程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count;<span class="comment">//全局变量，用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：计数传感器初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*外部中断的定义*/</span></span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);<span class="comment">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO初始化*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//将PB14引脚初始化为上拉输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*AFIO选择中断引脚*/</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);<span class="comment">//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*EXTI初始化*/</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">EXTI_InitStructure.EXTI_Line = EXTI_Line14;<span class="comment">//选择配置外部中断的14号线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;<span class="comment">//指定外部中断线使能</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;<span class="comment">//指定外部中断线为中断模式</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//指定外部中断线为下降沿触发</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);<span class="comment">//将结构体变量交给EXTI_Init，配置EXTI外设</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//配置NVIC为分组2</span></span><br><span class="line"><span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line"><span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line"><span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line"><span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;<span class="comment">//选择配置NVIC的EXTI15_10线</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：获取计数传感器的计数值</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：计数值，范围：0~65535</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：EXTI15_10外部中断函数</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span></span><br><span class="line"><span class="comment">  *           函数名为预留的指定名称，可以从启动文件复制</span></span><br><span class="line"><span class="comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//每次进入中断服务程序，中断标志位都会置1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line14) == SET)<span class="comment">//判断是否是外部中断14号线触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">CountSensor_Count ++;<span class="comment">//计数值自增一次</span></span><br><span class="line">}</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line14);<span class="comment">//清除外部中断14号线的中断标志位</span></span><br><span class="line"><span class="comment">//中断标志位必须清除</span></span><br><span class="line"><span class="comment">//否则中断将连续不断地触发，导致主程序卡死</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="主程序"><a class="markdownIt-Anchor" href="#主程序"></a> 主程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Encoder.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">Encoder_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"Encoder_Count:"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">n += Encoder_Get_Change_value();</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">1</span>, n, <span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 外部中断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[2]stm32GPIO输出</title>
      <link href="/posts/56552/"/>
      <url>/posts/56552/</url>
      
        <content type="html"><![CDATA[<h1 id="gpio输入"><a class="markdownIt-Anchor" href="#gpio输入"></a> GPIO输入</h1><h2 id="一-led闪烁"><a class="markdownIt-Anchor" href="#一-led闪烁"></a> 一、LED闪烁</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//配置GPIOA外部时钟</span></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;<span class="comment">//一般输出用推挽输出模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0  ;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//四个基本的输出电平设置函数</span></span><br><span class="line"><span class="comment">//GPIO_SetBits(GPIOA,GPIO_Pin_0);//LED灭</span></span><br><span class="line"><span class="comment">//GPIO_ResetBits(GPIOA,GPIO_Pin_0);//LED亮</span></span><br><span class="line"><span class="comment">//GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);//LED亮</span></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);<span class="comment">//LED灭</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二-led流水灯"><a class="markdownIt-Anchor" href="#二-led流水灯"></a> 二、LED流水灯</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;<span class="comment">//一般输出用推挽输出模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_All;<span class="comment">//可以用按位或的方式同时初始化多个引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">GPIO_Write(GPIOA,~(<span class="number">0x0001</span>&lt;&lt;i)); <span class="comment">//0000 0000 0000 0001</span></span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="三-蜂鸣器"><a class="markdownIt-Anchor" href="#三-蜂鸣器"></a> 三、蜂鸣器</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;<span class="comment">//一般输出用推挽输出模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_12;<span class="comment">//可以用按位或的方式同时初始化多个引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">50</span>);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">50</span>);</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">50</span>);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">700</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="gpio常用函数"><a class="markdownIt-Anchor" href="#gpio常用函数"></a> GPIO常用函数</h1><ul><li>xxxxxxxxxx&nbsp;typedef struct//typedef为成员列表提供了一个GPIO_InitTypeDef的名字{}GPIO_InitTypeDef;c</li><li>GPIO_ResetBits(GPIOA,GPIO_Pin_0);<strong>将GPIOA_0设置为低电平</strong></li><li>GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);<strong>将GPIOA_0<mark>选择</mark>为高电平</strong></li></ul><img src="/posts/56552/image-20240228000033935.png" class="" title="image-20240228000033935"><ul><li>GPIO_DeInit(*GPIO_InitTypeDef,GPIOX) <strong>初始化指定的GPIO的时钟</strong></li></ul><h1 id="gpio输出"><a class="markdownIt-Anchor" href="#gpio输出"></a> GPIO输出</h1><h2 id="一-按键控制led"><a class="markdownIt-Anchor" href="#一-按键控制led"></a> 一、按键控制LED</h2><h3 id="led底层代码"><a class="markdownIt-Anchor" href="#led底层代码"></a> LED底层代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_All;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_All);<span class="comment">//初始化默认低电平输出，所以要置高电平</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_OFF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_OFF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_Turn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二-按键底层代码"><a class="markdownIt-Anchor" href="#二-按键底层代码"></a> 二、按键底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);<span class="comment">//GPIOB外部时钟配置</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<span class="comment">//输入最大频率</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_1|GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);<span class="comment">//引脚初始化</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Key_GetNum</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//uint8_t相当于unsigned char </span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> KeyNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==<span class="number">0</span>);</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line">KeyNum= <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>);</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line">KeyNum= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> KeyNum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="三-主程序"><a class="markdownIt-Anchor" href="#三-主程序"></a> 三、主程序</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*初始化，配置按键输入引脚/LED电平输出引脚*/</span></span><br><span class="line">LED_Init();</span><br><span class="line">Key_Init();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key_GetNum();</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">LED1_Turn();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">LED2_Turn();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[1] stm32工程创建</title>
      <link href="/posts/5499/"/>
      <url>/posts/5499/</url>
      
        <content type="html"><![CDATA[<h1 id="stm32点亮led"><a class="markdownIt-Anchor" href="#stm32点亮led"></a> stm32点亮LED</h1><h2 id="一-配置寄存器方式"><a class="markdownIt-Anchor" href="#一-配置寄存器方式"></a> 一、配置寄存器方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*使用配置寄存器的方式进行点灯操作*/</span></span><br><span class="line">RCC-&gt;APB2ENR = <span class="number">0x00000010</span>;</span><br><span class="line">GPIOC-&gt;CRH = <span class="number">0x00300000</span>;</span><br><span class="line">GPIOC-&gt;ODR = <span class="number">0x00002000</span>; </span><br><span class="line"><span class="comment">//缺点：配置繁琐，操作多</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二-库函数方式"><a class="markdownIt-Anchor" href="#二-库函数方式"></a> 二、库函数方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*使用库函数的方式进行点灯操作*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);<span class="comment">//配置GPIOC的外设时钟</span></span><br><span class="line"><span class="comment">//函数的本质还是配置寄存器，但是封装好了完整可靠的功能</span></span><br><span class="line"><span class="comment">//不会影响到寄存器的其他位，不需要手动计算寄存器</span></span><br><span class="line">    </span><br><span class="line">GPIO_InitTypeDef GPIO_InitSructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">GPIO_InitSructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//选择推挽输出模式</span></span><br><span class="line">GPIO_InitSructure.GPIO_Pin = GPIO_Pin_13;<span class="comment">//选择13号引脚</span></span><br><span class="line">GPIO_InitSructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//GPIO最大频率50MHZ</span></span><br><span class="line">    </span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitSructure);<span class="comment">//根据配置的结构体，各个成员变量的参数，初始化GPIO口</span></span><br><span class="line"><span class="comment">//GPIO_SetBits(GPIOC,GPIO_Pin_13);//设置PC13口为高电平</span></span><br><span class="line">GPIO_ResetBits(GPIOC,GPIO_Pin_13);<span class="comment">//设置PC13口为低电平</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>对GPIO_InitTypeDef GPIO_InitSructure的理解</p><p>转到GPIO_InitTypeDef的定义</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;             <span class="comment">/*!&lt; Specifies the GPIO pins to be configured.</span></span><br><span class="line"><span class="comment">                                      This parameter can be any value of @ref GPIO_pins_define */</span></span><br><span class="line"></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">/*!&lt; Specifies the speed for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">/*!&lt; Specifies the operating mode for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span></span><br><span class="line">}GPIO_InitTypeDef;</span><br></pre></td></tr></tbody></table></figure><h3 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> #结构体</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>//类</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">sb</span>;</span><span class="comment">//结构体的成员可以是另外的结构体</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line"><span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> id[<span class="number">20</span>];</span><br><span class="line">} s1, s2;<span class="comment">//s1和s2也是结构体变量</span></span><br><span class="line"><span class="comment">//s1,s2是全局变量</span></span><br><span class="line"><span class="comment">//结构体的调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//s是局部变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span> =</span> { {<span class="string">'w'</span>,<span class="number">20</span>,<span class="number">3.14</span> }, <span class="string">"张三"</span>, <span class="number">30</span>, <span class="string">"20200534"</span> };<span class="comment">//对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>,s.sb.c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s.id);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>* <span class="title">ps</span> =</span> &amp;s;<span class="comment">//结构体指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>,(*ps).sb.c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, ps-&gt;sb.c);<span class="comment">//ps是指针可以用-&gt;操作符,sb是变量不是指针只能用.操作符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//<span class="title">typedef</span>为成员列表提供了一个<span class="title">GPIO_InitTypeDef</span>的名字</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">}GPIO_InitTypeDef;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】[1]线性规划</title>
      <link href="/posts/32828/"/>
      <url>/posts/32828/</url>
      
        <content type="html"><![CDATA[<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c=[<span class="number">2</span>;<span class="number">3</span>;<span class="number">1</span>];</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>];</span><br><span class="line">b=[<span class="number">8</span>,<span class="number">6</span>];</span><br><span class="line">[x,frav]=linprog(c,-a,-b,[],[],<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>))</span><br></pre></td></tr></tbody></table></figure><p><strong>zeros 的作用 ？</strong></p><blockquote><p>在这个问题中，<code>zeros(3,1)</code> 是用来设置线性规划问题的变量的下界为零的约束条件。</p></blockquote><ul><li><p>在 MATLAB 的 <code>linprog</code> 函数中，第五个参数是用来指定变量的下界约束条件的。在这个例子中，我们希望所有的变量都不能小于零，所以我们使用 <code>zeros(3,1)</code> 来创建一个全部元素为零的列向量作为下界约束条件。</p></li><li><p>这样设置下界约束条件后，线性规划求解器就会确保求解结果中的所有变量都大于等于零，符合我们的约束要求。</p></li><li><p>简而言之，<code>zeros(3,1)</code> 的作用是设置变量的<mark>下界为零</mark>，以满足线性规划问题的<mark>约束条件</mark>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 数学建模 </category>
          
          <category> Matlab </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言入门学习】函数01</title>
      <link href="/posts/36172/"/>
      <url>/posts/36172/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言入门学习函数的概念"><a class="markdownIt-Anchor" href="#c语言入门学习函数的概念"></a> 【C语言入门学习】函数的概念</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在数学中，函数是核心思想之一；同样，在计算机语言中，函数也是编程的核心思想。函数通过将代码结构化，帮助我们简化复杂的程序逻辑。</p><hr><h3 id="一-函数的定义"><a class="markdownIt-Anchor" href="#一-函数的定义"></a> 一、函数的定义</h3><p>根据维基百科的定义：<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">子程序</a>，子程序是计算机程序中负责完成某项特定任务的一段代码。它由一个或多个语句块组成，相较于其他代码，具备较高的独立性。子程序通常有输入参数和返回值，提供过程的封装与细节的隐藏，且多被集成为软件库中的函数。</p><hr><h3 id="二-函数的分类"><a class="markdownIt-Anchor" href="#二-函数的分类"></a> 二、函数的分类</h3><ul><li><strong>库函数</strong></li><li><strong>自定义函数</strong></li></ul><h4 id="为什么需要库函数"><a class="markdownIt-Anchor" href="#为什么需要库函数"></a> 为什么需要库函数？</h4><p>C语言的标准库中提供了大量的库函数，旨在减少重复编写常用功能的代码，<strong>避免重复造轮子</strong>。库函数帮助我们高效地解决常见问题，提高开发效率。</p><h4 id="如何查找库函数"><a class="markdownIt-Anchor" href="#如何查找库函数"></a> 如何查找库函数？</h4><p>以下是常用的库函数查询网站：</p><ul><li><a href="https://cplusplus.com/reference/">cplusplus.com</a></li><li><a href="https://en.cppreference.com/w/">cppreference.com</a></li></ul><blockquote><p>提示：<strong>cppreference</strong> 支持在 Edge 浏览器中安装插件，URL 搜索框中输入 “cc”+“空格” 可以快速查询函数的定义、使用方式及对应的封装库。</p></blockquote><h4 id="常见的库函数"><a class="markdownIt-Anchor" href="#常见的库函数"></a> 常见的库函数</h4><ul><li><strong>IO函数</strong>：如 <code>printf</code>、<code>scanf</code></li><li><strong>字符串操作函数</strong>：如 <code>strlen</code></li><li><strong>字符操作函数</strong></li><li><strong>内存操作函数</strong></li><li><strong>时间/日期函数</strong></li><li><strong>数学函数</strong></li><li><strong>其他库函数</strong></li></ul><hr><h3 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main1() {</span><br><span class="line">    // 库函数的应用示例</span><br><span class="line">    char arr1[20] = {0};</span><br><span class="line">    char arr2[] = "hello world";</span><br><span class="line"></span><br><span class="line">    // 字符串拷贝</span><br><span class="line">    strcpy(arr1, arr2);</span><br><span class="line">    printf("%s\n", arr1);</span><br><span class="line"></span><br><span class="line">    // 设置内存块</span><br><span class="line">    memset(arr1, 'x', 5);</span><br><span class="line">    printf("%s\n", arr1);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在C语言中，<strong>库函数</strong>的使用需要通过 <code>#include</code> 指令包含相应的头文件：</p><ul><li><code>#include &lt; &gt;</code>：用于引用标准库头文件，路径指向编译器的标准库目录。</li><li><code>#include " "</code>：用于引用自定义头文件，路径指向工程目录。</li></ul><hr><h3 id="三-自定义函数"><a class="markdownIt-Anchor" href="#三-自定义函数"></a> 三、自定义函数</h3><p>编写自定义函数可以根据具体需求设计功能，增强代码的灵活性，提升代码重用率和可读性。</p><p><strong>函数的基本结构：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(形参列表) {</span><br><span class="line">    // 函数体</span><br><span class="line">    return 返回值; // 如需要返回值</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/36172/784deb65dd214e76b6c971f2d2b4c04f.png" class="" title="在这里插入图片描述"><hr><h3 id="示例1找出两个数中的最大值"><a class="markdownIt-Anchor" href="#示例1找出两个数中的最大值"></a> 示例1：找出两个数中的最大值</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int get_max(int x, int y) {</span><br><span class="line">    int z = 0;</span><br><span class="line">    if (x &gt; y)</span><br><span class="line">        z = x;</span><br><span class="line">    else</span><br><span class="line">        z = y;</span><br><span class="line">    return z;  // 返回最大值z</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="示例2交换两个数的值"><a class="markdownIt-Anchor" href="#示例2交换两个数的值"></a> 示例2：交换两个数的值</h3><h4 id="swap1不通过指针交换值"><a class="markdownIt-Anchor" href="#swap1不通过指针交换值"></a> Swap1：不通过指针交换值</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Swap1(int x, int y) {</span><br><span class="line">    int temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="swap2通过指针交换值"><a class="markdownIt-Anchor" href="#swap2通过指针交换值"></a> Swap2：通过指针交换值</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Swap2(int* pa, int* pb) {</span><br><span class="line">    int temp = *pa;  // 解引用，获取pa指向的值</span><br><span class="line">    *pa = *pb;       // 交换两者的值</span><br><span class="line">    *pb = temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="主函数示例"><a class="markdownIt-Anchor" href="#主函数示例"></a> 主函数示例</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main() {</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line"></span><br><span class="line">    // 使用get_max函数获取最大值</span><br><span class="line">    int max = get_max(a, b);</span><br><span class="line">    printf("%d\n", max);  // 输出最大值</span><br><span class="line"></span><br><span class="line">    // 交换两个整型变量的值</span><br><span class="line">    printf("交换前：a=%d b=%d\n", a, b);</span><br><span class="line">    Swap1(a, b);  // 形参不影响实参</span><br><span class="line">    printf("交换后：a=%d b=%d\n", a, b);  // 无法交换成功</span><br><span class="line"></span><br><span class="line">    int* pa = &amp;a;  // pa是指向a的指针</span><br><span class="line">    *pa = 15;  // 通过指针修改a的值</span><br><span class="line">    printf("%d\n", a);  // 输出修改后的a</span><br><span class="line"></span><br><span class="line">    printf("交换前：a=%d b=%d\n", a, b);</span><br><span class="line">    Swap2(&amp;a, &amp;b);  // 通过指针传递，交换值</span><br><span class="line">    printf("交换后：a=%d b=%d\n", a, b);  // 成功交换</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="示例1-运行结果"><a class="markdownIt-Anchor" href="#示例1-运行结果"></a> 示例1 运行结果</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></tbody></table></figure><p><strong>解释</strong>：<code>get_max</code> 函数正确返回了较大的数。</p><hr><h3 id="示例2-运行结果1"><a class="markdownIt-Anchor" href="#示例2-运行结果1"></a> 示例2 运行结果1</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前：a=10 b=20</span><br><span class="line">交换后：a=10 b=20</span><br></pre></td></tr></tbody></table></figure><p><strong>问题分析</strong>：</p><ul><li><strong>Swap1</strong> 函数无法成功交换两个变量的值，因为传递给函数的实参被复制为形参，函数内部修改的仅是形参，不会影响原实参。</li></ul><hr><h3 id="示例2-运行结果2"><a class="markdownIt-Anchor" href="#示例2-运行结果2"></a> 示例2 运行结果2</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15</span><br><span class="line">交换前：a=15 b=20</span><br><span class="line">交换后：a=20 b=15</span><br></pre></td></tr></tbody></table></figure><p><strong>问题解决</strong>：</p><ul><li><strong>Swap2</strong> 函数通过指针操作了实参的内存地址，从而实现了变量交换。指针使得函数可以直接操作变量的值，而不是操作拷贝的形参。</li></ul><hr><h3 id="板书总结"><a class="markdownIt-Anchor" href="#板书总结"></a> 板书总结</h3><img src="/posts/36172/5ba991b9b5174ae489ff70b38066536d.png" class="" title="在这里插入图片描述"><hr><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li><strong>掌握库函数</strong>：养成查阅库函数文档的习惯，学会利用工具来提高编程效率。</li><li><strong>理解形参与实参的区别</strong>：函数中的形参是实参的拷贝，改变形参不会影响实参，除非通过指针传递内存地址。</li><li><strong>学会自定义函数</strong>：通过定义自定义函数，编写更加灵活和可维护的代码。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言入门学习】[3]代码书写的规范</title>
      <link href="/posts/15339/"/>
      <url>/posts/15339/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>c语言代码书写规范：</strong></p><ul><li><strong>if语句，while语句等等，尽量要带上{}</strong></li><li><strong>判断语句如if(a==1)最好改写成if(1==a)，因为一但写成if(a=)形式，  编译也能通过，但会导致程序执行完全不同的结果。<br>如果写成if(1=a)，<mark>因为语法规定</mark>,只能将值赋给等号左边的变量，不然编译不通过，这样的话，能够对编写语句起到 <em>约束作用</em> 避免了 “程序能跑就行”的局面</strong></li></ul></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main1()</span><br><span class="line">{</span><br><span class="line">int a = 0;</span><br><span class="line">printf("请输入：\n");</span><br><span class="line">scanf("%d", &amp;a);//不要加转义字符</span><br><span class="line">if (a % 2 == 1)</span><br><span class="line">{</span><br><span class="line">printf("为奇数\n");</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">printf("为偶数\n");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int num = 0;</span><br><span class="line">for (num = 1; num &lt;= 100; num++)</span><br><span class="line">{</span><br><span class="line">if (num % 2 == 1)</span><br><span class="line">{</span><br><span class="line">printf("奇数：%d\n", num);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://blog.csdn.net/weixin_44967885/article/details/108994960">scanf中的\n问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git学习】[1]基本命令</title>
      <link href="/posts/8948/"/>
      <url>/posts/8948/</url>
      
        <content type="html"><![CDATA[<h1 id="一-git仓库的创建"><a class="markdownIt-Anchor" href="#一-git仓库的创建"></a> 一、Git仓库的创建</h1><h2 id="1-git仓库的创建"><a class="markdownIt-Anchor" href="#1-git仓库的创建"></a> 1. Git仓库的创建：</h2><p>将当前目录变成可以GIT管理的目录</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init//创建初始化仓库</span><br></pre></td></tr></tbody></table></figure><h2 id="2-将文件添加到版本库repository"><a class="markdownIt-Anchor" href="#2-将文件添加到版本库repository"></a> 2. 将文件添加到版本库（Repository）:</h2><p>实际上就是把文件修改添加到暂存区</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . //将当前文件目录下所有文件移入暂存区`` </span><br></pre></td></tr></tbody></table></figure><h2 id="3-将暂存区内容添加到版本库repository中"><a class="markdownIt-Anchor" href="#3-将暂存区内容添加到版本库repository中"></a> 3. 将暂存区内容添加到版本库（Repository）中：</h2><p>仓库创建后，<code>head</code>默认指向master分支</p><p>实际上就是把暂存区的所有内容提交到当前分支</p><p>每一次的commit相当于一次快照，一但把项目文件该乱了，可以从最近的一次commit恢复</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"第一次版本提交"</span> //在后面加-m选项，以在命令行中提供提交注释</span><br><span class="line">git commit -am <span class="string">"第一次版本提交"</span>//跳过add这一步，可以直接使用 -a选项</span><br></pre></td></tr></tbody></table></figure><p>注意：每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中</p><h2 id="4-修改日志"><a class="markdownIt-Anchor" href="#4-修改日志"></a> 4. 修改日志</h2><p>版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看</p><img src="/posts/8948/image-20240903174408863.png" class="" title="image-20240903174408863"><h2 id="5-版本回退"><a class="markdownIt-Anchor" href="#5-版本回退"></a> 5. 版本回退</h2><p>1094a…是版本号</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1094a...</span><br></pre></td></tr></tbody></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──▶ ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></tbody></table></figure><p>改为指向<code>add distributed</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──▶ ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></tbody></table></figure><p>当主机重启后，之前回溯到了旧版本，这次又想回到新版本，Git提供了一个命令git reflog用来记录你的每一次命令：</p><img src="/posts/8948/image-20240903175257889.png" class="" title="image-20240903175257889"><h2 id="6-撤销修改"><a class="markdownIt-Anchor" href="#6-撤销修改"></a> 6. 撤销修改</h2><p>checkout可以丢弃工作区的修改</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></tbody></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><h2 id="其他命令"><a class="markdownIt-Anchor" href="#其他命令"></a> # 其他命令</h2><p><code>git status</code>查看状态</p><img src="/posts/8948/image-20240903175945894.png" class="" title="image-20240903175945894"><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>，<code>git rm</code>使用后相当于修改后将工作区的文件提交到暂存区，相当于<code>rm</code>文件后，使用<code>add</code>提交。</p><h1 id="二-远程仓库"><a class="markdownIt-Anchor" href="#二-远程仓库"></a> 二、远程仓库</h1><h2 id="1-git连接到远程仓库github"><a class="markdownIt-Anchor" href="#1-git连接到远程仓库github"></a> 1. Git连接到远程仓库（github）</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin [url]//参数[<span class="built_in">alias</span>]为别名， [url]为远程仓库的地址</span><br></pre></td></tr></tbody></table></figure><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上</p><h2 id="2-本地内容推送到远程仓库"><a class="markdownIt-Anchor" href="#2-本地内容推送到远程仓库"></a> 2. 本地内容推送到远程仓库</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></tbody></table></figure><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令</p><p>从现在开始，可以通过<code>git push -u origin main</code>直接推送到远程仓库</p><h2 id="3-删除远程库"><a class="markdownIt-Anchor" href="#3-删除远程库"></a> 3. 删除远程库</h2><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></tbody></table></figure><img src="/posts/8948/image-20240903182037631.png" class="" title="image-20240903182037631"><p>然后，根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></tbody></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h2 id="4-从远程库克隆"><a class="markdownIt-Anchor" href="#4-从远程库克隆"></a> 4. 从远程库克隆</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [address]</span><br></pre></td></tr></tbody></table></figure><p><a href="https://liaoxuefeng.com/books/git/remote/clone/index.html">从远程库克隆 - Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p>注意：Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快</p><h1 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> &gt; 常见问题</h1><h2 id="1-git-push-u-origin-main-报错"><a class="markdownIt-Anchor" href="#1-git-push-u-origin-main-报错"></a> 1. <code>git push -u origin main</code> 报错：</h2><p><img src="%E3%80%90Git%E5%AD%A6%E4%B9%A0%E3%80%91-1-%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4/image-20240830004335755.png" alt="image-20240830004335755"></p><blockquote><p><strong>解决方案：</strong></p><p>要解决这个问题，你需要先将远程仓库的更改合并到你的本地分支中，然后再进行推送。你可以按照以下步骤操作：</p><ol><li><strong>执行 <code>git pull</code></strong><br>在你的本地仓库中执行以下命令来获取并合并远程仓库的更改：</li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></tbody></table></figure><p>这将从远程的 <code>main</code> 分支拉取最新的提交，并尝试将这些更改合并到你本地的 <code>main</code> 分支中。</p><ol start="2"><li><p><strong>解决冲突（如果有的话）</strong><br>如果 Git 在合并过程中遇到冲突，它会提示你有冲突需要手动解决。你需要打开冲突的文件，手动编辑解决冲突，然后使用 <code>git add</code> 命令将解决冲突后的文件标记为已解决。</p></li><li><p><strong>提交合并（如果有冲突）</strong><br>解决冲突后，你需要提交这些更改：</p></li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></tbody></table></figure><p>如果没有冲突，Git 会自动完成合并。</p><ol start="4"><li><strong>重新推送到远程仓库</strong><br>一旦你已经合并了远程的更改，你可以再次尝试推送到远程仓库：</li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></tbody></table></figure><p>按照上述步骤操作，你应该能够成功地将本地更改推送到远程仓库。如果你对合并操作不太熟悉，可以提前备份你的代码库以防万一</p></blockquote><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://liaoxuefeng.com/books/git/remote/add-remote/index.html">添加远程库 - Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h1 id="更新日志"><a class="markdownIt-Anchor" href="#更新日志"></a> # 更新日志</h1><blockquote><p>date:2024.1.10</p><ul><li>优化blog内容</li></ul><p>date:2024.2.18</p><ul><li>优化blog内容</li></ul><p>date:2024.8.30</p><ul><li>优化blog内容</li></ul><p>date:2024.9.3</p><ul><li>优化blog内容</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Git </category>
          
          <category> 分布式系统 </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言入门学习】[2]初识C语言 02</title>
      <link href="/posts/32291/"/>
      <url>/posts/32291/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言入门学习2初识c语言-02"><a class="markdownIt-Anchor" href="#c语言入门学习2初识c语言-02"></a> 【C语言入门学习】[2]初识C语言 02</h1><h3 id="2024110更新"><a class="markdownIt-Anchor" href="#2024110更新"></a> 2024.1.10更新</h3><h4 id="常见操作符-关键字2"><a class="markdownIt-Anchor" href="#常见操作符-关键字2"></a> 常见操作符 关键字（2）</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.static 修饰局部变量</span></span><br><span class="line"><span class="comment">//2.static 修饰全局变量</span></span><br><span class="line"><span class="comment">//3.static 修饰函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_val;<span class="comment">//声明外部变量</span></span><br><span class="line"><span class="comment">//static int g_val = 100;  //static 修饰全局变量使得全局变量只能在自己所在的源文件内部使用</span></span><br><span class="line"><span class="comment">//extern int g_val;报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量，在其他源文件内部可以被使用，是因为全局变量具有外部链接属性</span></span><br><span class="line"><span class="comment">//但是被static修饰之后，就变成了内部链接属性，其他源文件就不能链接到这个静态的全局变量了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static int Add(int x, int y)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//return x + y;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//static 修饰函数，使得函数只能在自己的源文件内部使用，不能在其他源文件内部使用，</span></span><br><span class="line"><span class="comment">//本质上：static是将函数的外部链接属性变成内部链接属性（与static修饰全局变量类似）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//int a =1; 10个2</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">1</span>; <span class="comment">//2到11 , a 出函数体不会销毁，再次进入函数体保持上一次的值</span></span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;<span class="comment">//定义在test01.c中</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">{</span><br><span class="line">test();</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, g_val);</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> sum = Add(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sum = %d"</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//static修饰局部变量，改变了局部变量的生命周期（本质上是改变了变量的存储类型） </span></span><br></pre></td></tr></tbody></table></figure><h4 id="define定义常量和宏"><a class="markdownIt-Anchor" href="#define定义常量和宏"></a> define定义常量和宏</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//define定义符号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX = 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//define定义宏</span></span><br><span class="line"><span class="comment">//#define ADD(X,Y) X+Y //printf结果为11</span></span><br><span class="line"><span class="comment">//#define ADD(X,Y) （X+Y）错误写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(X,Y) ((X)+(Y)) <span class="comment">//模式替换</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">4</span> * ADD(<span class="number">2</span>, <span class="number">3</span>));<span class="comment">//4*2+3</span></span><br><span class="line"><span class="comment">//宏是实现替换的</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//一个内存单元是一个byte:字节 </span></span><br><span class="line"><span class="comment">//一个byte由8个bit构成,1个bit为一个地址，所以一共8个地址  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);<span class="comment">//%p用于打印地址;</span></span><br><span class="line"><span class="type">int</span> *pa = &amp;a;<span class="comment">//pa是用来存放地址的，在c语言中pa叫指针变量</span></span><br><span class="line"><span class="comment">//* 说明 pa是指针变量</span></span><br><span class="line"><span class="comment">//int 说明pa执行对象是int类型的</span></span><br><span class="line"><span class="type">char</span> ch = <span class="string">'w'</span>;</span><br><span class="line"><span class="type">char</span>* pc = &amp;ch;</span><br><span class="line"></span><br><span class="line">*pa = <span class="number">20</span>;<span class="comment">//*解引用操作，*pa就是通过pa里面的地址，找到a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">float</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>*));</span><br><span class="line"><span class="comment">//32位机器，4个字节</span></span><br><span class="line"><span class="comment">//64位机器，8个字节</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体可以让c语言创建出新的类型出来</span></span><br><span class="line"><span class="comment">//创建一个学生</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line"><span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> sex[<span class="number">5</span>];<span class="comment">//性别</span></span><br><span class="line"><span class="type">char</span> id[<span class="number">15</span>];<span class="comment">//学号</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//结构体的初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span> =</span> { <span class="string">"张三"</span>,<span class="number">18</span>,<span class="string">"男"</span>,<span class="string">"20241574"</span> };</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"名字:%s 年龄:%d 性别:%s 学号:%s\n"</span>, s.name, s.age, s.sex, s.id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作符：-&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>* <span class="title">ps</span> =</span> &amp;s;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"名字:%s 年龄:%d 性别:%s 学号:%s\n"</span>, ps-&gt;name, ps-&gt;age, ps-&gt;sex, ps-&gt;id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结：</strong></h1><h4 id="c语言的基本语法初步了解以及补充完成"><a class="markdownIt-Anchor" href="#c语言的基本语法初步了解以及补充完成"></a> c语言的基本语法初步了解以及补充完成</h4>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】定时器和中断 02</title>
      <link href="/posts/32229/"/>
      <url>/posts/32229/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机-第七节-定时器和中断总结代码部分"><a class="markdownIt-Anchor" href="#51单片机-第七节-定时器和中断总结代码部分"></a> [51单片机] 第七节 定时器和中断总结&lt;代码部分&gt;</h1><h3 id="ps-单片机的可位寻址不可位寻址"><a class="markdownIt-Anchor" href="#ps-单片机的可位寻址不可位寻址"></a> ps: 单片机的可位寻址/不可位寻址</h3><ul><li>可位寻址：可以对单个位赋值</li><li>不可位寻址：只能整体赋值</li></ul><p>代码示例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TMOD=<span class="number">0x01</span>; <span class="comment">//0000 0001</span></span><br><span class="line">TF=<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="定时器的快捷配置"><a class="markdownIt-Anchor" href="#定时器的快捷配置"></a> 定时器的快捷配置</h3><img src="/posts/32229/b094f812549147d6b17d96fc95302cb2.png" class="" title="在这里插入图片描述"><h2 id="晶振电路简介这里所使用晶振为110592mhz"><a class="markdownIt-Anchor" href="#晶振电路简介这里所使用晶振为110592mhz"></a> 晶振电路简介（这里所使用晶振为11.0592MHZ)</h2><img src="/posts/32229/e6afeca057c945fb9d15dc14a78c676c.png" class="" title="在这里插入图片描述"><h2 id="一-中断测试代码"><a class="markdownIt-Anchor" href="#一-中断测试代码"></a> 一、中断测试代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Tmier0.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void Timer0_Init()//定时器配置</span></span><br><span class="line"><span class="comment">// {</span></span><br><span class="line"><span class="comment">// //TMOD=0x01; //0000 0001 //缺点：会影响到其他定时器</span></span><br><span class="line"><span class="comment">// TMOD &amp;= 0xF0;//把TMOD的低四位清零，高四位保持不变 //优点：不影响高四位（其他定时器的配置）</span></span><br><span class="line"><span class="comment">// TMOD |=  0X01;//把TMOD的最低为置1，高四位保持不变</span></span><br><span class="line"><span class="comment">// TF0=0; // Gate = 0;</span></span><br><span class="line"><span class="comment">// TR0 = 1;//定时器0允许计数</span></span><br><span class="line"><span class="comment">// //mark</span></span><br><span class="line"><span class="comment">// TH0=64535/256;//16进制 取高八位</span></span><br><span class="line"><span class="comment">// TL0=64535%256;//取低八位</span></span><br><span class="line"><span class="comment">// ET0=1;//T0的中断溢出允许位</span></span><br><span class="line"><span class="comment">// EA=1;//总的允许位</span></span><br><span class="line"><span class="comment">// PT0=0;// IP</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//mark</span></span><br><span class="line"><span class="comment">//分析：如何计1s？</span></span><br><span class="line"><span class="comment">//0~65535</span></span><br><span class="line"><span class="comment">//每隔1us计数加一 12M 12分频</span></span><br><span class="line"><span class="comment">//总共定时时间65535us</span></span><br><span class="line"><span class="comment">//64535离计数器溢出差值1000，所以计时时间为1ms</span></span><br><span class="line"><span class="comment">//最大计65ms,所以这里分出1ms比较合适，再定义其他变量进行秒的计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化，中断溢出会跳到  Timer0_Routine() interrupt 1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//unsigned int T0Count;//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 <span class="comment">//中断子程序</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count;<span class="comment">//静态局部变量，保证退出函数之后不销毁</span></span><br><span class="line"><span class="comment">//TH0=64535/256;//计数器溢出中断后，计数会清理，所以每次进入中断后需要再赋初值</span></span><br><span class="line"><span class="comment">//TL0=64535%256;</span></span><br><span class="line">TL0 = <span class="number">0x66</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T0Count++;<span class="comment">//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"><span class="keyword">if</span>(T0Count&gt;=<span class="number">1000</span>)<span class="comment">//每1s执行对P2_0的操作</span></span><br><span class="line">{</span><br><span class="line">T0Count=<span class="number">0</span>;</span><br><span class="line">P2_0 =~P2_0;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ps-中断执行模块不宜存在过于复杂的任务"><a class="markdownIt-Anchor" href="#ps-中断执行模块不宜存在过于复杂的任务"></a> ps: 中断执行模块不宜存在过于复杂的任务</h2><h2 id="二-基于中断系统的流水灯按键控制"><a class="markdownIt-Anchor" href="#二-基于中断系统的流水灯按键控制"></a> 二、基于中断系统的流水灯按键控制</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Timer0.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void Timer0_Init()//定时器配置</span></span><br><span class="line"><span class="comment">// {</span></span><br><span class="line"><span class="comment">// //TMOD=0x01; //0000 0001 //缺点：会影响到其他定时器</span></span><br><span class="line"><span class="comment">// TMOD &amp;= 0xF0;//把TMOD的低四位清零，高四位保持不变 //优点：不影响高四位（其他定时器的配置）</span></span><br><span class="line"><span class="comment">// TMOD |=  0X01;//把TMOD的最低为置1，高四位保持不变</span></span><br><span class="line"><span class="comment">// TF0=0; // Gate = 0;</span></span><br><span class="line"><span class="comment">// TR0 = 1;//定时器0允许计数</span></span><br><span class="line"><span class="comment">// //mark</span></span><br><span class="line"><span class="comment">// TH0=64535/256;//16进制 取高八位</span></span><br><span class="line"><span class="comment">// TL0=64535%256;//取低八位</span></span><br><span class="line"><span class="comment">// ET0=1;//T0的中断溢出允许位</span></span><br><span class="line"><span class="comment">// EA=1;//总的允许位</span></span><br><span class="line"><span class="comment">// PT0=0;// IP</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//mark</span></span><br><span class="line"><span class="comment">//分析：如何计1s？</span></span><br><span class="line"><span class="comment">//0~65535</span></span><br><span class="line"><span class="comment">//每隔1us计数加一 12M 12分频</span></span><br><span class="line"><span class="comment">//总共定时时间65535us</span></span><br><span class="line"><span class="comment">//64535离计数器溢出差值1000，所以计时时间为1ms</span></span><br><span class="line"><span class="comment">//最大计65ms,所以这里分出1ms比较合适，再定义其他变量进行秒的计数</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> keynum,LEDMode;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">P2=<span class="number">0xFE</span>;<span class="comment">//初始化，点亮第一个LED</span></span><br><span class="line">  Timer0_Init();<span class="comment">//定时器初始化，中断溢出会跳到  Timer0_Routine() interrupt 1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">keynum = Key();</span><br><span class="line"><span class="keyword">if</span>(keynum)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(keynum == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">LEDMode++;</span><br><span class="line"><span class="keyword">if</span>(LEDMode&gt;=<span class="number">2</span>)LEDMode=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//unsigned int T0Count;//全局变量</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 <span class="comment">//中断子程序</span></span><br><span class="line"> {</span><br><span class="line"></span><br><span class="line"> <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count;<span class="comment">//静态局部变量，保证退出函数之后不销毁</span></span><br><span class="line"> <span class="comment">//TH0=64535/256;//计数器溢出中断后，计数会清理，所以每次进入中断后需要再赋初值</span></span><br><span class="line"> <span class="comment">//TL0=64535%256;</span></span><br><span class="line"> TL0 = <span class="number">0x66</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line"> TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line"> T0Count++;<span class="comment">//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"> <span class="keyword">if</span>(T0Count&gt;=<span class="number">500</span>)</span><br><span class="line"> {</span><br><span class="line"> T0Count=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(LEDMode == <span class="number">0</span>)</span><br><span class="line">P2=_crol_(P2,<span class="number">1</span>);<span class="comment">//循环左移</span></span><br><span class="line"><span class="keyword">if</span>(LEDMode == <span class="number">1</span>)</span><br><span class="line">P2=_cror_(P2,<span class="number">1</span>);<span class="comment">//循环右移，类似于移位寄存器（存在反馈电路）</span></span><br><span class="line"> }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p><mark>crol和cror函数区别于&lt;&lt;，&gt;&gt;移位操作符，具有“循环移位”的特性，不需要考虑移位“溢出”；</mark></p><h2 id="三-基于定时器的lcd数字时钟"><a class="markdownIt-Anchor" href="#三-基于定时器的lcd数字时钟"></a> 三、基于定时器的LCD数字时钟</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LCD1602.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Timer0.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sec=<span class="number">55</span>,min=<span class="number">59</span>,hour=<span class="number">23</span>; <span class="comment">//秒时钟 分时钟 小时时钟 这里我们赋上初值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">  LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"CLOCK:"</span>);<span class="comment">//字符串静态显示不需要放在while中</span></span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">3</span>,<span class="string">":  :  "</span>);</span><br><span class="line"><span class="comment">//LCD_ShowNum(2,1,sec,2);//需要更新显示</span></span><br><span class="line">Timer0_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,hour,<span class="number">2</span>);<span class="comment">//思考：动态的信号需要更新显示，静态的信号一般不用放在while循环中</span></span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">4</span>,min,<span class="number">2</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">7</span>,sec,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 <span class="comment">//中断子程序 秒控制计数器</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count;<span class="comment">//静态局部变量，保证退出函数之后不销毁  //不定义为全局变量是为了作为子函数内容，方便调用这个函数模板</span></span><br><span class="line">TL0 = <span class="number">0x66</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T0Count++;<span class="comment">//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"><span class="keyword">if</span>(T0Count&gt;=<span class="number">1000</span>)<span class="comment">//每1s执行对P2_0的操作</span></span><br><span class="line">{</span><br><span class="line">T0Count=<span class="number">0</span>;</span><br><span class="line">P2_0=~P2_0;</span><br><span class="line">sec++;</span><br><span class="line"><span class="keyword">if</span>(sec &gt;=<span class="number">60</span>)</span><br><span class="line">{</span><br><span class="line">sec=<span class="number">0</span>;</span><br><span class="line">min++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(min &gt;=<span class="number">60</span>)</span><br><span class="line">{</span><br><span class="line">min=<span class="number">0</span>;</span><br><span class="line">hour++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(hour &gt;=<span class="number">24</span>)</span><br><span class="line">{</span><br><span class="line">hour=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思考：Verilog/VHDL和单片机（c语言) 程序执行区别？</strong></p><ul><li><mark>c语言程序为顺序执行，而非并行执行，单片机中需要动态执行的任务要放在while循环体中</mark></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> 单片机定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】定时器和中断 01</title>
      <link href="/posts/31909/"/>
      <url>/posts/31909/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机-第七节-定时器和中断总结"><a class="markdownIt-Anchor" href="#51单片机-第七节-定时器和中断总结"></a> [51单片机] 第七节 定时器和中断总结</h1><h2 id="前言定时器中断-寄存器都是单片机中非常重要的概念涉及到许多交叉的控制掌握好这些知识点是学习单片机的关键"><a class="markdownIt-Anchor" href="#前言定时器中断-寄存器都是单片机中非常重要的概念涉及到许多交叉的控制掌握好这些知识点是学习单片机的关键"></a> <mark>前言：定时器中断 ，寄存器都是单片机中非常重要的概念，涉及到许多交叉的控制，掌握好这些知识点是学习单片机的关键。</mark></h2><h2 id="51单片机的时钟源"><a class="markdownIt-Anchor" href="#51单片机的时钟源"></a> 51单片机的时钟源</h2><p>1.外部脉冲<br>2.系统时钟（晶振），开发板上周期为12MHZ</p><h2 id="一-定时器简介-swig0-"><a class="markdownIt-Anchor" href="#一-定时器简介-swig0-"></a> 一、定时器简介<img src="/posts/31909/67e820f0a50c4166b9d09e96323cbbfc.png" class="" title="在这里插入图片描述"></h2><ul><li>注意：当时钟源为外部(T0)引脚提供时，定时器作为“计数器”作用，当外部每输入一个脉冲信号，计数器计数加一（不是常用功能）。</li></ul><h2 id="二-定时器工作模式"><a class="markdownIt-Anchor" href="#二-定时器工作模式"></a> 二、定时器工作模式</h2><img src="/posts/31909/64a2475b0b6249149499e02ab139f2f3.png" class="" title="在这里插入图片描述"><p>C/NT：当次开关为1时，为计数器功能(counter)，配置T0引脚，当为0时，即定时器功能(timer)，配置系统时钟。</p><p><strong>定时器整个工作系统分为三个模块：</strong></p><ul><li>时钟模块: SYSclk,T0 pin ，此图为12分频的模式</li><li>计数模块/中断系统：计数范围：0~65530：计数溢出时会置标志位TF0,申请中断</li><li>控制模块:  GATE,NINT0,TR0</li></ul><h2 id="三-中断系统简介"><a class="markdownIt-Anchor" href="#三-中断系统简介"></a> 三、中断系统简介</h2><img src="/posts/31909/bebdac2cb7844406bba4299a353e6c6b.png" class="" title="在这里插入图片描述"><ul><li>高优先级的中断可以打断低优先级的中断</li><li>中断系统即对紧急事件的实时处理</li></ul><h2 id="四-中断系统工作流程"><a class="markdownIt-Anchor" href="#四-中断系统工作流程"></a> 四、中断系统工作流程</h2><img src="/posts/31909/6e8e07edeeb447a2b59d06efb8eec845.png" class="" title="在这里插入图片描述"><h2 id="五-stc89c52的中断资源"><a class="markdownIt-Anchor" href="#五-stc89c52的中断资源"></a> 五、stc89c52的中断资源</h2><img src="/posts/31909/ddd0c3d15aef430fbd38dc6b8a28716d.png" class="" title="在这里插入图片描述"><h2 id="六-中断系统的结构"><a class="markdownIt-Anchor" href="#六-中断系统的结构"></a> 六、中断系统的结构</h2><img src="/posts/31909/1214475b0c524bdbb01c7d3ed8ce5353.png" class="" title="在这里插入图片描述"><ul><li><mark>寄存器解释，中断系统的详细原理见数据手册（养成良好的阅读素养）</mark></li></ul><h2 id="寄存器的简介"><a class="markdownIt-Anchor" href="#寄存器的简介"></a> 寄存器的简介</h2><img src="/posts/31909/def0dec741e3438db3d0698a194ad54e-17087026380168.png" class="" title="在这里插入图片描述"><ul><li><strong><mark>寄存器相当于连接单片机中电路的“特殊开关”</mark></strong></li></ul><img src="/posts/31909/df18bf435b3048e0be9d65398f023462.png" class="" title="在这里插入图片描述"><p><strong>ps: GATE直接给0 ，一级或门输出一，二级与门输出由TR0控制是否进行计数</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> 单片机定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】串口通信</title>
      <link href="/posts/17620/"/>
      <url>/posts/17620/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机-第八节-串口通信总结"><a class="markdownIt-Anchor" href="#51单片机-第八节-串口通信总结"></a> [51单片机] 第八节 串口通信总结</h1><p><mark><strong>51单片机中的自动重载概念实际上就是当计数溢出后自动赋初值</strong></mark><br><mark><strong>同步通信中波特率为通信双方约定好的通信速率</strong></mark></p><h2 id="前置部分"><a class="markdownIt-Anchor" href="#前置部分"></a> &lt;前置部分&gt;</h2><h3 id="一-串口简介"><a class="markdownIt-Anchor" href="#一-串口简介"></a> 一、串口简介：</h3><ul><li>串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信。</li><li>单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大的扩展了单片机的应用范围，增强了单片机系统的硬件实力。</li><li>51单片机内部自带UART（Universal Asynchronous Receiver Transmitter，通用异步收发器），可实现单片机的串口通信。</li></ul><p>CH340串口模块</p><img src="/posts/17620/27446b4622ad4a0cbcb38f713983f81b.png" class="" title="在这里插入图片描述"><p>蓝牙串口模块</p><img src="/posts/17620/8a2079d378f24b61ad22949edbdb3807.png" class="" title="在这里插入图片描述"><h3 id="二-串口通信方式"><a class="markdownIt-Anchor" href="#二-串口通信方式"></a> 二、串口通信方式：</h3><img src="/posts/17620/5e2154d6b0284aeea4bf2085df848fcd.png" class="" title="在这里插入图片描述"><img src="/posts/17620/f53dddcf5aa24cb9b527df57abb8439e.png" class="" title="在这里插入图片描述"><img src="/posts/17620/1aef41579afb4053bc396a79ed0acbba.png" class="" title="在这里插入图片描述"><h3 id="串口模式图"><a class="markdownIt-Anchor" href="#串口模式图"></a> #串口模式图：</h3><img src="/posts/17620/f0cfb31d68bb4a9e911fb4d194cbc5b4.png" class="" title="在这里插入图片描述"><ul><li>SBUF：串口数据缓存寄存器，物理上是两个独立的寄存器，但占用相同的地址。写操作时，写入的是发送寄存器，读操作时，读出的是接收寄存器，因此要<mark>通过检测TI和RI的信号</mark>判断是发送还是接收操作。</li></ul><h3 id="ps用串口端控制发送接收时要注意对应上hex文本模式"><a class="markdownIt-Anchor" href="#ps用串口端控制发送接收时要注意对应上hex文本模式"></a> ps:用串口端控制发送/接收时，要注意对应上HEX/文本模式</h3><ul><li>HEX模式/十六进制模式/二进制模式：以原始数据的形式显示</li><li>文本模式/字符模式：以原始数据编码后的形式显示</li></ul><h3 id="stc-isp-串口波特率代码生成"><a class="markdownIt-Anchor" href="#stc-isp-串口波特率代码生成"></a> # stc-isp 串口波特率代码生成</h3><img src="/posts/17620/0cd1dd1144844719857702f92b85defa.png" class="" title="在这里插入图片描述"><h3 id="三-串行口通信相关寄存器"><a class="markdownIt-Anchor" href="#三-串行口通信相关寄存器"></a> 三、串（行）口通信相关寄存器</h3><img src="/posts/17620/fb06092740624f0e9f0f842f86e67c71.png" class="" title="在这里插入图片描述"><img src="/posts/17620/239d9f30d5e948e9bb6b021a20d73cce.png" class="" title="在这里插入图片描述"><img src="/posts/17620/358ab45096b14af0b704f528e22fece1.png" class="" title="在这里插入图片描述"><img src="/posts/17620/1d59a35042d74b2bb9bd05c1212373b9.png" class="" title="在这里插入图片描述"><h3 id="串口通信的寄存器解释"><a class="markdownIt-Anchor" href="#串口通信的寄存器解释"></a> #串口通信的寄存器解释</h3><hr><h4 id="scon串行控制寄存器"><a class="markdownIt-Anchor" href="#scon串行控制寄存器"></a> SCON:串行控制寄存器</h4><ul><li><strong>SMO/FE：当PCON为1，FE生效，用于帧检测，当PCON为0，SM0生效，与SM1共同作用</strong></li><li>这里我们选择工作方式1，SM0=0,SM1=1，SM2=0（没有用到停止位），REN=0（暂不接收数据）,TB8=0,RB8=0,T1=0（方式1），RI=0(<mark>在收到一个Byte的数据时RI会自动置1</mark>);</li><li><mark>SCON = 0x40;</mark></li></ul><p><strong>ps:主机响应中断不能判断是接收还是发送中断，必须在中断服务程序中判断TI和RI的值</strong></p><hr><h4 id="pcon波特率选择寄存器"><a class="markdownIt-Anchor" href="#pcon波特率选择寄存器"></a> PCON:波特率选择寄存器</h4><ul><li>由常用串口软件如：stp-isp进行计算</li></ul><hr><h4 id="sbuf数据缓冲寄存器"><a class="markdownIt-Anchor" href="#sbuf数据缓冲寄存器"></a> SBUF:数据缓冲寄存器</h4><ul><li>通过程序，控制SBUF的内容，实现电脑端和单片机端的双向通信数据传输</li></ul><hr><h2 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> &lt;代码部分&gt;</h2><h3 id="一-串口向电脑端发送数据"><a class="markdownIt-Anchor" href="#一-串口向电脑端发送数据"></a> 一、串口向电脑端发送数据</h3><p>UART.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 串口初始化，//4800bps@11.0592MHz</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span><span class="comment">//串口初始化</span></span><br><span class="line">{<span class="comment">//波特率：通信双方约定的通信速率</span></span><br><span class="line">SCON=<span class="number">0x40</span>;</span><br><span class="line">PCON &amp;= <span class="number">0x7F</span>;<span class="comment">//波特率不倍速</span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">  TL1 = <span class="number">0xFA</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">  TH1 = <span class="number">0xFA</span>;<span class="comment">//设置定时重载值</span></span><br><span class="line">   ET1 = <span class="number">0</span>;<span class="comment">//禁止定时器中断</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 串口发送一个字节数据</span></span><br><span class="line"><span class="comment">  * @param  Byte 要发送的一个字节数据</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">SBUF=Byte;<span class="comment">//发送缓存器中的数据为Byte</span></span><br><span class="line"><span class="keyword">while</span>(TI==<span class="number">0</span>);<span class="comment">//发送完数据后，电脑端接收，然后TI=1，跳过while循环</span></span><br><span class="line">TI=<span class="number">0</span>;<span class="comment">//每次发送完数据,程序置0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>main.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"UART.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Sec;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">UART_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">UART_SendByte(Sec);</span><br><span class="line">Sec++;</span><br><span class="line">Delay(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二-电脑通过串口控制led"><a class="markdownIt-Anchor" href="#二-电脑通过串口控制led"></a> 二、电脑通过串口控制LED</h3><p>UART.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 串口初始化，//4800bps@11.0592MHz</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span><span class="comment">//串口初始化</span></span><br><span class="line">{<span class="comment">//波特率：通信双方约定的通信速率</span></span><br><span class="line">SCON=<span class="number">0x50</span>;</span><br><span class="line">PCON &amp;= <span class="number">0x7F</span>;<span class="comment">//波特率不倍速</span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">  TL1 = <span class="number">0xFA</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">  TH1 = <span class="number">0xFA</span>;<span class="comment">//设置定时重载值</span></span><br><span class="line">   ET1 = <span class="number">0</span>;<span class="comment">//禁止定时器中断</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//启动所有中断</span></span><br><span class="line">ES=<span class="number">1</span>;<span class="comment">//启动串口中断</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动重装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 串口发送一个字节数据</span></span><br><span class="line"><span class="comment">  * @param  Byte 要发送的一个字节数据</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">SBUF=Byte;</span><br><span class="line"><span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">TI=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口中断函数模板</span></span><br><span class="line"><span class="comment">void UART_Routine() interrupt 4</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(RI==1)// 接收 中断</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">RI=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>main.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"UART.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">UART_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Routine</span><span class="params">()</span> interrupt 4 <span class="comment">//带上interrupt 4表示UART_Routine()为中断服务子函数</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)<span class="comment">// 接收 中断</span></span><br><span class="line">{</span><br><span class="line">P2=~SBUF;</span><br><span class="line">UART_SendByte(SBUF);<span class="comment">//这里，单片机接收电脑端发送的数据，一个函数不能既在主函数里出现，也在中断中出现</span></span><br><span class="line">RI=<span class="number">0</span>;<span class="comment">//程序置0</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><mark><strong>总结：UART：同步双向，即向电脑端发送数据，也可接收电脑端发送的数据，通过内部程序执行相应的任务</strong></mark></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> 串口通信 </tag>
            
            <tag> UART通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】红外通信</title>
      <link href="/posts/50684/"/>
      <url>/posts/50684/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机第十七讲-红外通信"><a class="markdownIt-Anchor" href="#51单片机第十七讲-红外通信"></a> 【51单片机】第十七讲 红外通信</h1><p>2024.2.2日更新</p><h2 id="一-使用模块"><a class="markdownIt-Anchor" href="#一-使用模块"></a> 一、使用模块</h2><h3 id="红外遥控"><a class="markdownIt-Anchor" href="#红外遥控"></a> 红外遥控</h3><ol><li>介绍：红外遥控是利用红外光进行通信的设备，由红外LED将<mark>调制</mark>后的信号发出，由专用的红外接收头进行<mark>解调</mark>输出。</li><li>红外LED波长：940nm，红外信号属于电磁波</li><li>通信协议标准：<mark>NEC标准</mark></li></ol><h3 id="红外接收管"><a class="markdownIt-Anchor" href="#红外接收管"></a> 红外接收管</h3><img src="/posts/50684/6090cf36fd3340cc9904d8646fbe34b9.png" class="" title="img"><h2 id="二-原理部分"><a class="markdownIt-Anchor" href="#二-原理部分"></a> 二、原理部分</h2><h3 id="一-红外通信的原理"><a class="markdownIt-Anchor" href="#一-红外通信的原理"></a> 一、红外通信的原理</h3><ul><li>空闲状态：红外LED不亮，接收头输出高电平</li><li>发送低电平：红外LED以38KHz频率闪烁发光，接收头输出低电平</li><li>发送高电平：红外LED不亮，接收头输出高电平<br>总而言之，只有红外LED发送38KHZ的闪烁信号时，红外接收头OUT引脚才会对外输出低电平信号<br>红外发送–红外接收的本质是<mark>调制</mark>和<mark>解调</mark>，在这种条件下，可以过滤掉自然界中的“噪声信号”，只有38KHZ附近的红外信号才能被红外接收头识别转换为对应的低电平。</li></ul><p><strong>转换示意图：</strong><br>1.红外LED发出的信号</p><img src="/posts/50684/c97d453d8866482a8bc0a2191a565288.png" class="" title="在这里插入图片描述"><p>2.红外接收头发出的信号</p><img src="/posts/50684/3d972def937345fdb73a96eb875114b8.png" class="" title="在这里插入图片描述"><p>其中，红外接收头发出的低电平信号的宽度等价于红外LED发送的38KHz信号的时间。</p><h3 id="二-nec通信的原理"><a class="markdownIt-Anchor" href="#二-nec通信的原理"></a> 二、NEC通信的原理</h3><h4 id="一-红外nec协议"><a class="markdownIt-Anchor" href="#一-红外nec协议"></a> 一、红外NEC协议</h4><img src="/posts/50684/ac77a0c0463b43ec87199921737332ea.png" class="" title="在这里插入图片描述"><p>在51单片机中，使用NEC通信协议，虽然NEC标准上要求（比如说Start信号）低电平持续时间9ms,高电平持续时间4.5ms，但是stc89c52用红外通信要使用到外部中断，外部中断检测方式有两种：低电平/下降沿，我们这里使用下降沿检测方式，一个完整的Start信号，包含两个下降沿，即触发两次中断，所以只要从第一次中断开始起始，第二次中断判断时间长度，即可分辨是Start还是Repeat信号。</p><h4 id="二-nec编码"><a class="markdownIt-Anchor" href="#二-nec编码"></a> 二、NEC编码</h4><img src="/posts/50684/bfdf6d289ff1423ca951eba5640917c6.png" class="" title="在这里插入图片描述"><p><strong>NEC编码包括地址码和命令码，其中地址吗和命令码都会进行一次反码校验。因此，一段完整的NEC数据码一共有4个字节，32位bit</strong></p><p>遥控器键码</p><img src="/posts/50684/7a07fa67c2f145da96d22f3cd2c6d79a.png" class="" title="在这里插入图片描述"><p>这里，我们定义地址码为<mark>Address</mark>,命令码为<mark>Command</mark>, 完整的数据码为<mark>DATA</mark>，如果我们按下0,那么发送的<strong>Address=0x00; Command =0x16; 那么DATA一共包含0X00,0XFF,0X16,~0X16四个字节的先后数据。</strong></p><h3 id="三-外部中断的原理"><a class="markdownIt-Anchor" href="#三-外部中断的原理"></a> 三、外部中断的原理</h3><ul><li>STC89C52有四个外部中断</li><li>STC89C52外部中断有两种方式：下降沿/低电平触发</li><li>中断号</li></ul><img src="/posts/50684/371dbb882c974ce58699b8ceaa32e092.png" class="" title="在这里插入图片描述"><p>外部中断配置的寄存器：</p><img src="/posts/50684/53bd99d1486c4427aff48442fad5ee50.png" class="" title="在这里插入图片描述"><h1 id="三-代码部分"><a class="markdownIt-Anchor" href="#三-代码部分"></a> 三、代码部分</h1><h2 id="重要调试过程"><a class="markdownIt-Anchor" href="#重要调试过程"></a> #重要调试过程</h2><p><strong>11.0592MHZ和12MHZ的定时器计数速率不一致，硬件电路或者程序运行速度相关问题，可能导致实际的（比如Start命令）宽度并不是很接近于标准的通信协议，需要我们自己去调试，这里我在调试的过程中遇到了一些问题，以下为相关代码和解决方法</strong></p><p>外部中断</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"><span class="comment">#include "Delay.h"</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "INT0.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char Num;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">Int0_Init();</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line">LCD_ShowNum(1,1,Num,2);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Int0_Rountine(void)interrupt 0</span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @brief </span><br><span class="line">  * @param  </span><br><span class="line">  * @retval </span><br><span class="line"></span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">void Int0_Init(void)//@11.0592MHz</span><br><span class="line">{</span><br><span class="line">IT0=1;</span><br><span class="line">IE0=0;</span><br><span class="line">EX0=1;</span><br><span class="line">EA=1;</span><br><span class="line">PX0=1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">void Int0_Rountine(void)interrupt 0;</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><p>Timer0计时模块编写,用作跟红外通信相关的编码时序计时</p><img src="/posts/50684/353ffadddfd04e0f9e71870ae7e8448a.png" class="" title="在这里插入图片描述"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Timer0_Init(void)//@11.0592MHz</span><br><span class="line">{</span><br><span class="line">TMOD &amp;= 0xF0;</span><br><span class="line">TMOD |= 0x01;</span><br><span class="line">TL0 = 0x00;</span><br><span class="line">TH0 = 0x00;</span><br><span class="line">TF0 = 0;</span><br><span class="line">TR0 = 0;</span><br><span class="line">ET0=1;</span><br><span class="line">EA=1;</span><br><span class="line">PT0=0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Time0_SetCounter(unsigned int Number)</span><br><span class="line">{</span><br><span class="line">TL0=0x0F&amp;Number;</span><br><span class="line">TH0=0xF0&amp;Number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned int <span class="function"><span class="title">Time0_GetCounter</span></span>()</span><br><span class="line">{</span><br><span class="line">unsigned int number;</span><br><span class="line">number=TL0+TH0;</span><br><span class="line"><span class="built_in">return</span> number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Time0_Run(unsigned char Flag)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Flag)</span><br><span class="line">{</span><br><span class="line">TR0=1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">TR0=0;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">/*定时器中断函数模板</span><br><span class="line">void Timer0_Routine() interrupt 1 //中断子程序</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">static unsigned int T0Count;//静态局部变量，保证退出函数之后不销毁</span><br><span class="line">TL0 = 0x66;//设置定时初始值</span><br><span class="line">TH0 = 0xFC;//设置定时初始值</span><br><span class="line">T0Count++;//每次进入中断子程序，秒控制器自加一</span><br><span class="line"><span class="keyword">if</span>(T0Count&gt;=1000)//每1s执行对P2_0的操作</span><br><span class="line">{</span><br><span class="line">T0Count=0;</span><br><span class="line">P2_0 =~P2_0;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><p><strong>红外通信模块</strong></p><blockquote><p>测试结果：红外可以接收，但是无法发送起始命令（按下按键后，LED不亮）<br>问题分析 ：计时器计数的时长不在我们 &gt; if(IR_Time&gt;=13500-500 &amp;&amp; IR_Time&lt;=13500+500) &lt; 语句的判断范围内<br>解决方案：修改if语句的判断范围，使之能检测到Start命令，并用LCD1602显示定时器发送Start命令实际的定时器计数数值IR_Time。</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"><span class="comment">#include "INT0.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char IR_ADDRESS;</span><br><span class="line">unsigned char IR_State;</span><br><span class="line">unsigned char IR_Time;</span><br><span class="line"></span><br><span class="line">void IR_Init()//红外中断初始化</span><br><span class="line">{</span><br><span class="line">Timer0_Init();</span><br><span class="line">Int0_Init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Int0_Rountine(void)interrupt 0 //外部中断函数，使用状态机方法</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IR_State==0)//起始时，一但红外管检测到按键按下，就会进入外部中断程序，从状态0开始</span><br><span class="line">{</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">Timer0_Run(1);</span><br><span class="line">IR_State=1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_State==1)//状态1</span><br><span class="line">{</span><br><span class="line">IR_Time=Timer0_GetCounter();</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line"><span class="keyword">if</span>(IR_Time&gt;=13500-500 &amp;&amp; IR_Time&lt;=13500+500)//检测红外管是否发送起始命令</span><br><span class="line">{</span><br><span class="line">P2=0;</span><br><span class="line">IR_State=2;</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_Time&gt;=11250-500 &amp;&amp; IR_Time&lt;=11250+500)//重复命令</span><br><span class="line">{</span><br><span class="line">IR_State=0;</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">IR_State=1;//自循环</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试定时器是否正常计数<br>问题1：延时函数用到12MHZ,需要改写<br>问题2:   Timer0模块多个函数编写存在问题</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"><span class="comment">#include "Delay.h"</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "INT0.h"</span></span><br><span class="line"><span class="comment">#include "IR.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char Num;//Num只能到255</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">Timer0_Init();</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">Timer0_Run(1);</span><br><span class="line">Delay(1);</span><br><span class="line">LCD_ShowNum(1,1,Timer0_GetCounter(),5);</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改后，再次测试…<br>延时13ms观察定时器计数，通过LCD可以看到,13ms对应的计数居然是12076, 不符合12MHZ的通信要求，由此，我们要重新运算通信时序时长</p><p>使用时间转换器Timer0_usCount ，对比结果，显示真实的13500ms对应的定时器计数值</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Timer0.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LCD1602.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"INT0.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IR.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">Timer0_Init();Timer0_SetCounter(<span class="number">0</span>);Timer0_Run(<span class="number">1</span>);</span><br><span class="line">Delay(<span class="number">13</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Timer0_GetCounter(),<span class="number">5</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,Timer0_usCount(<span class="number">0x66</span>,<span class="number">0xCF</span>),<span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/50684/a2b23e45c4a744b79a619ced79a72ee2.png" class="" title="在这里插入图片描述"><p>实际红外管，起始命令的时长为"12926"</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"><span class="comment">#include "INT0.h"</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char IR_ADDRESS;</span><br><span class="line">unsigned char IR_State;</span><br><span class="line"></span><br><span class="line">//unsigned char IR_Time; 错误！！！这里定义为字符类型，对应的数值仅有255，对应的13500无法赋值给IR_Time</span><br><span class="line">unsigned int IR_Time;</span><br><span class="line"></span><br><span class="line">void IR_Init()//红外中断初始化</span><br><span class="line">{</span><br><span class="line">Timer0_Init();</span><br><span class="line">Int0_Init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Int0_Rountine(void)interrupt 0 //外部中断函数，使用状态机方法</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IR_State==0)//起始时，一但红外管检测到按键按下，就会进入外部中断程序，从状态0开始</span><br><span class="line">{</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">Timer0_Run(1);</span><br><span class="line">IR_State=1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_State==1)//状态1</span><br><span class="line">{</span><br><span class="line">IR_Time=Timer0_GetCounter();</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line"><span class="keyword">if</span>(IR_Time&gt;12926-500 &amp;&amp; IR_Time&lt;12926+500)//检测红外管是否发送起始命令</span><br><span class="line">{</span><br><span class="line">LCD_ShowNum(1,1,IR_Time,5);</span><br><span class="line">P2=0;</span><br><span class="line">IR_State=2;</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_Time&gt;=1000 &amp;&amp; IR_Time&lt;=2000)//重复命令</span><br><span class="line">{</span><br><span class="line">IR_State=0;</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">P2_5=1;</span><br><span class="line">P2_5=0;</span><br><span class="line">P2_5=1;</span><br><span class="line">IR_State=1;//自循环</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>经过对代码的修改后，将程序烧录到单片机上，在LCD1602上显示能够进入&gt;if(IR_Time&gt;12926-500 &amp;&amp; IR_Time&lt;12926+500)语句的命令时长&lt;</strong></p><img src="/posts/50684/353560c64d1f47b7b4af420f04f8b1ef.jpeg" class="" title="在这里插入图片描述"><p><strong>IR_Time在12926附近浮动，可见用标准的13500作为代码中的时长判断并不合适，同理，后续的其他命令时长（低电平/高电平/Repeat/)也用这种方法测试（调大判断范围、显示真实时长、修改合适的范围）</strong></p><h2 id="一-外部中断"><a class="markdownIt-Anchor" href="#一-外部中断"></a> 一、外部中断</h2><p>1.外部中断寄存器配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @brief </span><br><span class="line">  * @param  </span><br><span class="line">  * @retval </span><br><span class="line"></span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">void Int0_Init(void)//@11.0592MHz</span><br><span class="line">{</span><br><span class="line">IT0=1;//下降沿触发中断</span><br><span class="line">IE0=0;</span><br><span class="line">EX0=1;</span><br><span class="line">EA=1;</span><br><span class="line">PX0=1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">void Int0_Rountine(void)interrupt 0;</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><p>2.对定时器0进行重编写</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Timer0_Init(void)//@11.0592MHz</span><br><span class="line">{</span><br><span class="line">TMOD &amp;= 0xF0;</span><br><span class="line">TMOD |= 0x01;</span><br><span class="line">TL0 = 0x00;</span><br><span class="line">TH0 = 0x00;</span><br><span class="line">TF0 = 0;</span><br><span class="line">TR0 = 0;</span><br><span class="line">ET0=1;</span><br><span class="line">EA=1;</span><br><span class="line">PT0=0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">///TH0 TL0不能随便给Number的，有高低位之分！</span><br><span class="line">void Timer0_SetCounter(unsigned int Number)</span><br><span class="line">{</span><br><span class="line">TH0=Number/256;</span><br><span class="line">TL0=Number%256;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//!!!</span><br><span class="line">unsigned int Timer0_GetCounter(void)</span><br><span class="line">{</span><br><span class="line">//number=TL0+TH0;</span><br><span class="line"><span class="built_in">return</span> (TH0&lt;&lt;<span class="string">8)|TL0;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//!!!</span></span><br><span class="line"><span class="string">void Timer0_Run(unsigned char Flag)</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">//if(Flag)</span></span><br><span class="line"><span class="string">//{</span></span><br><span class="line"><span class="string">//TR0=1;</span></span><br><span class="line"><span class="string">//}</span></span><br><span class="line"><span class="string">//else</span></span><br><span class="line"><span class="string">//{</span></span><br><span class="line"><span class="string">//TR0=0;</span></span><br><span class="line"><span class="string">//}</span></span><br><span class="line"><span class="string">TR0=Flag;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unsigned int Timer0_usCount(unsigned int TL,unsigned int TH)//时间转换器</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">unsigned int us = (0xFF-TH)*16*16 + (0xFF-TL);</span></span><br><span class="line"><span class="string">return us;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*定时器中断函数模板</span></span><br><span class="line"><span class="string">void Timer0_Routine() interrupt 1 //中断子程序</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static unsigned int T0Count;//静态局部变量，保证退出函数之后不销毁</span></span><br><span class="line"><span class="string">TL0 = 0x66;//设置定时初始值</span></span><br><span class="line"><span class="string">TH0 = 0xFC;//设置定时初始值</span></span><br><span class="line"><span class="string">T0Count++;//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"><span class="string">if(T0Count&gt;=1000)//每1s执行对P2_0的操作</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">T0Count=0;</span></span><br><span class="line"><span class="string">P2_0 =~P2_0;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></tbody></table></figure><p>3.红外通信模块</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"><span class="comment">#include "INT0.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//unsigned char IR_Time; 错误！！！这里定义为字符类型，对应的数值仅有255，对应的13500无法赋值给IR_Time</span><br><span class="line">unsigned int IR_Time;</span><br><span class="line">unsigned char IR_State;</span><br><span class="line"></span><br><span class="line">unsigned char IR_Data[4];</span><br><span class="line">unsigned char IR_Data_p;</span><br><span class="line"></span><br><span class="line">unsigned char IR_DataFlag;</span><br><span class="line">unsigned char IR_RepeatFlag;</span><br><span class="line"></span><br><span class="line">unsigned char IR_Address;</span><br><span class="line">unsigned char IR_Command;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void IR_Init()//红外中断初始化</span><br><span class="line">{</span><br><span class="line">Timer0_Init();</span><br><span class="line">Int0_Init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char IR_GetAdress(void)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">return</span> IR_Address;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char IR_GetCommand(void)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">return</span> IR_Command;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char IR_GetDataFlag(void)</span><br><span class="line">{</span><br><span class="line">unsigned int Flag = IR_DataFlag;</span><br><span class="line">IR_DataFlag=0;</span><br><span class="line"><span class="built_in">return</span> Flag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char IR_GetRepeatFlag(void)</span><br><span class="line">{</span><br><span class="line">unsigned int Flag = IR_RepeatFlag;</span><br><span class="line">IR_RepeatFlag=0;</span><br><span class="line"><span class="built_in">return</span> Flag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Int0_Rountine(void)interrupt 0 //外部中断函数，使用状态机方法</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IR_State==0)//起始时，一但红外管检测到按键按下，就会进入外部中断程序，从状态0开始</span><br><span class="line">{</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">Timer0_Run(1);</span><br><span class="line">IR_State=1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_State==1)//状态1</span><br><span class="line">{</span><br><span class="line">IR_Time=Timer0_GetCounter();</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line"><span class="keyword">if</span>(IR_Time&gt;12926-500 &amp;&amp; IR_Time&lt;12926+500)//检测红外管是否发送起始命令</span><br><span class="line">{</span><br><span class="line">P2=0;</span><br><span class="line">IR_State=2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_Time&gt;11250-500 &amp;&amp; IR_Time&lt;11250+500)//重复命令</span><br><span class="line">{</span><br><span class="line">IR_RepeatFlag=1;</span><br><span class="line">IR_State=0;</span><br><span class="line">Timer0_Run(0);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">IR_State=1;//自循环</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_State==2)//状态2</span><br><span class="line">{</span><br><span class="line">IR_Time=Timer0_GetCounter();</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line"><span class="keyword">if</span>(IR_Time&gt;1032-500 &amp;&amp; IR_Time&lt;1032+500)//将IR_Data中的某一位置零</span><br><span class="line">{</span><br><span class="line">IR_Data[IR_Data_p/8] &amp;= ~(0x01&lt;&lt;(IR_Data_p%8)); // 0x01&lt;&lt;<span class="string">1 0000 0001 0000 0010 ~(0x01&lt;&lt;1</span>) 1111 1110 1111 1101</span><br><span class="line">//IR_Data_p++/8,对应的值从0到3</span><br><span class="line">//IR_Data_p++%8,对应的值0~7循环四轮</span><br><span class="line">IR_Data_p++;//Data的二进制位指针,0~31</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_Time&gt;2074-500 &amp;&amp; IR_Time&lt;2074+500)</span><br><span class="line">{</span><br><span class="line">IR_Data[IR_Data_p/8] |= (0x01&lt;&lt;(IR_Data_p%8)); // 0x01&lt;&lt;<span class="string">1 0000 0001 0000 0010 ~(0x01&lt;&lt;1</span>) 1111 1110 1111 1101</span><br><span class="line">//IR_Data_p++/8,对应的值从0到3</span><br><span class="line">//IR_Data_p++%8,对应的值0~7循环四轮</span><br><span class="line">IR_Data_p++;//Data的二进制位指针,0~31</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">IR_Data_p=0;</span><br><span class="line">IR_State=1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(IR_Data_p&gt;=32)</span><br><span class="line">{</span><br><span class="line">IR_Data_p=0;//位指针清零</span><br><span class="line"><span class="keyword">if</span>((IR_Data[<span class="number">0</span>] == ~IR_Data[<span class="number">1</span>]) &amp;&amp; (IR_Data[<span class="number">2</span>] == ~IR_Data[<span class="number">3</span>]))</span><br><span class="line">{</span><br><span class="line">IR_DataFlag=1;</span><br><span class="line">IR_Address=IR_Data[0];</span><br><span class="line">IR_Command=IR_Data[2];</span><br><span class="line">}</span><br><span class="line">Timer0_Run(0);</span><br><span class="line">IR_State=0;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3.主函数<br>运行问题1：在没有&gt;IR_GetDataFlag()||IR_GetRepeatFlag()&lt;的情况下，按下对应的红外按键也会产生连加的现象，这里<br>//if(Command==0x15)<br>//{<br>//Num–;<br>//}<br>//if(Command==0x09)<br>//{<br>//Num++;<br>//}跳出了&gt;if(IR_GetDataFlag())，<strong>只要红外遥控发出信号，红外发送管会产生对应的数据码，只要红外发送管产生单个方波信号，NUM也能自加，正确情况下应该是产生完整的数据码，然后标志位=1，NUM才能加一，这里出现了代码书写逻辑的错误</strong>&lt;</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "IR.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char Num;</span><br><span class="line">unsigned char Command,Address;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">IR_Init();</span><br><span class="line">LCD_ShowString(1,1,<span class="string">"ADR  COM  NUM"</span>);//tab键会被识别</span><br><span class="line">LCD_ShowHexNum(2,1,00,2);</span><br><span class="line">LCD_ShowHexNum(2,6,00,2);</span><br><span class="line">LCD_ShowNum(2,11,00,3);</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IR_GetDataFlag()||IR_GetRepeatFlag())//IR_GetRepeatFlag连加标志位</span><br><span class="line">{</span><br><span class="line">Command=IR_GetCommand();</span><br><span class="line">Address=IR_GetAdress();</span><br><span class="line">LCD_ShowHexNum(2,1,Address,2);</span><br><span class="line">LCD_ShowHexNum(2,6,Command,2);</span><br><span class="line"><span class="keyword">if</span>(Command==0x15)</span><br><span class="line">{</span><br><span class="line">Num--;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Command==0x09)</span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">}</span><br><span class="line">LCD_ShowNum(2,11,Num,3);</span><br><span class="line">}</span><br><span class="line">//<span class="keyword">if</span>(Command==0x15)</span><br><span class="line">//{</span><br><span class="line">//Num--;</span><br><span class="line">//}</span><br><span class="line">//<span class="keyword">if</span>(Command==0x09)</span><br><span class="line">//{</span><br><span class="line">//Num++;</span><br><span class="line">//}</span><br><span class="line">//LCD_ShowNum(2,8,Num,2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改完成后，运行正常</p><blockquote><p><strong>现象：按下对应的按键，LCD1602上会显示对应的地址码，键码，以及NUM，按下控制NUM加减的按键，NUM会正确地进行自加减，并且具备连加/减地功能</strong><br><strong><mark>本程序用到了大量函数封装的方法，便于我们进行调用以及参数的判断，模块化编程极大地优化了代码的结构以及可移植性</mark></strong></p></blockquote><h2 id="二-红外通信pwm控制电机转速"><a class="markdownIt-Anchor" href="#二-红外通信pwm控制电机转速"></a> 二、红外通信+PWM控制电机转速</h2><p>1.主函数<br><strong>由于红外通信和PWM都要用到定时器/中断，这里同时使用到STC89C52中的定时器0和定时器1，使用定时器/红外中断时要注意区分优先级</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "IR.h"</span></span><br><span class="line"><span class="comment">#include "Timer1.h"</span></span><br><span class="line"><span class="comment">#include "Nixie.h"</span></span><br><span class="line"><span class="comment">#include "Motor.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char Num;</span><br><span class="line">unsigned char Command,Address;</span><br><span class="line">unsigned char Speed;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">Motor_Init();</span><br><span class="line">IR_Init();</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line">Command=IR_GetCommand();</span><br><span class="line"><span class="keyword">if</span>(IR_GetDataFlag())</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Command==IR_VOL_ADD)</span><br><span class="line">{</span><br><span class="line">Speed++;</span><br><span class="line">Speed%=4;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">switch(Speed)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> 0:Motor_CompareSet(0);<span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span> 1:Motor_CompareSet(50);<span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span> 2:Motor_CompareSet(75);<span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span> 3:Motor_CompareSet(100);<span class="built_in">break</span>;</span><br><span class="line">}</span><br><span class="line">Nixie(1,Speed);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2.直流电机模块（定时器1）<br>这里将占空比封装成函数<br><strong>思考：直接将子模块中的参数封装成函数，和直接调用全局变量的区别？</strong><br>封装成函数更便于调用</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer1.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned char Count,Compare;</span><br><span class="line"></span><br><span class="line">sbit Motor = P1^3;</span><br><span class="line"></span><br><span class="line">void Motor_Init(void)</span><br><span class="line">{</span><br><span class="line">Timer1_Init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Motor_CompareSet(unsigned char num)//占空比设置</span><br><span class="line">{</span><br><span class="line">Compare=num;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Timer1_Routine() interrupt 3 //PWM控速</span><br><span class="line">{</span><br><span class="line">TL1 = 0x9C;</span><br><span class="line">TH1 = 0xFF;</span><br><span class="line">Count++;</span><br><span class="line">Count%=100;</span><br><span class="line"><span class="keyword">if</span>(Count&lt;Compare)</span><br><span class="line">{</span><br><span class="line">Motor=1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor=0;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>现象：按下红外遥控上对应的按键，直流电机速度发生变化</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> 红外通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言入门学习】分支和循环</title>
      <link href="/posts/6621/"/>
      <url>/posts/6621/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言入门学习分支和循环"><a class="markdownIt-Anchor" href="#c语言入门学习分支和循环"></a> 【C语言入门学习】分支和循环</h1><p><strong>2024.2.20更新</strong></p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> #基本概念</h2><h3 id="一-语句"><a class="markdownIt-Anchor" href="#一-语句"></a> 一、语句</h3><p><strong>什么是语句？</strong><br>c语言中语句是用于控制计算机执行相关操作的指令，一个<mark>语句</mark>会被<mark>编译</mark>成若干条<mark>机器命令</mark>继而由计算机执行。</p><p><strong>语句的类型</strong></p><ul><li>表达式语句</li><li>函数调用语句</li><li>控制语句</li><li>复合语句</li><li>空语句</li></ul><blockquote><p>控制语句用于<mark>控制程序的执行流程</mark>，以实现程序的各种结构方式，它们由特定的语句定义符组成，C语言有九种控制语句。可分成以下三类：</p><ol><li>条件判断语句也叫分支语句：if语句、switch语句；</li><li>循环执行语句：do while语句、while语句、for语句；</li><li>转向语句：break语句、goto语句、continue语句、return语句</li></ol></blockquote><hr><h2 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> #代码部分</h2><h3 id="一-if分支语句"><a class="markdownIt-Anchor" href="#一-if分支语句"></a> 一、if分支语句</h3><p>if语句的书写规范，跳转<a href="https://blog.csdn.net/qq_63100905/article/details/135834241?spm=1001.2014.3001.5502">【c语言入门学习】代码的书写规范</a></p><h3 id="二-switch分支语句"><a class="markdownIt-Anchor" href="#二-switch分支语句"></a> 二、switch分支语句</h3><p>switch中break的实际作用是把语句列表划分为不同的分支部分，不加break，会一直向下执行程序</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">int n = 1;</span><br><span class="line">int m = 2;</span><br><span class="line">switch (n)//switch执行一次条件判断，然后指定到对应的<span class="keyword">case</span>语句中</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> 1:</span><br><span class="line">m++;//n=1,m=3</span><br><span class="line"><span class="keyword">case</span> 2://此处也会执行，因为没有上句没有<span class="built_in">break</span>跳出, <span class="keyword">case</span>不需要判断条件,直接执行语句内容</span><br><span class="line">n++;//n=2,m=3</span><br><span class="line"><span class="keyword">case</span> 3://执行</span><br><span class="line">switch (n)</span><br><span class="line">{//switch允许嵌套使用</span><br><span class="line"><span class="keyword">case</span> 1:</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">case</span> 2:</span><br><span class="line">m++;</span><br><span class="line">n++;//m=4,n=3</span><br><span class="line"><span class="built_in">break</span>;//break跳出自己所在的switch语句</span><br><span class="line">}</span><br><span class="line"><span class="keyword">case</span> 4:</span><br><span class="line">m++;//m=5,n=3</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">default:</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"m = %d, n = %d\n"</span>, m, n);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="三-while循环语句"><a class="markdownIt-Anchor" href="#三-while循环语句"></a> 三、while循环语句</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">//在<span class="keyword">while</span>循环中，<span class="built_in">break</span>用于永久中止循环</span><br><span class="line">int i = 1;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= 10)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i == 5)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">//在<span class="keyword">while</span>循环中，<span class="built_in">continue</span>的作用是跳过本次循环,直接去判断部分，看是否进行下一次循环体</span><br><span class="line">int i = 1;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= 10)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i == 5)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">}//执行结果：<span class="built_in">continue</span>执行时会直接跳转到<span class="keyword">while</span>判断部分，而i=5保持不变，程序无限循环</span><br></pre></td></tr></tbody></table></figure><h3 id="do-while循环语句"><a class="markdownIt-Anchor" href="#do-while循环语句"></a> #do while循环语句</h3><p>先执行循环体，在执行循环判断</p><ul><li>do while较为少用</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">int i = 0;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hi\n"</span>);</span><br><span class="line">i++;</span><br><span class="line">} <span class="keyword">while</span> (i &lt; 5);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="三-for循环语句"><a class="markdownIt-Anchor" href="#三-for循环语句"></a> 三、for循环语句</h3><ul><li>for循环泛用性比while更好</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">int i = 0;//c语言风格<span class="keyword">for</span>语句之前需要定义变量,c++可以在<span class="keyword">for</span>循环内部定义</span><br><span class="line"><span class="keyword">for</span> (i = 1; i &lt;= 10; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i == 5)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">}//会执行i++，之后i=6</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);//结果跳过5</span><br><span class="line">}</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="for循环范例"><a class="markdownIt-Anchor" href="#for循环范例"></a> for循环范例：</h4><p><strong>for循环实现阶乘</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入n："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">{</span><br><span class="line">num = num * i;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()// <span class="keyword">for</span>循环 中最好不要在 循环体 内部 进行 变量再定义</span><br><span class="line">{</span><br><span class="line">int i = 0;</span><br><span class="line"><span class="keyword">for</span> (i = 0; i &lt; 10; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">i = 5;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>for循环实现1到10的阶乘和</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;<span class="comment">//1到10的阶乘</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//1到10的阶乘总和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">{</span><br><span class="line">num *= i;</span><br><span class="line">sum += num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d次和为:%d\n"</span>, i, sum);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//时间复杂度低，更高效的写法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"总的和为:%d\n"</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>for循环输出1到100中3的倍数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//写一个代码打印1-100之间所有3的倍数的数字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main008</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//判断i是否为3的倍数</span></span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="字符操作语句"><a class="markdownIt-Anchor" href="#字符操作语句"></a> #字符操作语句</h3><blockquote><p><strong>getchar</strong><br>作用：read/print “abcde” from stdin<br>可能的输出:<br>1.End of File reached<br>2.字符</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">//getchar() 获取一个字符</span><br><span class="line">//EOF end of file 文件结束的标识</span><br><span class="line">//putchar() 输出一个字符</span><br><span class="line">//int ch = getchar();</span><br><span class="line">//putchar(ch);</span><br><span class="line"></span><br><span class="line">int ch = 0;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line">{</span><br><span class="line">putchar(ch);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">//ctrl + z 读取到EOF结束</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">v</span><br><span class="line">v</span><br><span class="line">c</span><br><span class="line">c</span><br><span class="line">^Z</span><br><span class="line">D:\2_c++_项目\0_C_Project\01 分支和循环\Release\01 选择结构.exe (进程 39324)已退出，代码为 0。</span><br></pre></td></tr></tbody></table></figure><h4 id="范例密码程序"><a class="markdownIt-Anchor" href="#范例密码程序"></a> 范例：密码程序</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">char password[20] = { 0 };</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入密码："</span>);</span><br><span class="line">scanf(<span class="string">"%s"</span>, password);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请确认密码(Y/N)："</span>);</span><br><span class="line"></span><br><span class="line">//清除缓存区</span><br><span class="line">//getchar();//得到\n:回车</span><br><span class="line">//getchar();执行一次只能获取一个字符</span><br><span class="line"></span><br><span class="line">//清理缓冲区的多个字符</span><br><span class="line">int tmp = 0;</span><br><span class="line"><span class="keyword">while</span> ((tmp = getchar()) != <span class="string">'\n'</span>) //getchar函数得到的是字符，但是返回值是ASCII值等等，所以可以用整型变量获取</span><br><span class="line">{</span><br><span class="line">;//空操作</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int ch = getchar();</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'Y'</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"确认成功\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"确认失败\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>固定范围字符</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main07</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (ch &lt; <span class="string">'0'</span> || ch &gt;<span class="string">'9'</span>)<span class="comment">//这里为字符0和字符9</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="猜数字游戏"><a class="markdownIt-Anchor" href="#猜数字游戏"></a> 猜数字游戏</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个猜数字游戏</span></span><br><span class="line"><span class="comment">//1.自动产生一个1-100之间的数字</span></span><br><span class="line"><span class="comment">//2.猜数字</span></span><br><span class="line"><span class="comment">//a.猜对了，游戏结束</span></span><br><span class="line"><span class="comment">//b.猜错了，会告诉猜大了，还是猜小了，继续猜，直到猜对</span></span><br><span class="line"><span class="comment">//3.游戏可以一直玩，除非退出游戏</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">meun</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" ************************ \n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"******  猜数字游戏  ******\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****     1.开始      *****\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****     0.结束      *****\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" ************************ \n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Game</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//srand((unsigned int)time(NULL));//一个程序设置一次随机数种子函数就足够了，这里重复使用</span></span><br><span class="line"><span class="type">int</span> ret = rand() &amp; <span class="number">100</span> + <span class="number">1</span>;<span class="comment">//定义随机数，生成随机数的范围为0~32767,取模</span></span><br><span class="line"><span class="type">int</span> guess = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请猜数字："</span>);<span class="comment">//输入猜测的数字</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;guess);</span><br><span class="line"><span class="keyword">if</span> (guess &gt; ret)<span class="comment">//判断比较</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"猜大了\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (guess &lt; ret)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"猜小了\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" *         *\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"* *       * *\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"恭喜你猜对了！\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//退出循环</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));<span class="comment">//时间 - 时间戳</span></span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">meun();<span class="comment">//显示菜单</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请选择:&gt;"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (input)<span class="comment">//输入选择</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&lt;游戏开始&gt;\n"</span>);</span><br><span class="line">Game();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&lt;游戏结束&gt;\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&lt;输错了，请重新输入！&gt;\n"</span>);</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">while</span> (input); <span class="comment">//只要input不为0,程序继续执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="关机程序"><a class="markdownIt-Anchor" href="#关机程序"></a> 关机程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//关机</span></span><br><span class="line"><span class="comment">//c语言提供了一个函数:system() -执行系统命令的</span></span><br><span class="line"><span class="type">char</span> input[<span class="number">20</span>] = { <span class="number">0</span> }; <span class="comment">//存放输入的信息</span></span><br><span class="line">system(<span class="string">"shutdown -s -t 60"</span>);</span><br><span class="line">again:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请注意，你的电脑将在1分钟内关机，如果输入：我爱玩原神，就取消关机\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, input);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">"我爱玩原神"</span>) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">system(<span class="string">"shutdown -a"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二分值法"><a class="markdownIt-Anchor" href="#二分值法"></a> 二分值法</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个有序数组中查找具体的某个数字n。</span></span><br><span class="line"><span class="comment">//算法：二分值法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> };</span><br><span class="line"><span class="type">int</span> k = <span class="number">7</span>;<span class="comment">//要查找的数字</span></span><br><span class="line"><span class="comment">//在arr这个有序的数组中查找k对应的值</span></span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> mid = left + right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; k)</span><br><span class="line">{</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; k)</span><br><span class="line">{</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"要查找的值对应数组中的下标[%d]\n"</span>, mid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (left &gt; right)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组中没有待查找的值"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//当查找的范围在 6 ~ 7时，下标为5和6 ， 5+6/2 = 5 ，此时left +1 , mid = 6+6/2 =6 ，成功找到了7对应的下标</span></span><br></pre></td></tr></tbody></table></figure><h3 id="字符汇聚"><a class="markdownIt-Anchor" href="#字符汇聚"></a> 字符汇聚</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> arr1[] = <span class="string">"Welcome to bit!!!!!!"</span>;</span><br><span class="line"><span class="type">char</span> arr2[] = <span class="string">"####################"</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="built_in">strlen</span>(arr1) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;left &lt;= right; left++, right--)</span><br><span class="line">{</span><br><span class="line">arr2[left] = arr1[left];</span><br><span class="line">arr2[right] = arr1[right];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, arr2);</span><br><span class="line">Sleep(<span class="number">1000</span>);<span class="comment">//休眠一秒</span></span><br><span class="line">system(<span class="string">"cls"</span>);<span class="comment">//清空屏幕</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="密码验证程序"><a class="markdownIt-Anchor" href="#密码验证程序"></a> 密码验证程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span><span class="comment">//strlen strcmp</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> password[<span class="number">20</span>] = {<span class="number">0</span>};<span class="comment">//定义字符串 ， 假设密码为123456</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)<span class="comment">//限制三次循环</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入密码:&gt;"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, password);<span class="comment">//数组名本身就是地址</span></span><br><span class="line"><span class="comment">//if(password == "123456") //字符串不能用判断操作符</span></span><br><span class="line"><span class="comment">//if (strcmp(password, "123456")) //错误示例，if内要写条件“判断”，不然会直接执行！</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(password, <span class="string">"123456"</span>)) == <span class="number">0</span>)<span class="comment">//strcmp,依次比较ascii码值</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"密码正确\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"密码错误\n"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//printf("连续三次输入错误密码，程序退出..."); 直接写这一句，不正确，会导致输入正确密码后，跳出循环，也打印这句内容</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"连续三次输入错误密码，程序退出...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">1</span>, c = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = { a,b,c };</span><br><span class="line"><span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"原始数组为:"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 a,b,c的值不能直接改变arr中元素的值,实际上在初始定义arr时将a,b,c的值传入了arr而不是变量本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[j + <span class="number">1</span>])</span><br><span class="line">{</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"从高到低排序："</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>, arr[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="求最大公约数"><a class="markdownIt-Anchor" href="#求最大公约数"></a> 求最大公约数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);<span class="comment">//24 18</span></span><br><span class="line"><span class="comment">//如果两个数分别为24和18，最大公约数只能在18及以下</span></span><br><span class="line"><span class="type">int</span> min = <span class="number">0</span>;<span class="comment">//判断两个数谁更小</span></span><br><span class="line"><span class="keyword">if</span> (m &gt; n)</span><br><span class="line">{</span><br><span class="line">min = n;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m &lt; n)</span><br><span class="line">{</span><br><span class="line">min = m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">min = m;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="comment">//int maxgy = 0;//最大公约数</span></span><br><span class="line"><span class="comment">//for (i = 1; i &lt;= min; i++)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//if (m % i || n % i == 0)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//maxgy = i;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////方法二</span></span><br><span class="line"><span class="comment">//while (1)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//if (m % min == 0 &amp;&amp; n % min == 0)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//printf("最大公约数是：%d\n", min);</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//min--;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//辗转相除法</span></span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (t = m % n)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//t = m % n;</span></span><br><span class="line">m = n;</span><br><span class="line">n = t;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最大公约数是：%d\n"</span>, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="闰年判断程序"><a class="markdownIt-Anchor" href="#闰年判断程序"></a> 闰年判断程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断 1000~2000年 之间哪些年份是闰年</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> y, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">1000</span>; y &lt;= <span class="number">2000</span>; y++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> ((y % <span class="number">100</span> != <span class="number">0</span> &amp;&amp; y % <span class="number">4</span> == <span class="number">0</span>) || (y % <span class="number">400</span> == <span class="number">0</span>)) <span class="comment">//y % 100 == n  n不是非零即1 n是任意整数</span></span><br><span class="line"><span class="comment">//y % 100 == 0 &amp; y % 400 == 0</span></span><br><span class="line"><span class="comment">//y % 400 = 0 更简洁</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"闰年为：%d年\n"</span>, y);</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"闰年个数为：%d"</span>, count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="素数判断程序"><a class="markdownIt-Anchor" href="#素数判断程序"></a> 素数判断程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个代码, 打印100~200之间的素数</span></span><br><span class="line"><span class="comment">//素数-质数</span></span><br><span class="line"><span class="comment">//只能被1和他本身整除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码优化</span></span><br><span class="line"><span class="comment">//执行次数更少</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">100</span>; i &lt;= <span class="number">200</span>; i++)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; i; j++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (j == i)<span class="comment">//如果i是素数,j会一直自加一直到等于i</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d为素数\n"</span>, i);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个代码,打印100~200之间的素数</span></span><br><span class="line"><span class="comment">//素数-质数</span></span><br><span class="line"><span class="comment">//只能被1和他本身整除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码优化1：</span></span><br><span class="line"><span class="comment">//m=a*b;</span></span><br><span class="line"><span class="comment">//a和b中一定至少有一个数字是 &lt;=开平方m的</span></span><br><span class="line"><span class="comment">//16 = 2*8 = 4*4</span></span><br><span class="line"><span class="comment">//所以，大于开平方m的就不需要判断是否为m的因子，减少循环执行次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sqrt用于计算开平方的函数 -需要用到库函数 math.h</span></span><br><span class="line"><span class="comment">//减少了循环的执行次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码优化2：</span></span><br><span class="line"><span class="comment">//偶数不可能是素数</span></span><br><span class="line"><span class="comment">//修改for (i = 100; i &lt;= 200; i ++)为for (i = 101; i &lt;= 200; i += 2)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断i是不是质数</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">101</span>; i &lt;= <span class="number">200</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//定义一个参数，检测i是否能被 除了1和它本身的数 整除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= <span class="built_in">sqrt</span>(i); j++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">flag = <span class="number">0</span>;<span class="comment">//如果能被2到i-1之间的整除，记录flag=0;</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)<span class="comment">//不能被2到i-1之间的数整除</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d是质数\n"</span>, i);<span class="comment">//那么i就是质数</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】DS18B20</title>
      <link href="/posts/18830/"/>
      <url>/posts/18830/</url>
      
        <content type="html"><![CDATA[<p>2024.1.29更新</p><p>2024.3.2</p><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><blockquote><p>所用外设：</p></blockquote><blockquote><p><mark>DS18B20温度传感器（OneWire协议）</mark></p></blockquote><h2 id="前置概念"><a class="markdownIt-Anchor" href="#前置概念"></a> #前置概念</h2><h3 id="一-onewire单总线协议"><a class="markdownIt-Anchor" href="#一-onewire单总线协议"></a> 一、OneWire（单总线）协议</h3><p>•单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线</p><p>•一根通信线：DQ</p><p>•异步、半双工</p><p>•单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线</p><h3 id="二-单总线电路规范"><a class="markdownIt-Anchor" href="#二-单总线电路规范"></a> 二、单总线电路规范</h3><p>•设备的DQ均要配置成开漏输出模式</p><p>•DQ添加一个上拉电阻，阻值一般为4.7KΩ左右</p><p>•若此总线的从机采取寄生供电，则主机还应配一个强上拉输出电路</p><img src="/posts/18830/image-20240302232447437.png" class="" title="image-20240302232447437"><h3 id="三-单总线的时序结构"><a class="markdownIt-Anchor" href="#三-单总线的时序结构"></a> 三、单总线的时序结构</h3><img src="/posts/18830/image-20240302232633388.png" class="" title="image-20240302232633388"><img src="/posts/18830/image-20240302232648244.png" class="" title="image-20240302232648244"><img src="/posts/18830/image-20240302232700200.png" class="" title="image-20240302232700200"><img src="/posts/18830/image-20240302232708528.png" class="" title="image-20240302232708528"><hr><h2 id="ds18b20介绍"><a class="markdownIt-Anchor" href="#ds18b20介绍"></a> DS18B20介绍</h2><p>•DS18B20是一种常见的数字温度传感器，其控制命令和数据都是以数字信号的方式输入输出，相比较于模拟温度传感器，具有功能强大、硬件简单、易扩展、抗干扰性强等特点</p><p>•测温范围：-55°C 到 +125°C</p><p>•通信接口：1-Wire（单总线）</p><p>•其它特征：可形成总线结构、内置温度报警功能、可寄生供电</p><h3 id="一-ds18b20温度存储格式"><a class="markdownIt-Anchor" href="#一-ds18b20温度存储格式"></a> 一、DS18B20温度存储格式</h3><img src="/posts/18830/1c9c55dd044b4cdb9e2c305088ccec28.png" class="" title="在这里插入图片描述"><blockquote><p><strong>MS BYTE和LS BYTE两个字节中BIT的解释：<br>BIT16~BIT11作为符号位，表示温度的正负<br>BIT10~BIT4存储温度的整数部分<br>BIT3~BIT0存储温度的小数部分（<mark>精度</mark>），BIT0 ‘1’对应 "0.0625"</strong></p></blockquote><h3 id="二-ds18b20时序"><a class="markdownIt-Anchor" href="#二-ds18b20时序"></a> 二、DS18B20时序</h3><img src="/posts/18830/image-20240302232951493.png" class="" title="image-20240302232951493"><img src="/posts/18830/image-20240302232958679.png" class="" title="image-20240302232958679"><h3 id="三-程序编写"><a class="markdownIt-Anchor" href="#三-程序编写"></a> 三、程序编写</h3><p>首先写第一个函数，用于初始化，其中添加Askbit，在LCD1602上显示一个数值，观察初始化函数是否有效，即从机是否响应。</p><p>首先编写好单总线的初始化程序，如果代码正确，根据单总线的通信协议，从机会发送一个应答信号（拉低总线）。<br>进行应答测试，通过LCD1602观察应答位，检测代码是否有效</p><h2 id="-code0-"><a class="markdownIt-Anchor" href="#-code0-"></a> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">sbit OneWire_DQ=P3^7;//通信口</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_Init(void)</span><br><span class="line">{</span><br><span class="line">unsigned char i,Askbit;</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 227;<span class="keyword">while</span> (--i);//500um</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">i = 29;<span class="keyword">while</span> (--i);//70um</span><br><span class="line">Askbit = OneWire_DQ;</span><br><span class="line"><span class="built_in">return</span> Askbit;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></h2><h2 id="一-ds18b20温度读取"><a class="markdownIt-Anchor" href="#一-ds18b20温度读取"></a> 一、DS18B20温度读取</h2><p>将程序下载到单片机上，运行<br>如下为main.c文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "DS18B20.h"</span></span><br><span class="line"><span class="comment">#include "OneWire.h"</span></span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(1,1,<span class="string">"Temperture:"</span>);</span><br><span class="line">DS18B20_Start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line">unsigned int temp=DS18B20_Read()*10000;</span><br><span class="line"><span class="keyword">if</span>(temp&gt;0)</span><br><span class="line">{</span><br><span class="line">LCD_ShowString(2,1,<span class="string">"+"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(temp&lt;0)</span><br><span class="line">{</span><br><span class="line">LCD_ShowString(2,1,<span class="string">"-"</span>);</span><br><span class="line">}</span><br><span class="line">LCD_ShowNum(2,2,temp/10000,4);</span><br><span class="line">LCD_ShowNum(2,6,temp%10000,4);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>结果异常：LCD1602第二行显示不正确数据/显示-000.0625<br>分析：<br>main.c中存在语法错误<br>OneWire.c DS18B20.c中的函数时序定义有误</p><img src="/posts/18830/d0595a62616c4d33a0f28a153c487761.jpeg" class="" title="请添加图片描述"></blockquote><p>对main.c进行更改</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Delay.h"</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "DS18B20.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> T;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">DS18B20_Convert();</span><br><span class="line">Delay(1000);</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(1,1,<span class="string">"Temperature:"</span>);</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line">DS18B20_Convert();</span><br><span class="line">T=DS18B20_Read();</span><br><span class="line"><span class="keyword">if</span>(T&lt;0)</span><br><span class="line">{</span><br><span class="line">LCD_ShowChar(2,1,<span class="string">'-'</span>);</span><br><span class="line">T=-T;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LCD_ShowChar(2,1,<span class="string">'+'</span>);</span><br><span class="line">}</span><br><span class="line">LCD_ShowNum(2,2,T,3);</span><br><span class="line">LCD_ShowChar(2,5,<span class="string">'.'</span>);</span><br><span class="line">LCD_ShowNum(2,6,(unsigned long)(T*10000)%10000,4);//强制类型转换</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>OneWire.c 错误分析：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">sbit OneWire_DQ=P3^7;//通信口</span><br><span class="line"></span><br><span class="line">void OneWire_Init(void)</span><br><span class="line">{</span><br><span class="line">unsigned char i,AskBit;</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 227;<span class="keyword">while</span> (--i);//500um</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 29;<span class="keyword">while</span> (--i);//70um</span><br><span class="line">AskBit=OneWire_DQ;//主机判断从机是否发送应答</span><br><span class="line">i = 227;<span class="keyword">while</span> (--i);//500um,要根据时序图构造代码</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_SendBit(unsigned char Bit)//发送一位</span><br><span class="line">{</span><br><span class="line">unsigned char i;</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">i = 2;<span class="keyword">while</span> (--i);//10um</span><br><span class="line">OneWire_DQ=Bit;</span><br><span class="line">i = 22;<span class="keyword">while</span> (--i);//54um</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_ReadBit(void)//接收一位</span><br><span class="line">{</span><br><span class="line">unsigned char i,Bit;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 2;<span class="keyword">while</span> (--i);//10um</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 2;<span class="keyword">while</span> (--i);//10um</span><br><span class="line">Bit=OneWire_DQ;</span><br><span class="line">i = 22;<span class="keyword">while</span> (--i);//54um</span><br><span class="line"><span class="built_in">return</span> Bit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_WriteByte(int Byte)</span><br><span class="line">{</span><br><span class="line">unsigned int i;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line">OneWire_SendBit(Byte&amp;(0x01&lt;&lt;<span class="string">i));//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unsigned char OneWire_ReadByte()</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">unsigned int i</span>;</span><br><span class="line">unsigned int Byte;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line">Byte=OneWire_ReadBit()|(0x01&lt;&lt;<span class="string">i);//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">return Byte;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure><p><mark>对OneWire.c进行更改</mark></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">sbit OneWire_DQ=P3^7;//通信口</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_Init(void)</span><br><span class="line">{</span><br><span class="line">unsigned char i,AskBit;</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 247;<span class="keyword">while</span> (--i);//500us</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 29;<span class="keyword">while</span> (--i);//70us</span><br><span class="line">AskBit=OneWire_DQ;//主机判断从机是否发送应答</span><br><span class="line">i = 247;<span class="keyword">while</span> (--i);//500um,要根据时序图构造代码</span><br><span class="line"><span class="built_in">return</span> AskBit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_SendBit(unsigned char Bit)//发送一位</span><br><span class="line">{</span><br><span class="line">unsigned char i;</span><br><span class="line">OneWire_DQ=0;//错误，应为0</span><br><span class="line">i = 2;<span class="keyword">while</span> (--i);//10us</span><br><span class="line">OneWire_DQ=Bit;</span><br><span class="line">i = 20;<span class="keyword">while</span> (--i);//50us</span><br><span class="line">OneWire_DQ=1;//遗漏</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_ReadBit(void)//接收一位</span><br><span class="line">{</span><br><span class="line">unsigned char i,Bit;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 1;<span class="keyword">while</span> (--i);//8us</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 1;<span class="keyword">while</span> (--i);//8us</span><br><span class="line">Bit=OneWire_DQ;</span><br><span class="line">i = 20;<span class="keyword">while</span> (--i);//50us</span><br><span class="line"><span class="built_in">return</span> Bit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_WriteByte(unsigned char Byte)</span><br><span class="line">{</span><br><span class="line">unsigned char i;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line">OneWire_SendBit(Byte&amp;(0x01&lt;&lt;<span class="string">i));//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unsigned char OneWire_ReadByte(void)</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">unsigned char i</span>;</span><br><span class="line">unsigned char Byte=0x00;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(OneWire_ReadBit()){Byte|=(0x01&lt;&lt;<span class="string">i);}//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">return Byte;</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>结论：OneWire_SendBit函数对总线的电平处理不正确</strong><br>void OneWire_SendBit(unsigned char Bit)//发送一位<br>{<br>unsigned char i;<br>OneWire_DQ=1;//<mark>此处错误，应为0</mark><br>i = 2;while (–i);//10us<br>OneWire_DQ=Bit;<br>i = 20;while (–i);//50us<br>OneWire_DQ=1;//遗漏<br>}</p><h2 id="二-ds18b20温度报警器"><a class="markdownIt-Anchor" href="#二-ds18b20温度报警器"></a> 二、DS18B20温度报警器</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Delay.h"</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "DS18B20.h"</span></span><br><span class="line"><span class="comment">#include "AT24C02.h"</span></span><br><span class="line"><span class="comment">#include "I2C.h"</span></span><br><span class="line"><span class="comment">#include "Key.h"</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//mark</span><br><span class="line">//在编写单片机程序时，要考虑到运行的高效性，定义变量的数据类型，优先选择较低内存占用的类型</span><br><span class="line"><span class="built_in">float</span> T;</span><br><span class="line"><span class="built_in">float</span> Tshow;</span><br><span class="line">char Thigh,Tlow;</span><br><span class="line">unsigned char KeyNum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">Thigh=AT24C02_ReadByte(0);//每次开机，读取存储器中的数据</span><br><span class="line">Tlow=AT24C02_ReadByte(1);</span><br><span class="line"></span><br><span class="line">DS18B20_Convert();//温度装载，防止T第一次读取到的是默认值20，消除多余现象</span><br><span class="line">Delay(1000);</span><br><span class="line"></span><br><span class="line">LCD_Init();</span><br><span class="line">Timer0_Init();</span><br><span class="line">LCD_ShowString(1,1,<span class="string">"T:"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line">DS18B20_Convert();//温度装载</span><br><span class="line">T=DS18B20_Read();</span><br><span class="line"><span class="keyword">if</span>(T&lt;0)</span><br><span class="line">{</span><br><span class="line">LCD_ShowChar(1,3,<span class="string">'-'</span>);</span><br><span class="line">//T=-T,这里T=-T的话，进行温度预置判断有问题，所以再定义一个变量Tshow</span><br><span class="line">Tshow=-T;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LCD_ShowChar(1,3,<span class="string">'+'</span>);</span><br><span class="line">Tshow=T;</span><br><span class="line">}</span><br><span class="line">LCD_ShowNum(1,4,Tshow,3);</span><br><span class="line">LCD_ShowChar(1,7,<span class="string">'.'</span>);</span><br><span class="line">LCD_ShowNum(1,8,(unsigned char)(Tshow*100)%100,2);</span><br><span class="line"></span><br><span class="line">//温度阈值控制</span><br><span class="line">KeyNum=Key();</span><br><span class="line"><span class="keyword">if</span>(KeyNum)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(KeyNum==1)</span><br><span class="line">{</span><br><span class="line">Thigh++;</span><br><span class="line"><span class="keyword">if</span>(Thigh&gt;125)</span><br><span class="line">{</span><br><span class="line">Thigh--;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KeyNum==2)</span><br><span class="line">{</span><br><span class="line">Thigh--;</span><br><span class="line"><span class="keyword">if</span>(Thigh&lt;=Tlow)</span><br><span class="line">{</span><br><span class="line">Thigh++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KeyNum==3)</span><br><span class="line">{</span><br><span class="line">Tlow++;</span><br><span class="line"><span class="keyword">if</span>(Tlow&gt;=Thigh)</span><br><span class="line">{</span><br><span class="line">Tlow--;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KeyNum==4)</span><br><span class="line">{</span><br><span class="line">Tlow--;</span><br><span class="line"><span class="keyword">if</span>(Tlow&lt;-125)</span><br><span class="line">{</span><br><span class="line">Tlow++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">AT24C02_WriteByte(0,Thigh);</span><br><span class="line">Delay(5);</span><br><span class="line">AT24C02_WriteByte(1,Tlow);</span><br><span class="line">Delay(5);</span><br><span class="line">}</span><br><span class="line">//Thigh=AT24C02_ReadByte(1);</span><br><span class="line">    //Tlow=AT24C02_ReadByte(2);错误写法，会导致出现短暂的Thigh或者Tlow被赋值0,AT24C02没来得及读取数据就赋值给变量</span><br><span class="line">LCD_ShowString(2,1,<span class="string">"TH:"</span>);</span><br><span class="line">LCD_ShowString(2,10,<span class="string">"TL:"</span>);</span><br><span class="line">LCD_ShowSignedNum(2,4,Thigh,3);//显示带符号的数字</span><br><span class="line">LCD_ShowSignedNum(2,13,Tlow,3);</span><br><span class="line"></span><br><span class="line">//温度报警，LCD1602显示</span><br><span class="line"><span class="keyword">if</span>(T&gt;Thigh)</span><br><span class="line">{</span><br><span class="line">LCD_ShowString(1,13,<span class="string">"OV:H"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T&lt;Tlow)</span><br><span class="line">{</span><br><span class="line">LCD_ShowString(1,13,<span class="string">"OV:L"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LCD_ShowString(1,13,<span class="string">"    "</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Timer0_Routine() interrupt 1 //中断子程序</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">static unsigned int T0Count1;//静态局部变量，保证退出函数之后不销毁</span><br><span class="line">TL0 = 0x66;//设置定时初始值</span><br><span class="line">TH0 = 0xFC;//设置定时初始值</span><br><span class="line">T0Count1++;//每次进入中断子程序，秒控制器自加一</span><br><span class="line"><span class="keyword">if</span>(T0Count1&gt;=20)</span><br><span class="line">{</span><br><span class="line">T0Count1=0;</span><br><span class="line">Key_Loop();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>实验现象1：加入定时器扫描按键后，按下按键不影响温度的读取和显示，但是LCD1602上显示的温度数值会出现闪烁的状态<br>分析：每隔20ms进入中断程序，对按键进行扫描检测，但是，单总线上对数据的发送和接受，部分过程时间在几十us，远远小于20ms,中断程序打断了温度的正常读取<br>解决方案：每个OneWire的读写操作加入定时器的关闭动作，这样不会对OneWire的读写操作产生影响</strong><br><mark>如下:</mark></p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">sbit OneWire_DQ=P3^7;//通信口</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_Init(void)</span><br><span class="line">{</span><br><span class="line">unsigned char i,AskBit;</span><br><span class="line">EA=0;</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 247;<span class="keyword">while</span> (--i);//500us</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 29;<span class="keyword">while</span> (--i);//70us</span><br><span class="line">AskBit=OneWire_DQ;//主机判断从机是否发送应答</span><br><span class="line">i = 247;<span class="keyword">while</span> (--i);//500um,要根据时序图构造代码</span><br><span class="line">EA=1;</span><br><span class="line"><span class="built_in">return</span> AskBit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_SendBit(unsigned char Bit)//发送一位</span><br><span class="line">{</span><br><span class="line">unsigned char i;</span><br><span class="line">EA=0;</span><br><span class="line">OneWire_DQ=0;//错误，应为0</span><br><span class="line">i = 2;<span class="keyword">while</span> (--i);//10us</span><br><span class="line">OneWire_DQ=Bit;</span><br><span class="line">i = 20;<span class="keyword">while</span> (--i);//50us</span><br><span class="line">OneWire_DQ=1;//遗漏</span><br><span class="line">EA=1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_ReadBit(void)//接收一位</span><br><span class="line">{</span><br><span class="line">unsigned char i,Bit;</span><br><span class="line">EA=0;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 1;<span class="keyword">while</span> (--i);//8us</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 1;<span class="keyword">while</span> (--i);//8us</span><br><span class="line">Bit=OneWire_DQ;</span><br><span class="line">i = 20;<span class="keyword">while</span> (--i);//50us</span><br><span class="line">EA=1;</span><br><span class="line"><span class="built_in">return</span> Bit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_WriteByte(unsigned char Byte)</span><br><span class="line">{</span><br><span class="line">unsigned char i;</span><br><span class="line">EA=0;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line">OneWire_SendBit(Byte&amp;(0x01&lt;&lt;<span class="string">i));//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">EA=1;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unsigned char OneWire_ReadByte(void)</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">unsigned char i</span>;</span><br><span class="line">unsigned char Byte=0x00;</span><br><span class="line">EA=0;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(OneWire_ReadBit()){Byte|=(0x01&lt;&lt;<span class="string">i);}//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">EA=1;</span></span><br><span class="line"><span class="string">return Byte;</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p><mark>缺点：对定时器有较大影响，需要区分任务的优先级，这里我们只有对温度进行处理的任务，一但存在多个任务，比如这里同时在数码管上显示一个时钟，使用单总线的局限性会非常大</mark><br><mark>IIC通信方式一般比单总线广泛地多</mark><br><mark>思考：IIC和单总线地区别</mark></p><hr><h1 id="蓝桥杯stc15拓展"><a class="markdownIt-Anchor" href="#蓝桥杯stc15拓展"></a> 蓝桥杯(STC15)拓展</h1><p><strong>OneWire底层</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*# 单总线代码片段说明</span></span><br><span class="line"><span class="comment">1. 本文件夹中提供的驱动代码供参赛选手完成程序设计参考。</span></span><br><span class="line"><span class="comment">2. 参赛选手可以自行编写相关代码或以该代码为基础，根据所选单片机类型、运行速度和试题</span></span><br><span class="line"><span class="comment">中对单片机时钟频率的要求，进行代码调试和修改。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;onewire.h&gt;</span></span></span><br><span class="line">sbit DQ= P1^<span class="number">4</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_OneWire</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>  </span><br><span class="line">{</span><br><span class="line">t *= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_DS18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">DQ = dat&amp;<span class="number">0x01</span>;</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_DS18B20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(DQ)</span><br><span class="line">{</span><br><span class="line">dat |= <span class="number">0x80</span>;</span><br><span class="line">}    </span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">bit <span class="title function_">init_ds18b20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  bit initflag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">12</span>);</span><br><span class="line">  DQ = <span class="number">0</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">80</span>);</span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">10</span>); </span><br><span class="line">    initflag = DQ;     </span><br><span class="line">  Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> initflag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基于底层编写*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">ds18b20_read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> low,high;<span class="comment">//高八位，低八位，DS18B20温度数据是十六位二进制</span></span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0x44</span>);<span class="comment">//ds18b20开始温度转换</span></span><br><span class="line">    </span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0xbe</span>);<span class="comment">//ds18b20开始温度读取</span></span><br><span class="line">low=Read_DS18B20();</span><br><span class="line">high=Read_DS18B20();</span><br><span class="line"><span class="keyword">return</span>((high &lt;&lt; <span class="number">8</span> )| low) /<span class="number">16.0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="主模块ds18b20模拟题"><a class="markdownIt-Anchor" href="#主模块ds18b20模拟题"></a> 主模块(DS18B20模拟题)</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;onewire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Disp_Mode;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Tempture=<span class="number">0</span>;<span class="comment">//实时温度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Tempture_Disp=<span class="number">25</span>;<span class="comment">//温度暂存设置参数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Tempture_Control=<span class="number">25</span>;<span class="comment">//温度阈值参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> DAC_Output=<span class="number">3.25</span>;<span class="comment">//DAC输出电压</span></span><br><span class="line">bit DAC_Output_MODE;<span class="comment">//DAC输出模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();<span class="comment">//读取键值</span></span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//读取上升沿键值</span></span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//读取下降沿键值</span></span><br><span class="line">Key_Old=Key_Val;<span class="comment">//保存键值（旧键值）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Key_Down) </span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span>(Nixie_Disp_Mode==<span class="number">0</span>){Tempture_Disp=Tempture_Control;}<span class="comment">//上一个界面为实时温度显示界面时</span></span><br><span class="line"><span class="keyword">if</span>(Nixie_Disp_Mode==<span class="number">1</span>){Tempture_Control=Tempture_Disp;}<span class="comment">//上一个界面为温度阈值设置显示界面时</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Disp_Mode==<span class="number">3</span>){Nixie_Disp_Mode=<span class="number">0</span>;}<span class="comment">//模式切换 0~模式1 1~模式2</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">DAC_Output_MODE^=<span class="number">1</span>;<span class="comment">//DAC输出模式切换</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="keyword">if</span>(Nixie_Disp_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Tempture_Disp==<span class="number">100</span>){Tempture_Disp=<span class="number">0</span>;}<span class="comment">//前置+1,判断条件刚好为溢出值</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="keyword">if</span>(Nixie_Disp_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--Tempture_Disp==<span class="number">255</span>){Tempture_Disp=<span class="number">99</span>;}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信息处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line">Tempture=ds18b20_read();<span class="comment">//实时温度读取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Nixie_Disp_Mode)<span class="comment">//数码管多模式显示</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">13</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)Tempture/<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)Tempture%<span class="number">10</span>;</span><br><span class="line">Nixie_Point[<span class="number">5</span>]=<span class="number">1</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=(<span class="type">unsigned</span> <span class="type">int</span>)(Tempture*<span class="number">10</span>)%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=(<span class="type">unsigned</span> <span class="type">int</span>)(Tempture*<span class="number">100</span>)%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Point[<span class="number">5</span>]=<span class="number">0</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=Tempture_Disp/<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=Tempture_Disp%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">11</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)DAC_Output;</span><br><span class="line">Nixie_Point[<span class="number">5</span>]=<span class="number">1</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)(DAC_Output*<span class="number">10</span>)%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=(<span class="type">unsigned</span> <span class="type">int</span>)(DAC_Output*<span class="number">100</span>)%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他显示函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="comment">/*实时输出DAC电压*/</span></span><br><span class="line">DA_Write((<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">51</span>*DAC_Output));<span class="comment">//DAC输出</span></span><br><span class="line"><span class="keyword">if</span>(DAC_Output_MODE==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Tempture&lt;Tempture_Control)</span><br><span class="line">{</span><br><span class="line">DAC_Output=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">DAC_Output=<span class="number">5.0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Tempture&lt;<span class="number">20</span>)</span><br><span class="line">{</span><br><span class="line">DAC_Output=<span class="number">1.0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Tempture&gt;<span class="number">40</span>)</span><br><span class="line">{</span><br><span class="line">DAC_Output=<span class="number">4.0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">DAC_Output=<span class="number">0.15</span>*(Tempture<span class="number">-20</span>)+<span class="number">1.0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">ucLED[<span class="number">0</span>]=~DAC_Output_MODE;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">{</span><br><span class="line">ucLED[i+<span class="number">1</span>]= (i==Nixie_Disp_Mode);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay750ms</span><span class="params">()</span> <span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j, k;</span><br><span class="line">i = <span class="number">35</span>;</span><br><span class="line">j = <span class="number">51</span>;</span><br><span class="line">k = <span class="number">182</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (--k)</span><br><span class="line">;</span><br><span class="line">} <span class="keyword">while</span> (--j);</span><br><span class="line">} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Tempture=ds18b20_read();<span class="comment">//ds18b20第一次默认读取的是85</span></span><br><span class="line">Delay750ms();</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行任务</span></span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line">Nixie_Proc();</span><br><span class="line">LED_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">300</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//300ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">10</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//10ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED循环“值”检测，发生变化则对LED相关IO发生电平变化</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数字电路】课程设计</title>
      <link href="/posts/24146/"/>
      <url>/posts/24146/</url>
      
        <content type="html"><![CDATA[<h2 id="设计题目-智能消防系统"><a class="markdownIt-Anchor" href="#设计题目-智能消防系统"></a> 设计题目： 智能消防系统</h2><p><strong>题目来源： 2023 年全国大学生电子设计竞赛试题试题 G 题</strong></p><h3 id="一-任务"><a class="markdownIt-Anchor" href="#一-任务"></a> 一、 任务：</h3><ul><li>设计一套智能消防系统， 采用 FPGA 实验板。 防区区域为 40dm× 48dm，</li><li>可能出现的火源如图所示的 1、 2、 3、 4。 当消防车接收到火源地点位置信息即刻前往熄灭火源， 消防工作完成时间越短越好。 其中白色部分是街区， 消防车不得驶入， 红色区域是消防车停车点。<img src="/posts/24146/dac9932d16494eaf88b83d8983639dfd-17086935318804.png" class="" title="在这里插入图片描述"></li></ul><h3 id="二-要求"><a class="markdownIt-Anchor" href="#二-要求"></a> 二、 要求：</h3><ul><li>消防车起始停留在红色区域， 接收到火情信息并显示火源地点位置坐标后，</li><li>出发前往火源地点， 途中不得碾压街区及其边界线。 消防车距离火源地点 5dm内停车， 发出声光报警， 持续 5 秒， 表示将模拟火源熄灭， 之后消防车返回红色区域。 从消防车出发到返回红色区域， 用时越短越好</li></ul><h3 id="三-硬件部分"><a class="markdownIt-Anchor" href="#三-硬件部分"></a> 三、硬件部分</h3><ul><li>主要结构：4驱直流电机小车</li><li>主控：FPGA</li><li>传感器：1.四路循迹模块（避线）   2.红外计数器（测速/里程计算）</li><li>代码主要语法：状态机</li></ul><h3 id="四-解题四路"><a class="markdownIt-Anchor" href="#四-解题四路"></a> 四、解题四路</h3><h4 id="一-调试小车基本运动模式"><a class="markdownIt-Anchor" href="#一-调试小车基本运动模式"></a> 一、调试小车基本运动模式</h4><img src="/posts/24146/e8fb6a097cd9432cb9c084fee621ae42-17086935318806.png" class="" title="在这里插入图片描述"><h3 id="什么是分频器"><a class="markdownIt-Anchor" href="#什么是分频器"></a> 什么是分频器？</h3><p><strong>分频器原理</strong></p><ul><li>通过检测输入时钟信号下降沿（上升沿），或者说采样的方法，控制输出的时钟信号频率。</li></ul><p><strong>如将50MHZ的时钟信号12分频：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process(clk,q1)</span><br><span class="line">begin</span><br><span class="line">if clk'event and clk='1' then</span><br><span class="line">if q1&lt;=2 then CLKFMQ&lt;='1';q1&lt;=q1+1;</span><br><span class="line">--改变q1&lt;=2参数可变更占空比</span><br><span class="line"> elsif q1=11 then CLKFMQ&lt;='0';q1&lt;=0;</span><br><span class="line"> --改变q1=11参数可以变更CLKFMQ的频率</span><br><span class="line"> else CLKFMQ&lt;='0';q1&lt;=q1+1;</span><br><span class="line">end if;</span><br><span class="line">end if;</span><br><span class="line">end process ;</span><br></pre></td></tr></tbody></table></figure><p><strong>分频器模块</strong></p><ul><li>用于产生各种所需频率的方波信号</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------</span><br><span class="line">LIBRARY IEEE;</span><br><span class="line">USE IEEE.STD_LOGIC_1164.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_ARITH.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_UNSIGNED.ALL;</span><br><span class="line">--------------------------------------</span><br><span class="line">ENTITY   CLK_mode is--分频器模块                              </span><br><span class="line">PORT(clk:in std_logic; --系统晶振源 50MHZ              </span><br><span class="line">      CLK1hz,clk01s,CLKFMQ,clk1ms:out std_logic--1hz,1000hz,蜂鸣器频率</span><br><span class="line">);</span><br><span class="line">END CLK_mode   ;                                           </span><br><span class="line">--------------------------------------</span><br><span class="line">ARCHITECTURE abc OF CLK_mode   IS  </span><br><span class="line">signal q1:integer range 0 to 24999; --中间信号</span><br><span class="line">signal q2:integer range 0 to 4999999;</span><br><span class="line">signal q3:integer range 0 to 49999;</span><br><span class="line">BEGIN</span><br><span class="line">--蜂鸣器频率--</span><br><span class="line">process(clk,q1)</span><br><span class="line">begin</span><br><span class="line">if clk'event and clk='1' then</span><br><span class="line">if q1&lt;=12999 then CLKFMQ&lt;='1';q1&lt;=q1+1;</span><br><span class="line"> elsif q1=24999 then CLKFMQ&lt;='0';q1&lt;=0;</span><br><span class="line"> else CLKFMQ&lt;='0';q1&lt;=q1+1;</span><br><span class="line">end if;</span><br><span class="line">end if;</span><br><span class="line">end process ;</span><br><span class="line">--0.1s的分频--</span><br><span class="line">process(clk)</span><br><span class="line">begin</span><br><span class="line">if clk'event and clk='1'then</span><br><span class="line">if q2&lt;=5 then clk01s&lt;='1';q2&lt;=q2+1;</span><br><span class="line">elsif q2=4999999 then clk01s&lt;='0';q2&lt;=0;</span><br><span class="line">else clk01s&lt;='0';q2&lt;=q2+1;</span><br><span class="line">end if;</span><br><span class="line">end if;</span><br><span class="line">end process;</span><br><span class="line">--1ms--</span><br><span class="line">process(clk)</span><br><span class="line">begin</span><br><span class="line">if clk'event and clk='1'then</span><br><span class="line">if q3&lt;=40000 then clk1ms&lt;='1';q3&lt;=q3+1;</span><br><span class="line">elsif q3=49999 then clk1ms&lt;='0';q3&lt;=0;</span><br><span class="line">else clk1ms&lt;='0';q3&lt;=q3+1;</span><br><span class="line">end if;</span><br><span class="line">end if;</span><br><span class="line">end process;</span><br><span class="line">end abc;</span><br></pre></td></tr></tbody></table></figure><h3 id="什么是pwm"><a class="markdownIt-Anchor" href="#什么是pwm"></a> 什么是PWM？</h3><ul><li>PWM（Pulse Width Modulation）即脉冲宽度调制，在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速、开关电源等领域</li><li>PWM重要参数：      频率 = 1 / TS            占空比 = TON / TS           精度 = 占空比变化步距</li></ul><img src="/posts/24146/64ab8ccb124f48e1867bd21f1717fba2-17086935318808.png" class="" title="在这里插入图片描述"><p><strong>信号接口/变量定义：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">LIBRARY IEEE;</span><br><span class="line">USE IEEE.STD_LOGIC_1164.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_ARITH.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_UNSIGNED.ALL;</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">ENTITY   Carcontrol_4  is--路线四控制模块                             </span><br><span class="line">PORT(CLK,CLKFMQ,clk01s,clk1ms:in std_logic; --pwm,时钟信号,复位信号</span><br><span class="line">RESET:IN STD_LOGIC;</span><br><span class="line">Mapan:in std_logic;--码盘信号</span><br><span class="line">X1,X2:in std_logic_vector(<span class="number">3</span> downto <span class="number">0</span>);--巡线信号</span><br><span class="line">en11,en12,en21,en22,FMQ:OUT std_logic;--通道A B 的驱动电压</span><br><span class="line">turn_timer1,LED:out std_logic_vector(<span class="number">7</span> downto <span class="number">0</span>):=<span class="string">"00000000"</span>;--计数器</span><br><span class="line">contrologic:OUT std_logic_vector(<span class="number">7</span> downto <span class="number">0</span>):=<span class="string">"00000000"</span>--电机驱动/制动的信号--输出到数据选择器上</span><br><span class="line">);</span><br><span class="line">END Carcontrol_4;                                           </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">ARCHITECTURE abc OF  Carcontrol_4  IS  </span><br><span class="line">  type Sreg0_type is--状态枚举</span><br><span class="line">  (T0,T00,T01,T20,T1,T2,T21,T3,</span><br><span class="line">  stop1,stop2,stop3,stop4,</span><br><span class="line">  TX1,TX1fix,TX1end,</span><br><span class="line">  TX2,TX2fix,TX2end,</span><br><span class="line">  TX3,TX3fix,TX3end,</span><br><span class="line">  TBX1,TBX1fix,TBX1end,</span><br><span class="line">  TBX2,TBX2fix,TBX2end,</span><br><span class="line">  TBX3,TBX3fix,TBX3end,</span><br><span class="line">  TB1,TB2,TB3,TB4,TB5,HT);</span><br><span class="line">  signal XJ :std_logic_vector(<span class="number">7</span> downto <span class="number">0</span>);--两个四路循迹模块的并置信号</span><br><span class="line">  signal Sreg0: Sreg0_type;--状态类型</span><br><span class="line">  signal FMQEN: std_logic:=<span class="string">'1'</span>;--蜂鸣器的使能信号，低电平有效</span><br><span class="line">  signal Z11,Z12,Z21,Z22:integer;--PWM脉宽调制占空比</span><br><span class="line">  signal left1,left2,right1,right2:std_logic;</span><br><span class="line">  signal q1:integer range <span class="number">0</span> to <span class="number">100</span>;</span><br><span class="line">  signal q2:integer range <span class="number">0</span> to <span class="number">100</span>;</span><br><span class="line">  signal q3:integer range <span class="number">0</span> to <span class="number">100</span>;</span><br><span class="line">  signal q4:integer range <span class="number">0</span> to <span class="number">100</span>;</span><br><span class="line">  signal turn_timer:INTEGER  range <span class="number">0</span> to <span class="number">100000</span> ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">XJ&lt;=X1&amp;X2;--循迹信号（八位）</span><br><span class="line">LED&lt;=XJ;--通过LED观察循迹模块是否正常运行</span><br><span class="line">EN11&lt;=left1;EN12&lt;=right1;EN21&lt;=left2;EN22&lt;=right2;--电机的PWM信号输入</span><br><span class="line">--------------------------------------------</span><br><span class="line">--四个模块，分别控制小车四个电机的PWM信号输入</span><br><span class="line">--占空比定义为 变量（整型），在没有pid控制的情况下，便于对小车进行校准，以及调速。</span><br><span class="line">process(clk,q1)</span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> clk<span class="number">'</span>event and clk=<span class="string">'1'</span> then</span><br><span class="line"><span class="keyword">if</span> q1&lt;=Z11 then left1&lt;=<span class="string">'1'</span>;q1&lt;=q1+<span class="number">1</span>;--高电平有效值定义为整型，便于在状态机中进行变速</span><br><span class="line"> elsif q1=<span class="number">100</span> then left1&lt;=<span class="string">'0'</span>;q1&lt;=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span> left1&lt;=<span class="string">'0'</span>;q1&lt;=q1+<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process;</span><br><span class="line">process(clk,q2)</span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> clk<span class="number">'</span>event and clk=<span class="string">'1'</span> then</span><br><span class="line"><span class="keyword">if</span> q2&lt;=Z12 then right1&lt;=<span class="string">'1'</span>;q2&lt;=q2+<span class="number">1</span>;</span><br><span class="line"> elsif q2=<span class="number">100</span> then right1&lt;=<span class="string">'0'</span>;q2&lt;=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span> right1&lt;=<span class="string">'0'</span>;q2&lt;=q2+<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process;</span><br><span class="line">process(clk,q3)</span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> clk<span class="number">'</span>event and clk=<span class="string">'1'</span> then</span><br><span class="line"><span class="keyword">if</span> q3&lt;=Z21 then left2&lt;=<span class="string">'1'</span>;q3&lt;=q3+<span class="number">1</span>;</span><br><span class="line"> elsif q3=<span class="number">100</span> then left2&lt;=<span class="string">'0'</span>;q3&lt;=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span> left2&lt;=<span class="string">'0'</span>;q3&lt;=q3+<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process;</span><br><span class="line">process(clk,q4)</span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> clk<span class="number">'</span>event and clk=<span class="string">'1'</span> then</span><br><span class="line"><span class="keyword">if</span> q4&lt;=Z22 then right2&lt;=<span class="string">'1'</span>; q4&lt;= q4+<span class="number">1</span>;</span><br><span class="line"> elsif  q4=<span class="number">100</span> then right2&lt;=<span class="string">'0'</span>; q4&lt;=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span> right2&lt;=<span class="string">'0'</span>;q4&lt;=q4+<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process;</span><br><span class="line">-----------------------------------------------------------------------------</span><br></pre></td></tr></tbody></table></figure><h2 id="路线规划以路线4为例"><a class="markdownIt-Anchor" href="#路线规划以路线4为例"></a> 路线规划（以路线4为例）</h2><h3 id="计时器控制小车在不同状态下定时运动"><a class="markdownIt-Anchor" href="#计时器控制小车在不同状态下定时运动"></a> 计时器（控制小车在不同状态下定时运动）</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process(clk1ms,Timer_flag)</span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> Timer_flag = <span class="number">1</span> THEN</span><br><span class="line"><span class="keyword">if</span> rising_edge(clk1ms) THEN</span><br><span class="line">turn_timer &lt;= turn_timer +<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">turn_timer&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process;</span><br></pre></td></tr></tbody></table></figure><h3 id="程序主要部分状态机"><a class="markdownIt-Anchor" href="#程序主要部分状态机"></a> 程序主要部分（状态机）</h3><blockquote><p><strong>不同状态下，根据路径规划，小车的运动姿态（转向，直行）不同，每个状态有特定的<mark>状态转移条件</mark>（运动时间（用红外计数里程判断更精准），特征值（黑线）</strong></p></blockquote><ul><li>小车碰到黑线（居民楼）进行偏移转向</li><li>车头碰到黑线（关键点检测）进行直角转弯</li><li>小车要精确地行驶，到底指定地点，需要利用好黑线，既不能触线，也不能过偏，即贴线行驶，这就要使得小车在贴线行驶的路段在规定的 时间 / 里程 内，进行<mark>贴线行驶</mark>-&gt;<mark>避线</mark>-&gt;<mark>贴线行驶</mark>，三个状态的闭环，在小车行驶姿态垂直于黑线时的路径，循迹模块检测黑线直接进行直角转弯即可（这样就不需要控制里程/时间）。</li><li>规划好前往火源点的路径后，返回的路径按照相反的逻辑控制即可。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">PROCESS(reset, clk1ms)-<span class="number">-1</span>ms的时钟信号，用于状态机的状态检测以及计时器的计时精度</span><br><span class="line">BEGIN</span><br><span class="line">    IF reset = <span class="string">'1'</span> THEN--复位信号</span><br><span class="line">      Sreg0 &lt;= T0;FMQEN&lt;=<span class="string">'1'</span>;Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--蜂鸣器无效，状态机初始化</span><br><span class="line">      contrologic &lt;= <span class="string">"00000000"</span>;--控制逻辑均置零</span><br><span class="line">turn_timer&lt;= <span class="number">0</span> ;--计数器清零</span><br><span class="line">    ELSIF <span class="title function_">rising_edge</span><span class="params">(clk1ms)</span> THEN</span><br><span class="line">      CASE Sreg0 IS </span><br><span class="line">        WHEN T0 =&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --直行</span><br><span class="line">   <span class="keyword">if</span> turn_timer = <span class="number">1000</span> then</span><br><span class="line">   Sreg0 &lt;= T00;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;  </span><br><span class="line">WHEN T00 =&gt;</span><br><span class="line">          <span class="keyword">if</span>  XJ(<span class="number">3</span>)=<span class="string">'0'</span> then--检测黑线</span><br><span class="line">    Sreg0&lt;=T01;</span><br><span class="line"> ELSE  Sreg0&lt;=T00;</span><br><span class="line">          end <span class="keyword">if</span>;</span><br><span class="line">  WHEN T01 =&gt;contrologic &lt;= <span class="string">"10011001"</span>; Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--碰到黑线回退</span><br><span class="line">   <span class="keyword">if</span> turn_timer = <span class="number">700</span> then -<span class="number">-1450</span></span><br><span class="line">   Sreg0 &lt;= T1;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;  </span><br><span class="line">        WHEN T1 =&gt;contrologic &lt;= <span class="string">"00100010"</span>;Z12&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;--转弯</span><br><span class="line"><span class="keyword">if</span> turn_timer = <span class="number">1250</span> then</span><br><span class="line">   Sreg0 &lt;= stop1;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;  </span><br><span class="line">  WHEN stop1 =&gt;contrologic &lt;= <span class="string">"00000000"</span> ;--停止</span><br><span class="line"><span class="keyword">if</span> turn_timer = <span class="number">300</span> then</span><br><span class="line">   Sreg0 &lt;= T2;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">--贴线 </span><br><span class="line">  WHEN T2 =&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --空白区域直行</span><br><span class="line">  <span class="keyword">if</span> turn_timer = <span class="number">1500</span> then</span><br><span class="line">   Sreg0 &lt;= TX1;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;</span><br><span class="line"> When TX1 =&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --贴线循迹(街区<span class="number">2</span>）</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>))  = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TX1fix; </span><br><span class="line">elsif turn_timer = <span class="number">2800</span> then--完成贴线</span><br><span class="line">   Sreg0 &lt;= TX1end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> WHEN TX1fix =&gt; contrologic &lt;= <span class="string">"10101010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;--修正</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'1'</span>then Sreg0 &lt;= TX1; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> When TX1end =&gt; contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --完成贴线,直行小段</span><br><span class="line"> <span class="keyword">if</span> turn_timer = <span class="number">500</span> then </span><br><span class="line">   Sreg0 &lt;= T20;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">    end <span class="keyword">if</span>;</span><br><span class="line">----------------------------------------------------------------------------- </span><br><span class="line">       WHEN T20 =&gt;</span><br><span class="line">          <span class="keyword">if</span>  XJ(<span class="number">3</span>)=<span class="string">'0'</span> then  --前端检测黑线</span><br><span class="line">    Sreg0&lt;=T21;</span><br><span class="line">          end <span class="keyword">if</span>;</span><br><span class="line">  WHEN T21 =&gt;contrologic &lt;= <span class="string">"10011001"</span>; Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--检测到黑线，回退</span><br><span class="line">  <span class="keyword">if</span> turn_timer = <span class="number">600</span> then</span><br><span class="line">   Sreg0 &lt;= T3;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;  </span><br><span class="line">  WHEN T3 =&gt;contrologic &lt;= <span class="string">"00100010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;--直角转弯</span><br><span class="line"><span class="keyword">if</span> turn_timer = <span class="number">1500</span> then</span><br><span class="line">   Sreg0 &lt;= TX2; --进入第二段循迹贴线（火源区<span class="number">3</span>）</span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;</span><br><span class="line">----------------------------------------------------------------------------- </span><br><span class="line">  WHEN TX2 =&gt;contrologic &lt;= <span class="string">"10011001"</span>; Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--进入第二段循迹贴线（火源区<span class="number">3</span>）</span><br><span class="line"><span class="keyword">if</span> XJ(<span class="number">4</span>) = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TX2fix; </span><br><span class="line">elsif turn_timer = <span class="number">2000</span> then--限制贴线时间</span><br><span class="line">   Sreg0 &lt;= TX2end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> WHEN TX2fix =&gt; contrologic &lt;= <span class="string">"01010101"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span> XJ(<span class="number">4</span>) = <span class="string">'1'</span>then Sreg0 &lt;= TX2; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> When TX2end =&gt; contrologic &lt;= <span class="string">"10011001"</span>; Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;</span><br><span class="line"> <span class="keyword">if</span> turn_timer = <span class="number">500</span> then --贴线结束，空白区直行</span><br><span class="line">   Sreg0 &lt;= TX3;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">    end <span class="keyword">if</span>;</span><br><span class="line">----------------------------------------------------------------------------- </span><br><span class="line">  WHEN TX3 =&gt;contrologic &lt;= <span class="string">"10011001"</span>;  Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--进入第三段循迹贴线（火源区<span class="number">4</span>）</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">4</span>) and XJ(<span class="number">5</span>) and XJ(<span class="number">6</span>) and XJ(<span class="number">7</span>)) = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TX3fix; </span><br><span class="line">elsif turn_timer = <span class="number">1900</span> then--限制时间</span><br><span class="line">   Sreg0 &lt;= TX3end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> WHEN TX3fix =&gt; contrologic &lt;= <span class="string">"01010101"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">4</span>) and XJ(<span class="number">5</span>) and XJ(<span class="number">6</span>) and XJ(<span class="number">7</span>)) = <span class="string">'1'</span>then Sreg0 &lt;= TX3; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">  WHEN TX3end=&gt;FMQEN&lt;=<span class="string">'0'</span>;contrologic &lt;= <span class="string">"00000000"</span>; --报警</span><br><span class="line">  <span class="keyword">if</span> turn_timer =<span class="number">4999</span> then </span><br><span class="line">Sreg0 &lt;= TBX1;FMQEN&lt;=<span class="string">'1'</span>;</span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">WHEN TBX1 =&gt;contrologic &lt;= <span class="string">"01100110"</span>; Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --进入返回第一段循迹贴线（火源区<span class="number">4</span>）</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TBX1fix; </span><br><span class="line">elsif turn_timer = <span class="number">1200</span> then</span><br><span class="line">   Sreg0 &lt;= TBX1end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">   WHEN TBX1fix =&gt; contrologic &lt;= <span class="string">"10101010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>))= <span class="string">'1'</span>then Sreg0 &lt;= TBX1; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"> When TBX1end =&gt; contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --空白区域</span><br><span class="line"> <span class="keyword">if</span> turn_timer = <span class="number">500</span> then </span><br><span class="line">   Sreg0 &lt;= TBX2;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">    end <span class="keyword">if</span>;</span><br><span class="line">    WHEN TBX2 =&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>;--进入返回第二段循迹贴线（火源区<span class="number">3</span>）</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TBX2fix; </span><br><span class="line">elsif turn_timer = <span class="number">3500</span> then</span><br><span class="line">   Sreg0 &lt;= TBX2end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> WHEN TBX2fix =&gt; contrologic &lt;= <span class="string">"10101010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'1'</span>then Sreg0 &lt;= TBX2; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">  WHEN TBX2end=&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>;--前端检测黑线</span><br><span class="line">          <span class="keyword">if</span>  XJ(<span class="number">3</span>)=<span class="string">'0'</span> then  </span><br><span class="line">    Sreg0&lt;=HT;</span><br><span class="line"> Else  Sreg0&lt;=TBX2end;</span><br><span class="line">          end <span class="keyword">if</span>; </span><br><span class="line">  WHEN HT =&gt;contrologic &lt;= <span class="string">"10011001"</span>; Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--碰到黑线回退</span><br><span class="line">   <span class="keyword">if</span> turn_timer = <span class="number">500</span> then -<span class="number">-1450</span></span><br><span class="line">   Sreg0 &lt;= TB3;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;</span><br><span class="line">        WHEN TB3=&gt;contrologic &lt;= <span class="string">"00100010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;--转向 </span><br><span class="line"><span class="keyword">if</span> turn_timer = <span class="number">900</span> then</span><br><span class="line">   Sreg0 &lt;= TBX3;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">    WHEN TBX3 =&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --贴线循迹，回到起点</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TBX3fix; </span><br><span class="line">elsif turn_timer = <span class="number">4200</span> then</span><br><span class="line">   Sreg0 &lt;= TBX3end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> WHEN TBX3fix =&gt; contrologic &lt;= <span class="string">"10101010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'1'</span>then Sreg0 &lt;= TBX3; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">  WHEN OTHERS =&gt; null; contrologic&lt;= <span class="string">"00000000"</span>;</span><br><span class="line">  END CASE;</span><br><span class="line">END IF;</span><br><span class="line">  END PROCESS;</span><br><span class="line">PROCESS(FMQEN)</span><br><span class="line">BEGIN</span><br><span class="line">IF FMQEN&lt;=<span class="string">'0'</span>then FMQ&lt;=CLKFMQ;</span><br><span class="line">ELSE FMQ&lt;=<span class="string">'1'</span>;</span><br><span class="line">END IF;</span><br><span class="line">END PROCESS;</span><br><span class="line">END abc;</span><br></pre></td></tr></tbody></table></figure><h3 id="四路数据选择器模块"><a class="markdownIt-Anchor" href="#四路数据选择器模块"></a> 四路数据选择器模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY IEEE;</span><br><span class="line">USE IEEE.STD_LOGIC_1164.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_ARITH.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_UNSIGNED.ALL;</span><br><span class="line">--四路（总线式）数据选择器，通过四位按键控制电机逻辑/电机有效电压（PWM）/蜂鸣器信号/选择小车行驶路线</span><br><span class="line">ENTITY MUX4 IS</span><br><span class="line"><span class="title function_">PORT</span><span class="params">(C1,C2,C3,C4:IN STD_LOGIC_VECTOR(<span class="number">7</span> DOWNTO <span class="number">0</span>);</span></span><br><span class="line"><span class="params">  EN11_1,EN12_1,EN21_1,EN22_1:in std_logic;</span></span><br><span class="line"><span class="params">  EN11_2,EN12_2,EN21_2,EN22_2:in std_logic;</span></span><br><span class="line"><span class="params">  EN11_3,EN12_3,EN21_3,EN22_3:in std_logic;</span></span><br><span class="line"><span class="params">  EN11_4,EN12_4,EN21_4,EN22_4:in std_logic;</span></span><br><span class="line"><span class="params">  FMQ1,FMQ2,FMQ3,FMQ4:in std_logic;</span></span><br><span class="line"><span class="params">  RESET:IN STD_LOGIC_vector(<span class="number">3</span> downto <span class="number">0</span>);--路线选择信号</span></span><br><span class="line"><span class="params">  FMQ:out std_logic;--蜂鸣器</span></span><br><span class="line"><span class="params">  LOGIC:OUT STD_LOGIC_vector(<span class="number">7</span> DOWNTO <span class="number">0</span>);--小车运动控制逻辑</span></span><br><span class="line"><span class="params">  EN11,EN12,EN21,EN22:OUT STD_LOGIC;--小车电机PWM方波输出信号</span></span><br><span class="line"><span class="params">  CLK1MS:in std_logic;--光耦传感器脉冲，复位信号，<span class="number">1</span>MS时钟</span></span><br><span class="line"><span class="params">  LEDSEG: OUT STD_LOGIC_VECTOR(<span class="number">6</span> DOWNTO <span class="number">0</span>);--LED显示</span></span><br><span class="line"><span class="params">  Y:out std_logic_VECTOR(<span class="number">5</span> DOWNTO <span class="number">0</span>)--共阴极</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">END MUX4;--</span><br><span class="line">ARCHITECTURE ABC OF MUX4 IS</span><br><span class="line">signal ledin:std_logic_vector(<span class="number">3</span> downto <span class="number">0</span>);</span><br><span class="line">signal SEL:std_logic_vector(<span class="number">2</span> downto <span class="number">0</span>):=<span class="string">"000"</span>;</span><br><span class="line">BEGIN</span><br><span class="line">--显示译码器--</span><br><span class="line">P11:process (ledin)</span><br><span class="line">BEGIN</span><br><span class="line">CASE ledin IS </span><br><span class="line">WHEN <span class="string">"0000"</span>=&gt;ledseg&lt;=<span class="string">"0111111"</span>;--<span class="string">"1111111110"</span>;</span><br><span class="line">WHEN <span class="string">"0001"</span>=&gt;ledseg&lt;=<span class="string">"0000110"</span>;--<span class="string">"1111111101"</span>;</span><br><span class="line">WHEN <span class="string">"0010"</span>=&gt;ledseg&lt;=<span class="string">"1011011"</span>;--<span class="string">"1111111011"</span>;</span><br><span class="line">WHEN <span class="string">"0011"</span>=&gt;ledseg&lt;=<span class="string">"1001111"</span>;--<span class="string">"1111110111"</span>; </span><br><span class="line">WHEN <span class="string">"0100"</span>=&gt;ledseg&lt;=<span class="string">"1100110"</span>;--<span class="string">"1111101111"</span>;</span><br><span class="line">WHEN <span class="string">"0101"</span>=&gt;ledseg&lt;=<span class="string">"1101101"</span>;--<span class="string">"1111011111"</span>;</span><br><span class="line">WHEN <span class="string">"0110"</span>=&gt;ledseg&lt;=<span class="string">"1111101"</span>;--<span class="string">"1110111111"</span>;</span><br><span class="line">WHEN <span class="string">"0111"</span>=&gt;ledseg&lt;=<span class="string">"0000111"</span>;--<span class="string">"1101111111"</span>;</span><br><span class="line">WHEN <span class="string">"1000"</span>=&gt;ledseg&lt;=<span class="string">"1111111"</span>;--<span class="string">"1011111111"</span>;</span><br><span class="line">WHEN <span class="string">"1001"</span>=&gt;ledseg&lt;=<span class="string">"1101111"</span>;--<span class="string">"0111111111"</span>;</span><br><span class="line">WHEN <span class="string">"1010"</span>=&gt;ledseg&lt;=<span class="string">"0000001"</span>;--<span class="string">"0111111111"</span>;</span><br><span class="line">WHEN OTHERS=&gt;ledseg&lt;=<span class="string">"0000000"</span>;--共阴极，无效</span><br><span class="line">END CASE;</span><br><span class="line">end process P11;</span><br><span class="line">--四位脉冲分配器--</span><br><span class="line">p22:process(clk1ms)</span><br><span class="line">begin</span><br><span class="line">IF clk1ms<span class="number">'</span>event and clk1ms=<span class="string">'1'</span> then</span><br><span class="line"><span class="keyword">if</span> sel=<span class="string">"101"</span> then sel&lt;=<span class="string">"000"</span>;</span><br><span class="line"><span class="keyword">else</span> sel&lt;=sel+<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process P22;</span><br><span class="line">PROCESS(RESET)</span><br><span class="line">BEGIN</span><br><span class="line">CASE RESET IS</span><br><span class="line">WHEN <span class="string">"1000"</span> =&gt; </span><br><span class="line">LOGIC &lt;=C1;</span><br><span class="line">EN11&lt;=EN11_1;</span><br><span class="line">EN12&lt;=EN12_1;</span><br><span class="line">EN21&lt;=EN21_1;</span><br><span class="line">EN22&lt;=EN22_1;</span><br><span class="line">FMQ&lt;=FMQ1;</span><br><span class="line">CASE SEL IS</span><br><span class="line">WHEN <span class="string">"001"</span>=&gt;ledin&lt;=<span class="string">"0000"</span>;y&lt;=<span class="string">"111101"</span>;</span><br><span class="line">WHEN <span class="string">"010"</span>=&gt;ledin&lt;=<span class="string">"1001"</span>;y&lt;=<span class="string">"111011"</span>;</span><br><span class="line">WHEN <span class="string">"011"</span>=&gt;ledin&lt;=<span class="string">"0011"</span>;y&lt;=<span class="string">"110111"</span>;</span><br><span class="line">WHEN <span class="string">"100"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"101111"</span>;</span><br><span class="line">WHEN OTHERS =&gt;ledin&lt;=<span class="string">"1111"</span>;y&lt;=<span class="string">"111111"</span>;</span><br><span class="line">END CASE;</span><br><span class="line">WHEN <span class="string">"0100"</span> =&gt; LOGIC &lt;=C2;</span><br><span class="line">EN11&lt;=EN11_2;</span><br><span class="line">EN12&lt;=EN12_2;</span><br><span class="line">EN21&lt;=EN21_2;</span><br><span class="line">EN22&lt;=EN22_2;</span><br><span class="line">FMQ&lt;=FMQ2;</span><br><span class="line">CASE SEL IS</span><br><span class="line">WHEN <span class="string">"000"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"111101"</span>;</span><br><span class="line">WHEN <span class="string">"001"</span>=&gt;ledin&lt;=<span class="string">"1000"</span>;y&lt;=<span class="string">"111011"</span>;</span><br><span class="line">WHEN <span class="string">"010"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"110111"</span>;</span><br><span class="line">WHEN <span class="string">"011"</span>=&gt;ledin&lt;=<span class="string">"1001"</span>;y&lt;=<span class="string">"101111"</span>;</span><br><span class="line">WHEN OTHERS =&gt;ledin&lt;=<span class="string">"1111"</span>;y&lt;=<span class="string">"111111"</span>;</span><br><span class="line">END CASE;</span><br><span class="line">WHEN <span class="string">"0010"</span> =&gt; LOGIC &lt;=C3;</span><br><span class="line">EN11&lt;=EN11_3;</span><br><span class="line">EN12&lt;=EN12_3;</span><br><span class="line">EN21&lt;=EN21_3;</span><br><span class="line">EN22&lt;=EN22_3;</span><br><span class="line">FMQ&lt;=FMQ3;</span><br><span class="line">CASE SEL IS</span><br><span class="line">WHEN <span class="string">"000"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"111101"</span>;</span><br><span class="line">WHEN <span class="string">"001"</span>=&gt;ledin&lt;=<span class="string">"1000"</span>;y&lt;=<span class="string">"111011"</span>;</span><br><span class="line">WHEN <span class="string">"010"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"110111"</span>;</span><br><span class="line">WHEN <span class="string">"011"</span>=&gt;ledin&lt;=<span class="string">"1001"</span>;y&lt;=<span class="string">"101111"</span>;</span><br><span class="line">WHEN OTHERS =&gt;ledin&lt;=<span class="string">"1111"</span>;y&lt;=<span class="string">"111111"</span>;</span><br><span class="line">END CASE;</span><br><span class="line">WHEN <span class="string">"0001"</span> =&gt; LOGIC &lt;=C4;</span><br><span class="line">EN11&lt;=EN11_4;</span><br><span class="line">EN12&lt;=EN12_4;</span><br><span class="line">EN21&lt;=EN21_4;</span><br><span class="line">EN22&lt;=EN22_4;</span><br><span class="line">FMQ&lt;=FMQ4;</span><br><span class="line">CASE SEL IS</span><br><span class="line">WHEN <span class="string">"000"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"111101"</span>;</span><br><span class="line">WHEN <span class="string">"001"</span>=&gt;ledin&lt;=<span class="string">"1000"</span>;y&lt;=<span class="string">"111011"</span>;</span><br><span class="line">WHEN <span class="string">"010"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"110111"</span>;</span><br><span class="line">WHEN <span class="string">"011"</span>=&gt;ledin&lt;=<span class="string">"1001"</span>;y&lt;=<span class="string">"101111"</span>;</span><br><span class="line">WHEN OTHERS =&gt;ledin&lt;=<span class="string">"1111"</span>;y&lt;=<span class="string">"111111"</span>;</span><br><span class="line">end <span class="keyword">case</span>;</span><br><span class="line">WHEN OTHERS=&gt;LOGIC&lt;=<span class="string">"00000000"</span>;</span><br><span class="line">END CASE;</span><br><span class="line">END PROCESS;</span><br><span class="line">END ABC;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 项目 </category>
          
          <category> FPGA </category>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> 电赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HEXO】[01]HEXO常用命令</title>
      <link href="/posts/64680/"/>
      <url>/posts/64680/</url>
      
        <content type="html"><![CDATA[<p><strong>hexo远程发布</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></tbody></table></figure><p><strong>新建md文件</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n "name"</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 博客 </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言入门学习】[1]初识C语言 01</title>
      <link href="/posts/13150/"/>
      <url>/posts/13150/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言入门学习1初识c语言-01"><a class="markdownIt-Anchor" href="#c语言入门学习1初识c语言-01"></a> 【C语言入门学习】[1]初识C语言 01</h1><h3 id="202419更新"><a class="markdownIt-Anchor" href="#202419更新"></a> 2024.1.9更新</h3><h3 id="2024220更新"><a class="markdownIt-Anchor" href="#2024220更新"></a> 2024.2.20更新</h3><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><h3 id="什么是c语言"><a class="markdownIt-Anchor" href="#什么是c语言"></a> 什么是C语言？</h3><ul><li>C语言是一门通用计算机编程语言，广泛应用于<strong>底层开发</strong>。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。尽管C语言提供了许多低级处理的功能，但仍然保持着良好跨平台的特性，以一个标准规格写出的C语言程序可在许多电脑平台上进行编译，甚至包含一些<strong>嵌入式处理器</strong>（单片机或称MCU）以及<strong>超级电脑</strong>等作业平台。</li><li>ANSI C，作为C语言最初的标准</li><li>C语言是一门<strong>面向过程</strong>的计算机编程语言，与C++，Java等<strong>面向对象</strong>的编程语言有所不同。</li><li>其编译器主要有Clang、GCC、WIN-TC、SUBLIME、MSVC、Turbo C</li><li><strong>C语言介于机器语言和高级语言之间</strong></li></ul><h2 id="一-基本概念"><a class="markdownIt-Anchor" href="#一-基本概念"></a> 一、基本概念</h2><h3 id="一-c语言的基本框架"><a class="markdownIt-Anchor" href="#一-c语言的基本框架"></a> 一、c语言的基本框架</h3><ul><li>main函数是程序的入口</li><li>return 0;函数正常运行结束时返回0</li></ul><h3 id="二-c语言的数据类型"><a class="markdownIt-Anchor" href="#二-c语言的数据类型"></a> 二、c语言的数据类型</h3><ul><li>char //字符数据类型</li><li>short //短整型</li><li>int //整形</li><li>long //长整型</li><li>long long //更长的整形</li><li>float //单精度浮点数</li><li>double //双精度浮点数</li><li>C语言有没有字符串类型？<br><code>add[]="String"</code></li></ul><p><strong>每种字符类型对应的字节大小</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">double</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输出结果：<br>1<br>2<br>4<br>4<br>8<br>4<br>8<br>8 最大为8个字节 2的64次方(64位系统)<br>对于计算机内存的解释,见：</p></blockquote><h3 id="三-变量的作用域和生命周期"><a class="markdownIt-Anchor" href="#三-变量的作用域和生命周期"></a> 三、变量的作用域和生命周期</h3><p>作用域</p><blockquote><p>作用域（scope）是程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用<br>的<br>而限定这个名字的可用性的代码范围就是这个名字的作用域。</p></blockquote><ol><li>局部变量的作用域是变量所在的局部范围。</li><li>全局变量的作用域是整个工程。</li></ol><p>生命周期</p><blockquote><p>变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段</p></blockquote><ol><li>局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束。</li><li>全局变量的生命周期是：整个程序的生命周期。</li></ol><p><strong>代码示例</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用域</span></span><br><span class="line"><span class="comment">//局部变量的作用域：就是变量所在的局部范围</span></span><br><span class="line"><span class="comment">//全局变量的作用域：整个工程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_val = <span class="number">2021</span>;<span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1:%d\n"</span>, g_val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hehe\n"</span>);</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2:%d\n"</span>, g_val);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3:%d\n"</span>, g_val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="extern关键字"><a class="markdownIt-Anchor" href="#extern关键字"></a> #extern(关键字)：</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一下变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_val;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, g_val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生命周期</span></span><br><span class="line"><span class="comment">//变量的生命周期：变量的创建和销毁之间的时间段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量的生命周期：进入局部范围生命开始，出局部范围生命结束</span></span><br><span class="line"><span class="comment">//全局变量的生命周期：程序的生命周期</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//a创建</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//a销毁</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="defineconst和enum"><a class="markdownIt-Anchor" href="#defineconst和enum"></a> #define/const和enum</h3><h4 id="define-和const的区别"><a class="markdownIt-Anchor" href="#define-和const的区别"></a> define 和const的区别</h4><p><strong>1.编译器处理阶段</strong></p><p>define是预处理器预处理阶段完成，const是编译器开始编译程序阶段完成，因此#define先于const处理。<br><strong>2.语法语义方面</strong></p><p>define是宏定义，特点是简单原位做替换，其定义的常量值没有类型限定，也不做类型检查，在出现宏名称的地方直接展开。<br>const是关键字，本质上会定义一个只读变量，不可以更改，编译是检查常量值的类型是否匹配。</p><blockquote><p>例如：</p><p>define PI 3.14159<br>int r = 25;<br>double s = rrPI;<br>r = 30;<br>s = rrPI;<br>预处理完成以后的代码是：<br>int r = 25;<br>double s = rr3.14159;<br>r = 30;<br>s = rr3.14159;<br>define明显是直接替换，PI出现几次，其数值3.14159出现几次。<br>// 必须指定正确的类型<br>const double PI = 3.14159 ;<br>int r = 25;<br>double s = rrPI;<br>r = 30;<br>s = rrPI;<br>const明显是声明和定义一个变量，分配内存空间保存3.14159的数值，以后使用时和普通变量一样取值，但是无法对其进行赋值修改。<br>3.#define宏只做替换，不做表达式计算，如果#define定义的不是单个数值，而是一个常量表达式，建议加上圆括号，避免出错。<br>例如：定义常量表示每个元素的大小是int+double型大小之和。<br>define N sizeof(int) + sizeof(double)<br>int m = 100;<br>// 根据输入的m变量值计算总的空间大小<br>int total = m<em>N;<br>这是错误的，因为替换以后int total= m</em>sizeof(int) + sizeof(double);<br>正确写法是：<br>define N (sizeof(int) + sizeof(double))<br>展开以后：<br>int total = m*(sizeof(int) + sizeof(double));<br>使用const不存在以上问题，const会对表达式先计算。<br>const int N = sizeof(int) + sizeof(double);<br>int m = 100;<br>// 根据输入的m变量值计算总的空间大小<br>int total = m*N;</p></blockquote><p><strong>代码示例</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//1. 字面常量</span></span><br><span class="line"><span class="comment">//3.14;</span></span><br><span class="line"><span class="comment">//10;</span></span><br><span class="line"><span class="comment">//'a';</span></span><br><span class="line"><span class="comment">//"abcdef";</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. const修饰的常变量</span></span><br><span class="line"><span class="comment">//const int num = 10;//num就是常变量 - 具有常属性（不能被改变的属性）</span></span><br><span class="line"><span class="comment">//num = 20;</span></span><br><span class="line"><span class="comment">//printf("num = %d\n", num);//20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int arr[10] = {0};//10个元素</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//const int n = 10;</span></span><br><span class="line"><span class="comment">//int arr2[n] = {0};//n是变量的，这里是不行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. #define 定义的标识符常量</span></span><br><span class="line"><span class="comment">//MAX = 20000;//err</span></span><br><span class="line"><span class="comment">/*int n = MAX;</span></span><br><span class="line"><span class="comment">printf("n = %d\n", n);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">性别</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="comment">//这种枚举类型的变量的未来可能取值</span></span><br><span class="line"><span class="comment">//枚举常量</span></span><br><span class="line">MALE = <span class="number">3</span>,<span class="comment">//赋初值</span></span><br><span class="line">FEMALE,</span><br><span class="line">SECRET</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//4. 枚举常量</span></span><br><span class="line"><span class="comment">//可以一一列举的常量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span> <span class="title">s</span> =</span> MALE;</span><br><span class="line"><span class="comment">//MALE = 3;//err</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, MALE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, FEMALE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SECRET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串和转义字符"><a class="markdownIt-Anchor" href="#字符串和转义字符"></a> #字符串和转义字符</h3><blockquote><p>由双引号（Double Quote）引起来的一串字符称为字符串字面值（String Literal），或者简称字符<br>串。<br>注：字符串的结束标志是一个 \0 的转义字符。在计算字符串长度的时候 \0 是结束标志，不算作字符串内容<br>注：使用<strong>strlen</strong>计算字符串长度时会将\0一并算入</p></blockquote><table><thead><tr><th>转义字符</th><th>x&nbsp;#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#include&lt;math.h&gt;​//写一个代码,打印100~200之间的素数//素数-质数//只能被1和他本身整除​//代码优化1：//m=a<em>b;//a和b中一定至少有一个数字是 &lt;=开平方m的//16 = 2</em>8 = 4*4//所以，大于开平方m的就不需要判断是否为m的因子，减少循环执行次数​//sqrt用于计算开平方的函数 -需要用到库函数 math.h//减少了循环的执行次数​//代码优化2：//偶数不可能是素数//修改for (i = 100; i &lt;= 200; i <ins>)为for (i = 101; i &lt;= 200; i += 2)​int main(){    int i, j = 0;​    //判断i是不是质数    for (i = 101; i &lt;= 200; i += 2)    {        int flag = 1;//定义一个参数，检测i是否能被 除了1和它本身的数 整除​        for (j = 2; j &lt;= sqrt(i); j</ins>)        {            if (i % j == 0)            {                flag = 0;//如果能被2到i-1之间的整除，记录flag=0;                //break;            }        }​        if (flag == 1)//不能被2到i-1之间的数整除        {            printf("%d是质数\n", i);//那么i就是质数        }    }    return 0;}c</th></tr></thead><tbody><tr><td>?</td><td>在书写连续多个问号时使用，防止他们被解析成三字母词</td></tr><tr><td>’</td><td>用于表示字符常量’</td></tr><tr><td>\“</td><td>用于表示一个字符串内部的双引号</td></tr><tr><td>\</td><td>用于表示一个反斜杠，防止它被解释为一个转义序列符。</td></tr><tr><td>\a</td><td>警告字符，蜂鸣</td></tr><tr><td>\b</td><td>退格符</td></tr><tr><td>\f</td><td>进纸符</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\ddd</td><td>ddd表示1~3个八进制的数字。 如： \130 X</td></tr><tr><td>\xdd</td><td>dd表示2个十六进制数字。 如： \x30 0</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串就是一串字符 - 用双引号括起来的一串字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="string">"abcdef"</span>;</span><br><span class="line"><span class="string">"hello bit"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//字符数组 - 数组是一组形同类型的元素</span></span><br><span class="line"><span class="comment">//字符串在结尾的位置隐藏了一个\0的字符</span></span><br><span class="line"><span class="comment">//\0是字符串的结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char arr[] = "hello";</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr1[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="type">char</span> arr2[] = {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">//求一下字符串的长度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(arr1));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(arr2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//int len = strlen("abc");//string length</span></span><br><span class="line"><span class="comment">//printf("%d\n", len);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印字符串</span></span><br><span class="line"><span class="comment">//printf("%s\n", arr1);</span></span><br><span class="line"><span class="comment">//printf("%s\n", arr2);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("c:\test\test.c");</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ab\ncd"</span>);<span class="comment">//\+n</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("(are you ok??)");//??) -- ] - 三字母词</span></span><br><span class="line"><span class="comment">//(are you ok]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//printf("%c\n", '\'');</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"abc"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"\""</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"'"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"c:\\test\\test.c"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf在打印数据的时候，可以指定打印的格式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="string">"abc"</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="四-ascii码"><a class="markdownIt-Anchor" href="#四-ascii码"></a> 四、ASCII码</h3><p><a href="https://c.biancheng.net/c/ascii/">ASCII码一览表</a></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("%c\n", '\130');//8进制的130是十进制的多少呢？</span></span><br><span class="line"><span class="comment">//X   -- ASCII码值是88</span></span><br><span class="line"><span class="comment">//printf("%c\n", '\101');//A - 65 - 8进制是：101</span></span><br><span class="line"><span class="comment">//printf("%c\n", '\x30');//48 - '0'</span></span><br><span class="line"><span class="comment">//printf("%d\n", strlen("abc"));//3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(<span class="string">"c:\test\328\test.c"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="c语言的注释"><a class="markdownIt-Anchor" href="#c语言的注释"></a> #C语言的注释</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">注释: 是用来解释复杂代码的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//int a = 10; //C++注释风格</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int b = 0;</span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line"><span class="comment">//C语言的注释风格 - 不支持嵌套注释</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="c语言的语句"><a class="markdownIt-Anchor" href="#c语言的语句"></a> #C语言的语句</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;<span class="comment">//输入的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"加入比特:&gt;\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"那要好好学习吗(1/0)?&gt;:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (input == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"好offer\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{ </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"卖红薯\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">比特 - <span class="number">30000</span>代码 - 找一个不错的工作</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> line = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">while</span>(line&lt;<span class="number">30000</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"写代码:%d\n"</span>, line);</span><br><span class="line">line++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (line == <span class="number">30000</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"好offer\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="函数概念"><a class="markdownIt-Anchor" href="#函数概念"></a> #函数概念</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line">z = x + y;</span><br><span class="line"><span class="keyword">return</span> z;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;num1, &amp;num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//int sum = num1 + num2;</span></span><br><span class="line"><span class="comment">//函数的方式解决</span></span><br><span class="line"><span class="type">int</span> sum = Add(num1, num2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="数组概念"><a class="markdownIt-Anchor" href="#数组概念"></a> #数组概念</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//int a = 1;</span></span><br><span class="line"><span class="comment">//int b = 2;</span></span><br><span class="line"><span class="comment">//int c = 3;</span></span><br><span class="line"><span class="comment">//int d = 4;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组 - 一组相同类型的元素的集合</span></span><br><span class="line"><span class="comment">//10个整形1-10存起来</span></span><br><span class="line"><span class="comment">//数组是用下标来访问的</span></span><br><span class="line"><span class="comment">//*</span></span><br><span class="line"><span class="comment">// /</span></span><br><span class="line"><span class="comment">//int arr[10] = {1,2,3,4,5,6,7,8,9,10};</span></span><br><span class="line"><span class="comment">//int i = 0;</span></span><br><span class="line"><span class="comment">//while (i &lt; 10)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//printf("%d ", arr[i]);</span></span><br><span class="line"><span class="comment">//i++;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">////char ch[5] = {'a', 'b', 'c'};//不完全初始化，剩余的默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 9 / 2;</span></span><br><span class="line"><span class="comment">//float a = 9 / 2.0;</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span> % <span class="number">2</span>;<span class="comment">//% - 取模（余）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="c语言的操作符和关键字"><a class="markdownIt-Anchor" href="#c语言的操作符和关键字"></a> #c语言的操作符和关键字</h3><p>基本操作符</p><p>常见关键字<br><img src="../img/447d/1cc8c8fe87ff45d5951b158a2fff6ab5-1.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//关于操作符的补充</span></span><br><span class="line"><span class="comment">//+ - * / % </span></span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span> / <span class="number">2</span>;<span class="comment">//整数除法</span></span><br><span class="line"><span class="type">float</span> b = <span class="number">9</span> / <span class="number">2</span>;<span class="comment">//整数除法</span></span><br><span class="line"><span class="type">float</span> c = <span class="number">9</span> / <span class="number">2.0</span>;<span class="comment">//输出为小数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, c);<span class="comment">//正确结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移位操作符</span></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">2</span>;<span class="comment">//0010,此处省略n个0...</span></span><br><span class="line"><span class="type">int</span> b1 = a1 &lt;&lt; <span class="number">1</span>;<span class="comment">//左移操作符，移动的是二进制位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b1);<span class="comment">//0100</span></span><br><span class="line"><span class="comment">//位操作符：&amp; 按位与 | 按位或 ^ 按位异或</span></span><br><span class="line"><span class="comment">//赋值操作符 += -= *= /= ...</span></span><br><span class="line"><span class="comment">//单目操作符：!（逻辑取反） - + &amp;  </span></span><br><span class="line"><span class="comment">// *:间接访问操作符（解引用操作符）</span></span><br><span class="line"><span class="comment">//PS: a+b 有两个操作数，此处+为双目操作符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof是一个操作符，不是函数</span></span><br><span class="line"><span class="keyword">sizeof</span>(a);<span class="comment">//通常使用方法</span></span><br><span class="line"><span class="keyword">sizeof</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, !a);<span class="comment">//非0即真</span></span><br><span class="line">a = -a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//mark:为什么a按位取反后，输出结果为-1;</span></span><br><span class="line"><span class="comment">//~</span></span><br><span class="line">    a = <span class="number">0</span>;<span class="comment">//二进制位32个bit</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ~a);<span class="comment">//结果为-1，按位取反，位即二进制位，按位取反包括符号位（bit31)，补码反码转换符号位不变</span></span><br><span class="line"><span class="comment">//数据在内存中存储的是补码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int b = (++a) + (++a) + (++a);//不建议使用的表达</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"><span class="comment">//int a = (int)3.14;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;&amp;逻辑与 ||逻辑或</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//条件操作符（三目操作符）? :</span></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a2 &gt; b2)</span><br><span class="line">{</span><br><span class="line">max = a2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">max = b2;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max);</span><br><span class="line"></span><br><span class="line">max = a2 &gt; b2 ? a2 : b2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max);</span><br><span class="line"></span><br><span class="line"><span class="comment">//逗号表达式</span></span><br><span class="line"><span class="comment">//逗号表达式从左向右依次计算</span></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b3 = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> c3 = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> d3 = (a3 = b3 + <span class="number">3</span>, b3 = c3 - a3, c3 = a3 + b3);</span><br><span class="line"><span class="comment">//整个表达式是结果是最后一个表达式的结果</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, d3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下标引用，函数调用和结构成员</span></span><br><span class="line"><span class="comment">//[] () , -&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数的时候，函数名后面的()</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hi\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言的关键字</span></span><br><span class="line"><span class="comment">//1.无法自己创建</span></span><br><span class="line"><span class="comment">//2.不能作变量名</span></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a0 = <span class="number">10</span>;<span class="comment">//自动创建，自动销毁 -自动变量</span></span><br><span class="line"><span class="comment">//auto 通常省略</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//extern用来申明外部符号</span></span><br><span class="line"><span class="comment">//register寄存器关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//频繁被使用的数据，可以存储在寄存器中，提升效率</span></span><br><span class="line"><span class="comment">//计算机中效率最快的是寄存器</span></span><br><span class="line"><span class="comment">//现代编译器会自动将数据处理到寄存器中，所以register一般不使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> Number = <span class="number">849797</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//signed 有符号的 10 -10</span></span><br><span class="line"><span class="comment">//unsigned 无符号的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static 静态的</span></span><br><span class="line"><span class="comment">//union 联合体(共用体）</span></span><br><span class="line"><span class="comment">//void 无 空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//volatile</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//类型重命名</span></span><br><span class="line"><span class="comment">//define,include不是关键字，为预处理命令</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num11 = <span class="number">100</span>;</span><br><span class="line">u_int num2 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="内存本质"><a class="markdownIt-Anchor" href="#内存本质"></a> #内存本质</h3><p><img src="https://img-blog.csdnimg.cn/direct/b0be605535994a9aaaa292c9d1f0eaba.png" alt=""></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结：</strong></h1><h3 id="计算机原理补充"><a class="markdownIt-Anchor" href="#计算机原理补充"></a> 计算机原理补充：</h3><p><mark>变量的二进制本质上是32位bit的,最高位为符号位，用&amp;按位取反时会改变所有位</mark></p><p><mark>整数在内存中存储的是补码</mark></p><p><mark>补码 -&gt;原码转换不会变符号位</mark></p><p><mark>一个内存单元大小为一个字节，然后再分配地址</mark></p><p><mark>1byte = 8bit</mark></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS2】OriginBot ROS2用指令</title>
      <link href="/posts/54789/"/>
      <url>/posts/54789/</url>
      
        <content type="html"><![CDATA[<h3 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3><p>每次对originbot的功能包参数进行修改后都要进行编译操作，命令如下<br><code>cd /userdata/dev_ws/</code><br><code>colcon build</code></p><h3 id="小车ssh远程连接"><a class="markdownIt-Anchor" href="#小车ssh远程连接"></a> 小车ssh远程连接</h3><p><code>ssh root@192.168.238.81</code><br>在多类终端均可使用该命令</p><h3 id="建立dss连接"><a class="markdownIt-Anchor" href="#建立dss连接"></a> 建立DSS连接</h3><p><code>export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp</code><br><code>CYCLONEDDS_URI='&lt;CycloneDDS&gt;&lt;Domain&gt;&lt;General&gt;&lt;NetworkInterfaceAddress&gt;ens33&lt;/NetworkInterfaceAddress&gt;&lt;/General&gt;&lt;/Domain&gt;&lt;/CycloneDDS&gt;'</code></p><h3 id="查看网络配置"><a class="markdownIt-Anchor" href="#查看网络配置"></a> 查看网络配置</h3><p><code>ifconfig</code><br><code>sudo apt install net-tools</code><br>才能使用ifcongfig命令</p><h3 id="关机"><a class="markdownIt-Anchor" href="#关机"></a> 关机</h3><p><code>halt</code></p><p>xxxxxxxxxx&nbsp;git remote add [alias] [url]//参数[alias]为别名， [url]为远程仓库的地址bash</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> ROS </category>
          
          <category> Linux </category>
          
          <category> RDK X3 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> RDK X3 </tag>
            
            <tag> Originbot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first blog</title>
      <link href="/posts/63785/"/>
      <url>/posts/63785/</url>
      
        <content type="html"><![CDATA[<h2 id="声明本站主要作为个人开发学习也欢迎各位分享知识和交流技术经验"><a class="markdownIt-Anchor" href="#声明本站主要作为个人开发学习也欢迎各位分享知识和交流技术经验"></a> 声明：本站主要作为个人开发学习，也欢迎各位分享知识和交流技术经验。</h2><h3 id="将在后续保持优化网站架构及内容更新"><a class="markdownIt-Anchor" href="#将在后续保持优化网站架构及内容更新"></a> 将在后续保持优化网站架构及内容更新</h3><h4 id="记录markdown错误写法-后面要加空格同理"><a class="markdownIt-Anchor" href="#记录markdown错误写法-后面要加空格同理"></a> 记录，markdown错误写法 ，-后面要加空格（#同理）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tags: </span><br><span class="line">-数字电路与VHDL设计<span class="string">"</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
