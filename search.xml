<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【stm32单片机】[Hal库][3]嵌入式工程模板与“任务调度器”</title>
      <link href="/posts/56683/"/>
      <url>/posts/56683/</url>
      
        <content type="html"><![CDATA[<h1 id="一-任务调度器"><a class="markdownIt-Anchor" href="#一-任务调度器"></a> 一、任务调度器</h1><h2 id="1-调度器结构体"><a class="markdownIt-Anchor" href="#1-调度器结构体"></a> 1. 调度器结构体</h2><p><strong>指针函数:</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调度器类型的结构体类型声明</span></span><br><span class="line"><span class="comment">//任务结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">void</span> *<span class="title function_">task_func</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//指针函数</span></span><br><span class="line">    <span class="type">uint32_t</span> rate_ms;<span class="comment">//任务运行周期</span></span><br><span class="line">    <span class="type">uint32_t</span> last_run;<span class="comment">//上次运行时间</span></span><br><span class="line">} <span class="type">scheduler_task_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><code>typedef struct {} scheduler_task_t;</code>是⼀种定义新结构体类型的⽅式，这⾥定义 了⼀个名为  scheduler_task_t 的结构体类型。这个结构体类型包含三个成员。</p><ul><li><p><code>void *task_func(void);</code>定义了一个函数指针，用于储存任务函数的地址，便于进行任务调度</p></li><li><p><code>rate_ms</code>表示任务具体的执行周期</p></li><li><p><code>last_run</code>⽤于存储任务上次运⾏的时间戳（以毫秒为单位）。该成员⽤于 记录任务上⼀次被调度执⾏的时间点，以便计算任务是否需要再次执⾏</p></li></ul><p>静态任务数组，每个任务包括任务函数，执行周期，和上次执行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Led_task</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义调度器类型的变量 任务</span></span><br><span class="line"><span class="comment">//任务数组</span></span><br><span class="line"><span class="comment">//给scheduler_task_t类型变量tasks赋初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">scheduler_task_t</span> tasks[] ={</span><br><span class="line">    {Led_task,<span class="number">1000</span>,<span class="number">0</span>}<span class="comment">//定义一个任务，任务函数为Led_Proc,执行周期为1000毫秒，初始上次运行时间为0</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="2-调度器初始化"><a class="markdownIt-Anchor" href="#2-调度器初始化"></a> 2. 调度器初始化</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">//计算任务数组中任务函数的个数，结果储存在tasks_num中</span></span><br><span class="line">    tasks_num = <span class="keyword">sizeof</span>(tasks)/<span class="keyword">sizeof</span>(<span class="type">scheduler_task_t</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-调度器函数"><a class="markdownIt-Anchor" href="#3-调度器函数"></a> 3. 调度器函数</h2><p>遍历任务数组，检查是否有任务需要进行，如果系统当前时间超过任务的执行周期，那么执行任务变更，并且更新上次运行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_run</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">/*任务轮询*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>; i&lt; tasks_num; i++){</span><br><span class="line">        <span class="comment">//获取当前时间（毫秒）</span></span><br><span class="line">        <span class="type">uint8_t</span> time_now = HAL_GetTick();</span><br><span class="line">        <span class="comment">//检查任务是否到达当前时间点</span></span><br><span class="line">        <span class="keyword">if</span>(time_now &gt;= tasks[i].rate_ms + tasks[i].last_run){</span><br><span class="line">            <span class="comment">//更新任务的上次运行时间，保存时间戳</span></span><br><span class="line">            tasks[i].last_run = time_now;<span class="comment">//保存当前时间</span></span><br><span class="line">            tasks[i].task_func();<span class="comment">//执行对应指向的任务</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Tensorflow】[2] 神经网络搭建</title>
      <link href="/posts/34487/"/>
      <url>/posts/34487/</url>
      
        <content type="html"><![CDATA[<h1 id="一-独热编码"><a class="markdownIt-Anchor" href="#一-独热编码"></a> 一、独热编码</h1><p>独热编码使用N位代表N种状态，任意时候只有其中一位有效。采用独热编码的例程：</p><p>独热编码使用N位代表N种状态，任意时候只有其中一位有效。</p><p>采用独热编码的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">性别:  </span><br><span class="line">[0, 1]代表女，[1, 0]代表男</span><br><span class="line"></span><br><span class="line">数字0-9: </span><br><span class="line">[0,0,0,0,0,0,0,0,0,1]代表9，[0,1,0,0,0,0,0,0,0,0]代表1</span><br></pre></td></tr></tbody></table></figure><p>独热编码的优点在于</p><ul><li>能够处理非连续型数值特征</li><li>在一定程度上也扩充了特征。比如性别本身是一个特征，经过编码以后，就变成了男或女两个特征。</li><li>适合分类</li></ul><p>在神经网络中，独热编码其实具有很强的容错性，比如神经网络的输出结果是 [0,0.1,0.2,0.7,0,0,0,0,0, 0]转成独热编码后，表示数字3。即值最大的地方变为1，其余均为0。[0,0.1,0.4,0.5,0,0,0,0,0, 0]也能表示数字3。</p><blockquote><p>numpu中有一个函数，numpy.argmax()可以取得最大值的下标。</p></blockquote><h1 id="二-神经网络训练的重要概念"><a class="markdownIt-Anchor" href="#二-神经网络训练的重要概念"></a> 二、神经网络训练的重要概念</h1><h2 id="1-输入x输出y-标签label"><a class="markdownIt-Anchor" href="#1-输入x输出y-标签label"></a> 1. 输入（x）输出（y）、标签（label）</h2><ul><li>输入是指传入给网络处理的向量，相当于数学函数中的变量。</li><li>输出是指网络处理后返回的结果，相当于数据函数中的函数值。</li><li>标签是指我们期望网络返回的结果。</li></ul><p>对于识别mnist图片而言，输入是大小为784（28 * 28）的向量，输出是大小为10的概率向量（概率最大的位置，即预测的数字）,这部分操作由<mark>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的</mark>。</p><h2 id="2-损失函数loss-function"><a class="markdownIt-Anchor" href="#2-损失函数loss-function"></a> 2. 损失函数（loss function）</h2><p>损失函数评估网络模型的好坏，值越大，表示模型越差，值越小，表示模型越好。因为传入大量的训练集训练的目标，就是将损失函数的值降到最小。</p><h3 id="21-常见的损失函数定义"><a class="markdownIt-Anchor" href="#21-常见的损失函数定义"></a> 2.1 <strong>常见的损失函数定义：</strong></h3><p><strong>差的平方和 sum((y - label)^2)</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 1] 与 [0.1, 0.3, 0.6]的差的平方和为 0.01 + 0.09 + 0.16 = 0.26</span><br><span class="line">[0, 0, 1] 与 [0.2, 0.2, 0.6]的差的平方和为 0.04 + 0.04 + 0.16 = 0.24</span><br><span class="line">[0, 0, 1] 与 [0.1, 0, 0.9]的差的平方和为 0.01 + 0.01 = 0.02</span><br></pre></td></tr></tbody></table></figure><p><strong>交叉熵 -sum(label * log(y))</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 1] 与 [0.1, 0.3, 0.6]的交叉熵为 -log(0.6) = 0.51</span><br><span class="line">[0, 0, 1] 与 [0.2, 0.2, 0.6]的交叉熵为 -log(0.6) = 0.51</span><br><span class="line">[0, 0, 1] 与 [0.1, 0, 0.9]的交叉熵为 -log(0.9) = 0.10</span><br></pre></td></tr></tbody></table></figure><p>当label为0时，交叉熵为0，label为1时，交叉熵为-log(y)，交叉熵只关注独热编码中有效位的损失。这样屏蔽了无效位值的变化（无效位的值的变化并不会影响最终结果），并且通过取对数放大了有效位的损失。当有效位的值趋近于0时，交叉熵趋近于正无穷大。</p><h2 id="3-回归模型"><a class="markdownIt-Anchor" href="#3-回归模型"></a> 3. 回归模型</h2><p>我们可以将网络理解为一个函数，回归模型，其实是希望对这个函数进行拟合。<br>比如定义模型为 Y = X * w + b，对应的损失即</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss = (Y - labal)^2</span><br><span class="line">     = -(X * w - b - label)^2</span><br><span class="line">这里损失函数用方差计算，这个函数是关于w和b的二次函数，所以神经网络训练的目的是找到w和b，使得loss最小。</span><br></pre></td></tr></tbody></table></figure><p>可以通过不断地传入X和label的值，来修正w和b，使得最终得到的Y与label的loss最小。这个训练的过程，可以采用<strong>梯度下降</strong>的方法。通过梯度下降，找到最快的方向，调整w和b值，使得w * X + b的值越来越接近label。</p><p><a href="https://blog.csdn.net/iqdutao/article/details/107174240">机器学习-梯度下降算法原理及公式推导_梯度下降计算公式-CSDN博客</a></p><img src="/posts/34487/loss.png" class="" title="loss"><h2 id="4-学习速率"><a class="markdownIt-Anchor" href="#4-学习速率"></a> 4. 学习速率</h2><p>简单说，梯度即一个函数的斜率，找到函数的斜率，其实就知道了w和b的值往哪个方向调整，能够让函数值（loss）降低得最快。那么方向知道了，往这个方向调整多少呢？这个数，神经网络中称之为学习速率。学习速率调得太低，训练速度会很慢，学习速率调得过高，每次迭代波动会很大</p><h2 id="5-softmax激活函数"><a class="markdownIt-Anchor" href="#5-softmax激活函数"></a> 5. softmax激活函数</h2><p>作用：一是放大效果，二是梯度下降时需要一个可导的函数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def softmax(x):</span><br><span class="line">    import numpy as np</span><br><span class="line">    return np.exp(x) / np.sum(np.exp(x), axis=0)</span><br><span class="line"></span><br><span class="line">softmax([4, 5, 10])</span><br><span class="line"># [ 0.002,  0.007,  0.991]</span><br></pre></td></tr></tbody></table></figure><h1 id="三-tensorflow识别手写数字-实现简单的神经网络"><a class="markdownIt-Anchor" href="#三-tensorflow识别手写数字-实现简单的神经网络"></a> 三、tensorflow识别手写数字-实现简单的神经网络</h1><h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> # 思考</h1><h2 id="一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"><a class="markdownIt-Anchor" href="#一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"></a> 一、输入x是 784长度的向量，什么机制使得输出y变成的长度为10的向量？</h2><p>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的。具体操作通过 <strong>权重矩阵</strong> 和 <strong>偏置向量</strong> 来完成。</p><h3 id="1-全连接层的基本机制"><a class="markdownIt-Anchor" href="#1-全连接层的基本机制"></a> 1. <strong>全连接层的基本机制：</strong></h3><p>全连接层的工作机制可以用矩阵乘法来描述。给定输入向量 x<em>x</em>（长度为784），要转换为长度为10的输出向量，通常通过如下步骤：</p><h4 id="2-步骤"><a class="markdownIt-Anchor" href="#2-步骤"></a> 2. <strong>步骤：</strong></h4><ol><li><p><strong>输入向量 <img src="/posts/34487/image-20240907224214042.png" class="" title="image-20240907224214042"></strong>：这是一个长度为784的向量，表示神经网络的输入。</p><img src="/posts/34487/image-20240907224042533.png" class="" title="image-20240907224042533"></li><li><p><strong>权重矩阵 <img src="/posts/34487/image-20240907224200098.png" class="" title="image-20240907224200098"></strong>：全连接层会有一个权重矩阵 W<em>W</em>，其维度是 10×78410×784，表示从输入784维向量到输出10维向量的权重连接。每一行表示一个输出神经元与所有输入神经元的权重连接。</p></li><li><p><strong>偏置向量 <img src="/posts/34487/image-20240907224226570.png" class="" title="image-20240907224226570"></strong>：偏置向量 b<em>b</em> 是一个长度为10的向量，表示每个输出神经元的偏置。</p></li><li><p><strong>计算输出向量 <img src="/posts/34487/image-20240907224234671.png" class="" title="image-20240907224234671"></strong>：通过矩阵乘法计算输出向量。输出向量 o<em>o</em> 的维度是10。具体计算方式如下：</p><img src="/posts/34487/image-20240907224051327.png" class="" title="image-20240907224051327"><ul><li>W \cdot x )：矩阵 ( W ) 乘以向量 ( x )，将784维的输入向量映射为10维的输出向量。</li></ul></li></ol><h3 id="3-矩阵乘法具体步骤"><a class="markdownIt-Anchor" href="#3-矩阵乘法具体步骤"></a> 3. <strong>矩阵乘法具体步骤：</strong></h3><ul><li><p>假设输入向量<img src="/posts/34487/image-20240907224214042.png" class="" title="image-20240907224214042"> 是长度为784的向量：</p><img src="/posts/34487/image-20240907224100515.png" class="" title="image-20240907224100515"></li><li><p>权重矩阵 <img src="/posts/34487/image-20240907224200098.png" class="" title="image-20240907224200098"> 是一个 10×78410×784 的矩阵：</p><img src="/posts/34487/image-20240907224116095.png" class="" title="image-20240907224116095"></li><li><p>偏置向量<img src="/posts/34487/image-20240907224226570.png" class="" title="image-20240907224226570"> 是一个长度为10的向量：</p><img src="/posts/34487/image-20240907224125174.png" class="" title="image-20240907223954313"></li><li><p>输出向量 <img src="/posts/34487/image-20240907224234671.png" class="" title="image-20240907224234671">通过矩阵乘法和加法得到，维度为10：</p><img src="/posts/34487/image-20240907224134345.png" class="" title="image-20240907224134345"></li></ul><p>每一行表示一个输出神经元的结果，最终得到一个长度为10的向量。</p><h3 id="4-激活函数"><a class="markdownIt-Anchor" href="#4-激活函数"></a> 4. <strong>激活函数：</strong></h3><p>在得到长度为10的向量后，通常会将其通过激活函数进行处理。在分类任务中，输出层通常使用 <strong>Softmax</strong> 函数，将每个输出值转换为概率值。Softmax 函数公式为：</p><img src="/posts/34487/image-20240907224012315.png" class="" title="image-20240907224012315"><p>这会将输出向量 o<em>o</em> 转换为一个概率分布，表示输入属于不同类别的概率。</p><p>作用：对输出结果进行非负化和归一化，保证了概论的和为1</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>将784长度的输入向量变为10长度的输出向量的关键步骤是通过 <strong>全连接层的矩阵乘法</strong> 和 <strong>偏置项</strong>，最终计算出长度为10的向量，并通过 <strong>Softmax</strong> 函数将其转换为概率分布，从而实现分类。</p><h2 id="二-softmax"><a class="markdownIt-Anchor" href="#二-softmax"></a> 二、Softmax</h2><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> # 参考文章</h1><p><a href="https://geektutu.com/post/tensorflow-mnist-simplest.html">TensorFlow入门(一) - mnist手写数字识别(网络搭建) | 极客兔兔 (geektutu.com)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】[1]Python的基本语法</title>
      <link href="/posts/46726/"/>
      <url>/posts/46726/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Git学习】[3]标签管理</title>
      <link href="/posts/7213/"/>
      <url>/posts/7213/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针</p><p>使用<code>tag</code>命名指向历史版本号，能够更好的进行代码管理</p><h1 id="一-创建标签"><a class="markdownIt-Anchor" href="#一-创建标签"></a> 一、创建标签</h1><p>查看分支</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></tbody></table></figure><p>创建新的标签</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903190927707.png" class="" title="image-20240903190927707"><p>查看所有标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191014025.png" class="" title="image-20240903191014025"><p>查看历史提交</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline --abbrev-commit</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191100832.png" class="" title="image-20240903191100832"><p>比如要对-&gt;“博客备份”这次打标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.9 607328c</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191236366.png" class="" title="image-20240903191236366"><p>查看标签信息，注意：```tag``是按字母顺序排列的</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v0.9</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191323368.png" class="" title="image-20240903191323368"><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v0.1 -m "version 0.1 released" 1094adb</span><br></pre></td></tr></tbody></table></figure><h1 id="二-操作标签"><a class="markdownIt-Anchor" href="#二-操作标签"></a> 二、操作标签</h1><p>删除标签</p><p>注意：对标签的操作都在本地，不会影响远程</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v0.1</span><br></pre></td></tr></tbody></table></figure><p>如果要推送标签到远程仓库，使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.0</span><br></pre></td></tr></tbody></table></figure><p>一次性推送全部尚未推送到远程的标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></tbody></table></figure><p>如果标签已经推送到远程，需要：</p><p>1.删除本地标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v0.9</span><br></pre></td></tr></tbody></table></figure><p>2.从远程删除</p><p>格式：:refs/tags/<tagname></tagname></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v0.9</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Git </category>
          
          <category> 分布式系统 </category>
          
          <category> github </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Git学习】[2]分支管理</title>
      <link href="/posts/21302/"/>
      <url>/posts/21302/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Git </category>
          
          <category> 分布式系统 </category>
          
          <category> github </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习】[1]神经网络的基本概念</title>
      <link href="/posts/23492/"/>
      <url>/posts/23492/</url>
      
        <content type="html"><![CDATA[<h1 id="一-神经网络的基本概念"><a class="markdownIt-Anchor" href="#一-神经网络的基本概念"></a> 一、神经网络的基本概念</h1><h2 id="1-神经元感知器"><a class="markdownIt-Anchor" href="#1-神经元感知器"></a> 1. 神经元（感知器）</h2><p>一种被称为感知器的人工神经元在20世纪五六十年代被科学家Frank提出。通过数学模型，可以认识到<strong>感知器</strong>是一个根据输入与权重来做出决定的设备，随着<strong>权重</strong>和<strong>阈值</strong>的变化，可以得到不同的<strong>决策模型</strong>。当一个感知器计算后得到的值大于阈值时，从神经学的角度来讲这个感知器被激活，反之为0。感知器可以一定程度上模仿人脑做出决策，但是感知器的决策过程全部是线性的，在处理图像处理、语音识别等复杂问题时，难以仅靠线性模型达到良好的识别效果，因此需要在感知器模型种引入非线性部分。</p><h2 id="2-非线性神经元"><a class="markdownIt-Anchor" href="#2-非线性神经元"></a> 2. 非线性神经元</h2><p>为解决复杂的数学模型，引入<strong>激活函数</strong>，激活函数给神经元带来了非线性因素，使得神经网络可以任意逼近任何非线性函数。</p><p>通常将激活函数与线性神经元合并使之成为<strong>非线性神经元</strong></p><p>如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的<a href="https://baike.baidu.com/item/%E6%84%9F%E7%9F%A5%E6%9C%BA/12723581">感知机</a>（Perceptron）。</p><img src="/posts/23492/34d6b14bf4b79175276eac52abacdf94.png" class="" title="img"><p>激活函数可以分为<strong>两大类：</strong></p><img src="/posts/23492/e41598583c8b35dcbb907f9fd66d8351.png" class="" title="img"><ul><li><strong>饱和激活函数：</strong> sigmoid、 tanh…</li><li><strong>非饱和激活函数:</strong> ReLU 、Leaky Relu  、ELU、PReLU、RReLU…</li></ul><p><a href="https://blog.csdn.net/qq_42691298/article/details/126590726">深度学习中常见的10种激活函数（Activation Function）总结_激活函数有哪些-CSDN博客</a></p><h2 id="3常见的激活函数"><a class="markdownIt-Anchor" href="#3常见的激活函数"></a> 3.常见的激活函数</h2><h3 id="31-sigmoid函数"><a class="markdownIt-Anchor" href="#31-sigmoid函数"></a> 3.1 Sigmoid函数</h3><img src="/posts/23492/6c9269a456ee0497c9bb0d1383e51cc8.png" class="" title="img"><img src="/posts/23492/af5f15ef44f1b276c78bec5e140e7082.png" class="" title="img"><h3 id="32-tanh函数"><a class="markdownIt-Anchor" href="#32-tanh函数"></a> 3.2 tanh函数</h3><p><strong>tanh</strong>激活函数的数学表达式为：</p><img src="/posts/23492/70ad61d6f8c019d3dee98ad6ef45cb1a.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/e58d7204fef7f7410e92b4bf82e91938.png" class="" title="img"><h3 id="33-relu函数"><a class="markdownIt-Anchor" href="#33-relu函数"></a> 3.3 ReLU函数</h3><p><strong>ReLU</strong>激活函数的数学表达式为：</p><img src="/posts/23492/ae65877d14768ad1b6789c6ccdcd6e31.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/a2f4f9f3c522518908e20d7865beb48c.png" class="" title="img"><p>什么情况下适合使用ReLU？</p><ul><li><p>ReLU解决了梯度消失的问题，当输入值为正时，神经元不会饱和</p></li><li><p>由于ReLU线性、非饱和的性质，在SGD中能够快速收敛</p></li><li><p>计算复杂度低，不需要进行指数运算</p></li></ul><p>ReLU有哪些缺点？</p><ul><li><p>与Sigmoid一样，其输出不是以0为中心的</p></li><li><p>Dead ReLU 问题。当输入为负时，梯度为0。这个神经元及之后的神经元梯度永远为0，不再对任何数据有所响应，导致相应参数永远不会被更新</p></li><li><p>训练神经网络的时候，一旦学习率没有设置好，第一次更新权重的时候，输入是负值，那么这个含有ReLU的神经节点就会死亡，再也不会被激活。所以，要设置一个合适的较小的学习率，来降低这种情况的发生</p></li></ul><h2 id="4-神经网络的基本架构"><a class="markdownIt-Anchor" href="#4-神经网络的基本架构"></a> 4. 神经网络的基本架构</h2><img src="/posts/23492/bf32fef369b3823adc20dcdf9af603e3.jpg" class="" title="bf32fef369b3823adc20dcdf9af603e3"><ul><li><p>神经网络最左边的称为<strong>输入层</strong>，其中的神经元称为<strong>输入神经元</strong>，原始数据经由该层输入到神经网络进行后续处理。</p></li><li><p>最右边的称为<strong>输出层</strong>，包含输出神经元，该层的输出是神经网络对样本处理后的最终结果，如分类结果。</p></li><li><p>在输入层和输出层之间的是中间层，也称为 <strong>隐藏层</strong>，即既非输入也非输出的神经网络层，一个神经网络可以有一个或者多个隐藏层，隐藏层的主要作用是处理从上一层神经元传递来的信号。</p></li></ul><p>一般的，<strong>输入层</strong>和 <strong>输出层</strong>在整体神经网络的外部，称为可见层。设计神经网络的输入输出通常比较简单，直接，例如，假设我们知道了一朵花的4个明显特征（如花瓣的长度，宽度），可以利用这4个特征确定它是哪一种类的花，由于我们已经知道这朵花的4个特征，那么就需要4个输入神经元，每个数值代表花朵的一种特征的具体数值。<strong>输出层</strong>可以包含一个或者多个神经元，这由我们想要设定的具体花朵类别决定，可以根据输出的数字，确定花朵的类型。我们可以使用每一个<strong>输出神经元</strong>代表一种类型的花，这种方法称为One-Hot，One-Hot是一种常见的输出层编码方法。</p><h2 id="5-梯度下降"><a class="markdownIt-Anchor" href="#5-梯度下降"></a> 5. 梯度下降</h2><p><a href="https://blog.csdn.net/iqdutao/article/details/107174240">机器学习-梯度下降算法原理及公式推导_梯度下降计算公式-CSDN博客</a></p><h2 id="6-反向传播"><a class="markdownIt-Anchor" href="#6-反向传播"></a> 6. 反向传播</h2><p><a href="https://blog.csdn.net/ft_sunshine/article/details/90221691">“反向传播算法”过程及公式推导（超直观好懂的Backpropagation）_反向传播算法(过程及公式推导)-CSDN博客</a></p><p><strong>“正向传播”求损失，“反向传播”回传误差</strong>。同时，神经网络每层的每个神经元都可以<strong>根据误差信号修正每层的权重</strong></p><h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h1><h2 id="一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"><a class="markdownIt-Anchor" href="#一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"></a> 一、输入x是 784长度的向量，什么机制使得输出y变成的长度为10的向量？</h2><p>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的。具体操作通过 <strong>权重矩阵</strong> 和 <strong>偏置向量</strong> 来完成。</p><h3 id="1-全连接层的基本机制"><a class="markdownIt-Anchor" href="#1-全连接层的基本机制"></a> 1. <strong>全连接层的基本机制：</strong></h3><p>全连接层的工作机制可以用矩阵乘法来描述。给定输入向量 x<em>x</em>（长度为784），要转换为长度为10的输出向量，通常通过如下步骤：</p><h4 id="2-步骤"><a class="markdownIt-Anchor" href="#2-步骤"></a> 2. <strong>步骤：</strong></h4><ol><li><p><strong>输入向量 <img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"></strong>：这是一个长度为784的向量，表示神经网络的输入。</p><img src="/posts/23492/image-20240907224042533.png" class="" title="image-20240907224042533"></li><li><p><strong>权重矩阵 <img src="/posts/23492/image-20240907224200098.png" class="" title="image-20240907224200098"></strong>：全连接层会有一个权重矩阵 W<em>W</em>，其维度是 10×78410×784，表示从输入784维向量到输出10维向量的权重连接。每一行表示一个输出神经元与所有输入神经元的权重连接。</p></li><li><p><strong>偏置向量 <img src="/posts/23492/image-20240907224226570.png" class="" title="image-20240907224226570"></strong>：偏置向量 b<em>b</em> 是一个长度为10的向量，表示每个输出神经元的偏置。</p></li><li><p><strong>计算输出向量 <img src="/posts/23492/image-20240907224234671.png" class="" title="image-20240907224234671"></strong>：通过矩阵乘法计算输出向量。输出向量 o<em>o</em> 的维度是10。具体计算方式如下：</p><img src="/posts/23492/image-20240907224051327.png" class="" title="image-20240907224051327"><ul><li>W \cdot x )：矩阵 ( W ) 乘以向量 ( x )，将784维的输入向量映射为10维的输出向量。</li></ul></li></ol><h3 id="3-矩阵乘法具体步骤"><a class="markdownIt-Anchor" href="#3-矩阵乘法具体步骤"></a> 3. <strong>矩阵乘法具体步骤：</strong></h3><ul><li><p>假设输入向量<img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"> 是长度为784的向量：</p><img src="/posts/23492/image-20240907224100515.png" class="" title="image-20240907224100515"></li><li><p>权重矩阵 W<em>W</em> 是一个 10×78410×784 的矩阵：</p><img src="/posts/23492/image-20240907224116095.png" class="" title="image-20240907224116095"></li><li><p>偏置向量 b<em>b</em> 是一个长度为10的向量：</p><img src="/posts/23492/image-20240907224125174.png" class="" title="image-20240907223954313"></li><li><p>输出向量 o<em>o</em> 通过矩阵乘法和加法得到，维度为10：</p><img src="/posts/23492/image-20240907224134345.png" class="" title="image-20240907224134345"></li></ul><p>每一行表示一个输出神经元的结果，最终得到一个长度为10的向量。</p><h3 id="4-激活函数"><a class="markdownIt-Anchor" href="#4-激活函数"></a> 4. <strong>激活函数：</strong></h3><p>在得到长度为10的向量后，通常会将其通过激活函数进行处理。在分类任务中，输出层通常使用 <strong>Softmax</strong> 函数，将每个输出值转换为概率值。Softmax 函数公式为：</p><img src="/posts/23492/image-20240907224012315.png" class="" title="image-20240907224012315"><p>这会将输出向量 o<em>o</em> 转换为一个概率分布，表示输入属于不同类别的概率。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>将784长度的输入向量变为10长度的输出向量的关键步骤是通过 <strong>全连接层的矩阵乘法</strong> 和 <strong>偏置项</strong>，最终计算出长度为10的向量，并通过 <strong>Softmax</strong> 函数将其转换为概率分布，从而实现分类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记,深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[Hal库][2]stm32时钟树</title>
      <link href="/posts/9067/"/>
      <url>/posts/9067/</url>
      
        <content type="html"><![CDATA[<h1 id="一-锁相环的原理与应用"><a class="markdownIt-Anchor" href="#一-锁相环的原理与应用"></a> 一、锁相环的原理与应用</h1><p>参考文章：<a href="https://blog.csdn.net/weixin_46274168/article/details/130437627">【STM32】知识补充 锁相环原理与应用解析_stm32数字锁相-CSDN博客</a></p><h2 id="什么是锁相环-ppl"><a class="markdownIt-Anchor" href="#什么是锁相环-ppl"></a> 什么是锁相环 (PPL)</h2><p>锁相环是一种闭环反馈控制系统. 用于生成与输入信号同步且<a href="https://so.csdn.net/so/search?q=%E7%9B%B8%E4%BD%8D&amp;spm=1001.2101.3001.7020">相位</a>相同的输出信号. 它的核心功能是在输入信号的相位变化时, 自动调整输出信号以保持同步. 这使得锁相环成为了一种理想的频率和相位控制技术.</p><img src="/posts/9067/f9cb0a753bddf1fb37003ddd1310111b.png" class="" title="锁相环原理图"><h2 id="锁相环的基本组成"><a class="markdownIt-Anchor" href="#锁相环的基本组成"></a> 锁相环的基本组成</h2><p>锁相环主要由以下几个部分组成:</p><ul><li>相位比较器 (Phase Detector): 相位比较器负责比较输入信号和反馈信号的相位差, 并将其转换为电压信号</li><li>低通滤波器 (Low-Pass Filter): 低通滤波器对相位比较器的输出信号进行滤波, 以消除高频噪声和相位抖动</li><li>电压控制振荡器 (Voltage-Controlled Oscillator): 根据低通过滤波器的输出电压调整输出信号的频率和相位</li><li>反馈分频器 (Feedback Divider): 反馈分频器对 VCO 的输出信号进行分频处理, 并将其反馈给相位比较器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Tensorflow】[1]配置Tensorflow-GPU的快速模型训练</title>
      <link href="/posts/33676/"/>
      <url>/posts/33676/</url>
      
        <content type="html"><![CDATA[<p>author: sz_jmu</p><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>TensorFlow 是一个用于机器学习和深度学习的开源框架，由 Google Brain 团队开发并在 2015 年发布。它是目前最流行的深度学习框架之一，广泛用于构建、训练和部署机器学习模型，特别是在处理复杂的神经网络任务时。TensorFlow 提供了灵活的工具和库，支持从研究到生产环境中的机器学习应用。</p><p>TensorFlow可以支持CPU，也可以支持CPU+GPU，前者配置较为简单，兼容性较好，后者需要一些额外的操作支持。</p><p>在训练规模庞大的模型时，使用CPU往往存在较大的性能限制，模型训练速度较慢。神经网络算法通常涉及大量的参数、激活值、梯度值的缓冲区，其中每个值在每一次训练迭代中国都要被完全更新，有可能会超出传统计算机的高速缓存（Cache），所以内存带宽通常会成为主要瓶颈。而与CPU相比，GPU的一个显著优势就是具有极高的内存带宽。神经网络的训练算法通常不涉及大量的分支运算和复杂控制指令，更适合在GPU硬件上完成，具有并行特性的GPU更适合神经网络的计算，因此，安装TensorFlow的GPU环境是合适的选择。</p><p>参考文章：</p><p><a href="https://blog.csdn.net/Sciws/article/details/125290718">解决tensorflow-gpu版本训练loss一直为nan，或者loss，accuracy数值明显不对问题_采用gpu训练 loss为负数 采用cpu训练正常-CSDN博客</a></p><p>注意：配置Tensorflow gpu版本，建议使用Anoconda创建环境，避免出现污染环境变量等问题，Anoconda的配置与使用，不做过多赘述。</p><h1 id="一-tensorflow环境的基本配置"><a class="markdownIt-Anchor" href="#一-tensorflow环境的基本配置"></a> 一、Tensorflow环境的基本配置</h1><p>Tensorflow的GPU环境，在不同的系统下配置存在一些兼容性问题，如果直接安装最新的版本，很难完成通过GPU进行深度学习相关的环境搭建。</p><p>CUDA,cuDNN,python,tensorflow的版本需要一一对应。</p><p>使用如：python=3.8 CUDA=11.3 cuDNN=8.2.1 tensorflow-gpu=2.7.0，运行较为稳定。</p><p><strong>在Anoconda命令行环境下，创建Tensorflow的专属环境</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tf_gpu_1 python==<span class="number">3.8</span></span><br></pre></td></tr></tbody></table></figure><p><strong>诸如CSDN等网站，许多参考文章说明要从Nivida官网安装CUDA，比较耗时麻烦，实际上tensorflow需要的是CUDA中的cudatoolkit，所以在Anoconda环境下进行如下安装操作即可：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install cudatoolkit=<span class="number">11.3</span></span><br></pre></td></tr></tbody></table></figure><p><strong>安装cudnn,实际上作用是CUDA的补丁包</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install cudnn=<span class="number">8.2</span><span class="number">.1</span></span><br></pre></td></tr></tbody></table></figure><p><strong>安装tensorflow-gpu版本</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install tensorflow-gpu=<span class="number">2.7</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><p><strong>安装完成后，在tf_gpu_1环境中，检查是否能够查找到显卡驱动</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nivida-smi</span><br></pre></td></tr></tbody></table></figure><p><strong>检查tensorflow是否识别到GPU设备</strong></p><p>1.进入python命令行环境</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></tbody></table></figure><p>2.导入tensorflow库</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></tbody></table></figure><p>3.是否查找到GPU设备</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"是否有 GPU 设备:"</span>, <span class="built_in">len</span>(tf.config.list_physical_devices(<span class="string">'GPU'</span>)) &gt; <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><p>如果tensorflow环境配置正常，能够正常识别到主机GPU，tensorflow深度学习框架基本搭建完成，由于此例使用的tensorflow和python版本不是当前最高版本，后续自行编写相关代码可能需要根据具体的情况安装更多的依赖包或对代码进行调整。</p><h1 id="二-手写汉字识别神经网络模型训练"><a class="markdownIt-Anchor" href="#二-手写汉字识别神经网络模型训练"></a> 二、手写汉字识别神经网络模型训练</h1><h2 id="1数据集的准备"><a class="markdownIt-Anchor" href="#1数据集的准备"></a> 1.数据集的准备</h2><p>要实现手写汉字识别，需要准备规模庞大的数据集。仅仅是常见的汉字数据集，就有高达七千多种类别，且汉字书法风格迥异，若要训练出泛化性强，准确度高的神经网络模型，就需要足够充分复杂的数据集，数据集即要体现出汉字的普遍特征，也要具备不同的形式风格，通过数据集也可以预料到需要足够强大的模型才能实现对任意手写汉字的识别。</p><p>例如，常见手写汉字识别数据集的下载：</p><p><a href="https://drive.google.com/file/d/1k849yUZhkUfbupZT0kRR2ZzZj5g89yLw/view?usp=sharing">汉字名为类别标签的手写数据集</a> (747M)</p><p>文件结构如下：</p><p>├── data<br>│   ├── chinese-calligraphy-dataset<br>│   │   ├── ㄚ<br>│   │   ├── 一<br>│   │   ├── 丁<br>│   │   ├── 七<br>│   │   ├── 万<br>│   │   └── …<br>│   └── label_character.csv</p><h2 id="2编写tensorflow工具链与使用说明"><a class="markdownIt-Anchor" href="#2编写tensorflow工具链与使用说明"></a> 2.编写Tensorflow工具链与使用说明</h2><p>准备好数据集后，我们首先要做的工作是对数据集进行处理，使其符合神经网络模型训练的规范格式，其次，也有一些通过程序的方法能够对原始数据集进行处理，增加数据集的多样性，我们使用的方法为“数据增强”，即在原始数据集的基础上，对每张图片进行小幅度旋转，对比度调节，平移，压缩，放大等操作，这样有利于提高最后训练的模型的泛化性。</p><p>注意：代码运行需要在在命令行的<mark>本例：tf_gpu_1</mark>的环境中运行</p><h3 id="21数据集划分脚本"><a class="markdownIt-Anchor" href="#21数据集划分脚本"></a> 2.1<strong>数据集划分脚本</strong></h3><p>本脚本分为三个阶段：</p><p>1.将原始数据集复制到指定目录，并且分为test,val,train，即测试集，验证集，训练集。</p><p>2.对分类后的数据集进行数据增强，每张图片生成5张增强后的图像，那么，数据集的复杂程度得到了一定的增加</p><p>3.检查测试集中是否存在空的子文件夹，由于有些类别的汉字图片可能较少，按照代码中：20%的比例从训练集划分给测试集，若测试集图片少于2张，可能导致测试集中该类别没有对应的图片，所以，这个阶段用于对测试集文件夹进行二次排查，确保测试集中不存在空的汉字类别图片。</p><p><mark>使用方法：</mark></p><p>修改</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src_data_folder = <span class="string">"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/CursiveChineseCalligraphyDataset-master/Cursive_Chinese_Calligraphy_Dataset/Training"</span>  <span class="comment"># todo 修改你的原始数据集路径</span></span><br><span class="line">target_data_folder = <span class="string">"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu"</span>  <span class="comment"># </span></span><br></pre></td></tr></tbody></table></figure><p>其中src_data_folder为原始数据集路径，target_data_folder为划分好的目标路径(将包含train,val,test三个子文件夹)</p><p>在tf_gpu_1环境下，输入命令 python data_split.py</p><p><strong>完整代码(data_split.py)如下：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copy2, move</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageEnhance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_file</span>(<span class="params">src_dest</span>):</span><br><span class="line">    src_img_path, target_folder = src_dest</span><br><span class="line">    copy2(src_img_path, target_folder)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_file</span>(<span class="params">src_dest</span>):</span><br><span class="line">    src_img_path, target_folder = src_dest</span><br><span class="line">    move(src_img_path, target_folder)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">augment_image</span>(<span class="params">src_img_path, target_folder, num_augments=<span class="number">5</span></span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(src_img_path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_augments):</span><br><span class="line">        img_aug = img.copy()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机旋转</span></span><br><span class="line">        angle = random.uniform(-<span class="number">15</span>, <span class="number">15</span>)  <span class="comment"># -15到15度之间的随机旋转</span></span><br><span class="line">        img_aug = img_aug.rotate(angle, fillcolor=<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机平移</span></span><br><span class="line">        max_translate = <span class="number">5</span>  <span class="comment"># 最大平移像素值</span></span><br><span class="line">        x_translate = random.randint(-max_translate, -max_translate)</span><br><span class="line">        y_translate = random.randint(-max_translate, -max_translate)</span><br><span class="line">        img_aug = img_aug.transform(img_aug.size, Image.AFFINE, (<span class="number">1</span>, <span class="number">0</span>, x_translate, <span class="number">0</span>, <span class="number">1</span>, y_translate),</span><br><span class="line">                                    fillcolor=<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机缩放</span></span><br><span class="line">        scale_factor = random.uniform(<span class="number">0.9</span>, <span class="number">1.1</span>)</span><br><span class="line">        w, h = img_aug.size</span><br><span class="line">        img_aug = img_aug.resize((<span class="built_in">int</span>(w * scale_factor), <span class="built_in">int</span>(h * scale_factor)), Image.Resampling.LANCZOS)</span><br><span class="line">        img_aug = img_aug.resize((w, h), Image.Resampling.LANCZOS)  <span class="comment"># 重新调整为原始尺寸</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机对比度调整</span></span><br><span class="line">        enhancer = ImageEnhance.Contrast(img_aug)</span><br><span class="line">        img_aug = enhancer.enhance(random.uniform(<span class="number">0.8</span>, <span class="number">1.2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机亮度调整</span></span><br><span class="line">        enhancer = ImageEnhance.Brightness(img_aug)</span><br><span class="line">        img_aug = enhancer.enhance(random.uniform(<span class="number">0.8</span>, <span class="number">1.2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存增强后的图像</span></span><br><span class="line">        aug_img_name = os.path.basename(src_img_path).replace(<span class="string">"."</span>, <span class="string">f"_aug_<span class="subst">{i}</span>."</span>)</span><br><span class="line">        img_aug.save(os.path.join(target_folder, aug_img_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_set_split_and_augment</span>(<span class="params">src_data_folder, target_data_folder, train_scale=<span class="number">0.8</span>, val_scale=<span class="number">0.2</span>, test_scale=<span class="number">0.0</span>,</span></span><br><span class="line"><span class="params">                               num_augments=<span class="number">5</span></span>):</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    读取源数据文件夹，生成划分好的文件夹，并对每张图片生成5张增强图片。</span></span><br><span class="line"><span class="string">    :param src_data_folder: 源文件夹</span></span><br><span class="line"><span class="string">    :param target_data_folder: 目标文件夹</span></span><br><span class="line"><span class="string">    :param train_scale: 训练集比例</span></span><br><span class="line"><span class="string">    :param val_scale: 验证集比例</span></span><br><span class="line"><span class="string">    :param test_scale: 测试集比例</span></span><br><span class="line"><span class="string">    :param num_augments: 每张图片生成的增强图片数量</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    class_names = os.listdir(src_data_folder)</span><br><span class="line">    split_names = [<span class="string">'train'</span>, <span class="string">'val'</span>, <span class="string">'test'</span>]</span><br><span class="line">    data_split_completed = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查目标文件夹是否已存在文件，如果存在则跳过数据集划分</span></span><br><span class="line">    <span class="keyword">for</span> split_name <span class="keyword">in</span> split_names:</span><br><span class="line">        split_path = os.path.join(target_data_folder, split_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(split_path) <span class="keyword">or</span> <span class="built_in">len</span>(os.listdir(split_path)) == <span class="number">0</span>:</span><br><span class="line">            data_split_completed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data_split_completed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"开始数据集划分"</span>)</span><br><span class="line">        <span class="comment"># 在目标目录下创建文件夹</span></span><br><span class="line">        <span class="keyword">for</span> split_name <span class="keyword">in</span> split_names:</span><br><span class="line">            split_path = os.path.join(target_data_folder, split_name)</span><br><span class="line">            os.makedirs(split_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># 在split_path的目录下创建类别文件夹</span></span><br><span class="line">            <span class="keyword">for</span> class_name <span class="keyword">in</span> class_names:</span><br><span class="line">                class_split_path = os.path.join(split_path, class_name)</span><br><span class="line">                os.makedirs(class_split_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        tasks = []</span><br><span class="line">        total_files = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算总文件数并生成任务列表</span></span><br><span class="line">        <span class="keyword">for</span> class_name <span class="keyword">in</span> class_names:</span><br><span class="line">            current_class_data_path = os.path.join(src_data_folder, class_name)</span><br><span class="line">            current_all_data = os.listdir(current_class_data_path)</span><br><span class="line">            total_files += <span class="built_in">len</span>(current_all_data)</span><br><span class="line"></span><br><span class="line">            random.shuffle(current_all_data)</span><br><span class="line"></span><br><span class="line">            train_folder = os.path.join(os.path.join(target_data_folder, <span class="string">'train'</span>), class_name)</span><br><span class="line">            val_folder = os.path.join(os.path.join(target_data_folder, <span class="string">'val'</span>), class_name)</span><br><span class="line">            test_folder = os.path.join(os.path.join(target_data_folder, <span class="string">'test'</span>), class_name)</span><br><span class="line"></span><br><span class="line">            train_stop_flag = <span class="built_in">len</span>(current_all_data) * train_scale</span><br><span class="line">            val_stop_flag = <span class="built_in">len</span>(current_all_data) * (train_scale + val_scale)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> idx, img_name <span class="keyword">in</span> <span class="built_in">enumerate</span>(current_all_data):</span><br><span class="line">                src_img_path = os.path.join(current_class_data_path, img_name)</span><br><span class="line">                <span class="keyword">if</span> idx &lt;= train_stop_flag:</span><br><span class="line">                    tasks.append((src_img_path, train_folder))</span><br><span class="line">                <span class="keyword">elif</span> idx &lt;= val_stop_flag:</span><br><span class="line">                    tasks.append((src_img_path, val_folder))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tasks.append((src_img_path, test_folder))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用多线程进行复制，并显示进度条</span></span><br><span class="line">        <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">8</span>) <span class="keyword">as</span> executor:</span><br><span class="line">            <span class="built_in">list</span>(tqdm(executor.<span class="built_in">map</span>(copy_file, tasks), total=total_files, desc=<span class="string">"文件复制进度"</span>))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"数据集划分完成！"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"数据集划分已经完成，跳过该步骤。"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二阶段：数据增强</span></span><br><span class="line">    data_augmentation_completed = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> class_name <span class="keyword">in</span> class_names:</span><br><span class="line">        train_class_folder = os.path.join(target_data_folder, <span class="string">'train'</span>, class_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>(<span class="string">"_aug_"</span> <span class="keyword">in</span> fname <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(train_class_folder)):</span><br><span class="line">            data_augmentation_completed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data_augmentation_completed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"开始数据增强"</span>)</span><br><span class="line">        aug_tasks = []</span><br><span class="line">        <span class="keyword">for</span> split_name <span class="keyword">in</span> split_names:</span><br><span class="line">            split_folder = os.path.join(target_data_folder, split_name)</span><br><span class="line">            <span class="keyword">for</span> class_name <span class="keyword">in</span> class_names:</span><br><span class="line">                class_split_folder = os.path.join(split_folder, class_name)</span><br><span class="line">                <span class="keyword">for</span> img_name <span class="keyword">in</span> os.listdir(class_split_folder):</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">"_aug_"</span> <span class="keyword">in</span> img_name:  <span class="comment"># 检查是否已经增强过</span></span><br><span class="line">                        src_img_path = os.path.join(class_split_folder, img_name)</span><br><span class="line">                        aug_tasks.append((src_img_path, class_split_folder, num_augments))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">8</span>) <span class="keyword">as</span> executor:</span><br><span class="line">            <span class="built_in">list</span>(tqdm(executor.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: augment_image(*x), aug_tasks), total=<span class="built_in">len</span>(aug_tasks), desc=<span class="string">"数据增强进度"</span>))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"数据增强完成！"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"数据增强已经完成，跳过该步骤。"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三阶段：检查并补充val文件夹中的内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"开始检查并补充val文件夹"</span>)</span><br><span class="line">    supplement_tasks = []</span><br><span class="line">    <span class="keyword">for</span> class_name <span class="keyword">in</span> class_names:</span><br><span class="line">        val_class_folder = os.path.join(target_data_folder, <span class="string">'val'</span>, class_name)</span><br><span class="line">        train_class_folder = os.path.join(target_data_folder, <span class="string">'train'</span>, class_name)</span><br><span class="line"></span><br><span class="line">        val_files = os.listdir(val_class_folder)</span><br><span class="line">        train_files = os.listdir(train_class_folder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(val_files) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(val_files) &lt; <span class="built_in">len</span>(train_files) * <span class="number">0.1</span>:</span><br><span class="line">            num_to_move = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="built_in">len</span>(train_files) * <span class="number">0.1</span>))</span><br><span class="line">            random.shuffle(train_files)</span><br><span class="line">            files_to_move = train_files[:num_to_move]</span><br><span class="line">            <span class="keyword">for</span> file_name <span class="keyword">in</span> files_to_move:</span><br><span class="line">                src_img_path = os.path.join(train_class_folder, file_name)</span><br><span class="line">                supplement_tasks.append((src_img_path, val_class_folder))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">8</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="built_in">list</span>(tqdm(executor.<span class="built_in">map</span>(move_file, supplement_tasks), total=<span class="built_in">len</span>(supplement_tasks), desc=<span class="string">"补充val文件夹进度"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"val文件夹补充完成！"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    src_data_folder = <span class="string">"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/CursiveChineseCalligraphyDataset-master/Cursive_Chinese_Calligraphy_Dataset/Training"</span>  <span class="comment"># todo 修改你的原始数据集路径</span></span><br><span class="line">    target_data_folder = <span class="string">"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu"</span>  <span class="comment"># todo 修改为你要存放的路径</span></span><br><span class="line">    data_set_split_and_augment(src_data_folder, target_data_folder, num_augments=<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="22数据集标签的提取"><a class="markdownIt-Anchor" href="#22数据集标签的提取"></a> 2.2数据集标签的提取</h3><p>此例汉字识别的类别高达7318种，并且为中文的格式，手动定义数据集的标签显然不太现实，因此，需要编写一个能够提取数据集标签的脚本。</p><p>使用方法：</p><p>在tf_gpu_1环境下使用命令 python labels_get.py运行此代码，将在代码相同目录下生成标签文件</p><p><strong>完整代码(labels_get)如下</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集加载函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_chinese_dataset</span>(<span class="params">data_dir</span>):</span><br><span class="line">    <span class="comment"># 使用 pathlib 处理路径</span></span><br><span class="line">    data_dir = Path(data_dir).resolve()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载数据集，获取类别标签和图像数据</span></span><br><span class="line">    dataset = tf.keras.preprocessing.image_dataset_from_directory(</span><br><span class="line">        <span class="built_in">str</span>(data_dir),</span><br><span class="line">        label_mode=<span class="string">'int'</span>,  <span class="comment"># 使用整数标签</span></span><br><span class="line">        seed=<span class="number">123</span>,</span><br><span class="line">        batch_size=<span class="number">32</span>,  <span class="comment"># 根据内存大小调整批量大小</span></span><br><span class="line">        image_size=(<span class="number">256</span>, <span class="number">256</span>)  <span class="comment"># 根据需要调整图像大小</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取类别标签</span></span><br><span class="line">    class_names = dataset.class_names</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印类别标签</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"类别标签（中文）："</span>, class_names)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存标签到 Python 文件</span></span><br><span class="line">    labels_file_path = Path(data_dir).parent / <span class="string">"lables_caoshu.py"</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(labels_file_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(<span class="string">"labels_caoshu = [\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> label <span class="keyword">in</span> class_names:</span><br><span class="line">            file.write(<span class="string">f"    '<span class="subst">{label}</span>',\n"</span>)</span><br><span class="line">        file.write(<span class="string">"]\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"标签已保存到 <span class="subst">{labels_file_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回数据集和标签</span></span><br><span class="line">    <span class="keyword">return</span> dataset, class_names</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：使用指定路径加载汉字数据集</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data_dir = <span class="string">r"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu/train"</span></span><br><span class="line">    dataset, chinese_labels = load_chinese_dataset(data_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印一些样本数据</span></span><br><span class="line">    <span class="keyword">for</span> images, labels <span class="keyword">in</span> dataset.take(<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"图像批次："</span>, images.numpy())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"标签批次："</span>, labels.numpy())</span><br></pre></td></tr></tbody></table></figure><h3 id="23模型的训练"><a class="markdownIt-Anchor" href="#23模型的训练"></a> 2.3模型的训练</h3><h4 id="231基于卷积神经网络cnn的模型训练"><a class="markdownIt-Anchor" href="#231基于卷积神经网络cnn的模型训练"></a> 2.3.1基于卷积神经网络(CNN)的模型训练</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量以确保使用 UTF-8 编码</span></span><br><span class="line">os.environ[<span class="string">'PYTHONIOENCODING'</span>] = <span class="string">'utf-8'</span></span><br><span class="line">os.environ[<span class="string">'LANG'</span>] = <span class="string">'zh_CN.UTF-8'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集加载函数，指明数据集的位置并统一处理为imgheight*imgwidth的大小，同时设置batch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_load</span>(<span class="params">data_dir, test_data_dir, img_height, img_width, batch_size</span>):</span><br><span class="line">    <span class="comment"># 使用 pathlib 处理路径</span></span><br><span class="line">    data_dir = Path(data_dir).resolve()</span><br><span class="line">    test_data_dir = Path(test_data_dir).resolve()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载训练集</span></span><br><span class="line">    train_ds = tf.keras.preprocessing.image_dataset_from_directory(</span><br><span class="line">        <span class="built_in">str</span>(data_dir),</span><br><span class="line">        label_mode=<span class="string">'categorical'</span>,</span><br><span class="line">        seed=<span class="number">123</span>,</span><br><span class="line">        image_size=(img_height, img_width),</span><br><span class="line">        batch_size=batch_size)</span><br><span class="line">    <span class="comment"># 加载测试集</span></span><br><span class="line">    val_ds = tf.keras.preprocessing.image_dataset_from_directory(</span><br><span class="line">        <span class="built_in">str</span>(test_data_dir),</span><br><span class="line">        label_mode=<span class="string">'categorical'</span>,</span><br><span class="line">        seed=<span class="number">123</span>,</span><br><span class="line">        image_size=(img_height, img_width),</span><br><span class="line">        batch_size=batch_size)</span><br><span class="line">    class_names = train_ds.class_names</span><br><span class="line">    <span class="comment"># 返回处理之后的训练集、验证集和类名</span></span><br><span class="line">    <span class="keyword">return</span> train_ds, val_ds, class_names</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建CNN模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model_load</span>(<span class="params">IMG_SHAPE=(<span class="params"><span class="number">160</span>, <span class="number">160</span>, <span class="number">3</span></span>), class_num=<span class="number">12</span></span>):</span><br><span class="line">    <span class="comment"># 搭建模型</span></span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">        <span class="comment"># 对模型做归一化的处理，将0-255之间的数字统一处理到0到1之间</span></span><br><span class="line">        <span class="comment"># 使用 Lambda 层代替 Rescaling 层以兼容旧版本 TensorFlow</span></span><br><span class="line">        tf.keras.layers.Lambda(<span class="keyword">lambda</span> x: x / <span class="number">255.0</span>, input_shape=IMG_SHAPE),</span><br><span class="line">        <span class="comment"># 卷积层，该卷积层的输出为32个通道，卷积核的大小是3*3，激活函数为relu</span></span><br><span class="line">        tf.keras.layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>),</span><br><span class="line">        <span class="comment"># 添加池化层，池化的kernel大小是2*2</span></span><br><span class="line">        tf.keras.layers.MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="comment"># Add another convolution</span></span><br><span class="line">        <span class="comment"># 卷积层，输出为64个通道，卷积核大小为3*3，激活函数为relu</span></span><br><span class="line">        tf.keras.layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>),</span><br><span class="line">        <span class="comment"># 池化层，最大池化，对2*2的区域进行池化操作</span></span><br><span class="line">        tf.keras.layers.MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="comment"># 将二维的输出转化为一维</span></span><br><span class="line">        tf.keras.layers.Flatten(),</span><br><span class="line">        <span class="comment"># 和卷积前的例子一样，这里使用了 128 个全连接层和 10 个输出层</span></span><br><span class="line">        tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">        <span class="comment"># 通过softmax函数将模型输出为类名长度的神经元上，激活函数采用softmax对应概率值</span></span><br><span class="line">        tf.keras.layers.Dense(class_num, activation=<span class="string">'softmax'</span>)</span><br><span class="line">    ])</span><br><span class="line">    <span class="comment"># 输出模型信息</span></span><br><span class="line">    model.summary()</span><br><span class="line">    <span class="comment"># 指明模型的训练参数，优化器为sgd优化器，损失函数为交叉熵损失函数</span></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=<span class="string">'sgd'</span>, loss=<span class="string">'categorical_crossentropy'</span>, metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">    <span class="comment"># 返回模型</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示训练过程的曲线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_loss_acc</span>(<span class="params">history</span>):</span><br><span class="line">    <span class="comment"># 从history中提取模型训练集和验证集准确率信息和误差信息</span></span><br><span class="line">    acc = history.history[<span class="string">'accuracy'</span>]</span><br><span class="line">    val_acc = history.history[<span class="string">'val_accuracy'</span>]</span><br><span class="line">    loss = history.history[<span class="string">'loss'</span>]</span><br><span class="line">    val_loss = history.history[<span class="string">'val_loss'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照上下结构将图画输出</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    plt.plot(acc, label=<span class="string">'Training Accuracy'</span>)</span><br><span class="line">    plt.plot(val_acc, label=<span class="string">'Validation Accuracy'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'lower right'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Accuracy'</span>)</span><br><span class="line">    plt.ylim([<span class="built_in">min</span>(plt.ylim()), <span class="number">1</span>])</span><br><span class="line">    plt.title(<span class="string">'Training and Validation Accuracy'</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    plt.plot(loss, label=<span class="string">'Training Loss'</span>)</span><br><span class="line">    plt.plot(val_loss, label=<span class="string">'Validation Loss'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Cross Entropy'</span>)</span><br><span class="line">    plt.title(<span class="string">'Training and Validation Loss'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">    plt.savefig(<span class="string">'results/results_cnn.png'</span>, dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epochs</span>):</span><br><span class="line">    <span class="comment"># 开始训练，记录开始时间</span></span><br><span class="line">    begin_time = time()</span><br><span class="line">    <span class="comment"># 加载数据集， 修改为你的数据集的路径</span></span><br><span class="line">    train_ds, val_ds, class_names = data_load(</span><br><span class="line">        <span class="string">r"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-all-more/train"</span>,</span><br><span class="line">        <span class="string">r"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-all-more/val"</span>,</span><br><span class="line">        <span class="number">160</span>, <span class="number">160</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"类别标签（中文）："</span>, class_names)</span><br><span class="line">    <span class="comment"># 加载模型</span></span><br><span class="line">    model = model_load(class_num=<span class="built_in">len</span>(class_names))</span><br><span class="line">    <span class="comment"># 指明训练的轮数epoch，开始训练</span></span><br><span class="line">    history = model.fit(train_ds, validation_data=val_ds, epochs=epochs)</span><br><span class="line">    <span class="comment"># 保存模型， 修改为你要保存的模型的名称</span></span><br><span class="line">    model.save(<span class="string">"models/cnn_hanzi_2.h5"</span>)</span><br><span class="line">    <span class="comment"># 记录结束时间</span></span><br><span class="line">    end_time = time()</span><br><span class="line">    run_time = end_time - begin_time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'该循环程序运行时间：'</span>, run_time, <span class="string">"s"</span>)  <span class="comment"># 该循环程序运行时间： 1.4201874732</span></span><br><span class="line">    <span class="comment"># 绘制模型训练过程图</span></span><br><span class="line">    show_loss_acc(history)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    train(epochs=<span class="number">40</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="232基于残差神经网络resnet的模型训练"><a class="markdownIt-Anchor" href="#232基于残差神经网络resnet的模型训练"></a> <strong>2.3.2基于残差神经网络(Resnet)的模型训练</strong></h4><p>汉字识别模型类别非常多，使用一般的神经网络训练出来的模型可能泛化性并不理想，针对多类别的模型训练可以采用更复杂的网络，比如本例的Resnet残差神经网络，最终训练的模型准确率和泛化性极高。</p><p><mark>使用方法：</mark></p><p>代码片段中，修改路径为已经划分好的训练集，测试集路径</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_ds, val_ds, class_names = data_load(</span><br><span class="line">    <span class="string">r"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu/train"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">r"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu/val"</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">128</span>, <span class="number">64</span>)  <span class="comment"># 减小批处理大小</span></span><br></pre></td></tr></tbody></table></figure><p>模型保存名称修改</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.save(<span class="string">"models/final_resnet50_chinese_kai"</span>, save_format=<span class="string">'tf'</span>)</span><br></pre></td></tr></tbody></table></figure><p>在tf_gpu_1环境下，使用命令 python model_train_resnet50.py</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量以确保使用 UTF-8 编码</span></span><br><span class="line">os.environ[<span class="string">'PYTHONIOENCODING'</span>] = <span class="string">'utf-8'</span></span><br><span class="line">os.environ[<span class="string">'LANG'</span>] = <span class="string">'zh_CN.UTF-8'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用混合精度训练</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.mixed_precision <span class="keyword">import</span> experimental <span class="keyword">as</span> mixed_precision</span><br><span class="line">policy = mixed_precision.Policy(<span class="string">'mixed_float16'</span>)</span><br><span class="line">mixed_precision.set_policy(policy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据加载函数，加入数据增强</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_load</span>(<span class="params">data_dir, test_data_dir, img_height, img_width, batch_size</span>):</span><br><span class="line">    data_dir = Path(data_dir).resolve()</span><br><span class="line">    test_data_dir = Path(test_data_dir).resolve()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载训练集</span></span><br><span class="line">    train_ds = tf.keras.preprocessing.image_dataset_from_directory(</span><br><span class="line">        <span class="built_in">str</span>(data_dir),</span><br><span class="line">        label_mode=<span class="string">'categorical'</span>,</span><br><span class="line">        seed=<span class="number">123</span>,</span><br><span class="line">        image_size=(img_height, img_width),</span><br><span class="line">        batch_size=batch_size</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取类别标签</span></span><br><span class="line">    class_names = train_ds.class_names</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据增强</span></span><br><span class="line">    data_augmentation = tf.keras.Sequential([</span><br><span class="line">        tf.keras.layers.experimental.preprocessing.RandomFlip(<span class="string">'horizontal'</span>),</span><br><span class="line">        tf.keras.layers.experimental.preprocessing.RandomRotation(<span class="number">0.1</span>),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加入数据增强</span></span><br><span class="line">    train_ds = train_ds.<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: (data_augmentation(x), y), num_parallel_calls=tf.data.experimental.AUTOTUNE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载测试集</span></span><br><span class="line">    val_ds = tf.keras.preprocessing.image_dataset_from_directory(</span><br><span class="line">        <span class="built_in">str</span>(test_data_dir),</span><br><span class="line">        label_mode=<span class="string">'categorical'</span>,</span><br><span class="line">        seed=<span class="number">123</span>,</span><br><span class="line">        image_size=(img_height, img_width),</span><br><span class="line">        batch_size=batch_size</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预取数据</span></span><br><span class="line">    train_ds = train_ds.prefetch(buffer_size=tf.data.experimental.AUTOTUNE)</span><br><span class="line">    val_ds = val_ds.prefetch(buffer_size=tf.data.experimental.AUTOTUNE)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_ds, val_ds, class_names</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建ResNet模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model_load</span>(<span class="params">IMG_SHAPE=(<span class="params"><span class="number">128</span>, <span class="number">128</span>, <span class="number">3</span></span>), class_num=<span class="number">7200</span></span>):</span><br><span class="line">    resnet = tf.keras.applications.ResNet50(weights=<span class="string">'imagenet'</span>, include_top=<span class="literal">False</span>, input_shape=IMG_SHAPE)</span><br><span class="line"></span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">        resnet,</span><br><span class="line">        tf.keras.layers.GlobalAveragePooling2D(),</span><br><span class="line">        tf.keras.layers.Dense(<span class="number">1024</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">        tf.keras.layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">        tf.keras.layers.Dense(class_num, activation=<span class="string">'softmax'</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    model.summary()</span><br><span class="line"></span><br><span class="line">    initial_learning_rate = <span class="number">0.01</span></span><br><span class="line">    lr_schedule = tf.keras.optimizers.schedules.ExponentialDecay(</span><br><span class="line">        initial_learning_rate, decay_steps=<span class="number">10000</span>, decay_rate=<span class="number">0.9</span>, staircase=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    optimizer = tf.keras.optimizers.SGD(learning_rate=lr_schedule, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=optimizer,</span><br><span class="line">                  loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">                  metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示训练过程的曲线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_loss_acc</span>(<span class="params">history</span>):</span><br><span class="line">    acc = history.history[<span class="string">'accuracy'</span>]</span><br><span class="line">    val_acc = history.history[<span class="string">'val_accuracy'</span>]</span><br><span class="line">    loss = history.history[<span class="string">'loss'</span>]</span><br><span class="line">    val_loss = history.history[<span class="string">'val_loss'</span>]</span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    plt.plot(acc, label=<span class="string">'Training Accuracy'</span>)</span><br><span class="line">    plt.plot(val_acc, label=<span class="string">'Validation Accuracy'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'lower right'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Accuracy'</span>)</span><br><span class="line">    plt.ylim([<span class="built_in">min</span>(plt.ylim()), <span class="number">1</span>])</span><br><span class="line">    plt.title(<span class="string">'Training and Validation Accuracy'</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    plt.plot(loss, label=<span class="string">'Training Loss'</span>)</span><br><span class="line">    plt.plot(val_loss, label=<span class="string">'Validation Loss'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Cross Entropy'</span>)</span><br><span class="line">    plt.title(<span class="string">'Training and Validation Loss'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">    plt.savefig(<span class="string">'results/results_resnet.png'</span>, dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加早停和模型检查点回调</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epochs</span>):</span><br><span class="line">    begin_time = time()</span><br><span class="line"></span><br><span class="line">    train_ds, val_ds, class_names = data_load(</span><br><span class="line">        <span class="string">r"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu/train"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">r"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu/val"</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">128</span>, <span class="number">64</span>)  <span class="comment"># 减小批处理大小</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"类别标签（中文）："</span>, class_names)</span><br><span class="line"></span><br><span class="line">    model = model_load(class_num=<span class="built_in">len</span>(class_names))</span><br><span class="line"></span><br><span class="line">    early_stopping = tf.keras.callbacks.EarlyStopping(</span><br><span class="line">        monitor=<span class="string">'val_loss'</span>, patience=<span class="number">10</span>, restore_best_weights=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    checkpoint = tf.keras.callbacks.ModelCheckpoint(</span><br><span class="line">        <span class="string">'models/final_resnet50_chinese_kai'</span>, monitor=<span class="string">'val_loss'</span>, save_best_only=<span class="literal">True</span>, save_format=<span class="string">'tf'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    history = model.fit(</span><br><span class="line">        train_ds, validation_data=val_ds, epochs=epochs,</span><br><span class="line">        callbacks=[early_stopping, checkpoint]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    model.save(<span class="string">"models/final_resnet50_chinese_kai"</span>, save_format=<span class="string">'tf'</span>)</span><br><span class="line"></span><br><span class="line">    end_time = time()</span><br><span class="line">    run_time = end_time - begin_time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'该循环程序运行时间：'</span>, run_time, <span class="string">"s"</span>)</span><br><span class="line"></span><br><span class="line">    show_loss_acc(history)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    train(epochs=<span class="number">15</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="24-模型的测试"><a class="markdownIt-Anchor" href="#24-模型的测试"></a> 2.4 模型的测试</h3><p>代码如下，更改测试集以及模型路径为相应的目标路径即可</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Matplotlib显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">'font.family'</span>] = [<span class="string">'sans-serif'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据加载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_load</span>(<span class="params">data_dir, test_data_dir, img_height, img_width, batch_size</span>):</span><br><span class="line">    class_names = <span class="built_in">sorted</span>(</span><br><span class="line">        [dir_name <span class="keyword">for</span> dir_name <span class="keyword">in</span> os.listdir(data_dir) <span class="keyword">if</span> os.path.isdir(os.path.join(data_dir, dir_name))])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Detected <span class="subst">{<span class="built_in">len</span>(class_names)}</span> classes."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_path</span>(<span class="params">file_path</span>):</span><br><span class="line">        label = tf.strings.split(file_path, os.path.sep)[-<span class="number">2</span>]</span><br><span class="line">        label = tf.where(tf.equal(tf.constant(class_names), label))[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        img = tf.io.read_file(file_path)</span><br><span class="line">        img = tf.image.decode_jpeg(img, channels=<span class="number">3</span>)</span><br><span class="line">        img = tf.image.resize(img, [img_height, img_width])</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepare_dataset</span>(<span class="params">directory</span>):</span><br><span class="line">        list_ds = tf.data.Dataset.list_files(os.path.join(directory, <span class="string">'*/*'</span>), shuffle=<span class="literal">True</span>)</span><br><span class="line">        labeled_ds = list_ds.<span class="built_in">map</span>(process_path, num_parallel_calls=tf.data.experimental.AUTOTUNE)</span><br><span class="line">        labeled_ds = labeled_ds.batch(batch_size).prefetch(buffer_size=tf.data.experimental.AUTOTUNE)</span><br><span class="line">        <span class="keyword">return</span> labeled_ds</span><br><span class="line"></span><br><span class="line">    train_ds = prepare_dataset(data_dir)</span><br><span class="line">    val_ds = prepare_dataset(test_data_dir)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Loaded datasets: <span class="subst">{<span class="built_in">len</span>(train_ds)}</span> training batches, <span class="subst">{<span class="built_in">len</span>(val_ds)}</span> validation batches."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_ds, val_ds, class_names</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚合类别并随机抽取10个类别生成热力图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aggregate_labels_and_select</span>(<span class="params">real_labels, pred_labels, num_classes, num_groups, selected_groups</span>):</span><br><span class="line">    group_size = num_classes // num_groups</span><br><span class="line">    real_labels_agg = [label // group_size <span class="keyword">for</span> label <span class="keyword">in</span> real_labels]</span><br><span class="line">    pred_labels_agg = [label // group_size <span class="keyword">for</span> label <span class="keyword">in</span> pred_labels]</span><br><span class="line"></span><br><span class="line">    real_labels_selected = [real_labels_agg[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_labels_agg)) <span class="keyword">if</span></span><br><span class="line">                            real_labels_agg[i] <span class="keyword">in</span> selected_groups]</span><br><span class="line">    pred_labels_selected = [pred_labels_agg[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pred_labels_agg)) <span class="keyword">if</span></span><br><span class="line">                            real_labels_agg[i] <span class="keyword">in</span> selected_groups]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> real_labels_selected, pred_labels_selected</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试cnn模型准确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_cnn</span>():</span><br><span class="line">    <span class="comment"># 加载数据</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    train_ds, test_ds, class_names = data_load(</span><br><span class="line">        <span class="string">r"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-all/train"</span>,</span><br><span class="line">        <span class="string">r"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-all/val"</span>,</span><br><span class="line">        <span class="number">160</span>, <span class="number">160</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Data loading completed in <span class="subst">{time.time() - start_time:<span class="number">.2</span>f}</span> seconds."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载模型</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    model = tf.keras.models.load_model(<span class="string">"models/final_resnet50_chinese"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Model loaded in <span class="subst">{time.time() - start_time:<span class="number">.2</span>f}</span> seconds."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 编译模型</span></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=<span class="string">'adam'</span>, loss=<span class="string">'sparse_categorical_crossentropy'</span>, metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 推理</span></span><br><span class="line">    test_real_labels = []</span><br><span class="line">    test_pre_labels = []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Starting model inference..."</span>)</span><br><span class="line">    inference_start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (test_batch_images, test_batch_labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_ds):</span><br><span class="line">        <span class="keyword">if</span> batch_idx &gt;= <span class="number">10</span>:  <span class="comment"># 只处理前10个batch来加速测试</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"Processing batch <span class="subst">{batch_idx + <span class="number">1</span>}</span>..."</span>)</span><br><span class="line">        test_batch_labels = test_batch_labels.numpy()</span><br><span class="line">        test_batch_pres = model.predict(test_batch_images)</span><br><span class="line"></span><br><span class="line">        test_real_labels.extend(test_batch_labels)</span><br><span class="line">        test_pre_labels.extend(np.argmax(test_batch_pres, axis=<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Inference completed in <span class="subst">{time.time() - inference_start_time:<span class="number">.2</span>f}</span> seconds."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 聚合类别并随机抽取10个类别</span></span><br><span class="line">    num_groups = <span class="number">10</span></span><br><span class="line">    selected_groups = random.sample(<span class="built_in">range</span>(num_groups), <span class="number">10</span>)</span><br><span class="line">    test_real_labels_agg, test_pre_labels_agg = aggregate_labels_and_select(</span><br><span class="line">        test_real_labels, test_pre_labels, <span class="built_in">len</span>(class_names), num_groups, selected_groups</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成聚合后的热力图</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Generating aggregated heatmaps..."</span>)</span><br><span class="line">    heat_maps = np.zeros((num_groups, num_groups))</span><br><span class="line">    <span class="keyword">for</span> real_label, pred_label <span class="keyword">in</span> <span class="built_in">zip</span>(test_real_labels_agg, test_pre_labels_agg):</span><br><span class="line">        heat_maps[real_label][pred_label] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    heat_maps_sum = np.<span class="built_in">sum</span>(heat_maps, axis=<span class="number">1</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    heat_maps_sum[heat_maps_sum == <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    heat_maps_float = heat_maps / heat_maps_sum</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建存储热力图的文件夹</span></span><br><span class="line">    output_dir = <span class="string">"results/aggregated_heatmap"</span></span><br><span class="line">    os.makedirs(output_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存聚合热力图</span></span><br><span class="line">    save_path = os.path.join(output_dir, <span class="string">"aggregated_heatmap.png"</span>)</span><br><span class="line">    show_heatmaps(<span class="string">"Aggregated Heatmap"</span>, selected_groups, selected_groups,</span><br><span class="line">                  heat_maps_float[selected_groups][:, selected_groups], save_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Saved aggregated heatmap to <span class="subst">{save_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"All heatmaps generated and saved."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_heatmaps</span>(<span class="params">title, x_labels, y_labels, harvest, save_name</span>):</span><br><span class="line">    <span class="comment"># 创建画布</span></span><br><span class="line">    fig, ax = plt.subplots()</span><br><span class="line">    im = ax.imshow(harvest, cmap=<span class="string">"OrRd"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改标签</span></span><br><span class="line">    ax.set_xticks(np.arange(<span class="built_in">len</span>(y_labels)))</span><br><span class="line">    ax.set_yticks(np.arange(<span class="built_in">len</span>(x_labels)))</span><br><span class="line">    ax.set_xticklabels(y_labels)</span><br><span class="line">    ax.set_yticklabels(x_labels)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 旋转x轴标签</span></span><br><span class="line">    plt.setp(ax.get_xticklabels(), rotation=<span class="number">45</span>, ha=<span class="string">"right"</span>, rotation_mode=<span class="string">"anchor"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加每个热力块的具体数值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_labels)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_labels)):</span><br><span class="line">            ax.text(j, i, <span class="built_in">round</span>(harvest[i, j], <span class="number">2</span>), ha=<span class="string">"center"</span>, va=<span class="string">"center"</span>, color=<span class="string">"black"</span>)</span><br><span class="line"></span><br><span class="line">    ax.set_xlabel(<span class="string">"Predict label"</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">"Actual label"</span>)</span><br><span class="line">    ax.set_title(title)</span><br><span class="line">    fig.tight_layout()</span><br><span class="line">    plt.colorbar(im)</span><br><span class="line">    plt.savefig(save_name, dpi=<span class="number">100</span>)</span><br><span class="line">    plt.close(fig)  <span class="comment"># 关闭图形以释放内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    test_cnn()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Total execution time: <span class="subst">{time.time() - start_time:<span class="number">.2</span>f}</span> seconds."</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="25-tensorboard工具模型流图"><a class="markdownIt-Anchor" href="#25-tensorboard工具模型流图"></a> 2.5 tensorboard工具——模型流图</h3><p>model = tf.saved_model.load(“models/final_resnet50_chinese”) 语句中修改为目标模型</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设你已经加载了你的模型</span></span><br><span class="line">model = tf.saved_model.load(<span class="string">"models/final_resnet50_chinese"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取模型的推理签名（与导出的模型相关，可能需要调整具体签名名称）</span></span><br><span class="line">infer = model.signatures[<span class="string">'serving_default'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 TensorBoard 日志目录</span></span><br><span class="line">log_dir = <span class="string">"logs/graph"</span></span><br><span class="line">writer = tf.summary.create_file_writer(log_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包装函数并使用 tf.function</span></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model_inference</span>(<span class="params">input_tensor</span>):</span><br><span class="line">    <span class="keyword">return</span> infer(input_tensor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个示例输入张量（调整形状以匹配模型的输入要求）</span></span><br><span class="line">example_input = tf.random.normal([<span class="number">1</span>, <span class="number">160</span>, <span class="number">160</span>, <span class="number">3</span>])  <span class="comment"># 假设模型输入是160x160x3的图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录数据流图</span></span><br><span class="line"><span class="keyword">with</span> writer.as_default():</span><br><span class="line">    <span class="comment"># 开启追踪</span></span><br><span class="line">    tf.summary.trace_on(graph=<span class="literal">True</span>, profiler=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行一次推理以记录计算图</span></span><br><span class="line">    model_inference(example_input)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录计算图</span></span><br><span class="line">    tf.summary.trace_export(name=<span class="string">"model_trace"</span>, step=<span class="number">0</span>, profiler_outdir=log_dir)</span><br><span class="line"></span><br><span class="line">    writer.flush()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Graph has been written to TensorBoard logs. You can view it using TensorBoard."</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="26-模型的使用"><a class="markdownIt-Anchor" href="#26-模型的使用"></a> 2.6 模型的使用</h2><p>本例为基于Qt界面的汉字识别程序，通过加载训练好的Tensorflow模型，选择本地的图片作为输入，进行手写汉字识别</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2021/6/17 20:29</span></span><br><span class="line"><span class="comment"># @Author  : dejahu</span></span><br><span class="line"><span class="comment"># @Email   : 1148392984@qq.com</span></span><br><span class="line"><span class="comment"># @File    : window.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># @Brief   : 图形化界面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> lables_caoshu <span class="keyword">import</span> labels_caoshu</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>(<span class="title class_ inherited__">QTabWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.setWindowIcon(QIcon(<span class="string">'images/logo.png'</span>))</span><br><span class="line">        self.setWindowTitle(<span class="string">'CNN汉字识别系统'</span>)</span><br><span class="line">        self.model = tf.keras.models.load_model(<span class="string">"models/final_resnet50_chinese"</span>)</span><br><span class="line">        self.to_predict_name = <span class="string">"images/Start_1.png"</span></span><br><span class="line">        self.class_names = labels_caoshu</span><br><span class="line">        self.resize(<span class="number">900</span>, <span class="number">700</span>)</span><br><span class="line">        self.initUI()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initUI</span>(<span class="params">self</span>):</span><br><span class="line">        main_widget = QWidget()</span><br><span class="line">        main_layout = QHBoxLayout()</span><br><span class="line">        font = QFont(<span class="string">'楷体'</span>, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">        dark_style = <span class="string">"""</span></span><br><span class="line"><span class="string">            QWidget {</span></span><br><span class="line"><span class="string">                background-color: #2E2E2E;</span></span><br><span class="line"><span class="string">                color: #FFFFFF;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QLabel {</span></span><br><span class="line"><span class="string">                color: #FFFFFF;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QPushButton {</span></span><br><span class="line"><span class="string">                background-color: #4F4F4F;</span></span><br><span class="line"><span class="string">                border: 2px solid #6E6E6E;</span></span><br><span class="line"><span class="string">                color: #FFFFFF;</span></span><br><span class="line"><span class="string">                padding: 5px;</span></span><br><span class="line"><span class="string">                border-radius: 5px;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QPushButton:hover {</span></span><br><span class="line"><span class="string">                background-color: #6E6E6E;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QPushButton:pressed {</span></span><br><span class="line"><span class="string">                background-color: #3D3D3D;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QTabBar::tab {</span></span><br><span class="line"><span class="string">                background: #3D3D3D;</span></span><br><span class="line"><span class="string">                color: #FFFFFF;</span></span><br><span class="line"><span class="string">                padding: 10px;</span></span><br><span class="line"><span class="string">                border-radius: 5px;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QTabBar::tab:selected {</span></span><br><span class="line"><span class="string">                background: #2E2E2E;</span></span><br><span class="line"><span class="string">                border-bottom: 2px solid #4F4F4F;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QTabBar::tab:!selected {</span></span><br><span class="line"><span class="string">                background: #3D3D3D;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.setStyleSheet(dark_style)</span><br><span class="line"></span><br><span class="line">        left_widget = QWidget()</span><br><span class="line">        left_layout = QVBoxLayout()</span><br><span class="line">        img_title = QLabel(<span class="string">"输入作品"</span>)</span><br><span class="line">        img_title.setFont(font)</span><br><span class="line">        img_title.setAlignment(Qt.AlignCenter)</span><br><span class="line">        self.img_label = QLabel()</span><br><span class="line">        self.process_image(self.to_predict_name)</span><br><span class="line">        self.img_label.setPixmap(QPixmap(<span class="string">"images/binary_show.png"</span>))</span><br><span class="line">        left_layout.addWidget(img_title)</span><br><span class="line">        left_layout.addWidget(self.img_label, <span class="number">1</span>, Qt.AlignCenter)</span><br><span class="line">        left_widget.setLayout(left_layout)</span><br><span class="line"></span><br><span class="line">        right_widget = QWidget()</span><br><span class="line">        right_layout = QVBoxLayout()</span><br><span class="line">        btn_change = QPushButton(<span class="string">" 上传作品 "</span>)</span><br><span class="line">        btn_change.setIcon(QIcon(<span class="string">'images/upload.png'</span>))</span><br><span class="line">        btn_change.clicked.connect(self.change_img)</span><br><span class="line">        btn_change.setFont(font)</span><br><span class="line">        btn_predict = QPushButton(<span class="string">" 开始识别 "</span>)</span><br><span class="line">        btn_predict.setIcon(QIcon(<span class="string">'images/recognize.png'</span>))</span><br><span class="line">        btn_predict.setFont(font)</span><br><span class="line">        btn_predict.clicked.connect(self.predict_img)</span><br><span class="line">        label_result = QLabel(<span class="string">' 识别结果 '</span>)</span><br><span class="line">        self.result = QLabel(<span class="string">"等待识别"</span>)</span><br><span class="line">        label_result.setFont(QFont(<span class="string">'楷体'</span>, <span class="number">16</span>))</span><br><span class="line">        self.result.setFont(QFont(<span class="string">'楷体'</span>, <span class="number">24</span>))</span><br><span class="line">        right_layout.addStretch()</span><br><span class="line">        right_layout.addWidget(label_result, <span class="number">0</span>, Qt.AlignCenter)</span><br><span class="line">        right_layout.addStretch()</span><br><span class="line">        right_layout.addWidget(self.result, <span class="number">0</span>, Qt.AlignCenter)</span><br><span class="line">        right_layout.addStretch()</span><br><span class="line">        right_layout.addStretch()</span><br><span class="line">        right_layout.addWidget(btn_change)</span><br><span class="line">        right_layout.addWidget(btn_predict)</span><br><span class="line">        right_layout.addStretch()</span><br><span class="line">        right_widget.setLayout(right_layout)</span><br><span class="line"></span><br><span class="line">        main_layout.addWidget(left_widget)</span><br><span class="line">        main_layout.addWidget(right_widget)</span><br><span class="line">        main_widget.setLayout(main_layout)</span><br><span class="line"></span><br><span class="line">        about_widget = QWidget()</span><br><span class="line">        about_layout = QVBoxLayout()</span><br><span class="line">        about_title = QLabel(<span class="string">'欢迎使用手写汉字识别系统'</span>)</span><br><span class="line">        about_title.setFont(QFont(<span class="string">'楷体'</span>, <span class="number">18</span>))</span><br><span class="line">        about_title.setAlignment(Qt.AlignCenter)</span><br><span class="line">        about_img = QLabel()</span><br><span class="line">        about_img.setPixmap(QPixmap(<span class="string">'images/CNN.png'</span>))</span><br><span class="line">        about_img.setAlignment(Qt.AlignCenter)</span><br><span class="line">        label_super = QLabel(<span class="string">"sz_jmu"</span>)</span><br><span class="line">        label_super.setFont(QFont(<span class="string">'楷体'</span>, <span class="number">12</span>))</span><br><span class="line">        label_super.setAlignment(Qt.AlignRight)</span><br><span class="line">        about_layout.addWidget(about_title)</span><br><span class="line">        about_layout.addStretch()</span><br><span class="line">        about_layout.addWidget(about_img)</span><br><span class="line">        about_layout.addStretch()</span><br><span class="line">        about_layout.addWidget(label_super)</span><br><span class="line">        about_widget.setLayout(about_layout)</span><br><span class="line"></span><br><span class="line">        self.addTab(main_widget, <span class="string">'主页'</span>)</span><br><span class="line">        self.addTab(about_widget, <span class="string">'关于'</span>)</span><br><span class="line">        self.setTabIcon(<span class="number">0</span>, QIcon(<span class="string">'images/主页面.png'</span>))</span><br><span class="line">        self.setTabIcon(<span class="number">1</span>, QIcon(<span class="string">'images/关于.png'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 上传并显示图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change_img</span>(<span class="params">self</span>):</span><br><span class="line">        openfile_name = QFileDialog.getOpenFileName(self, <span class="string">'chose files'</span>, <span class="string">''</span>,</span><br><span class="line">                                                    <span class="string">'Image files(*.jpg *.png *jpeg)'</span>)  <span class="comment"># 打开文件选择框选择文件</span></span><br><span class="line">        img_name = openfile_name[<span class="number">0</span>]  <span class="comment"># 获取图片名称</span></span><br><span class="line">        <span class="keyword">if</span> img_name == <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target_image_name = <span class="string">"images/tmp_up."</span> + img_name.split(<span class="string">"."</span>)[-<span class="number">1</span>]  <span class="comment"># 将图片移动到当前目录</span></span><br><span class="line">            shutil.copy(img_name, target_image_name)</span><br><span class="line">            self.to_predict_name = target_image_name</span><br><span class="line">            self.process_image(self.to_predict_name)</span><br><span class="line">            self.img_label.setPixmap(QPixmap(<span class="string">"images/binary_show.png"</span>))  <span class="comment"># 显示二值化后的图片</span></span><br><span class="line">            self.result.setText(<span class="string">"等待识别"</span>)</span><br><span class="line">            self.show_binary_image()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图片处理和二值化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_image</span>(<span class="params">self, image_path</span>):</span><br><span class="line">        img_init = cv2.imread(image_path)  <span class="comment"># 打开图片</span></span><br><span class="line">        h, w, c = img_init.shape</span><br><span class="line">        scale = <span class="number">400</span> / h</span><br><span class="line">        img_show = cv2.resize(img_init, (<span class="number">0</span>, <span class="number">0</span>), fx=scale, fy=scale)  <span class="comment"># 将图片的大小统一调整到400的高，方便界面显示</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二值化处理</span></span><br><span class="line">        gray_img = cv2.cvtColor(img_init, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        _, binary_img = cv2.threshold(gray_img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">        binary_img_inverted = cv2.bitwise_not(binary_img)</span><br><span class="line">        binary_img_colored = cv2.cvtColor(binary_img_inverted, cv2.COLOR_GRAY2BGR)</span><br><span class="line">        binary_img_show = cv2.resize(binary_img_colored, (<span class="number">0</span>, <span class="number">0</span>), fx=scale, fy=scale)  <span class="comment"># 将二值化图像调整到400高显示</span></span><br><span class="line"></span><br><span class="line">        cv2.imwrite(<span class="string">'images/binary_show.png'</span>, binary_img_show)  <span class="comment"># 保存显示用的二值化图片</span></span><br><span class="line">        cv2.imwrite(<span class="string">'images/target.png'</span>, binary_img_colored)  <span class="comment"># 保存用于识别的二值化图片</span></span><br><span class="line">        cv2.imwrite(<span class="string">'images/binary_target.png'</span>, binary_img)  <span class="comment"># 保存仅用于二值化显示的图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict_img</span>(<span class="params">self</span>):</span><br><span class="line">        img = Image.<span class="built_in">open</span>(<span class="string">'images/target.png'</span>)  <span class="comment"># 读取二值化图片</span></span><br><span class="line">        img = img.resize((<span class="number">128</span>, <span class="number">128</span>))  <span class="comment"># 调整图像大小到模型所需的输入尺寸</span></span><br><span class="line">        img = np.asarray(img)  <span class="comment"># 将图片转化为numpy的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确保图像是3个通道的</span></span><br><span class="line">        <span class="keyword">if</span> img.shape[-<span class="number">1</span>] != <span class="number">3</span>:</span><br><span class="line">            img = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)</span><br><span class="line"></span><br><span class="line">        img = img.reshape(<span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">3</span>)  <span class="comment"># 调整图像的形状以匹配模型输入</span></span><br><span class="line">        outputs = self.model.predict(img)  <span class="comment"># 将图片输入模型得到结果</span></span><br><span class="line">        result_index = <span class="built_in">int</span>(np.argmax(outputs))</span><br><span class="line">        result = self.class_names[result_index]  <span class="comment"># 获得对应的识别结果</span></span><br><span class="line">        self.result.setText(result)  <span class="comment"># 在界面上显示结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示二值化图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_binary_image</span>(<span class="params">self</span>):</span><br><span class="line">        binary_image_window = QMainWindow()</span><br><span class="line">        binary_image_window.setWindowTitle(<span class="string">'二值化处理结果'</span>)</span><br><span class="line">        binary_image_widget = QLabel()</span><br><span class="line">        binary_image = QPixmap(<span class="string">"images/binary_target.png"</span>)</span><br><span class="line">        binary_image_widget.setPixmap(binary_image)</span><br><span class="line">        binary_image_widget.setAlignment(Qt.AlignCenter)</span><br><span class="line">        binary_image_window.setCentralWidget(binary_image_widget)</span><br><span class="line">        binary_image_window.resize(binary_image.size())</span><br><span class="line">        binary_image_window.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 界面关闭事件，询问用户是否关闭</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">closeEvent</span>(<span class="params">self, event</span>):</span><br><span class="line">        reply = QMessageBox.question(self,</span><br><span class="line">                                     <span class="string">'退出'</span>,</span><br><span class="line">                                     <span class="string">"是否要退出程序？"</span>,</span><br><span class="line">                                     QMessageBox.Yes | QMessageBox.No,</span><br><span class="line">                                     QMessageBox.No)</span><br><span class="line">        <span class="keyword">if</span> reply == QMessageBox.Yes:</span><br><span class="line">            self.close()</span><br><span class="line">            event.accept()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            event.ignore()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    x = MainWindow()</span><br><span class="line">    x.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></tbody></table></figure><p><strong>运行结果如下：</strong></p><p>tensorflow_gpu_tools工具链总结：</p><ul><li><p>data_split.py：数据集划分脚本</p></li><li><p>labels_get.py：标签生成脚本</p></li><li><p>model_train_resnet50.py：训练脚本</p></li><li><p>tf_board.py：模型结构/流图展示脚本</p></li><li><p><a href="http://window.py">window.py</a>：模型识别QT程序</p></li></ul><h1 id="更新记录"><a class="markdownIt-Anchor" href="#更新记录"></a> 更新记录</h1><p>此栏目用于记录代码项目新增功能，bug修复等日志</p><blockquote><p>date:2024.8.29</p><p>对<strong>model_train_densenet169.py</strong> 新增<strong>参数接口化</strong>配置，使用<strong>命令行</strong>即可便捷配置模型训练参数</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse                          <span class="comment"># 导入argparse模块以处理命令行参数</span></span><br></pre></td></tr></tbody></table></figure><img src="/posts/33676/image-20240830003108581.png" class="" title="image-20240830003108581"><p>如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script_name.py --train_data_dir <span class="string">"path/to/train_data"</span> --test_data_dir <span class="string">"path/to/test_data"</span> --img_height <span class="number">128</span> --img_width <span class="number">128</span> --batch_size <span class="number">64</span> --epochs <span class="number">15</span></span><br></pre></td></tr></tbody></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【TI】[2]常见外设的基本配置</title>
      <link href="/posts/9383/"/>
      <url>/posts/9383/</url>
      
        <content type="html"><![CDATA[<h1 id="sysconfig界面"><a class="markdownIt-Anchor" href="#sysconfig界面"></a> Sysconfig界面:</h1><h2 id="1波特率数据格式的配置"><a class="markdownIt-Anchor" href="#1波特率数据格式的配置"></a> 1.波特率，数据格式的配置</h2><img src="/posts/9383/image-20240717232902923.png" class="" title="image-20240717232902923"><h2 id="2中断使能配置"><a class="markdownIt-Anchor" href="#2中断使能配置"></a> 2.中断使能配置</h2><img src="/posts/9383/image-20240718004436675.png" class="" title="image-20240718004436675"><h2 id="3引脚配置"><a class="markdownIt-Anchor" href="#3引脚配置"></a> 3.引脚配置</h2><p>PS：LP-G3507开发板上用于板载调试的串口与单片机的PA11和PA10连接（跳线帽），配置这两个引脚可以直接通过MicroUSB接口与主机进行串口通信</p><img src="/posts/9383/image-20240718004509861.png" class="" title="image-20240718004509861"><h1 id="库函数使用"><a class="markdownIt-Anchor" href="#库函数使用"></a> 库函数使用</h1><h2 id="1初始化部分"><a class="markdownIt-Anchor" href="#1初始化部分"></a> 1.初始化部分</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NVIC_ClearPendingIRQ(UART_0_INST_INT_IRQN);<span class="comment">//清除串口中断标志位</span></span><br><span class="line">NVIC_EnableIRQ(UART_0_INST_INT_IRQN);<span class="comment">//使能串口中断</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2中断配置"><a class="markdownIt-Anchor" href="#2中断配置"></a> 2.中断配置</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_0_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (DL_UART_Main_getPendingInterrupt(UART_0_INST)) {</span><br><span class="line">        <span class="keyword">case</span> DL_UART_MAIN_IIDX_RX:</span><br><span class="line">            gEchoData = DL_UART_Main_receiveData(UART_0_INST);</span><br><span class="line">            DL_UART_Main_transmitData(UART_0_INST, gEchoData);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> MSPM0G3507 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【电赛】2023-激光跟随系统复盘</title>
      <link href="/posts/38463/"/>
      <url>/posts/38463/</url>
      
        <content type="html"><![CDATA[<h1 id="一-图像处理方案"><a class="markdownIt-Anchor" href="#一-图像处理方案"></a> 一、图像处理方案</h1><p>Opencv: 开源计算机视觉处理库，使用嵌入式SOC板卡作为摄像头模块，提供相对可靠的性能。</p><p>由于激光点的亮度远高于其他位置，所以采用HSV格式的色彩空间，对图像H,S,V域进行识别。</p><p>若要区分红绿激光，那么就对图像的RGB空间进行处理</p><h2 id="2-电工胶带的识别"><a class="markdownIt-Anchor" href="#2-电工胶带的识别"></a> 2. 电工胶带的识别</h2><ul><li><p>使用原图像-&gt;灰度图像-&gt;设置阈值后进行二值化的方法，使得黑胶带区域识别为纯白色，其余部分全部为纯黑色区域。关于调参：建议使用创建滑块窗口的方法，进行动态调参，减少调参上浪费的时间。</p></li><li><p>摄像头容易受到外接环境光的干扰，可以通过调节分辨率，设置摄像头的图像获取范围，也有一种更为实用的方法：ROI（感兴趣区），可以通过创建<mark>掩膜</mark>的方式，只对ROI区域进行处理，这样就排除了外界环境的干扰。当然也可以使用切片的方法，定义一个变量用于读取图像的指定范围，然后再进行图像处理，需要显示参数时，再将一些特征点、辅助线、坐标点、数据显示在想要观看的图像上，使用opencv中的imshow进行可视化显示（注意：imshow是非常耗时的操作，在调试时可以使用，在最终运行时建议注释掉，提升程序执行效率，或者采取图像编解码的方法，使用TCP/UDP协议，ROS通信等方式进行远程图传，降低软件资源的使用）</p></li><li><p>ROI区域也不一定是适宜的图像处理区域，也可能有一些噪声信号的干扰，这可能就要需要用到一些滤波处理的算法，如：高斯平滑滤波（高斯模糊）。</p></li><li><p>胶带容易受激光点的影响，导致二值化图像被==“分割”==，所以需要对胶带的二值化图像先膨胀，后进行图形学闭运算缝合胶带二值化图像漏洞</p></li></ul><h2 id="3-串口通信的关键问题"><a class="markdownIt-Anchor" href="#3-串口通信的关键问题"></a> 3. 串口通信的关键问题</h2><ul><li>数据帧：一开始采用字符串发送地方法。结果单片机很容易接收不到一些数据帧</li><li>通信速率：19200</li></ul><h2 id="3-激光巡线的路径规划"><a class="markdownIt-Anchor" href="#3-激光巡线的路径规划"></a> 3. 激光“巡线”的路径规划</h2><ul><li><p>第一种方法：程序不断对图像进行处理，边缘检测，封闭图形检测，然后激光沿着检测出来的图形边沿进行巡线</p></li><li><p>第二种方法：采用“路径规划的方法”，进行一定时间的图像采集后，确定好激光的运行路径，这样，即避免了激光对矩形框识别的强光干扰，又大大减少了程序运行的资源损耗，只需要执行激光跟随部分的程序，不需要再对图像进行边沿检测。</p></li></ul><h1 id="opencv程序部分"><a class="markdownIt-Anchor" href="#opencv程序部分"></a> OpenCV程序部分</h1><h2 id="1-摄像头处理部分"><a class="markdownIt-Anchor" href="#1-摄像头处理部分"></a> 1. 摄像头处理部分</h2><h3 id="11-摄像头的类封装"><a class="markdownIt-Anchor" href="#11-摄像头的类封装"></a> 1.1 摄像头的类封装</h3><p>GuideLine 的作用：绘制辅助线</p><p>思考：Python中函数对形参的调用，会不会影响到实参？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 摄像头类创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pi_Camera</span>():</span><br><span class="line">    <span class="comment"># 类的初始化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 图像初始化配置</span></span><br><span class="line">        self.Video = cv2.VideoCapture(<span class="number">8</span>, cv2.CAP_V4L2)<span class="comment"># 使能摄像头8的驱动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查摄像头是否打开</span></span><br><span class="line">        ret = self.Video.isOpened()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The video is opened."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"No video."</span>)</span><br><span class="line">    </span><br><span class="line">        codec = cv2.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>)   </span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FOURCC, codec)</span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FPS, <span class="number">60</span>)                 <span class="comment"># 帧数</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">640</span>)        <span class="comment"># 列 宽度</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>)       <span class="comment"># 行 高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制辅助线</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GuideLine</span>(<span class="params">self, c1, c2</span>):</span><br><span class="line">        ret, image = self.Video.read()<span class="comment"># 注意：read返回一个bull值和图像数据list！，需要用两个变量获取</span></span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">360</span>), (<span class="number">640</span>, <span class="number">360</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)<span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">240</span>), (<span class="number">640</span>, <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)<span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="built_in">int</span>(c1), <span class="number">360</span>), (<span class="built_in">int</span>(c2), <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">2</span>)<span class="comment"># 绘出倾角线</span></span><br><span class="line">            cv2.imshow(<span class="string">"GuideLine"</span>, image)</span><br></pre></td></tr></tbody></table></figure><h3 id="12-摄像头的图像获取"><a class="markdownIt-Anchor" href="#12-摄像头的图像获取"></a> 1.2 摄像头的图像获取</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret, frame = Watch.Video.read() <span class="comment">#获取摄像头图像数据</span></span><br></pre></td></tr></tbody></table></figure><h3 id="13-相机资源的释放"><a class="markdownIt-Anchor" href="#13-相机资源的释放"></a> 1.3 相机资源的释放</h3><p>思考：Python中不对窗口，或者使用Python语言的硬件资源不释放会怎么样？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Watch.Video.release()</span><br></pre></td></tr></tbody></table></figure><h2 id="2-激光追踪相关"><a class="markdownIt-Anchor" href="#2-激光追踪相关"></a> 2. 激光追踪相关</h2><p>要想实现激光点的巡线，以及红绿激光的相互跟随，首先要做到单个激光点的精确识别与控制移动，这里我们使用了二维舵机云台，精度在能够完成基本要求之内。使用USB 1080P摄像头进行画面捕获。</p><p>激光点在图像中的亮度远远大于其他图像像素点，不难想到在HSV空间中对图像进行操作更容易识别到激光点。</p><h3 id="21-激光点识别的图形预处理"><a class="markdownIt-Anchor" href="#21-激光点识别的图形预处理"></a> 2.1 激光点识别的图形预处理</h3><p>通过调用v2.cvtColor()函数的方法，将图像颜色空间转换到 HSV中，然后通过设定阈值，进行图像的二值化（阈值调节建议采用滑块创建的方法，并且函数需要赋初值）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找激光点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_lasers</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># imgae:用于处理的画布图像，frame：原图像，且是最终数据展示的图像</span></span><br><span class="line">    <span class="keyword">global</span> load_process<span class="comment"># 声明使用外部定义的 load_process</span></span><br><span class="line">    </span><br><span class="line">    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)<span class="comment"># 转换颜色空间为HSV</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义红色激光点hsv色彩阈值范围，用作二值化</span></span><br><span class="line">    lower_laser = np.array([<span class="number">0</span>, <span class="number">100</span>, <span class="number">180</span>])</span><br><span class="line">    upper_laser = np.array([<span class="number">179</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建二值化图像</span></span><br><span class="line">    mask_laser = cv2.inRange(hsv, lower_laser, upper_laser) </span><br><span class="line">    <span class="comment"># cv2.imshow("mask_laser1", mask_laser)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 闭运算</span></span><br><span class="line">    kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">    mask_laser = cv2.morphologyEx(mask_laser, cv2.MORPH_CLOSE, kernel)</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-激光点的轮廓识别"><a class="markdownIt-Anchor" href="#2-2-激光点的轮廓识别"></a> 2. 2 激光点的轮廓识别</h3><p><strong>调用cv2.findContours()函数，对封闭图形进行检测，并且绘制出激光点的图形识别轮廓</strong></p><p>函数解释：</p><ol><li><strong><code>mask_laser</code></strong>：这是输入的二值图像，也就是说，它应该是经过阈值处理或其他形式的图像处理后得到的黑白图像（通常是单通道的，只有 0 和 255 两个像素值）。</li><li><strong><code>cv2.RETR_EXTERNAL</code></strong>：这是轮廓检索模式（Contour Retrieval Mode），指定了轮廓的检索模式。<code>RETR_EXTERNAL</code> 表示只检索最外层的轮廓，忽略内部的轮廓。还有其他的检索模式，比如 <code>RETR_LIST</code>、<code>RETR_TREE</code> 等，可以根据需要选择不同的模式。</li><li><strong><code>cv2.CHAIN_APPROX_SIMPLE</code></strong>：这是轮廓的逼近方法（Contour Approximation Method），指定了轮廓的表示方法。<code>CHAIN_APPROX_SIMPLE</code> 表示压缩水平、垂直和对</li><li>第一个返回值 <code>contours_laser</code> 是一个列表，其中每个元素是一个 numpy 数组，表示一个检测到的轮廓</li></ol><p><strong>cv2.minAreaRect()</strong></p><p>函数解释：</p><ul><li><strong><code>contour</code></strong>：这是一个轮廓，通常是通过 <code>findContours</code> 函数找到的其中一个轮廓对象，它是一个包含轮廓点的 numpy 数组。</li><li><strong><code>cv2.minAreaRect(contour)</code></strong>：这个函数接收一个轮廓作为输入，并返回一个 <code>RotatedRect</code> 对象，它表示包围轮廓的最小旋转矩形框。</li></ul><p>具体来说，返回的 <code>RotatedRect</code> 对象包含以下信息：</p><ul><li><strong><code>center</code></strong>：矩形框的中心点坐标 <code>(cx, cy)</code>。</li><li><strong><code>size</code></strong>：矩形框的宽度和高度 <code>(width, height)</code>。</li><li><strong><code>angle</code></strong>：矩形框相对于水平方向的旋转角度（逆时针为正）</li></ul><p><strong>获取矩形框角点：</strong></p><ol><li><strong><code>box = cv2.boxPoints(rect)</code></strong>：<ul><li><code>cv2.boxPoints</code> 函数接收一个 <code>RotatedRect</code> 对象作为输入，并返回该旋转矩形框的四个顶点坐标。</li><li>这些顶点坐标是浮点型数据，表示为一个包含四个点的 numpy 数组。</li></ul></li><li><strong><code>box = np.int0(box)</code></strong>：<ul><li>这一步将上一步得到的四个顶点坐标 <code>box</code> 转换为整数类型的 numpy 数组。</li><li><code>np.int0()</code> 函数会将浮点数数组四舍五入为最接近的整数，并返回一个整数类型的 numpy 数组。</li></ul></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找轮廓</span></span><br><span class="line">contours_laser, _ = cv2.findContours(mask_laser, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">laser_coords = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours_laser:</span><br><span class="line">    rect = cv2.minAreaRect(contour)<span class="comment"># 获取最小矩形框</span></span><br><span class="line">    laser_coords = <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, rect[<span class="number">0</span>]))<span class="comment"># 矩形框的中心坐标</span></span><br><span class="line">    box = cv2.boxPoints(rect)<span class="comment"># 矩形框的四个角点</span></span><br><span class="line">    box = np.int0(box)</span><br><span class="line">    cv2.drawContours(frame, [box], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)<span class="comment"># 绘制矩形框(原图像中) </span></span><br></pre></td></tr></tbody></table></figure><h3 id="23激光点的颜色区分"><a class="markdownIt-Anchor" href="#23激光点的颜色区分"></a> 2.3激光点的颜色区分</h3><p><strong>imge.shape[]</strong></p><ul><li><strong><code>image.shape</code></strong>：这是一个 numpy 数组属性，用于获取图像的尺寸和通道数信息。</li><li><strong><code>image.shape[:2]</code></strong>：这是对 <code>shape</code> 属性进行切片操作，<code>[:2]</code> 表示取前两个元素，即图像的高度和宽度。</li></ul><p>具体来说，如果 <code>image</code> 是一个图像的 numpy 数组，例如形状为 <code>(height, width, channels)</code>，那么 <code>image.shape[:2]</code> 将返回一个包含图像高度和宽度的元组 <code>(height, width)</code>。</p><p>这种操作通常用于获取图像的空间尺寸信息，以便在处理图像时进行尺寸相关的计算或操作</p><p><strong>方圆坐标确定：</strong></p><ol><li><strong>获取输入坐标：</strong><ul><li><code>x, y = coords</code>：这行代码将变量 <code>coords</code> 解构为 <code>x</code> 和 <code>y</code>，分别表示中心点的横纵坐标。</li></ul></li><li><strong>确定左上角坐标：</strong><ul><li><code>x_start = max(0, x - radius)</code>：计算方形区域的左上角横坐标。<code>x - radius</code> 表示以中心点 <code>x</code> 为基础，向左偏移半径 <code>radius</code> 的距离。<code>max(0, ...)</code> 确保左上角横坐标不会小于 0，即不会超出图像左边界。</li><li><code>y_start = max(0, y - radius)</code>：计算方形区域的左上角纵坐标。同理，<code>y - radius</code> 表示以中心点 <code>y</code> 为基础，向上偏移半径 <code>radius</code> 的距离。<code>max(0, ...)</code> 确保左上角纵坐标不会小于 0，即不会超出图像上边界。</li></ul></li><li><strong>确定右下角坐标：</strong><ul><li><code>x_end = min(width - 1, x + radius)</code>：计算方形区域的右下角横坐标。<code>x + radius</code> 表示以中心点 <code>x</code> 为基础，向右偏移半径 <code>radius</code> 的距离。<code>min(width - 1, ...)</code> 确保右下角横坐标不会超过图像的右边界。</li><li><code>y_end = min(height - 1, y + radius)</code>：计算方形区域的右下角纵坐标。同理，<code>y + radius</code> 表示以中心点 <code>y</code> 为基础，向下偏移半径 <code>radius</code> 的距离。<code>min(height - 1, ...)</code> 确保右下角纵坐标不会超过图像的下边界。</li></ul></li></ol><p><strong>get_pixel_sum</strong></p><p>这段代码用于从给定的区域中提取红色（R）和绿色（G）颜色通道的值。让我来解释一下这段代码的含义：</p><ol><li><strong><code>roi[:, :, 2]</code>：</strong><ul><li><code>roi</code> 应该是图像的一个区域，即感兴趣的区域（Region of Interest，ROI）。</li><li><code>:</code> 是一个表示所有行或所有列的切片操作。</li><li><code>[ : , : , 2]</code> 表示选取所有行的所有列的第三个颜色通道。在 BGR 颜色空间中，第三个通道对应的是红色通道，所以这行代码获取了 ROI 中所有的红色通道值。</li></ul></li><li><strong><code>roi[:, :, 1]</code>：</strong><ul><li>与上面的代码类似，这行代码选取了所有行的所有列的第二个颜色通道。在 BGR 颜色空间中，第二个通道对应的是绿色通道，所以这行代码获取了 ROI 中所有的绿色通道值。</li></ul></li></ol><p>在大多数图像处理库中（如 OpenCV），图像默认是以 BGR 顺序存储的，而不是 RGB。这意味着在获取颜色通道时需要使用 <code>[ : , : , 2]</code> 来获取红色通道，<code>[ : , : , 1]</code> 来获取绿色通道，<code>[ : , : , 0]</code> 来获取蓝色通道。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激光点RGB值获取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pixel_sum</span>(<span class="params">image, coords</span>):</span><br><span class="line">    <span class="comment"># 获取图像宽度和高度</span></span><br><span class="line">    height, width = image.shape[:<span class="number">2</span>]</span><br><span class="line">    radius = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确定方圆的左上角和右下角坐标</span></span><br><span class="line">    x, y = coords</span><br><span class="line">    x_start = <span class="built_in">max</span>(<span class="number">0</span>, x - radius)</span><br><span class="line">    y_start = <span class="built_in">max</span>(<span class="number">0</span>, y - radius)</span><br><span class="line">    x_end = <span class="built_in">min</span>(width - <span class="number">1</span>, x + radius)</span><br><span class="line">    y_end = <span class="built_in">min</span>(height - <span class="number">1</span>, y + radius)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取方圆区域</span></span><br><span class="line">    roi = image[y_start:y_end, x_start:x_end]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算 R 和 G 通道总值</span></span><br><span class="line">    r_channel = roi[:, :, <span class="number">2</span>]</span><br><span class="line">    g_channel = roi[:, :, <span class="number">1</span>]</span><br><span class="line">    r_sum = <span class="built_in">int</span>(r_channel.<span class="built_in">sum</span>())</span><br><span class="line">    g_sum = <span class="built_in">int</span>(g_channel.<span class="built_in">sum</span>())</span><br><span class="line">    <span class="keyword">return</span> r_sum, g_sum</span><br></pre></td></tr></tbody></table></figure><p><strong>cv2.circle(frame, laser_coords, 4, (0, 0, 255), -1)</strong></p><p>绘制实心圆</p><p><strong>cv2.putText()</strong></p><ol><li><strong>参数解释：</strong><ul><li><code>frame</code>：这是目标图像帧，即要在其上添加文本的图像。</li><li><code>"RED"</code>：要写入的文本内容，这里是字符串 “RED”。</li><li><code>(laser_coords[0] - 10, laser_coords[1] - 10)</code>：文本放置的起始位置，由 <code>laser_coords</code> 提供，向左上方偏移了 <code>(10, 10)</code> 的像素值。</li><li><code>cv2.FONT_HERSHEY_SIMPLEX</code>：字体类型，这里使用了简单的字体类型。</li><li><code>0.5</code>：字体大小因子，控制文本大小相对于基础字体的比例。</li><li><code>(0, 0, 255)</code>：文本的颜色，这里是红色，对应 BGR 颜色空间中的 <code>(0, 0, 255)</code>。</li><li><code>2</code>：文本的线宽，即文本轮廓的粗细。</li></ul></li><li><strong>作用说明：</strong><ul><li>这行代码的主要作用是在图像帧的指定位置绘制红色的文本 “RED”。通常用于在图像或视频中标记特定的对象、位置或状态信息。</li></ul></li><li><strong>注意事项：</strong><ul><li>如果 <code>laser_coords</code> 提供的坐标 <code>(x, y)</code> 位于图像的边缘，确保 <code>(x - 10, y - 10)</code> 不会超出图像边界，以避免出现越界错误。</li></ul></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否获取到激光点矩形框的中心坐标，防止读取值为空</span></span><br><span class="line"><span class="keyword">if</span> laser_coords <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 获取激光点的RGB数据</span></span><br><span class="line">    color_vel = get_pixel_sum(image, laser_coords)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在红色激光点中心坐标出绘制圆点图像(原图像中)</span></span><br><span class="line">    cv2.circle(frame, laser_coords, <span class="number">4</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 打印文本数据“RED”在红色激光点上 </span></span><br><span class="line">    cv2.putText(frame ,<span class="string">"RED"</span>, (laser_coords[<span class="number">0</span>] - <span class="number">10</span>, laser_coords[<span class="number">1</span>] - <span class="number">10</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)    </span><br></pre></td></tr></tbody></table></figure><h3 id="24差值计算与串口通信"><a class="markdownIt-Anchor" href="#24差值计算与串口通信"></a> 2.4差值计算与串口通信</h3><p>PS:上位机与下位机通信，建议采用十六进制：帧头+数据类型+数据内容 的单帧数据包格式，这样才能保证下位机能够同步反应上位机发送的特征值，减小通信的复杂度，同时可靠性和速率较高，不建议采用发送字符串类型的通信。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> mode == <span class="string">'A'</span>:</span><br><span class="line">        direction = long_path[load_process]</span><br><span class="line">        <span class="comment"># 获取激光点与图像中心坐标或目标坐标的差值</span></span><br><span class="line">        x_err = laser_coords[<span class="number">0</span>]-direction[<span class="number">0</span>]</span><br><span class="line">        y_err = laser_coords[<span class="number">1</span>]-direction[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">'B'</span>:     </span><br><span class="line">        x_err = laser_coords[<span class="number">0</span>]-center_point_x</span><br><span class="line">        y_err = laser_coords[<span class="number">1</span>]-center_point_y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果激光点到达目标点（误差小于定值），目标点切换到下一个路径点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x_err) &lt;= <span class="number">5</span> <span class="keyword">and</span> <span class="built_in">abs</span>(y_err) &lt;= <span class="number">5</span>:</span><br><span class="line">        load_process-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> load_process == -<span class="number">1</span>:</span><br><span class="line">        load_process=<span class="number">11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 串口发送，数据帧格式:0xFF(帧头),&lt;x轴误差的数据类型&gt;,&lt;y轴误差的数据类型&gt;,&lt;x轴误差大小&gt;,&lt;y轴误差大小&gt;</span></span><br><span class="line">    <span class="keyword">if</span> x_err &lt; <span class="number">0</span>:</span><br><span class="line">        x_data_type = <span class="number">0x2D</span>  <span class="comment"># -x</span></span><br><span class="line">        x_data = <span class="built_in">abs</span>(x_err)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x_data_type = <span class="number">0x2B</span>  <span class="comment"># +x</span></span><br><span class="line">        x_data = x_err</span><br><span class="line">    <span class="keyword">if</span> y_err &lt; <span class="number">0</span>:</span><br><span class="line">        y_data_type = <span class="number">0x3D</span>  <span class="comment"># -y</span></span><br><span class="line">        y_data = <span class="built_in">abs</span>(y_err)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_data_type = <span class="number">0x3B</span>  <span class="comment"># +y</span></span><br><span class="line">        y_data = y_err</span><br><span class="line"></span><br><span class="line">    hex_data = <span class="built_in">bytes</span>([<span class="number">0xFF</span>,x_data_type,y_data_type,x_data, y_data])<span class="comment">#y-</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(hex_data.<span class="built_in">hex</span>())</span><br><span class="line">    ser.write(hex_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print('x:'+ str(x_err))</span></span><br><span class="line">    <span class="comment">#print('y:'+ str(y_err))</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"没找到激光点"</span>)</span><br><span class="line"><span class="keyword">return</span> image</span><br><span class="line"><span class="comment">#cv2.circle(image, (center_x, center_y), 5, (0, 255, 0), -1)</span></span><br><span class="line"><span class="comment">#cv2.imshow("Laser Detection", image)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3胶带矩形框识别"><a class="markdownIt-Anchor" href="#3胶带矩形框识别"></a> 3.胶带矩形框识别</h2><h3 id="31-roi区域的创建"><a class="markdownIt-Anchor" href="#31-roi区域的创建"></a> 3.1 ROI区域的创建</h3><p>PS: 使用ROI区域后，又想还原到原图像上对图像进行处理，就需要对坐标进行还原操作，保证图形每个像素点的索引和原图像对应</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROIPixelProcessor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_roi</span>(<span class="params">self, image, roi</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        取得 ROI 区域的像素值进行处理，但不改变索引号</span></span><br><span class="line"><span class="string">        :param image: 输入图像</span></span><br><span class="line"><span class="string">        :param roi: ROI 参数 (x, y, width, height)</span></span><br><span class="line"><span class="string">        :return: ROI 区域的像素值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x, y, w, h = roi</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确保 ROI 在图像范围内</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            w += x</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> y &lt; <span class="number">0</span>:</span><br><span class="line">            h += y</span><br><span class="line">            y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x + w &gt; image.shape[<span class="number">1</span>]:</span><br><span class="line">            w = image.shape[<span class="number">1</span>] - x</span><br><span class="line">        <span class="keyword">if</span> y + h &gt; image.shape[<span class="number">0</span>]:</span><br><span class="line">            h = image.shape[<span class="number">0</span>] - y</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 提取 ROI 区域的像素值</span></span><br><span class="line">        roi_pixels = image[y:y+h, x:x+w]</span><br><span class="line">        <span class="keyword">return</span> roi_pixels</span><br></pre></td></tr></tbody></table></figure><h3 id="32-图像的预处理"><a class="markdownIt-Anchor" href="#32-图像的预处理"></a> 3.2 图像的预处理</h3><p>通过BGR转灰度，自设定阈值进行二值化地方法，将胶带部分转换为白色单值，其他部分全为黑色单值，并且通过滤波、腐蚀、闭运算地方法对图形进行处理，降低噪点干扰，提高图形识别完整性。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> time.time()-start_time &lt;= <span class="number">5</span>:       </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将图像转换为灰度图</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment">#cv2.imshow('gray',gray)</span></span><br><span class="line"></span><br><span class="line">    gray = cv2.GaussianBlur(gray, (<span class="number">9</span>, <span class="number">9</span>), <span class="number">0</span>) <span class="comment">#高斯平滑滤波,(9,9)是卷积核，0 代表函数自动计算标准差</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#cv2.imshow('gauss',gray)</span></span><br><span class="line">    <span class="comment"># 对灰度图进行阈值处理，将黑色部分变为白色，其他部分变为黑色</span></span><br><span class="line">    _, threshold = cv2.threshold(gray, <span class="number">120</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行形态学闭操作，填充内部空洞</span></span><br><span class="line">    kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">    closing = cv2.morphologyEx(threshold, cv2.MORPH_CLOSE, kernel, iterations=<span class="number">3</span>)       </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行形态学腐蚀操作，缩小黑框大小，减少噪点信号干扰</span></span><br><span class="line">    kernel = np.ones((<span class="number">3</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">    erosion = cv2.erode(closing,kernel,iterations = <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#dilation = cv2.dilate(threshold, kernel, iterations=1) </span></span><br></pre></td></tr></tbody></table></figure><h3 id="33-矩形框轮廓的识别"><a class="markdownIt-Anchor" href="#33-矩形框轮廓的识别"></a> 3.3 矩形框轮廓的识别</h3><p>同样地，使用封闭图形检测算法，检测矩形框轮廓，这里使用 ROI处理，要特别注意像素点索引（坐标）的复原的操作。</p><p>即：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将轮廓绘制在原始图像上</span></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    <span class="comment"># 将轮廓点的坐标映射回原始图像的坐标系</span></span><br><span class="line">    contour += (x, y)  <span class="comment"># 将ROI的偏移加回来</span></span><br></pre></td></tr></tbody></table></figure><p><strong>近似曲线</strong></p><p>注意：这里approx_contour得到的是最终近似矩形的四个角点的坐标！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epsilon = 0.01 * cv2.arcLength(max_contour, True)</span><br><span class="line">approx_contour = cv2.approxPolyDP(max_contour, epsilon, True)</span><br></pre></td></tr></tbody></table></figure><ul><li><code>cv2.arcLength</code> 用于计算轮廓的周长或弧长。</li><li><code>epsilon</code> 是一个近似精度参数，通常是轮廓周长的某个百分比，这里设定为总周长的1%。</li><li><code>cv2.approxPolyDP</code> 用来对轮廓进行多边形逼近，通过减少顶点的数量来近似表示轮廓。</li><li><code>approx_contour</code> 是近似后的多边形轮廓。</li></ul><p><strong>找到左右轮廓的边界点（列表）</strong></p><p>leftmost[0]就是左轮廓第一个点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftmost = min(path, key=lambda x: x[0])  # 左轮廓边界坐标点</span><br><span class="line">rightmost = max(path, key=lambda x: x[0])  # 右轮廓边界坐标点</span><br></pre></td></tr></tbody></table></figure><ul><li><code>path</code> 是一组坐标点的集合，通常表示为一个列表或数组。</li><li><code>min(path, key=lambda x: x[0])</code> 和 <code>max(path, key=lambda x: x[0])</code> 分别用于找到 <code>path</code> 中横坐标 <code>x</code> 最小和最大的点，即左轮廓和右轮廓的边界点。</li></ul><p><strong>参数说明</strong>：</p><ul><li><code>lambda x: x[0]</code> 是一个匿名函数，用于指定以每个点的横坐标 <code>x</code> 作为比较的关键字。因此，<code>min</code> 函数找到具有最小横坐标的点，而 <code>max</code> 函数找到具有最大横坐标的点。</li></ul><p><strong>计算轮廓的中心点</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">center_point_x = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">0</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">center_point_y = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">1</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">center_point = (center_point_x, center_point_y)</span><br></pre></td></tr></tbody></table></figure><ul><li><code>path</code> 是一组轮廓的坐标点集合，通常表示为一个列表或数组。</li><li><code>sum([point[0] for point in path])</code> 对 <code>path</code> 中所有点的横坐标进行求和。</li><li><code>sum([point[1] for point in path])</code> 对 <code>path</code> 中所有点的纵坐标进行求和。</li><li><code>len(path)</code> 是 <code>path</code> 中点的数量，即轮廓的长度或大小。</li></ul><p><strong>参数说明</strong>：</p><ul><li><code>center_point_x</code> 和 <code>center_point_y</code> 分别是计算得到的轮廓中心点的横坐标和纵坐标。</li><li><code>center_point</code> 是由 <code>center_point_x</code> 和 <code>center_point_y</code> 组成的元组，表示轮廓的中心点坐标 <code>(x, y)</code>。</li></ul><p><strong>作用</strong>：</p><ul><li>这段代码的作用是计算轮廓 <code>path</code> 的几何中心点，通过对所有点的坐标进行平均值计算得出</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cv2.imshow('dilation',erosion)</span></span><br><span class="line"></span><br><span class="line">roi = closing[center_y-<span class="number">120</span>:center_y+<span class="number">120</span>, center_x-<span class="number">120</span>:center_x+<span class="number">120</span>]<span class="comment">#创建ROI图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow('roi',roi)</span></span><br><span class="line">x,y,w,h = center_x-<span class="number">120</span>,center_y-<span class="number">120</span>,<span class="number">240</span>,<span class="number">240</span> <span class="comment">#ROI左上角点为220,140，ROI检测框高度为200，宽度为200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制ROI矩形</span></span><br><span class="line">cv2.rectangle(frame,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow('erosion',erosion)</span></span><br><span class="line"><span class="comment"># 利用轮廓检测函数找到黑色框的轮廓</span></span><br><span class="line">contours, hierarchy = cv2.findContours(roi, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"><span class="comment"># 轮廓      层级                               轮廓检索模式  轮廓逼近方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将轮廓绘制在原始图像上</span></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    <span class="comment"># 将轮廓点的坐标映射回原始图像的坐标系</span></span><br><span class="line">    contour += (x, y)  <span class="comment"># 将ROI的偏移加回来</span></span><br><span class="line">    <span class="comment">#cv2.drawContours(frame, [contour], -1, (0, 0, 255), 2) 原始轮廓，这里用近似法得到更平滑的外围轮廓</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果找到了轮廓</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(contours) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 提取最大的轮廓</span></span><br><span class="line">    max_contour = <span class="built_in">max</span>(contours, key=cv2.contourArea)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 近似曲线</span></span><br><span class="line">    epsilon = <span class="number">0.01</span> * cv2.arcLength(max_contour, <span class="literal">True</span>)</span><br><span class="line">    approx_contour = cv2.approxPolyDP(max_contour, epsilon, <span class="literal">True</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 获取路径坐标</span></span><br><span class="line">    path = []</span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> approx_contour:</span><br><span class="line">        path.append(<span class="built_in">tuple</span>(point[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到左右轮廓的边界点</span></span><br><span class="line">    leftmost = <span class="built_in">min</span>(path, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])<span class="comment"># 左轮廓边界坐标点</span></span><br><span class="line">    rightmost = <span class="built_in">max</span>(path, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])<span class="comment"># 右轮廓边界坐标点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算左右轮廓的中间点</span></span><br><span class="line">    middle_x = <span class="built_in">int</span>((leftmost[<span class="number">0</span>] + rightmost[<span class="number">0</span>]) / <span class="number">2</span>)<span class="comment"># x中心坐标</span></span><br><span class="line">    middle_y = <span class="built_in">int</span>((leftmost[<span class="number">1</span>] + rightmost[<span class="number">1</span>]) / <span class="number">2</span>)<span class="comment"># y中心坐标</span></span><br><span class="line">    middle_point = (middle_x, middle_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制左右轮廓中心点                 </span></span><br><span class="line">    <span class="comment">#cv2.circle(frame, middle_point, 5, (0, 255, 0), -1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算轮廓的中心点</span></span><br><span class="line">    center_point_x = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">0</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">    center_point_y = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">1</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">    center_point = (center_point_x, center_point_y)            </span><br><span class="line"></span><br><span class="line">    cv2.drawContours(frame, [np.array(path)], -<span class="number">1</span>, (<span class="number">125</span>, <span class="number">255</span>, <span class="number">125</span>), <span class="number">1</span>) <span class="comment">#近似后的轮廓</span></span><br><span class="line">    <span class="comment">#                           轮廓     第几个(默认-1：所有)   颜色       线条厚度       </span></span><br><span class="line">    <span class="comment"># 绘制轮廓中心点</span></span><br><span class="line">    cv2.circle(frame, center_point, <span class="number">3</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)        </span><br><span class="line"></span><br><span class="line">    resize = <span class="number">0.92</span></span><br><span class="line"></span><br><span class="line">    resize_path = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> path:</span><br><span class="line">        resize_x =  <span class="built_in">int</span>(center_point_x + resize*(point[<span class="number">0</span>]-center_point_x))</span><br><span class="line">        resize_y =  <span class="built_in">int</span>(center_point_y + resize*(point[<span class="number">1</span>]-center_point_y))</span><br><span class="line">        resize_path.append((resize_x,resize_y))</span><br><span class="line"></span><br><span class="line">    cv2.drawContours(frame, [np.array(resize_path)], -<span class="number">1</span>, (<span class="number">125</span>, <span class="number">255</span>, <span class="number">125</span>), <span class="number">1</span>) <span class="comment"># 内缩后的轮廓</span></span><br><span class="line">    long_path = interpolate_points(resize_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> long_path:</span><br><span class="line">        cv2.circle(frame, point, <span class="number">4</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="3-4-矩形框的路径规划-插值算法"><a class="markdownIt-Anchor" href="#3-4-矩形框的路径规划-插值算法"></a> 3-4 矩形框的路径规划-插值算法</h3><p>如果让激光点沿着轮廓一个一个坐标点去走，这样计算量会相当大，不如将矩形轮廓通过近似得到四个角点，再通过插值法，设置相邻点的插值参数，得到12个路径点，这样就既保证了巡线的稳定性，也大大减少了巡线的计算量。同时，通过调用time库来计时，程序启动时定时5s后，这段时间提供给我们确认摄像机状态，移动ROI区域，完成路径规划，实现“动态建图”的效果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#插值算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">interpolate_points</span>(<span class="params">points</span>):</span><br><span class="line">    interpolated_points = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">        start_point = points[i]</span><br><span class="line">        end_point = points[(i+<span class="number">1</span>) % <span class="built_in">len</span>(points)]</span><br><span class="line">        <span class="comment"># 计算两点之间的距离</span></span><br><span class="line">        dx = end_point[<span class="number">0</span>] - start_point[<span class="number">0</span>]</span><br><span class="line">        dy = end_point[<span class="number">1</span>] - start_point[<span class="number">1</span>]</span><br><span class="line">        distance = <span class="number">3</span></span><br><span class="line">        <span class="comment"># 根据距离进行插值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(distance):</span><br><span class="line">            x = start_point[<span class="number">0</span>] + <span class="built_in">int</span>(dx * j / distance)</span><br><span class="line">            y = start_point[<span class="number">1</span>] + <span class="built_in">int</span>(dy * j / distance)</span><br><span class="line">            interpolated_points.append((x, y))</span><br><span class="line">    <span class="keyword">return</span> interpolated_points</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> RDK X3 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电赛 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 激光追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TI】-1-Sysconfig工具使用（GPIO、定时器为例）</title>
      <link href="/posts/35334/"/>
      <url>/posts/35334/</url>
      
        <content type="html"><![CDATA[<h1 id="一-编译器ccs-theia的基本使用"><a class="markdownIt-Anchor" href="#一-编译器ccs-theia的基本使用"></a> 一、编译器CCS Theia的基本使用</h1><p>​本文主要介绍通过CCS Theia以及Sysconfig的基本使用方法，将以GPIO和定时器为例，泛化性地介绍CCS Theia这个工具，便于其他外设配置的理解，对于CCS Theia IDE的安装及其环境配置，不做多赘述。</p><h2 id="1-范例程序的导入"><a class="markdownIt-Anchor" href="#1-范例程序的导入"></a> 1.  范例程序的导入</h2><blockquote><p>步骤：</p><ol><li><p>选择File -&gt; import Project(s)</p></li><li><p>选择SDK中官方示例的地址，本文安装路径为：S:\ti\mspm0_sdk_2_01_00_03\examples\nortos\LP_MSPM0G3507\driverlib</p><img src="/posts/35334/image-20240806015913088.png" class="" title="image-20240806015913088"><ul><li>gcc：代表C++方式编程的工程格式</li><li>ticlang：代表TI官方IDE的工程格式</li></ul></li></ol></blockquote><h2 id="2-sysconfig界面"><a class="markdownIt-Anchor" href="#2-sysconfig界面"></a> 2.  Sysconfig界面</h2><p>​Sysconfig界面是TI推出的图形化界面配置，类似于ST 的CubeMX，能够极大简化对于单片机外设的初始化配置，更容易上手，但是这也需要我们正确小心地去使用这个工具，错误的配置很容易导致单片机无法正常工作。</p><p>​一般的，在我们使用CCS Theia配置工程时，CCS<mark>成功加载</mark>工程文件后会显示一些特殊图标（偶尔会加载不成功，这个时候工程是无效的使用状态，需要重启软件），其中，主程序（如 main.c）同级目录下会生成一个后缀名为.syscfg的文件，这个文件用于存放TI M0系列图形化配置，点击main.syscfg即可打开图形化配置界面，本文着重介绍外设配置界面。</p><img src="/posts/35334/image-20240806020630210.png" class="" title="image-20240806020630210"><h1 id="二-gpio口的基本配置"><a class="markdownIt-Anchor" href="#二-gpio口的基本配置"></a> 二、GPIO口的基本配置</h1><img src="/posts/35334/image-20240806021554207.png" class="" title="image-20240806021554207"><h2 id="1-gpio输出模式"><a class="markdownIt-Anchor" href="#1-gpio输出模式"></a> 1. GPIO输出模式</h2><p>简单配置Direction(方向)为Output即可</p><img src="/posts/35334/image-20240806021652604.png" class="" title="image-20240806021652604"><p><strong>GPIO引脚置高电平</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DL_GPIO_setPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN); <span class="comment">//将FR1置高</span></span><br></pre></td></tr></tbody></table></figure><p><strong>GPIO引脚清空</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN);<span class="comment">//将FR2置低</span></span><br></pre></td></tr></tbody></table></figure><p>注意：PORT和PIN的区别</p><ul><li><strong>PORT</strong>更侧重于表示一种逻辑或物理接口的集合，而<strong>PIN</strong>则是指具体的电气连接点。在微控制器中，端口通常由多个引脚组成，而引脚是最基本的物理连接单位。</li></ul><h2 id="2-gpio输入模式"><a class="markdownIt-Anchor" href="#2-gpio输入模式"></a> 2. GPIO输入模式</h2><h3 id="21-读取引脚值"><a class="markdownIt-Anchor" href="#21-读取引脚值"></a> 2.1 读取引脚值</h3><p><strong>GPIO读取引脚状态</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DL_GPIO_readPins(GPIO_TRACE_PORT,GPIO_TRACE_PIN_TRACE_0_PIN);<span class="comment">//读取TRACE0的电平（可能是n位返回值）</span></span><br></pre></td></tr></tbody></table></figure><p>注意：</p><p>​使用此函数读取的GPIO引脚状态为多个引脚的组合，需要经过逻辑操作来单独取一位。</p><h3 id="22-按键"><a class="markdownIt-Anchor" href="#22-按键"></a> 2.2 按键</h3><p>注意：特别地，如果要配置外部按键控制单片机，对应的引脚不能是浮空输入的状态，必须有具体的TTL电平状态，可以在Digtial IOMUX Features配置Internal Resistor选项为上拉输入，其他的默认配置即可。</p><p><img src="C:%5CUsers%5C123%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240811011437475.png" alt="image-20240811011437475"></p><h3 id="23-外部中断"><a class="markdownIt-Anchor" href="#23-外部中断"></a> 2.3. 外部中断</h3><p>外部中断一般用于特定的事件检测，计数（如：里程），配合定时器测电机速度等，图示为<strong>双边沿触发的外部中断</strong>，并且中断优先级配置为1</p><img src="/posts/35334/image-20240811012509997.png" class="" title="image-20240811012509997"><h1 id="三-定时器的基本配置"><a class="markdownIt-Anchor" href="#三-定时器的基本配置"></a> 三、定时器的基本配置</h1><h2 id="1-定时器频率设置"><a class="markdownIt-Anchor" href="#1-定时器频率设置"></a> 1.  定时器频率设置</h2><blockquote><ul><li>Timer Clock Source: 时钟源选择，一般为BUSCLK</li><li>Timer Clock Divider:前分频</li><li>Timer Clock Prescaler:后分频</li></ul><p>定时器的频率/单位周期会在sysconfig中自动计算好</p></blockquote><img src="/posts/35334/image-20240715192616803.png" class="" title="image-20240715192616803"><p>注意：</p><ul><li>定时器的计数精度有限，具体由设置决定</li></ul><h2 id="3-定时器计数模式"><a class="markdownIt-Anchor" href="#3-定时器计数模式"></a> 3. 定时器计数模式</h2><img src="/posts/35334/image-20240811012753418.png" class="" title="image-20240811012753418"><h2 id="4-advanced-configuration高级功能设置"><a class="markdownIt-Anchor" href="#4-advanced-configuration高级功能设置"></a> 4. Advanced Configuration：高级功能设置</h2><h2 id="5-中断配置"><a class="markdownIt-Anchor" href="#5-中断配置"></a> 5. 中断配置</h2><blockquote><ul><li>如图，计数到零触发中断</li><li>interrupt Priority：中断优先级</li></ul></blockquote><img src="/posts/35334/image-20240715193539699.png" class="" title="image-20240715193539699"><h3 id="51-中断事件使能"><a class="markdownIt-Anchor" href="#51-中断事件使能"></a> 5.1 <strong>中断事件使能：</strong></h3><p>与一般单片机不同，G3507配置中断后，程序中需要加上对中断事件类型的判断。</p><img src="/posts/35334/image-20240715194038332.png" class="" title="image-20240715194038332"><p><strong>定时器中断代码部分：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIMER_0_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (DL_TimerG_getPendingInterrupt(TIMER_0_INST)) {</span><br><span class="line">        <span class="keyword">case</span> DL_TIMER_IIDX_ZERO:</span><br><span class="line">            DL_GPIO_togglePins(GPIO_LEDS_PORT,</span><br><span class="line">                GPIO_LEDS_USER_LED_1_PIN | GPIO_LEDS_USER_TEST_PIN);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-定时器设备选择"><a class="markdownIt-Anchor" href="#6-定时器设备选择"></a> 6. 定时器设备选择</h2><img src="/posts/35334/image-20240715193738345.png" class="" title="image-20240715193738345"><h1 id="m0系列的低功耗工艺"><a class="markdownIt-Anchor" href="#m0系列的低功耗工艺"></a> #M0系列的低功耗工艺</h1><img src="/posts/35334/image-20240715194311900.png" class="" title="image-20240715194311900"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DL_SYSCTL_enableSleepOnExit();<span class="comment">//使能：当从中断返回到主函数中，单片机工作状态从RUN切换到SLEEP状态</span></span><br><span class="line"><span class="comment">// __WFI();</span></span><br></pre></td></tr></tbody></table></figure><h1 id="四-定时器pwm配置"><a class="markdownIt-Anchor" href="#四-定时器pwm配置"></a> 四、定时器PWM配置</h1><h2 id="1-pwm工作模式"><a class="markdownIt-Anchor" href="#1-pwm工作模式"></a> 1. PWM工作模式</h2><ul><li>Edge-aligned:边沿对齐</li><li>Center-aligned:中心对齐</li></ul><img src="/posts/35334/image-20240715214605017.png" class="" title="image-20240715214605017"><p>PS：</p><ul><li>定时器0可以生成四路PWM</li></ul><h2 id="2-pwm的频率设置"><a class="markdownIt-Anchor" href="#2-pwm的频率设置"></a> 2. PWM的频率设置</h2><img src="/posts/35334/image-20240715215253775.png" class="" title="image-20240715215253775"><h2 id="3-pwm占空比设置"><a class="markdownIt-Anchor" href="#3-pwm占空比设置"></a> 3. PWM占空比设置</h2><p>注意：</p><ul><li>Compare Value = PWM Period Count  * (1-Duty Cycle)</li><li>xxxxxxxxxx&nbsp;python script_name.py --train_data_dir “path/to/train_data” --test_data_dir “path/to/test_data” --img_height 128 --img_width 128 --batch_size 64 --epochs 15python</li></ul><img src="/posts/35334/image-20240715215418979.png" class="" title="image-20240715215418979"><h2 id="4-pwm输出引脚设置"><a class="markdownIt-Anchor" href="#4-pwm输出引脚设置"></a> 4. PWM输出引脚设置</h2><p>注意：</p><ul><li>PWM四个引脚输出可以复用PWM通道</li></ul><img src="/posts/35334/image-20240715215919260.png" class="" title="image-20240715215919260">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> MSPM0G3507 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【yolov5】[1]初探目标检测算法--YOLOv5的训练及在地平线RDK X3上的快速部署</title>
      <link href="/posts/31493/"/>
      <url>/posts/31493/</url>
      
        <content type="html"><![CDATA[<h1 id="一-windows环境下的模型训练"><a class="markdownIt-Anchor" href="#一-windows环境下的模型训练"></a> 一、Windows环境下的模型训练</h1><p>针对YOLO的模型训练环境配置，Windows端兼容性差于Ubuntu，如果电脑上有Ubuntu系统，建议用Ubuntu系统进行训练（但注意，虚拟机安装的Ubuntu系统无法使用物理GPU进行训练）。</p><p><strong><mark>YOLO版本：YOLOV5 7.0</mark></strong></p><h2 id="xxxxxxxxxx-tags-数字电路与vhdl设计bash"><a class="markdownIt-Anchor" href="#xxxxxxxxxx-tags-数字电路与vhdl设计bash"></a> xxxxxxxxxx&nbsp;$ tags: -数字电路与VHDL设计"bash</h2><p>准备好目标模型对应的图片数据集，使用labelme命令，启动数据集打标工具</p><h2 id="2-模型的训练和导出onnx"><a class="markdownIt-Anchor" href="#2-模型的训练和导出onnx"></a> 2. 模型的训练和导出ONNX</h2><h3 id="21-环境配置"><a class="markdownIt-Anchor" href="#21-环境配置"></a> 2.1 环境配置</h3><blockquote><p>Anoconda可以区分不同的环境，不同的环境下可以使用的命令是不同的</p><p>创建环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n yolov5_7<span class="number">.0</span> python==<span class="number">3.8</span><span class="number">.5</span></span><br></pre></td></tr></tbody></table></figure><p>列举所有环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env <span class="built_in">list</span></span><br></pre></td></tr></tbody></table></figure><p>删除’环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env remove --name &lt;env_name&gt;</span><br></pre></td></tr></tbody></table></figure><p>激活环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate &lt;env_name&gt;</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p>如配置好yolo的环境，安装好pytorch，cuda，yolo相关依赖，就需要使用conda activate yolov5_7.0激活</p></blockquote><h4 id="211-常见问题"><a class="markdownIt-Anchor" href="#211-常见问题"></a> 2.1.1 <mark>常见问题：</mark></h4><p>Anoconda环境下无法识别到CUDA</p><p><strong>参考文章</strong>：<a href="https://blog.csdn.net/qq_71547093/article/details/133581922">print(torch.cuda.is_available())是false_pip install torch==2.0.1+cu117-CSDN博客</a></p><img src="/posts/31493/0248d8bfdc09cf576bce9846dbea681e.png" class="" title="img"><p><strong>问题原因</strong>：</p><p>所使用的环境是anaconda pytorch。</p><p>使用GPU来加速某个项目，但是GPU不能用，原因是没有安装GPU版本的torch和torchvision</p><p><strong>解决方法</strong>：</p><p>使用pip安装GPU版本的支持CUDA 11.7的torch和torchvision，并且版本分别为torch<mark>2.0.1和torchvision</mark>0.15.2。具体可以根据需要的版本进行修改。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==<span class="number">2.0</span><span class="number">.1</span>+cu117 torchvision==<span class="number">0.15</span><span class="number">.2</span>+cu117 -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></tbody></table></figure><p>安装完成之后，检查是否可以正常使用。</p><p><strong><mark>如果在线安装速度过慢，可以尝试进入网页的方法：</mark></strong></p><p>手动下载 <code>.whl</code> 文件并离线安装。</p><ol><li><p><strong>下载 <code>.whl</code> 文件</strong>：<br>访问 <a href="https://download.pytorch.org/whl/torch_stable.html">PyTorch 官网</a> 或使用下面的链接手动下载相应的 <code>.whl</code> 文件：</p><ul><li><a href="https://download.pytorch.org/whl/cu117/torch-2.0.1%2Bcu117-cp38-cp38-win_amd64.whl">torch-2.0.1+cu117</a></li><li><a href="https://download.pytorch.org/whl/cu117/torchvision-0.15.2%2Bcu117-cp38-cp38-win_amd64.whl">torchvision-0.15.2+cu117</a></li></ul></li><li><p><strong>离线安装</strong>：<br>下载完成后，使用 <code>pip</code> 离线安装：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install path/to/torch-<span class="number">2.0</span><span class="number">.1</span>+cu117-cp38-cp38-win_amd64.whl</span><br><span class="line">pip install path/to/torchvision-<span class="number">0.15</span><span class="number">.2</span>+cu117-cp38-cp38-win_amd64.whl</span><br></pre></td></tr></tbody></table></figure></li></ol><p>输入python，回车，然后输入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="23-训练过程源码修改板端设备-rdk-x3"><a class="markdownIt-Anchor" href="#23-训练过程源码修改板端设备-rdk-x3"></a> 2.3 <strong>训练过程源码修改(板端设备 RDK X3)</strong></h3><p>修改YOLO源码的内容，使用GPU进行快速训练</p><p><strong>参考文章：</strong><a href="https://developer.horizon.cc/forumDetail/177840589839214598">YOLOv5较新版本的部署方法 (horizon.cc)</a></p><p>主目录下 <a href="http://export.py">export.py</a> 约1351行附近，标注两处不做注释</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shape = <span class="built_in">tuple</span>((y[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">isinstance</span>(y, <span class="built_in">tuple</span>) <span class="keyword">else</span> y).shape)  <span class="comment"># model output shape#转换时注释</span></span><br><span class="line">metadata = {<span class="string">"stride"</span>: <span class="built_in">int</span>(<span class="built_in">max</span>(model.stride)), <span class="string">"names"</span>: model.names}  <span class="comment"># model metadata###</span></span><br><span class="line">LOGGER.info(<span class="string">f"\n<span class="subst">{colorstr(<span class="string">'PyTorch:'</span>)}</span> starting from <span class="subst">{file}</span> with output shape <span class="subst">{shape}</span> (<span class="subst">{file_size(file):<span class="number">.1</span>f}</span> MB)"</span>)<span class="comment">#转换时注释</span></span><br></pre></td></tr></tbody></table></figure><p>model/yolo.py 约91行处</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    <span class="string">"""Processes input through YOLOv5 layers, altering shape for detection: `x(bs, 3, ny, nx, 85)`."""</span></span><br><span class="line">    z = []  <span class="comment"># inference output</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.nl):</span><br><span class="line">        x[i] = self.m[i](x[i])  <span class="comment"># conv###</span></span><br><span class="line">        bs, _, ny, nx = x[i].shape  <span class="comment"># x(bs,255,20,20) to x(bs,3,20,20,85)###</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">### ###</span></span><br><span class="line">        <span class="comment">#转换成注释，训练时启用</span></span><br><span class="line">        x[i] = x[i].view(bs, self.na, self.no, ny, nx).permute(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>).contiguous()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.training:  <span class="comment"># inference</span></span><br><span class="line">            <span class="keyword">if</span> self.dynamic <span class="keyword">or</span> self.grid[i].shape[<span class="number">2</span>:<span class="number">4</span>] != x[i].shape[<span class="number">2</span>:<span class="number">4</span>]:</span><br><span class="line">                self.grid[i], self.anchor_grid[i] = self._make_grid(nx, ny, i)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(self, Segment):  <span class="comment"># (boxes + masks)</span></span><br><span class="line">                xy, wh, conf, mask = x[i].split((<span class="number">2</span>, <span class="number">2</span>, self.nc + <span class="number">1</span>, self.no - self.nc - <span class="number">5</span>), <span class="number">4</span>)</span><br><span class="line">                xy = (xy.sigmoid() * <span class="number">2</span> + self.grid[i]) * self.stride[i]  <span class="comment"># xy</span></span><br><span class="line">                wh = (wh.sigmoid() * <span class="number">2</span>) ** <span class="number">2</span> * self.anchor_grid[i]  <span class="comment"># wh</span></span><br><span class="line">                y = torch.cat((xy, wh, conf.sigmoid(), mask), <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># Detect (boxes only)</span></span><br><span class="line">                xy, wh, conf = x[i].sigmoid().split((<span class="number">2</span>, <span class="number">2</span>, self.nc + <span class="number">1</span>), <span class="number">4</span>)</span><br><span class="line">                xy = (xy * <span class="number">2</span> + self.grid[i]) * self.stride[i]  <span class="comment"># xy</span></span><br><span class="line">                wh = (wh * <span class="number">2</span>) ** <span class="number">2</span> * self.anchor_grid[i]  <span class="comment"># wh</span></span><br><span class="line">                y = torch.cat((xy, wh, conf), <span class="number">4</span>)</span><br><span class="line">            z.append(y.view(bs, self.na * nx * ny, self.no))</span><br><span class="line">    <span class="keyword">return</span> x <span class="keyword">if</span> self.training <span class="keyword">else</span> (torch.cat(z, <span class="number">1</span>),) <span class="keyword">if</span> self.export <span class="keyword">else</span> (torch.cat(z, <span class="number">1</span>), x)</span><br><span class="line"><span class="comment">### ###</span></span><br><span class="line">        <span class="comment"># x[i] = x[i].permute(0, 2, 3, 1).contiguous()#转换时启用,训练时注释</span></span><br><span class="line">    <span class="comment"># return x#转换时启用</span></span><br></pre></td></tr></tbody></table></figure><h3 id="21-模型的训练"><a class="markdownIt-Anchor" href="#21-模型的训练"></a> 2.1 模型的训练</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --data face_data.yaml --cfg face_yolo5s.yaml --weights pretrained/yolov5s.pt --batch-size <span class="number">16</span> --epochs <span class="number">300</span>  --imgsz <span class="number">672</span> --device <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><ul><li>face_data.yaml：指定数据集的配置文件为 <code>face_data.yaml</code>，这个文件包含了训练和验证数据集的路径、类别数以及类别名称等信息</li><li>face_yolo5s.yaml：指定 YOLOv5 模型的配置文件为 <code>face_yolo5s.yaml</code>，这个文件定义了模型的结构和各项超参数</li><li>weights：指定预训练权重文件的路径为 <code>pretrained/yolov5s.pt</code>，这些权重将用于初始化模型的参数，以加速训练收敛</li><li>batch-size：设置训练时的批量大小为 4，这表示每次迭代中使用的样本数为 4，影响训练速度和模型训练过程</li><li>device：指定训练时使用的设备，这里的 <code>0</code> 表示使用 GPU 0。如果你有多个 GPU，可以根据需要更改这个数字；如果你想使用 CPU，可以将其设置为 <code>cpu</code></li><li>epochs：训练轮数</li><li>imgsz：模型大小（本例 输入输出为 672 x672）</li><li>deviece：选择设备号，0一般指向GPU（需要安装对应版本的CUDA和cudnn）</li></ul><h2 id="22-模型的onnx格式导出"><a class="markdownIt-Anchor" href="#22-模型的onnx格式导出"></a> 2.2 模型的ONNX格式导出</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python export.py --weights runs/train/exp/weights/best.pt --include onnx engine --img-size <span class="number">672</span> --batch-size <span class="number">1</span> --device <span class="number">0</span> </span><br></pre></td></tr></tbody></table></figure><ul><li>–weights：此段命令指向训练好的pt模型目录</li><li>include：目标格式</li></ul><h2 id="3-模型的windows端验证"><a class="markdownIt-Anchor" href="#3-模型的windows端验证"></a> 3. 模型的Windows端验证</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测摄像头</span></span><br><span class="line">python detect.py  --weights runs/train/exp_yolov5s/weights/best.pt --source <span class="number">0</span>  <span class="comment"># webcam</span></span><br><span class="line"><span class="comment"># 检测图片文件</span></span><br><span class="line"> python detect.py  --weights runs/train/exp_yolov5s/weights/best.pt --source file.jpg  <span class="comment"># image </span></span><br><span class="line"><span class="comment"># 检测视频文件</span></span><br><span class="line">  python detect.py --weights runs/train/exp_yolov5s/weights/best.pt --source file.mp4  <span class="comment"># video</span></span><br><span class="line"><span class="comment"># 检测一个目录下的文件</span></span><br><span class="line"> python detect.py --weights runs/train/exp_yolov5s/weights/best.pt path/  <span class="comment"># directory</span></span><br><span class="line"><span class="comment"># 检测网络视频</span></span><br><span class="line"> python detect.py --weights runs/train/exp_yolov5s/weights/best.pt <span class="string">'https://youtu.be/NUsoVlDFqZg'</span>  <span class="comment"># YouTube video</span></span><br><span class="line"><span class="comment"># 检测流媒体</span></span><br><span class="line"> python detect.py --weights runs/train/exp_yolov5s/weights/best.pt <span class="string">'rtsp://example.com/media.mp4'</span>  <span class="comment"># RTSP, RTMP, HTTP stream                            </span></span><br></pre></td></tr></tbody></table></figure><h1 id="二-模型部署"><a class="markdownIt-Anchor" href="#二-模型部署"></a> 二、模型部署</h1><h2 id="1-模型的工具链环境ubuntuonnx转化bin格式"><a class="markdownIt-Anchor" href="#1-模型的工具链环境ubuntuonnx转化bin格式"></a> 1. 模型的工具链环境(Ubuntu)——onnx转化bin格式</h2><p><strong>参考文章：<a href="https://developer.horizon.cc/forumDetail/163807123501918330">【模型提速】如何在X3pi使用yolov5模型50ms推理 (horizon.cc)</a></strong></p><hr><p><strong>文件结构</strong>：</p><p><code>hb_mapper_makertbin.log</code>是工具链自动生成的日志文件<br><code>imgs_train</code>存放训练集中的原图片<br><code>imgs_cal</code>存放转化模型需要的图片校准数据<br><code>tran.py</code>用于将原训练集图片转化成校准数据<br><code>medels_onnx</code>存放转化前的onnx模型<br><code>models_onnx</code>存放转化后的bin文件<br><code>tran.yaml</code>是转化所需的文本</p><hr><p><strong>模型验证</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hb_mapper checker --model-<span class="built_in">type</span> onnx --march bernoulli2 --model models_onnx/my_face.onnx --<span class="built_in">input</span>-shape images 1x3x672x672</span><br></pre></td></tr></tbody></table></figure><p>注意：–input-shape 需要跟之前的模型尺寸参数对应</p><p>验证执行之后，在命令行界面可以看到算子是否在CPU/BPU上支持运行</p><p><strong>板载模型转化</strong></p><p>转化之前，yaml文件中要注意修改对应标注的参数</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hb_mapper makertbin --config yaml文件的位置 --model-<span class="built_in">type</span> onnx</span><br></pre></td></tr></tbody></table></figure><p>执行命令之后，可以在model_output文件夹中找到对应的bin文件</p><p><strong>模型性能分析(开发机评测性能)</strong></p><p>使用 <code>hb_perf</code> 工具评测模型性能，使用方式如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hb_perf  ***.bin</span><br></pre></td></tr></tbody></table></figure><h2 id="2-板端rdk-x3部署"><a class="markdownIt-Anchor" href="#2-板端rdk-x3部署"></a> 2. 板端（RDK X3）部署</h2><p>将转换完成的bin文件，复制到板端对应目录即可</p><p><strong>RDK X3 板端模型运行过程：</strong></p><ul><li><p>模型预处理：CPU</p></li><li><p>模型推理：BPU 与 CPU 并行</p></li><li><p>模型后处理：CPU</p></li></ul><h3 id="21-后处理函数部分"><a class="markdownIt-Anchor" href="#21-后处理函数部分"></a> 2.1 后处理函数部分</h3><h4 id="211-python版本"><a class="markdownIt-Anchor" href="#211-python版本"></a> 2.1.1 Python版本</h4><blockquote><p>后处理函数中类别数目，类名都要跟模型一一对应</p><ul><li><code>postprocess.py</code>，把<code>num_classes</code>改成自己模型的class数量</li><li><code>def get_classes(class_file_name='dominoes.names')</code>，改成存放标签的名词</li></ul></blockquote><p><strong>后处理函数中数据处理模块需要根据模型的分辨率，类别数目进行修改。如若参数不对应，使用后处理函数时会报错</strong></p><p><a href="https://developer.horizon.cc/forumDetail/198686198578007656">YOLOV5 在地平线RDK X3的高效部署 (horizon.cc)</a></p><img src="/posts/31493/605ba25c7844d1c31120f0361c46893.png" class="" title="605ba25c7844d1c31120f0361c46893"><h4 id="212-c版本"><a class="markdownIt-Anchor" href="#212-c版本"></a> 2.1.2 C++版本</h4><p>由于Python是解释型语言，运行后处理这类计算量较大的操作非常耗时，用C++的方法编写代码速度快得多。</p><p>一种解决方案是，使用Cython加速后处理部分，用Cython的方法封装C++为Python的接口。能够极大提升模型性能。</p><p><strong>参考文章：</strong>[<a href="https://developer.d-robotics.cc/forumDetail/112555549341653639">BPU部署教程] 教你搞定YOLOV5部署 (版本_ 6.2) (d-robotics.cc)</a></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>参考文章汇总：</p><ul><li><a href="https://blog.csdn.net/qq_71547093/article/details/133581922">print(torch.cuda.is_available())是false_pip install torch==2.0.1+cu117-CSDN博客</a></li><li><a href="https://developer.horizon.cc/forumDetail/177840589839214598">YOLOv5较新版本的部署方法 (horizon.cc)</a></li><li><a href="https://developer.horizon.cc/forumDetail/163807123501918330">【模型提速】如何在X3pi使用yolov5模型50ms推理 (horizon.cc)</a></li><li><a href="https://developer.horizon.cc/forumDetail/198686198578007656">YOLOV5 在地平线RDK X3的高效部署 (horizon.cc)</a></li><li>[<a href="https://developer.d-robotics.cc/forumDetail/112555549341653639">BPU部署教程] 教你搞定YOLOV5部署 (版本_ 6.2) (d-robotics.cc)</a></li></ul><p>本文使用环境：Windows(训练) -&gt; 虚拟机Ubuntu(转换，校验) -&gt; 板端RDK X3(最终部署)</p><p>建议环境：Ubuntu(训练)-&gt;Ubuntu(转换，校验)-&gt;板端部署</p><p>本文使用YOLOv5 7.0，也可以尝试 YOLOv5 tag2.0 版本，站内有教程说明tag2.0版本与BPU的适配性更好。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【ROS2】[2]ROS2节点的编写</title>
      <link href="/posts/9164/"/>
      <url>/posts/9164/</url>
      
        <content type="html"><![CDATA[<h1 id="ros2节点的代码结构面向对象"><a class="markdownIt-Anchor" href="#ros2节点的代码结构面向对象"></a> ROS2节点的代码结构（面向对象）</h1><h2 id="主程序"><a class="markdownIt-Anchor" href="#主程序"></a> 主程序</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3 </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@作者: 古月居(www.guyuehome.com)</span></span><br><span class="line"><span class="string">@说明: ROS2节点示例-通过摄像头识别检测图片中出现的苹果</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy                            <span class="comment"># ROS2 Python接口库</span></span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node             <span class="comment"># ROS2 节点类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2                              <span class="comment"># OpenCV图像处理库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np                      <span class="comment"># Python数值计算库</span></span><br><span class="line"></span><br><span class="line">lower_red = np.array([<span class="number">0</span>, <span class="number">90</span>, <span class="number">128</span>])     <span class="comment"># 红色的HSV阈值下限</span></span><br><span class="line">upper_red = np.array([<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>])  <span class="comment"># 红色的HSV阈值上限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">object_detect</span>(<span class="params">image</span>):</span><br><span class="line">    hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)       <span class="comment"># 图像从BGR颜色模型转换为HSV模型</span></span><br><span class="line">    mask_red = cv2.inRange(hsv_img, lower_red, upper_red)  <span class="comment"># 图像二值化</span></span><br><span class="line"></span><br><span class="line">    contours, hierarchy = cv2.findContours(mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) <span class="comment"># 图像中轮廓检测</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:                                   <span class="comment"># 去除一些轮廓面积太小的噪声</span></span><br><span class="line">        <span class="keyword">if</span> cnt.shape[<span class="number">0</span>] &lt; <span class="number">150</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        (x, y, w, h) = cv2.boundingRect(cnt)               <span class="comment"># 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高</span></span><br><span class="line">        cv2.drawContours(image, [cnt], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>) <span class="comment"># 将苹果的轮廓勾勒出来</span></span><br><span class="line">        cv2.circle(image, (<span class="built_in">int</span>(x+w/<span class="number">2</span>), <span class="built_in">int</span>(y+h/<span class="number">2</span>)), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)    <span class="comment"># 将苹果的图像中心点画出来</span></span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">"object"</span>, image)                            <span class="comment"># 使用OpenCV显示处理后的图像效果</span></span><br><span class="line">    cv2.waitKey(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):                                       <span class="comment"># ROS2节点主入口main函数</span></span><br><span class="line">    rclpy.init(args=args)                                  <span class="comment"># ROS2 Python接口初始化</span></span><br><span class="line">    node = Node(<span class="string">"node_object_webcam"</span>)                      <span class="comment"># 创建ROS2节点对象并进行初始化</span></span><br><span class="line">    node.get_logger().info(<span class="string">"ROS2节点示例：检测图片中的苹果"</span>)</span><br><span class="line"></span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> rclpy.ok():</span><br><span class="line">        ret, image = cap.read()          <span class="comment"># 读取一帧图像</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">            object_detect(image)         <span class="comment"># 苹果检测</span></span><br><span class="line"></span><br><span class="line">    node.destroy_node()                  <span class="comment"># 销毁节点对象</span></span><br><span class="line">    rclpy.shutdown()                     <span class="comment"># 关闭ROS2 Python接口</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="setuppy"><a class="markdownIt-Anchor" href="#setuppy"></a> <a href="http://setup.py">setup.py</a>——节点的入口</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry_points={</span><br><span class="line">    <span class="string">'console_scripts'</span>: [</span><br><span class="line">     <span class="string">'node_helloworld       = learning_node.node_helloworld:main'</span>,</span><br><span class="line">     <span class="string">'node_helloworld_class = learning_node.node_helloworld_class:main'</span>,</span><br><span class="line">     <span class="string">'node_object           = learning_node.node_object:main'</span>,</span><br><span class="line">     <span class="string">'node_object_webcam    = learning_node.node_object_webcam:main'</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="ros2话题的编写"><a class="markdownIt-Anchor" href="#ros2话题的编写"></a> ROS2话题的编写</h1><h2 id="发布者"><a class="markdownIt-Anchor" href="#发布者"></a> 发布者</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@作者: 古月居(www.guyuehome.com)</span></span><br><span class="line"><span class="string">@说明: ROS2话题示例-发布图像话题</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy                        <span class="comment"># ROS2 Python接口库</span></span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node         <span class="comment"># ROS2 节点类</span></span><br><span class="line"><span class="keyword">from</span> sensor_msgs.msg <span class="keyword">import</span> Image   <span class="comment"># 图像消息类型</span></span><br><span class="line"><span class="keyword">from</span> cv_bridge <span class="keyword">import</span> CvBridge      <span class="comment"># ROS与OpenCV图像转换类</span></span><br><span class="line"><span class="keyword">import</span> cv2                          <span class="comment"># Opencv图像处理库</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">创建一个发布者节点</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImagePublisher</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)                                           <span class="comment"># ROS2节点父类初始化</span></span><br><span class="line">        self.publisher_ = self.create_publisher(Image, <span class="string">'image_raw'</span>, <span class="number">10</span>)  <span class="comment"># 创建发布者对象（消息类型、话题名、队列长度）</span></span><br><span class="line">        self.timer = self.create_timer(<span class="number">0.1</span>, self.timer_callback)         <span class="comment"># 创建一个定时器（单位为秒的周期，定时执行的回调函数）</span></span><br><span class="line">        self.cap = cv2.VideoCapture(<span class="number">0</span>)                                   <span class="comment"># 创建一个视频采集对象，驱动相机采集图像（相机设备号）</span></span><br><span class="line">        self.cv_bridge = CvBridge()                                      <span class="comment"># 创建一个图像转换对象，用于稍后将OpenCV的图像转换成ROS的图像消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timer_callback</span>(<span class="params">self</span>):</span><br><span class="line">        ret, frame = self.cap.read()                         <span class="comment"># 一帧一帧读取图像</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret == <span class="literal">True</span>:                                      <span class="comment"># 如果图像读取成功</span></span><br><span class="line">            self.publisher_.publish(</span><br><span class="line">                self.cv_bridge.cv2_to_imgmsg(frame, <span class="string">'bgr8'</span>)) <span class="comment"># 发布图像消息</span></span><br><span class="line"></span><br><span class="line">        self.get_logger().info(<span class="string">'Publishing video frame'</span>)     <span class="comment"># 输出日志信息，提示已经完成图像话题发布</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):                                 <span class="comment"># ROS2节点主入口main函数</span></span><br><span class="line">    rclpy.init(args=args)                            <span class="comment"># ROS2 Python接口初始化</span></span><br><span class="line">    node = ImagePublisher(<span class="string">"topic_webcam_pub"</span>)        <span class="comment"># 创建ROS2节点对象并进行初始化</span></span><br><span class="line">    rclpy.spin(node)                                 <span class="comment"># 循环等待ROS2退出</span></span><br><span class="line">    node.destroy_node()                              <span class="comment"># 销毁节点对象</span></span><br><span class="line">    rclpy.shutdown()                                 <span class="comment"># 关闭ROS2 Python接口</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="订阅者"><a class="markdownIt-Anchor" href="#订阅者"></a> 订阅者</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@作者: 古月居(www.guyuehome.com)</span></span><br><span class="line"><span class="string">@说明: ROS2话题示例-订阅图像话题</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy                            <span class="comment"># ROS2 Python接口库</span></span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node             <span class="comment"># ROS2 节点类</span></span><br><span class="line"><span class="keyword">from</span> sensor_msgs.msg <span class="keyword">import</span> Image       <span class="comment"># 图像消息类型</span></span><br><span class="line"><span class="keyword">from</span> cv_bridge <span class="keyword">import</span> CvBridge          <span class="comment"># ROS与OpenCV图像转换类</span></span><br><span class="line"><span class="keyword">import</span> cv2                              <span class="comment"># Opencv图像处理库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np                      <span class="comment"># Python数值计算库</span></span><br><span class="line"></span><br><span class="line">lower_red = np.array([<span class="number">0</span>, <span class="number">90</span>, <span class="number">128</span>])      <span class="comment"># 红色的HSV阈值下限</span></span><br><span class="line">upper_red = np.array([<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>])   <span class="comment"># 红色的HSV阈值上限</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">创建一个订阅者节点</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageSubscriber</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)                                <span class="comment"># ROS2节点父类初始化</span></span><br><span class="line">        self.sub = self.create_subscription(</span><br><span class="line">            Image, <span class="string">'image_raw'</span>, self.listener_callback, <span class="number">10</span>)   <span class="comment"># 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度）</span></span><br><span class="line">        self.cv_bridge = CvBridge()                           <span class="comment"># 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">object_detect</span>(<span class="params">self, image</span>):</span><br><span class="line">        hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)      <span class="comment"># 图像从BGR颜色模型转换为HSV模型</span></span><br><span class="line">        mask_red = cv2.inRange(hsv_img, lower_red, upper_red) <span class="comment"># 图像二值化</span></span><br><span class="line">        contours, hierarchy = cv2.findContours(</span><br><span class="line">            mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)   <span class="comment"># 图像中轮廓检测</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:                                  <span class="comment"># 去除一些轮廓面积太小的噪声</span></span><br><span class="line">            <span class="keyword">if</span> cnt.shape[<span class="number">0</span>] &lt; <span class="number">150</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            (x, y, w, h) = cv2.boundingRect(cnt)              <span class="comment"># 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高</span></span><br><span class="line">            cv2.drawContours(image, [cnt], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)<span class="comment"># 将苹果的轮廓勾勒出来</span></span><br><span class="line">            cv2.circle(image, (<span class="built_in">int</span>(x+w/<span class="number">2</span>), <span class="built_in">int</span>(y+h/<span class="number">2</span>)), <span class="number">5</span>,</span><br><span class="line">                       (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)                       <span class="comment"># 将苹果的图像中心点画出来</span></span><br><span class="line"></span><br><span class="line">        cv2.imshow(<span class="string">"object"</span>, image)                           <span class="comment"># 使用OpenCV显示处理后的图像效果</span></span><br><span class="line">        cv2.waitKey(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">listener_callback</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.get_logger().info(<span class="string">'Receiving video frame'</span>)     <span class="comment"># 输出日志信息，提示已进入回调函数</span></span><br><span class="line">        image = self.cv_bridge.imgmsg_to_cv2(data, <span class="string">'bgr8'</span>)  <span class="comment"># 将ROS的图像消息转化成OpenCV图像</span></span><br><span class="line">        self.object_detect(image)                           <span class="comment"># 苹果检测</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):                            <span class="comment"># ROS2节点主入口main函数</span></span><br><span class="line">    rclpy.init(args=args)                       <span class="comment"># ROS2 Python接口初始化</span></span><br><span class="line">    node = ImageSubscriber(<span class="string">"topic_webcam_sub"</span>)  <span class="comment"># 创建ROS2节点对象并进行初始化</span></span><br><span class="line">    rclpy.spin(node)                            <span class="comment"># 循环等待ROS2退出</span></span><br><span class="line">    node.destroy_node()                         <span class="comment"># 销毁节点对象</span></span><br><span class="line">    rclpy.shutdown()                            <span class="comment"># 关闭ROS2 Python接口</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>话题通信是异步单工通信，适合周期性发布逻辑固定的信息</p></blockquote><blockquote><p>在ROS系统中，话题通信数据的描述格式称之为消息，对应编程语言中数据结构的概念</p></blockquote><h2 id="话题的命令行操作"><a class="markdownIt-Anchor" href="#话题的命令行操作"></a> 话题的命令行操作</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic <span class="built_in">list</span>                <span class="comment"># 查看话题列表</span></span><br><span class="line">ros2 topic info &lt;topic_name&gt;   <span class="comment"># 查看话题信息</span></span><br><span class="line">ros2 topic hz &lt;topic_name&gt;     <span class="comment"># 查看话题发布频率</span></span><br><span class="line">ros2 topic bw &lt;topic_name&gt;     <span class="comment"># 查看话题传输带宽</span></span><br><span class="line">ros2 topic echo &lt;topic_name&gt;   <span class="comment"># 查看话题数据</span></span><br><span class="line">ros2 topic pub &lt;topic_name&gt; &lt;msg_type&gt; &lt;msg_data&gt;   <span class="comment"># 发布话题消息</span></span><br></pre></td></tr></tbody></table></figure><h2 id="虚拟机配置与开发机通信"><a class="markdownIt-Anchor" href="#虚拟机配置与开发机通信"></a> 虚拟机配置与开发机通信</h2><blockquote><p>虚拟器配置为桥接模式，且虚拟网络设置要配置与本机的有线网卡一置</p></blockquote><blockquote><p>Ubuntu22.04 使用 ip addr查看网络地址，或者ip a</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Opencv】[1]图像处理基本概念</title>
      <link href="/posts/51713/"/>
      <url>/posts/51713/</url>
      
        <content type="html"><![CDATA[<h1 id="opencv常见基本概念"><a class="markdownIt-Anchor" href="#opencv常见基本概念"></a> Opencv常见基本概念</h1><hr><h1 id="一-opencv常见基本概念"><a class="markdownIt-Anchor" href="#一-opencv常见基本概念"></a> 一、Opencv常见基本概念</h1><h2 id="1bgr和rgb格式"><a class="markdownIt-Anchor" href="#1bgr和rgb格式"></a> 1.BGR和RGB格式</h2><blockquote><ul><li><p>BGR和RGB是两种常见的颜色编码格式，它们在像素颜色排列的顺序上有所不同：</p><ol><li><strong>RGB格式</strong>：<ul><li>RGB指的是红色（R）、绿色（G）、蓝色（B）三个颜色通道的顺序。</li><li>在RGB格式中，像素的颜色值按照红、绿、蓝的顺序排列，即最开始的三个字节依次表示红色、绿色和蓝色分量。</li></ul></li><li><strong>BGR格式</strong>：<ul><li>BGR则是蓝色（B）、绿色（G）、红色（R）的顺序。</li><li>在BGR格式中，像素的颜色值按照蓝、绿、红的顺序排列，即最开始的三个字节依次表示蓝色、绿色和红色分量。</li></ul></li></ol><p>这两种格式主要在图像处理中有所区别。例如，<mark>在OpenCV中，默认情况下读取的图像格式是BGR而非RGB</mark>，这意味着你在处理图像数据时需要注意颜色通道的顺序。如果需要与其他软件或标准的RGB格式进行交互，通常需要进行颜色通道的重新排列。</p><p>总结：</p><ul><li><strong>RGB</strong>：红色、绿色、蓝色，像素颜色排列顺序是RGB。</li><li><strong>BGR</strong>：蓝色、绿色、红色，像素颜色排列顺序是BGR。</li></ul></li></ul></blockquote><h2 id="2常用函数库和视觉处理方法"><a class="markdownIt-Anchor" href="#2常用函数库和视觉处理方法"></a> 2.常用函数库和视觉处理方法</h2><h3 id="摄像头的开启"><a class="markdownIt-Anchor" href="#摄像头的开启"></a> 摄像头的开启</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#摄像头类创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pi_Camera</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 图像初始化配置</span></span><br><span class="line">        self.Video = cv2.VideoCapture(<span class="number">8</span>, cv2.CAP_V4L2) <span class="comment"># 使能摄像头8的驱动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查摄像头是否打开</span></span><br><span class="line">        ret = self.Video.isOpened()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The video is opened."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"No video."</span>)</span><br><span class="line">    </span><br><span class="line">        codec = cv2.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>)</span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FOURCC, codec)</span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FPS, <span class="number">60</span>)  <span class="comment"># 帧数</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">640</span>)  <span class="comment"># 列 宽度</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>)  <span class="comment"># 行 高度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GuideLine</span>(<span class="params">self, c1, c2</span>):</span><br><span class="line">        ret, image = self.Video.read()<span class="comment">#注意：read返回一个bull值和图像数据list！，需要用两个变量获取</span></span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">360</span>), (<span class="number">640</span>, <span class="number">360</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)  <span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">240</span>), (<span class="number">640</span>, <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)  <span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="built_in">int</span>(c1), <span class="number">360</span>), (<span class="built_in">int</span>(c2), <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">2</span>)  <span class="comment"># 绘出倾角线</span></span><br><span class="line">            cv2.imshow(<span class="string">"GuideLine"</span>, image)</span><br></pre></td></tr></tbody></table></figure><p><strong>异常的处理：</strong><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017598873256736">错误处理 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p><strong>ret的作用：</strong></p><p>​通常是一个函数返回值的缩写，在opencv中经常用来读取函数的布尔值，判断摄像是否打开、头图像是否读取成功等，防止后续处理空值报错</p><p><strong>摄像头的驱动：</strong></p><ul><li><pre class="highlight"><code class="python">self.Video = cv2.VideoCapture(<span class="hljs-number">8</span>, cv2.CAP_V4L2)&lt;!--code￼<span class="hljs-number">1</span>--&gt;</code></pre></li></ul><h1 id="三-opencv实现色块识别"><a class="markdownIt-Anchor" href="#三-opencv实现色块识别"></a> 三、Opencv实现色块识别</h1><h1 id="rdk-x3-开发体验"><a class="markdownIt-Anchor" href="#rdk-x3-开发体验"></a> #RDK X3 开发体验</h1><p>题主目前初学Python,OpenCV,Ros2, 且对深度学习，图像处理等知识存在相当大的欠缺，基本参考RDK X3的官方手册学习，不得不说，RDK X3的官方镜像，社区生态支持做的都相当便捷，嵌入式边缘计算设备方面领域能做到对初学者如此友好的仅此一家。</p><blockquote><p>sudo bash -c ‘echo 1 &gt; /sys/devices/system/cpu/cpufreq/boost’</p></blockquote><blockquote><p>可通过<code>sudo hrut_somstatus</code>命令查看当前芯片工作频率、温度等状态：</p></blockquote><blockquote><p>供电不稳定导致X3无法正常启动，或者程序执行过程中摄像头无法正常驱动</p></blockquote><blockquote><p>驱动USB摄像头时应该确定设备号，使用<code>ls /dev/video*</code>命令查看当前的video设备</p></blockquote><blockquote><p>使用 rc.local 可以便捷配置开机自启动脚本</p></blockquote><blockquote><p>使用ros2或者tros命令应配置好环境变量</p></blockquote><blockquote><p>烧录镜像应选择稳定版本，比如 2.10 ，3.0.0beta存在一些小毛病（VNC无法正常使用）</p></blockquote><blockquote><p>vscode remote无法获得opencv imshow的图像，使用MobaXterm则正常显示X3的摄像头图像</p></blockquote><h1 id="rdk-x3多媒体"><a class="markdownIt-Anchor" href="#rdk-x3多媒体"></a> RDK X3多媒体</h1><h2 id="术语约定httpsdeveloperhorizonccdocuments_rdkmultimedia_developmentoverviewterminology"><a class="markdownIt-Anchor" href="#术语约定httpsdeveloperhorizonccdocuments_rdkmultimedia_developmentoverviewterminology"></a> 术语约定(<a href="https://developer.horizon.cc/documents_rdk/multimedia_development/overview#terminology">https://developer.horizon.cc/documents_rdk/multimedia_development/overview#terminology</a>)</h2><table><thead><tr><th>缩写</th><th>全称</th><th>解释</th></tr></thead><tbody><tr><td>VIN</td><td>Video IN</td><td>包含视频处理接入、图像信号处理器、畸变矫正和防抖处理，接收来自sensor的数据并处理，也可以直接接收内存中的图像数据</td></tr><tr><td>VPS</td><td>Video Process System</td><td>包含图像旋转、图像裁剪、缩放功能，可对同一种输入源输出不同分辨率的图像。输入源可以是VIN模块，也可以是内存中的图像数据</td></tr><tr><td>VENC</td><td>Video Encode</td><td>VENC编码模块支持H.264/H.265/JPEG/MJPEG编码，VPS模块处理后的数据可通过编码模块按不同协议编码做码流输出</td></tr><tr><td>VDEC</td><td>Video Decode</td><td>VDEC解码模块支持H.264/H.265/JPEG/MJPEG解码，可对已编码的码流进行解码，交给VPS模块做进一步处理，输出到VOT模块进行显示</td></tr><tr><td>VPU</td><td>Video Processing Unit</td><td>视频处理单元，完成视频的编解码功能</td></tr><tr><td>JPU</td><td>JPEG Processing Unit</td><td>JPEG 图片处理单元，完成JPEG、MJPEG的编解码功能</td></tr><tr><td>VOT</td><td>Video Output</td><td>视频输出模块接收VPS、VDEC的图像数据，可输出到显示设备</td></tr><tr><td>VIO</td><td>Video IN/OUT</td><td>视频输入、输出，包括VIN和VOT模块</td></tr><tr><td>MIPI</td><td>Mobile Industry Processor Interface</td><td>移动产业处理器接口</td></tr><tr><td>CSI</td><td>Camera Serial Interface</td><td>相机串行接口。CSI接口与DSI接口同属一门，都是MIPI（移动产业处理器接口联盟）制定的一种接口规范</td></tr><tr><td>DVP</td><td>Digital Video Port</td><td>数字视频端口</td></tr><tr><td>SIF</td><td>Sensor Interface</td><td>sensor接口，用来接收mipi、dvp或者内存的图像数据</td></tr><tr><td>ISP</td><td>Image Signal Processor</td><td>图像信号处理器，完成图像的效果调校</td></tr><tr><td>LDC</td><td>Lens Distortion Correction</td><td>镜头畸变校正</td></tr><tr><td>DIS</td><td>Digital Image Stabilizer</td><td>数字图像稳定</td></tr><tr><td>DWE</td><td>Dewarp Engine</td><td>畸变矫正引擎，主要是将LDC和DIS集成在一起，包括LDC的畸变矫正和DIS的统计结果</td></tr><tr><td>IPU</td><td>Image Process Unit</td><td>图像信号处理单元，支持图像的旋转、图像裁剪、缩放功能</td></tr><tr><td>GDC</td><td>Geometrical Distortion Correction</td><td>几何畸变矫正</td></tr><tr><td>PYM</td><td>Pyramid</td><td>图像金字塔</td></tr><tr><td>OSD</td><td>On Screen Display</td><td>视频图像叠层显示</td></tr><tr><td>BPU</td><td>Brain Process Unit</td><td>地平线机器人自主研发的可编程AI加速引擎</td></tr><tr><td>HAL</td><td>Hardware Abstraction Layer</td><td>硬件抽象层</td></tr><tr><td>FW</td><td>Firmware</td><td>固件</td></tr><tr><td>Sensor</td><td>Sensor</td><td>如不做特别说明，特指CMOS图像传感器</td></tr></tbody></table><h1 id="usb推理函数解释"><a class="markdownIt-Anchor" href="#usb推理函数解释"></a> USB推理函数解释</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> hobot_dnn <span class="keyword">import</span> pyeasy_dnn <span class="keyword">as</span> dnn</span><br><span class="line"><span class="keyword">from</span> hobot_vio <span class="keyword">import</span> libsrcampy <span class="keyword">as</span> srcampy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> json </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_handler</span>(<span class="params">signal, frame</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nExiting program"</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">output_tensors = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">fcos_postprocess_info = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbSysMem_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"phyAddr"</span>,ctypes.c_double),</span><br><span class="line">        (<span class="string">"virAddr"</span>,ctypes.c_void_p),</span><br><span class="line">        (<span class="string">"memSize"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNQuantiShift_yt</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"shiftLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"shiftData"</span>,ctypes.c_char_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNQuantiScale_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"scaleLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"scaleData"</span>,ctypes.POINTER(ctypes.c_float)),</span><br><span class="line">        (<span class="string">"zeroPointLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"zeroPointData"</span>,ctypes.c_char_p)</span><br><span class="line">    ]    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensorShape_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"dimensionSize"</span>,ctypes.c_int * <span class="number">8</span>),</span><br><span class="line">        (<span class="string">"numDimensions"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensorProperties_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"validShape"</span>,hbDNNTensorShape_t),</span><br><span class="line">        (<span class="string">"alignedShape"</span>,hbDNNTensorShape_t),</span><br><span class="line">        (<span class="string">"tensorLayout"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"tensorType"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"shift"</span>,hbDNNQuantiShift_yt),</span><br><span class="line">        (<span class="string">"scale"</span>,hbDNNQuantiScale_t),</span><br><span class="line">        (<span class="string">"quantiType"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"quantizeAxis"</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">"alignedByteSize"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"stride"</span>,ctypes.c_int * <span class="number">8</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensor_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"sysMem"</span>,hbSysMem_t * <span class="number">4</span>),</span><br><span class="line">        (<span class="string">"properties"</span>,hbDNNTensorProperties_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FcosPostProcessInfo_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"height"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"width"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"ori_height"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"ori_width"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"score_threshold"</span>,ctypes.c_float),</span><br><span class="line">        (<span class="string">"nms_threshold"</span>,ctypes.c_float),</span><br><span class="line">        (<span class="string">"nms_top_k"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"is_pad_resize"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libpostprocess = ctypes.CDLL(<span class="string">'/usr/lib/libpostprocess.so'</span>) </span><br><span class="line"></span><br><span class="line">get_Postprocess_result = libpostprocess.FcosPostProcess</span><br><span class="line">get_Postprocess_result.argtypes = [ctypes.POINTER(FcosPostProcessInfo_t)]  </span><br><span class="line">get_Postprocess_result.restype = ctypes.c_char_p  </span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_bboxs</span>(<span class="params">image, bboxes, classes=get_classes(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="string">"""draw the bboxes in the original image"""</span></span><br><span class="line">    <span class="comment"># 获取类别数量</span></span><br><span class="line">    num_classes = <span class="built_in">len</span>(classes)</span><br><span class="line">    <span class="comment"># 获取图像的高度、宽度和通道数</span></span><br><span class="line">    image_h, image_w, channel = image.shape</span><br><span class="line">    <span class="comment"># 生成颜色列表，每个类别一个颜色</span></span><br><span class="line">    hsv_tuples = [(<span class="number">1.0</span> * x / num_classes, <span class="number">1.</span>, <span class="number">1.</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(num_classes)]</span><br><span class="line">    colors = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: colorsys.hsv_to_rgb(*x), hsv_tuples))</span><br><span class="line">    <span class="comment"># 将颜色值转换为0-255范围内的RGB值</span></span><br><span class="line">    colors = <span class="built_in">list</span>(</span><br><span class="line">        <span class="built_in">map</span>(<span class="keyword">lambda</span> x: (<span class="built_in">int</span>(x[<span class="number">0</span>] * <span class="number">255</span>), <span class="built_in">int</span>(x[<span class="number">1</span>] * <span class="number">255</span>), <span class="built_in">int</span>(x[<span class="number">2</span>] * <span class="number">255</span>)),</span><br><span class="line">            colors))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置字体缩放比例</span></span><br><span class="line">    fontScale = <span class="number">0.5</span></span><br><span class="line">    <span class="comment"># 设置矩形框的厚度</span></span><br><span class="line">    bbox_thick = <span class="built_in">int</span>(<span class="number">0.6</span> * (image_h + image_w) / <span class="number">600</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每个检测结果</span></span><br><span class="line">    <span class="keyword">for</span> i, result <span class="keyword">in</span> <span class="built_in">enumerate</span>(bboxes):</span><br><span class="line">        <span class="comment"># 获取矩形框的位置信息</span></span><br><span class="line">        bbox = result[<span class="string">'bbox'</span>]</span><br><span class="line">        <span class="comment"># 获取检测分数</span></span><br><span class="line">        score = result[<span class="string">'score'</span>]</span><br><span class="line">        <span class="comment"># 获取类别ID</span></span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">int</span>(result[<span class="string">'id'</span>])</span><br><span class="line">        <span class="comment"># 获取类别名称</span></span><br><span class="line">        name = result[<span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将位置信息四舍五入为整数</span></span><br><span class="line">        coor = [<span class="built_in">round</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> bbox]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据类别ID获取对应的颜色</span></span><br><span class="line">        bbox_color = colors[<span class="built_in">id</span>]</span><br><span class="line">        <span class="comment"># 矩形框的两个顶点坐标</span></span><br><span class="line">        c1, c2 = (coor[<span class="number">0</span>], coor[<span class="number">1</span>]), (coor[<span class="number">2</span>], coor[<span class="number">3</span>])</span><br><span class="line">        <span class="comment"># 画矩形框</span></span><br><span class="line">        cv2.rectangle(image, c1, c2, bbox_color, bbox_thick)</span><br><span class="line">        <span class="comment"># 类别名称</span></span><br><span class="line">        classes_name = name</span><br><span class="line">        <span class="comment"># 矩形框内显示的文字</span></span><br><span class="line">        bbox_mess = <span class="string">'%s: %.2f'</span> % (classes_name, score)</span><br><span class="line">        <span class="comment"># 获取文字尺寸</span></span><br><span class="line">        t_size = cv2.getTextSize(bbox_mess,</span><br><span class="line">                                 <span class="number">0</span>,</span><br><span class="line">                                 fontScale,</span><br><span class="line">                                 thickness=bbox_thick // <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 画矩形框的填充部分，用于显示文字背景</span></span><br><span class="line">        cv2.rectangle(image, c1, (c1[<span class="number">0</span>] + t_size[<span class="number">0</span>], c1[<span class="number">1</span>] - t_size[<span class="number">1</span>] - <span class="number">3</span>),</span><br><span class="line">                      bbox_color, -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 在图像上显示文字</span></span><br><span class="line">        cv2.putText(image,</span><br><span class="line">                    bbox_mess, (c1[<span class="number">0</span>], c1[<span class="number">1</span>] - <span class="number">2</span>),</span><br><span class="line">                    cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">                    fontScale, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                    bbox_thick // <span class="number">2</span>,</span><br><span class="line">                    lineType=cv2.LINE_AA)</span><br><span class="line">        <span class="comment"># 打印检测结果</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"{} is in the picture with confidence:{:.4f}"</span>.<span class="built_in">format</span>(</span><br><span class="line">            classes_name, score))</span><br><span class="line">    <span class="comment"># 返回绘制了矩形框和文字的图像</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_display_res</span>():</span><br><span class="line">    <span class="comment"># 检查指定路径下的可执行文件是否存在，如果不存在则返回默认分辨率 1920x1080</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">"/usr/bin/get_hdmi_res"</span>) == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1920</span>, <span class="number">1080</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> subprocess</span><br><span class="line">    <span class="comment"># 使用子进程运行 get_hdmi_res 命令，获取输出</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"/usr/bin/get_hdmi_res"</span>], stdout=subprocess.PIPE)</span><br><span class="line">    result = p.communicate()</span><br><span class="line">    <span class="comment"># 将结果按逗号分割</span></span><br><span class="line">    res = result[<span class="number">0</span>].split(<span class="string">b','</span>)</span><br><span class="line">    <span class="comment"># 确保宽度和高度在合理范围内</span></span><br><span class="line">    res[<span class="number">1</span>] = <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(res[<span class="number">1</span>]), <span class="number">1920</span>), <span class="number">0</span>)</span><br><span class="line">    res[<span class="number">0</span>] = <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(res[<span class="number">0</span>]), <span class="number">1080</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(res[<span class="number">1</span>]), <span class="built_in">int</span>(res[<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get HDMI display object</span></span><br><span class="line">disp = srcampy.Display()</span><br><span class="line"><span class="comment"># For the meaning of parameters, please refer to the relevant documents of HDMI display</span></span><br><span class="line">disp_w, disp_h = get_display_res()</span><br><span class="line">disp.display(<span class="number">0</span>, disp_w, disp_h) <span class="comment"># 显示模块初始化，并配置显示参数</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 FcosPostProcessInfo_t 对象</span></span><br><span class="line">fcos_postprocess_info = FcosPostProcessInfo_t()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标图像的高度和宽度</span></span><br><span class="line">fcos_postprocess_info.height = <span class="number">512</span></span><br><span class="line">fcos_postprocess_info.width = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置原始图像的高度和宽度</span></span><br><span class="line">fcos_postprocess_info.ori_height = disp_h</span><br><span class="line">fcos_postprocess_info.ori_width = disp_w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置分数阈值，用于过滤低置信度的检测框</span></span><br><span class="line">fcos_postprocess_info.score_threshold = <span class="number">0.5</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置非极大值抑制（NMS）的阈值，用于合并重叠的检测框</span></span><br><span class="line">fcos_postprocess_info.nms_threshold = <span class="number">0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 NMS 阶段保留的检测框数量上限</span></span><br><span class="line">fcos_postprocess_info.nms_top_k = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定是否在图像调整大小时使用填充</span></span><br><span class="line">fcos_postprocess_info.is_pad_resize = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(models[<span class="number">0</span>].outputs)):</span><br><span class="line">    <span class="comment"># 设置每个输出张量的布局属性</span></span><br><span class="line">    output_tensors[i].properties.tensorLayout = get_TensorLayout(models[<span class="number">0</span>].outputs[i].properties.layout)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查输出张量的 scale_data 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(models[<span class="number">0</span>].outputs[i].properties.scale_data) == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 如果 scale_data 为空，设置量化类型为 0</span></span><br><span class="line">        output_tensors[i].properties.quantiType = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果 scale_data 不为空，设置量化类型为 2</span></span><br><span class="line">        output_tensors[i].properties.quantiType = <span class="number">2</span>  </span><br><span class="line">        <span class="comment"># 将 scale_data 重新调整形状</span></span><br><span class="line">        scale_data_tmp = models[<span class="number">0</span>].outputs[i].properties.scale_data.reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, models[<span class="number">0</span>].outputs[i].properties.shape[<span class="number">3</span>])  </span><br><span class="line">        <span class="comment"># 将 scale_data 转换为指向浮点数的指针</span></span><br><span class="line">        output_tensors[i].properties.scale.scaleData = scale_data_tmp.ctypes.data_as(ctypes.POINTER(ctypes.c_float))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置每个输出张量的有效形状和对齐形状</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(models[<span class="number">0</span>].outputs[i].properties.shape)):</span><br><span class="line">        output_tensors[i].properties.validShape.dimensionSize[j] = models[<span class="number">0</span>].outputs[i].properties.shape[j]</span><br><span class="line">        output_tensors[i].properties.alignedShape.dimensionSize[j] = models[<span class="number">0</span>].outputs[i].properties.shape[j]</span><br></pre></td></tr></tbody></table></figure><h2 id="主循环"><a class="markdownIt-Anchor" href="#主循环"></a> 主循环</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        _ ,frame = cap.read()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(frame.shape)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Failed to get image from usb camera"</span>)</span><br><span class="line">        <span class="comment"># 把图片缩放到模型的输入尺寸</span></span><br><span class="line">        <span class="comment"># 获取算法模型的输入tensor 的尺寸</span></span><br><span class="line">        h, w = models[<span class="number">0</span>].inputs[<span class="number">0</span>].properties.shape[<span class="number">2</span>], models[<span class="number">0</span>].inputs[<span class="number">0</span>].properties.shape[<span class="number">3</span>]</span><br><span class="line">        des_dim = (w, h)</span><br><span class="line">        resized_data = cv2.resize(frame, des_dim, interpolation=cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line">        nv12_data = bgr2nv12_opencv(resized_data)</span><br><span class="line"></span><br><span class="line">        t0 = time()</span><br><span class="line">        <span class="comment"># Forward</span></span><br><span class="line">        outputs = models[<span class="number">0</span>].forward(nv12_data)</span><br><span class="line">        t1 = time()</span><br><span class="line">        <span class="comment"># print("forward time is :", (t1 - t0))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Do post process</span></span><br><span class="line">        strides = [<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strides)):</span><br><span class="line">            <span class="keyword">if</span> (output_tensors[i].properties.quantiType == <span class="number">0</span>):</span><br><span class="line">                output_tensors[i].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">5</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">5</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">10</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">10</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">            <span class="keyword">else</span>:      </span><br><span class="line">                output_tensors[i].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">5</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">5</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">10</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">10</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line"></span><br><span class="line">            libpostprocess.FcosdoProcess(output_tensors[i], output_tensors[i + <span class="number">5</span>], output_tensors[i + <span class="number">10</span>], ctypes.pointer(fcos_postprocess_info), i)</span><br><span class="line"></span><br><span class="line">        result_str = get_Postprocess_result(ctypes.pointer(fcos_postprocess_info))  </span><br><span class="line">        result_str = result_str.decode(<span class="string">'utf-8'</span>)  </span><br><span class="line">        t2 = time()</span><br><span class="line">        <span class="comment"># print("FcosdoProcess time is :", (t2 - t1))</span></span><br><span class="line">        <span class="comment"># print(result_str)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># draw result</span></span><br><span class="line">        <span class="comment"># 解析JSON字符串  </span></span><br><span class="line">        data = json.loads(result_str[<span class="number">14</span>:])  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frame.shape[<span class="number">0</span>]!=disp_h <span class="keyword">or</span> frame.shape[<span class="number">1</span>]!=disp_w:</span><br><span class="line">            frame = cv2.resize(frame, (disp_w,disp_h), interpolation=cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Draw bboxs</span></span><br><span class="line">        box_bgr = draw_bboxs(frame, data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># cv2.imwrite("imf.jpg", box_bgr)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Convert to nv12 for HDMI display</span></span><br><span class="line">        box_nv12 = bgr2nv12_opencv(box_bgr)</span><br><span class="line">        disp.set_img(box_nv12.tobytes())</span><br><span class="line"></span><br><span class="line">        finish_time = time()</span><br><span class="line">        image_counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> finish_time - start_time &gt;  <span class="number">10</span>:</span><br><span class="line">            <span class="built_in">print</span>(start_time, finish_time, image_counter)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"FPS: {:.2f}"</span>.<span class="built_in">format</span>(image_counter / (finish_time - start_time)))</span><br><span class="line">            start_time = finish_time</span><br><span class="line">            image_counter = <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记,计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS2】[1]ROS2基本概念</title>
      <link href="/posts/45607/"/>
      <url>/posts/45607/</url>
      
        <content type="html"><![CDATA[<h1 id="ros2上手体验"><a class="markdownIt-Anchor" href="#ros2上手体验"></a> ROS2上手体验</h1><p>ros2环境的配置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/humble/setup.bash #添加环境变量，需要每次启动终端使用此命令，比较繁琐</span><br><span class="line">echo " source /opt/ros/humble/setup.bash" &gt;&gt; ~/.bashrc #将添加环境变量的命令添加到脚本，开启终端自启动，无需反复source</span><br></pre></td></tr></tbody></table></figure><p>发布者节点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run demo_nodes_cpp talker </span><br></pre></td></tr></tbody></table></figure><p>订阅者节点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run demo_nodes_py listener</span><br></pre></td></tr></tbody></table></figure><p>node</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node</span><br></pre></td></tr></tbody></table></figure><h1 id="linuxros2命令行操作"><a class="markdownIt-Anchor" href="#linuxros2命令行操作"></a> Linux/Ros2命令行操作</h1><p>Linux的命令庞大，但基本掌握常用的一些基础命令即可</p><p>获取当前终端操作的目录位置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></tbody></table></figure><p>列举当前目录显示的文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></tbody></table></figure><p>列举当前目录（包括被隐藏的）文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -A</span><br></pre></td></tr></tbody></table></figure><p>新建文件夹</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br></pre></td></tr></tbody></table></figure><p>修改当前终端路径</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd test/</span><br></pre></td></tr></tbody></table></figure><p>效果：</p><img src="/posts/45607/image-20240706002347136.png" class="" title="image-20240706002347136"><p>在当前路径新建文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch read.txt</span><br></pre></td></tr></tbody></table></figure><p>在当前路径删除文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm read.txt</span><br></pre></td></tr></tbody></table></figure><p>删除文件夹</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -R test/ #-R表示递归删除</span><br></pre></td></tr></tbody></table></figure><p>安装软件包</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libopencv(自动补全)# sudo表示提升当前使用者权限为管理员,apt表示应用,install表示安装,安装opencv</span><br></pre></td></tr></tbody></table></figure><h2 id="ros2相关"><a class="markdownIt-Anchor" href="#ros2相关"></a> ros2相关</h2><p>将正在运行的节点进行打印</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node list </span><br></pre></td></tr></tbody></table></figure><p>查看节点正在运行的信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node info /节点名</span><br></pre></td></tr></tbody></table></figure><p>查看节点的基本数据/参数</p><p>以查看话题为例，查看哪些话题正在发布和订阅</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></tbody></table></figure><p>对话题进行订阅并打印</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic echo /turtlel/pose</span><br></pre></td></tr></tbody></table></figure><p>使用topic 进行pub，发布一个消息，和run一样可以控制“海龟”进行运动</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}" </span><br><span class="line"># --rate 1:频率1HZ</span><br><span class="line"># /turtle1/cmd_vel geometry_msgs/msg/Twist</span><br><span class="line"># linear:线速度</span><br><span class="line"># angular:角速度</span><br></pre></td></tr></tbody></table></figure><p>使用“服务”，产生新的机器人</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: 'abb'}"</span><br><span class="line"></span><br><span class="line">#使用ros2 topic list查看是否产生新的接口：</span><br><span class="line">turin@turin-virtual-machine:~/Desktop$ ros2 topic list</span><br><span class="line">/abb/cmd_vel</span><br><span class="line">/abb/color_sensor</span><br><span class="line">/abb/pose</span><br><span class="line">/parameter_events</span><br><span class="line">/rosout</span><br><span class="line">/turtle1/cmd_vel</span><br><span class="line">/turtle1/color_sensor</span><br><span class="line">/turtle1/pose</span><br></pre></td></tr></tbody></table></figure><p>总结：话题是机器人控制的<mark>接口</mark>,接口的名称不同，控制的对象不同</p><p>录制机器人的运动过程(录制)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 bag record /turtle/cmd_vel</span><br></pre></td></tr></tbody></table></figure><h1 id="节点"><a class="markdownIt-Anchor" href="#节点"></a> 节点</h1><p><a href="http://setup.py">setup.py</a></p><p>配置ros2程序执行的入口</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">package_name = <span class="string">'learning_node'</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=package_name,</span><br><span class="line">    version=<span class="string">'0.0.0'</span>,</span><br><span class="line">    packages=[package_name],</span><br><span class="line">    data_files=[</span><br><span class="line">        (<span class="string">'share/ament_index/resource_index/packages'</span>,</span><br><span class="line">            [<span class="string">'resource/'</span> + package_name]),</span><br><span class="line">        (<span class="string">'share/'</span> + package_name, [<span class="string">'package.xml'</span>]),</span><br><span class="line">    ],</span><br><span class="line">    install_requires=[<span class="string">'setuptools'</span>],</span><br><span class="line">    zip_safe=<span class="literal">True</span>,</span><br><span class="line">    maintainer=<span class="string">'Hu Chunxu'</span>,</span><br><span class="line">    maintainer_email=<span class="string">'huchunxu@guyuehome.com'</span>,</span><br><span class="line">    description=<span class="string">'TODO: Package description'</span>,</span><br><span class="line">    license=<span class="string">'TODO: License declaration'</span>,</span><br><span class="line">    tests_require=[<span class="string">'pytest'</span>],</span><br><span class="line">    entry_points={</span><br><span class="line">        <span class="string">'console_scripts'</span>: [</span><br><span class="line">         <span class="string">'node_helloworld       = learning_node.node_helloworld:main'</span>, <span class="comment">#节点的配置信息,配置完成后就可以用ros2 run运行</span></span><br><span class="line">         <span class="string">'node_helloworld_class = learning_node.node_helloworld_class:main'</span>,</span><br><span class="line">         <span class="string">'node_object            = learning_node.node_object:main'</span>,</span><br><span class="line">         <span class="string">'node_object_webcam     = learning_node.node_object_webcam:main'</span>,</span><br><span class="line">        ],</span><br><span class="line">    },</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p><strong>面向过程编程</strong></p><img src="/posts/45607/image-20240706230802271.png" class="" title="image-20240706230802271"><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@作者: 古月居(www.guyuehome.com)</span></span><br><span class="line"><span class="string">@说明: ROS2节点示例-发布“Hello World”日志信息, 使用面向对象的实现方式</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy                                     <span class="comment"># ROS2 Python接口库</span></span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node                      <span class="comment"># ROS2 节点类</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">创建一个HelloWorld节点, 初始化时输出“hello world”日志</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorldNode</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)                       <span class="comment"># ROS2节点父类初始化</span></span><br><span class="line">        <span class="keyword">while</span> rclpy.ok():                            <span class="comment"># ROS2系统是否正常运行</span></span><br><span class="line">            self.get_logger().info(<span class="string">"Hello World"</span>)    <span class="comment"># ROS2日志输出</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)                          <span class="comment"># 休眠控制循环时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):                                 <span class="comment"># ROS2节点主入口main函数</span></span><br><span class="line">    rclpy.init(args=args)                            <span class="comment"># ROS2 Python接口初始化</span></span><br><span class="line">    node = HelloWorldNode(<span class="string">"node_helloworld_class"</span>)   <span class="comment"># 创建ROS2节点对象并进行初始化</span></span><br><span class="line">    node.destroy_node()                              <span class="comment"># 销毁节点对象</span></span><br><span class="line">    rclpy.shutdown()                                 <span class="comment"># 关闭ROS2 Python接口</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意：编写完成程序后，需要重新编译，纯py文件无法用ros2命令直接运行, ros2 run 运行的是install</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024微机原理课程设计-小车跟随系统</title>
      <link href="/posts/50511/"/>
      <url>/posts/50511/</url>
      
        <content type="html"><![CDATA[<h1 id="小车基本控制设计"><a class="markdownIt-Anchor" href="#小车基本控制设计"></a> 小车基本控制设计</h1><h2 id="一-前期系统分析与设计"><a class="markdownIt-Anchor" href="#一-前期系统分析与设计"></a> 一、前期系统分析与设计</h2><p>​      在本次设计的前期准备工作中，通过对题目的分析，小车运动的精确低延迟控制+蓝牙通信都是相当重要的关键点。本次课程设计，使用电机型号为带霍尔传感器地无刷电机，能够通过内置编码器的A,B相固定输出390次/圈的脉冲，可以用于精准测量电机转速以及作为<mark>车辆里程表</mark>。因此，我基于所用电机的特性，利用PIC单片机CCP极其优秀的PWM输出功能，设计了一个易用的电机驱动程序，能够使得单片机输出频率10KHZ，占空比可调范围在0~100的PWM信号。对比于常规的使用定时器作为计时基准的方法，直接利用单片机设计好的电路外设模块，减轻了单片机<mark>程序</mark>上消耗的资源，也大幅提高了后续小车的运动性能以及稳定性。重要的一点是，基于对自动控制原理的粗略学习，我们可以利用本次电机所带的编码器模块，实现<strong>单片机测速——程序PID控制器——输出PWM波</strong>的一个PID自动控速系统以及能够精准记录脉冲数的<strong>车辆里程表（这在后面进行内外圈转向时发挥了关键的作用）</strong>，同时，蓝牙模块也是一个极其便捷的工具，使用两片蓝牙模块，分别连接单片机和计算机，在一些串口助手软件上，能够迅速实现基于上位机的参数检测以及调试系统。</p><p>注：本次设计的串口助手为VOFA，可以兼容所有串口调试的基本功能，能够根据数值的大小显示波形。</p><h3 id="设计框图蓝牙控速小车"><a class="markdownIt-Anchor" href="#设计框图蓝牙控速小车"></a> 设计框图：蓝牙控速小车</h3><p><strong>基于上述程序的编写以及小车板块的搭建，首先设计一个可以通过计算机或者手机终端等设备进行蓝牙遥控的小车运动系统。本次课程设计我们基于实验以及课程的理论经验，从搭建<mark>底层框架</mark>再到完成其余功能要求的设计思想，分阶段、板块完成设计，更有利于后面的高效分工与调试。</strong></p><img src="/posts/50511/image-20240625013830066.png" class="" title="image-20240625013830066"><h2 id="1电机驱动程序设计"><a class="markdownIt-Anchor" href="#1电机驱动程序设计"></a> 1.电机驱动程序设计</h2><p><strong>问题1：PWM输出</strong></p><p>​常见的8位单片机（stc89c52），产生PWM，通常是利用到定时器模块，以定时器计时为基准（时间基准t1，假设为1ms），程序上定义计时变量time(每次进定时器中断time自加1)、周期时间变量T（假设T=100）、占空比时间变量N（假设N=50），然后通过IF语句判断，翻转设定的引脚（假设为RC1）输出PWM方波信号。但是考虑到如果使用定时器，如果定时器的计数寄存器（计时溢出周期）设置过小，程序会频繁进入中断，不利于其他部分程序的执行，占用了软件上的资源；如果定时器计时周期设置的太大，比如10ms，又想输出一个可调范围0~100的PWM，那么PWM方波信号的周期就高达1s，PWM频率仅仅只有1HZ，这样就会使得电机无法正常驱动或者运动过程有明显的卡顿（PWM分辨率过低）。而本次使用的PIC16F877A单片机，具备CCP1+CCP2模块，能够通过配置寄存器，硬件自动生成两路的PWM信号，节省了软件资源，并且PIC单片机的CCP模块生成的PWM方波相当的精准可靠，在完成CCP模块PWM模式的初始化后，只需要修改CCP1L/CCP2L的值即可修改PWM（RC6、RC7）的占空比。</p><hr><p>电机驱动模块子程序设计</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_A RC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_B RC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_1 RB4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_2 RB5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_1 RB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_2 RB7</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函    数</span></span><br><span class="line"><span class="comment">参    数要写入的命令</span></span><br><span class="line"><span class="comment">返 回 值无</span></span><br><span class="line"><span class="comment">特殊说明无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_GPIO_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISB4=<span class="number">0</span>;</span><br><span class="line">TRISB5=<span class="number">0</span>;</span><br><span class="line">TRISB6=<span class="number">0</span>;</span><br><span class="line">TRISB7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;</span><br><span class="line">TRISC2=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_CCP_PWM_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*定义CCP1工作在PWM模式*/</span></span><br><span class="line">CCP1CON=<span class="number">0X0C</span>;<span class="comment">//定义CCP1模块工作在PWM模式</span></span><br><span class="line">CCPR1L=<span class="number">50</span>;<span class="comment">//定义脉宽为50us</span></span><br><span class="line">PR2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义CCP2工作在PWM模式*/</span></span><br><span class="line">    CCP2CON = <span class="number">0x0c</span>; <span class="comment">// 配置CCP2为PWM模式</span></span><br><span class="line">    CCPR2L = <span class="number">50</span>;          <span class="comment">// 设置CCP2 PWM占空比（高位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*与CCP模块PWM模式配合的TMR2*/</span></span><br><span class="line">T2CON=<span class="number">0</span>;<span class="comment">//定义TM2模块工作在预、后分频比都是1:1的定时器模式</span></span><br><span class="line">TMR2=<span class="number">0</span>;</span><br><span class="line">TMR2ON=<span class="number">1</span>;<span class="comment">//启动TMR2，此刻从RC2引脚输出所设的波形</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Speed_Set</span><span class="params">(<span class="type">int</span> Speed1,<span class="type">int</span> Speed2)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Speed1 &gt; <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">0</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">1</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Speed2 &gt;<span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">0</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">1</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>问题2：测速</strong></p><p><mark><strong>通过外部中断配合定时器1测速</strong></mark></p><p>​我们可以按照实验课中的方法，使用定时器1和外部中断配合设计测速系统，通过检测信号跳变，配合定时器1的TMR1ON控制启停，计算电平的持续时间，这样就能测量PWM的占空比。但是，通过对本次课程设计电机模块的分析以及学习（本次设计为无刷电机==(注意固定螺丝不能太长会磨损电机减速箱)==，并且自带霍尔编码器）</p><p>​霍尔编码器：通过霍尔传感器感应电机转过的次数，相应的，在本次设计中使用的电机模块，转动一圈产生390个脉冲。直接使用实验五的方法，通过串口调试助手打印测得速度，发现速度是不连续的（此图出现如290km/h 71km/h 15 km/h等速度）。因为如果要使用霍尔传感器，它的脉冲实际上不是代表的PWM，只有通过记录编码器输出的脉冲次数才能实现单位时间内小车的速度/里程计算。</p><img src="/posts/50511/image-20240621050939454.png" class="" title="image-20240621050939454"><hr><p><mark><strong>采用外部中断计数的方法测速，如下图</strong></mark></p><p><strong>我们改用定时器0（50ms为计数周期)，外部中断（测量电机驱动输出的编码器脉冲计数），这样就能轻而易举地计算出50ms内地脉冲数目，进而进行速度的精准测量+里程的累计。</strong></p><p>可见，直接通过计算脉冲次数的方法，速度的测量基本无波动（横坐标表示50ms时间内的脉冲计数,此图位48-49范围内波动，基本无误差）。</p><img src="/posts/50511/d34fd09e3d5cd10c526f393554abff6.png" class="" title="d34fd09e3d5cd10c526f393554abff6"><hr><p><strong>子函数设计</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_A RC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_B RC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_1 RB4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_2 RB5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_1 RB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_2 RB7</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函    数</span></span><br><span class="line"><span class="comment">参    数要写入的命令</span></span><br><span class="line"><span class="comment">返 回 值无</span></span><br><span class="line"><span class="comment">特殊说明无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_GPIO_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISB4=<span class="number">0</span>;</span><br><span class="line">TRISB5=<span class="number">0</span>;</span><br><span class="line">TRISB6=<span class="number">0</span>;</span><br><span class="line">TRISB7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;</span><br><span class="line">TRISC2=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_CCP_PWM_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*定义CCP1工作在PWM模式*/</span></span><br><span class="line">CCP1CON=<span class="number">0X0C</span>;<span class="comment">//定义CCP1模块工作在PWM模式</span></span><br><span class="line">CCPR1L=<span class="number">50</span>;<span class="comment">//定义脉宽为50us</span></span><br><span class="line">PR2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义CCP2工作在PWM模式*/</span></span><br><span class="line">    CCP2CON = <span class="number">0x0c</span>; <span class="comment">// 配置CCP2为PWM模式</span></span><br><span class="line">    CCPR2L = <span class="number">50</span>;          <span class="comment">// 设置CCP2 PWM占空比（高位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*与CCP模块PWM模式配合的TMR2*/</span></span><br><span class="line">T2CON=<span class="number">0</span>;<span class="comment">//定义TM2模块工作在预、后分频比都是1:1的定时器模式</span></span><br><span class="line">TMR2=<span class="number">0</span>;</span><br><span class="line">TMR2ON=<span class="number">1</span>;<span class="comment">//启动TMR2，此刻从RC2引脚输出所设的波形</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Speed_Set</span><span class="params">(<span class="type">int</span> Speed1,<span class="type">int</span> Speed2)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Speed1 &gt; <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">0</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">1</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Speed2 &gt;<span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">0</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">1</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>电机的速度计算准确后，通过我们对自动控制原理的学习了解，或许可以应用一些简单的算法，进行小车的速度闭环负反馈控制？</li></ul><h3 id="3串口通信初始化"><a class="markdownIt-Anchor" href="#3串口通信初始化"></a> 3.串口通信初始化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//putch 重定向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putch</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">    TXREG=ch;</span><br><span class="line">    <span class="keyword">while</span>(TRMT==<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*??????????*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_PrintString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *String)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(*String != <span class="string">'\0'</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,*String++);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口引脚初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">TRISC6=<span class="number">1</span>;</span><br><span class="line">TRISC7=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    SPBRG=<span class="number">12</span>;<span class="comment">//波特率设置为19200</span></span><br><span class="line">    TXSTA=<span class="number">0B</span>00100100;<span class="comment">//异步模式。发送8位数据，允许发送</span></span><br><span class="line">    RCSTA=<span class="number">0B</span>10010000;<span class="comment">//允许串口工作，连续接收使能，接收8位数据</span></span><br><span class="line">    GIE=<span class="number">1</span>;PEIE=<span class="number">1</span>;RCIE=<span class="number">1</span>;<span class="comment">//开放USART接收中断</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将连接单片机的蓝牙模块配置为主机模式，连接计算机的蓝牙模块配置为从机模式，并且两片蓝牙的密码设置为一致，波特率与单片机、电脑串口助手都设置为19200。这样，单片机就能够发送数据到串口助手，串口中断打印出数据/波形，实现远程调参效果。</p><h3 id="pid控速的尝试与应用"><a class="markdownIt-Anchor" href="#pid控速的尝试与应用"></a> PID控速的尝试与应用</h3><p>1.给定占空比</p><p>​通过修改CCP1L和CCP2L的值，可以实现指定PWM占空比的电机变速效果，通过串口助手显示编码器测速的波形，发现给定PWM的速度也是比较稳定的。</p><img src="/posts/50511/image-20240625022659866.png" class="" title="image-20240625022659866"><p>2.PID控速</p><p>​编写PID速度环控制子程序，将速度测量值以及速度目标值作为输入，返回值为PID的输出值，作为PWM的输出，形成闭环反馈系统。经上位机显示速度波形，测量速度（红线）能够逐渐趋近于目标速度（绿线），说明PID速度闭环的程序是正确的，后面对各个参数（Kp、Ki、Kd）进行优化，减少过充现象，增大反应速度，提高PID速度闭环系统的抗干扰能力。</p><img src="/posts/50511/image-20240625023158792.png" class="" title="image-20240625023158792"><p>​经过我们后面对PIC16F877A的引脚分配，发现它能够进行速度测量的引脚基本上只能使用外部中断，CCP模块以及被用作PWM输出，那么PID控速的想法就暂时被搁置了。但是，我们后面将编码器的脉冲输入作为车辆里程表，也可以实现灵活度更高的功能（内外圈转向区分）。</p><h1 id="灰度巡线pid-数学模型解决工程问题"><a class="markdownIt-Anchor" href="#灰度巡线pid-数学模型解决工程问题"></a> 灰度巡线PID - 数学模型解决工程问题</h1><img src="/posts/50511/image-20240621050902381.png" class="" title="image-20240621050902381"><p><strong>头文件定义/变量定义</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span><span class="comment">//PIC库</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);<span class="comment">//配置起始位</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//C语言库</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*PIC单片机驱动相关子函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\LCD1602.H"</span><span class="comment">//LCD1602子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\KeyBoard.H"</span><span class="comment">//按键子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\iic.H"</span><span class="comment">//iic通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Motor.H"</span><span class="comment">//电机驱动</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Usart.H"</span><span class="comment">//串口（蓝牙）通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Led.H"</span><span class="comment">//Led</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Encoder.H"</span><span class="comment">//霍尔编码器测速</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\PID.H"</span><span class="comment">//PID控制程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\csb.H"</span><span class="comment">//超声波控制程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*PIC单片机系统相关子函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\System\Timer.H"</span><span class="comment">//定时器初始化程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\System\Delay.H"</span><span class="comment">//延时子程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bluetooth;<span class="comment">//蓝牙接收字节存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*外部中断测速*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Counter_temp;<span class="comment">//车辆旋转圈数计数变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Timer0_Counter;<span class="comment">//定时器0溢出计数变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Encoder_Counter;<span class="comment">//脉冲计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*循迹控制主要变量*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Motor_Flag;<span class="comment">//电机允许模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Turn_PWM;<span class="comment">//转向PWM，由循迹PID控制函数输出赋值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Byte;<span class="comment">//八路循迹对应一个字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_left,Speed_right;<span class="comment">//寻线速度77y89-</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_Velcolity=<span class="number">33</span>;<span class="comment">//直行速度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> IO_flag=<span class="number">0</span>;<span class="comment">//（90度转向）启停标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Circle_Mode=<span class="number">0</span>;<span class="comment">//车辆运行模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Start_Find_flag=<span class="number">0</span>;<span class="comment">//脉冲计数标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Bifurcate_Flag=<span class="number">0</span>;<span class="comment">//分叉路口标志位，0表示第一个，1表示第二个</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Stop_Flag=<span class="number">0</span>;<span class="comment">//停车标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Mode=<span class="number">0</span>;<span class="comment">//八路循迹状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> distance;<span class="comment">//超声波距离</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> BT_State=<span class="number">0</span>;<span class="comment">//蓝牙通信状态机，无线调参</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> csb_Flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> NQ_fast_Flag=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*//循迹工作验证函数</span></span><br><span class="line"><span class="comment">unsigned char yz[8]={0};</span></span><br><span class="line"><span class="comment">unsigned char mod;</span></span><br><span class="line"><span class="comment">void yanzheng()</span></span><br><span class="line"><span class="comment">{ </span></span><br><span class="line"><span class="comment">unsigned char temp = mod;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">yz[i] = temp %2;</span></span><br><span class="line"><span class="comment">temp/=2;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>模块验证函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*//循迹工作验证函数</span></span><br><span class="line"><span class="comment">unsigned char yz[8]={0};</span></span><br><span class="line"><span class="comment">unsigned char mod;</span></span><br><span class="line"><span class="comment">void yanzheng()</span></span><br><span class="line"><span class="comment">{ </span></span><br><span class="line"><span class="comment">unsigned char temp = mod;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">yz[i] = temp %2;</span></span><br><span class="line"><span class="comment">temp/=2;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>循迹控制函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Byte;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Kp=<span class="number">3.2</span>;</span><br><span class="line"><span class="type">int</span> Kd=<span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> turn_err;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> last_err;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> err_difference;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Trace_PID</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Trace_Byte = (RC0&lt;&lt;<span class="number">7</span>|RC3&lt;&lt;<span class="number">6</span>|RE0&lt;&lt;<span class="number">5</span>|RE1&lt;&lt;<span class="number">4</span>|RE2&lt;&lt;<span class="number">3</span>|RA4&lt;&lt;<span class="number">2</span>|RC4&lt;&lt;<span class="number">1</span>|RC5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Trace_Byte)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//直行</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11100111: </span><br><span class="line">turn_err=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11110111:</span><br><span class="line">turn_err=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11101111:</span><br><span class="line">turn_err=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//左转</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11001111:</span><br><span class="line">turn_err=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11011111:</span><br><span class="line">turn_err=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>10011111:</span><br><span class="line">turn_err=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>10111111:</span><br><span class="line">turn_err=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>00111111:</span><br><span class="line">turn_err=<span class="number">6</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>01111111:</span><br><span class="line">turn_err=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右转</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11110011:</span><br><span class="line">turn_err=<span class="number">-2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111011:</span><br><span class="line">turn_err=<span class="number">-3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111001:</span><br><span class="line">turn_err=<span class="number">-4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111101:</span><br><span class="line">turn_err=<span class="number">-5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111100:</span><br><span class="line">turn_err=<span class="number">-6</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111110:</span><br><span class="line">turn_err=<span class="number">-7</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err_difference= turn_err - last_err;</span><br><span class="line"></span><br><span class="line">last_err= turn_err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)(turn_err*Kp + err_difference*Kd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>路线控制函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Trace_Control</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Circle_Mode == <span class="number">0</span>)<span class="comment">//起始点</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">1</span>;<span class="comment">//脉冲计数标志位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt;<span class="number">550</span>)<span class="comment">//固定距离，越过黑线</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">1</span>)<span class="comment">//第一圈，外圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag =<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Find_flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">200</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">IO_flag = <span class="number">1</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">2</span>;<span class="comment">//内圈</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">2</span>)<span class="comment">//第二圈，内圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IO_flag == <span class="number">0</span>)<span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//putch(3);//进入第三圈</span></span><br><span class="line">Start_Find_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Find_flag == <span class="number">1</span>  &amp;&amp; NQ_fast_Flag == <span class="number">0</span>)<span class="comment">//开启计脉冲且，内圈没有加速</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">300</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">IO_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">3</span>;</span><br><span class="line">csb_Flag= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(NQ_fast_Flag)<span class="comment">//开启内圈加速</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">800</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">NQ_fast_Flag = <span class="number">0</span>;</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;<span class="comment">//回归</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//内圈固定转向</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(<span class="number">20</span>,<span class="number">60</span>);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">320</span>)</span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">NQ_fast_Flag = <span class="number">1</span>;</span><br><span class="line">IO_flag = <span class="number">0</span>;</span><br><span class="line">Speed_Velcolity+=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">3</span>)<span class="comment">//第三圈，外圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">1</span>;</span><br><span class="line">Stop_Flag=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Stop_Flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">putch(<span class="number">0x08</span>);</span><br><span class="line">Motor_Speed_Set(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//停车</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> MSPM0G3507 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】PID平衡小车项目实战</title>
      <link href="/posts/25248/"/>
      <url>/posts/25248/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[Hal库][1]Hal库初始化配置</title>
      <link href="/posts/253/"/>
      <url>/posts/253/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><ul><li>xxxxxxxxxx&nbsp;$ tags: -数字电路与VHDL设计"bash</li><li>需要安装java环境，才能正常允许CubeMX</li><li>确保以及安装了Keil MDK，Keil完成了stm32的芯片包配置，至少下载串口通信（FLY MCU） , STLink Unit中其中一款下载/串口通信软件。</li></ul><h1 id="一-cubemx初始配置"><a class="markdownIt-Anchor" href="#一-cubemx初始配置"></a> 一、CubeMX初始配置</h1><h2 id="1cubemx安装芯片固件包"><a class="markdownIt-Anchor" href="#1cubemx安装芯片固件包"></a> 1.CubeMX安装芯片固件包</h2><img src="/posts/253/image-20240609153709278.png" class="" title="image-20240609153709278"><p>xxxxxxxxxx&nbsp;typedef struct//typedef为成员列表提供了一个GPIO_InitTypeDef的名字{}GPIO_InitTypeDef;c</p><p><strong>像常用的stm32f103c8t6，我们就选择STM32F1，勾选最新固件包，点击Install Now进行在线安装</strong></p><hr><img src="/posts/253/image-20240609155414174.png" class="" title="image-20240609155414174"><hr><h2 id="2工程创建"><a class="markdownIt-Anchor" href="#2工程创建"></a> 2.工程创建</h2><p>1.打开stm32cubeMX，File &gt; New project &gt;MCU/MPU Selector &gt;Part Number<br>2.输入stm32f103c8,Start Project<br>3.Project Manager &gt; Project</p><h2 id="3引脚配置"><a class="markdownIt-Anchor" href="#3引脚配置"></a> 3.引脚配置</h2><img src="/posts/253/image-20240609154359188.png" class="" title="image-20240609154359188"><h2 id="3外设配置"><a class="markdownIt-Anchor" href="#3外设配置"></a> 3.外设配置</h2><p><mark>GPIO属性配置</mark></p><img src="/posts/253/image-20240609155305797.png" class="" title="image-20240609155305797"><blockquote><p>GPIO output level &gt; High 输出等级 高</p><p>GPIO mode Output &gt; Push Pull 输出模式 推挽输出</p><p>GPIO Pull-up/Pull-down &gt; Pull-down 初始输出 设为低</p><p>User Label &gt;  用户标签，方便代码中使用，如图：</p><p>​<img src="/posts/253/image-20240609154825836.png" class="" title="image-20240609154825836"></p></blockquote><img src="/posts/253/image-20240609154611816.png" class="" title="image-20240609154611816"><p><mark>配置时钟模式</mark></p><p>Pinout &amp; Configuration &gt; A-Z &gt; RCC &gt; High Speed Clock<br>Crystal/Ceramic Resonator 使用外部时钟源</p><img src="/posts/253/image-20240609155203231.png" class="" title="image-20240609155203231"><p><mark>时钟可视化配置</mark></p><p>Clock Configuration<br>选中HSE,倍频x9，不分频</p><img src="/posts/253/image-20240609154912764.png" class="" title="image-20240609154912764"><h2 id="4工程设置"><a class="markdownIt-Anchor" href="#4工程设置"></a> 4.工程设置</h2><blockquote><p>Project Name 项目名称，填写led</p><p>Project Location 项目位置，选择一个你喜欢的文件夹，不要出现中文 Toolchain/IDE</p><p>交叉编译链，选择MDK，V5</p><p>勾选 Use latest available version</p></blockquote><img src="/posts/253/image-20240609155924976.png" class="" title="image-20240609155924976"><blockquote><p>Project Manager &gt; Code Generator</p><p>勾选Generate peripheral…</p></blockquote><img src="/posts/253/image-20240609160038284.png" class="" title="image-20240609160038284"><blockquote><p>其余默认配置即可</p></blockquote><img src="/posts/253/image-20240609160159606.png" class="" title="image-20240609160159606"><blockquote><p>GENERATE CODE生成代码，Open Project</p></blockquote><h1 id="二-mdk代码编写"><a class="markdownIt-Anchor" href="#二-mdk代码编写"></a> 二、MDK代码编写</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">  HAL_Init();<span class="comment">//HAL库初始化</span></span><br><span class="line">  SystemClock_Config();<span class="comment">//时钟初始化</span></span><br><span class="line">  MX_GPIO_Init();<span class="comment">//GPIO初始化</span></span><br><span class="line"><span class="comment">/* USER CODE END 1 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_5);<span class="comment">//翻转引脚电平</span></span><br><span class="line">  HAL_Delay(<span class="number">500</span>);<span class="comment">//延时500ms</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em><em>==注意：    /</em> USER CODE BEGIN 3 <em>/之内的代码不会杯CubeMX重新生成代码时覆盖掉！ /</em> USER CODE END 3 <em>/==</em></em></p><img src="/posts/253/image-20240609160459831.png" class="" title="image-20240609160459831"><img src="/posts/253/image-20240609160610985.png" class="" title="image-20240609160610985"><p>下载后编译，观察PA5引脚电平变化（利用LED），是否以0.5s周期变化</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【蓝桥杯单片机】客观题</title>
      <link href="/posts/24737/"/>
      <url>/posts/24737/</url>
      
        <content type="html"><![CDATA[<h1 id="rc低通滤波器"><a class="markdownIt-Anchor" href="#rc低通滤波器"></a> RC低通滤波器</h1><h2 id="截止频率"><a class="markdownIt-Anchor" href="#截止频率"></a> 截止频率</h2><img src="/posts/24737/image-20240526121741003.png" class="" title="image-20240526121741003">]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记,蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[11]IIC通信(mpu6050)</title>
      <link href="/posts/5621/"/>
      <url>/posts/5621/</url>
      
        <content type="html"><![CDATA[<h1 id="iic通信协议"><a class="markdownIt-Anchor" href="#iic通信协议"></a> IIC通信协议</h1><h2 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h2><ul><li><p>同步时序的稳定性比异步时序更高</p></li><li><p>半双工</p></li><li><p>SCL、SDA两根通信线</p></li><li><p>支持总线挂载（一主多从，多主多从）</p></li></ul><h2 id="硬件电路"><a class="markdownIt-Anchor" href="#硬件电路"></a> 硬件电路</h2><ul><li>所有I2C设备的SCL连接在一起，SDA连接在一起</li><li>设备的SCL和SDA均要配置成开漏输出模式(防止形成短路电流，SDA要么<mark>被上拉</mark>，要么<mark>输出低电平</mark>)，会有“线与”的现象。在多主机的模式下，可以利用线与的特性，实现总线仲裁和时钟同步。</li><li>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</li></ul><img src="/posts/5621/image-20240524211453559.png" class="" title="image-20240524211453559"><hr><img src="/posts/5621/image-20240524212810776.png" class="" title="image-20240524212810776"><p><strong>PS：IIC时序是高位先行，串口是低位先行</strong></p><hr><img src="/posts/5621/image-20240524212934134.png" class="" title="image-20240524212934134"><p><strong>PS：主机接收时，需要释放SDA，即输入模式</strong></p><hr><img src="/posts/5621/image-20240524213709342.png" class="" title="image-20240524213709342"><p><strong>PS:从机的地址可以通过电路改变</strong></p><hr><img src="/posts/5621/image-20240524214219090.png" class="" title="image-20240524214219090"><p><strong><mark>红线处，此时需要从机应答，这里如果但看主机的SDA，应该会释放SDA，即高电平，由于从机要发送应答，根据线与的特性，这里拉低了SDA，所以最后SDA呈现图中所示。</mark></strong></p><hr><img src="/posts/5621/image-20240524214908190.png" class="" title="image-20240524214908190"><p><strong>IIC通信的设备中会有单独一个字节空间存储地址指针，当给IIC设备指定地址写时，地址指针会加一，这时如果使用当前地址读，就是读取指针地址指向的内存。此时序较为少用、</strong></p><hr><img src="/posts/5621/image-20240524215204768.png" class="" title="image-20240524215204768"><p><strong><mark>指定地址读的实现原理：先调用指定地址写，但是不写数据。再次调用当前地址读，这样复合的时序就能完成指定地址读的功能了</mark></strong></p><h1 id="mpu6050"><a class="markdownIt-Anchor" href="#mpu6050"></a> MPU6050</h1><img src="/posts/5621/image-20240524220155605.png" class="" title="image-20240524220155605"><h2 id="姿态角欧拉角"><a class="markdownIt-Anchor" href="#姿态角欧拉角"></a> 姿态角（欧拉角）</h2><img src="/posts/5621/image-20240524220352017.png" class="" title="image-20240524220352017"><p><strong>飞机相对于初始三个轴的夹角：</strong></p><ul><li>俯仰角：Pitch</li><li>滚转：Roll</li><li>偏航：Yaw</li></ul><p>要想获得稳定的欧拉角，就需要进行数据融合，进一步得到姿态角。</p><p><strong>常见的数据融合算法：</strong></p><ul><li>互补滤波</li><li>卡尔曼滤波</li></ul><p>ps:惯性导航领域里，姿态解算</p><h2 id="加速度计结构"><a class="markdownIt-Anchor" href="#加速度计结构"></a> 加速度计结构</h2><img src="/posts/5621/image-20240524220855509.png" class="" title="image-20240524220855509"><p><strong>F=ma(测力计)</strong></p><img src="/posts/5621/image-20240524221000525.png" class="" title="image-20240524221000525"><p><strong><mark>加速度计测得的是静态加速度，只能在物体静止的时候使用</mark></strong></p><h2 id="陀螺仪传感器"><a class="markdownIt-Anchor" href="#陀螺仪传感器"></a> 陀螺仪传感器</h2><img src="/posts/5621/image-20240524221506605.png" class="" title="image-20240524221506605"><p><strong>测得的是角速度，要想得到角度，可以进行求积分</strong></p><p><strong><mark>陀螺仪具有动态稳定性，不具有静态稳定性</mark></strong></p><p><strong><mark>对两种传感器进行互补滤波，就可以得到稳定的姿态角了</mark></strong></p><h2 id="mpu6050的参数"><a class="markdownIt-Anchor" href="#mpu6050的参数"></a> MPU6050的参数</h2><img src="/posts/5621/image-20240524221944683.png" class="" title="image-20240524221944683"><p>eg: mpu6050的从机地址：0x68 ，IIC时序中发送的第一个字节，高七位为从机地址，第八位为读写位。有时候把0XD0当作MPU6050的地址</p><h2 id="硬件结构"><a class="markdownIt-Anchor" href="#硬件结构"></a> 硬件结构</h2><img src="/posts/5621/image-20240525205511856.png" class="" title="image-20240525205511856"><blockquote><p><strong>六轴传感器的缺点：没有稳定的参考方向</strong></p><p>XCL，XDA：挂载磁力计，气压计</p><p>INT引脚：可以配置MPU6050内部一些事件，产生电平跳变</p><p>PS：MPU6050内部包含DMP单元：进行姿态融合和数据结算</p><p>包含稳压电路</p></blockquote><p><mark><strong>传感器内部含有自测单元</strong></mark></p><img src="/posts/5621/image-20240525210718105.png" class="" title="image-20240525210718105"><p>使能自测-&gt;读取数据1-&gt;失能自测-&gt;读取数据2，两个数据相减，得到的数据称作自测响应，自测响应如果在<mark>规定的范围内</mark>，说明芯片性能没问题。</p><hr><p><strong>电荷泵</strong></p><img src="/posts/5621/image-20240525210953979.png" class="" title="image-20240525210953979"><p>是一种<mark>升压电路</mark></p><p>原理：电源和电容串并联的切换（充电-&gt;串联-&gt;相当于电压升高（放电）-&gt;快速切换到并联-&gt;充电-&gt;循环）+ 电容滤波 = 平稳升压</p><img src="/posts/5621/image-20240525211051107.png" class="" title="image-20240525211051107"><hr><p><strong>DMP</strong>（数字运动处理器）</p><img src="/posts/5621/image-20240525211323304.png" class="" title="image-20240525211323304"><p>配合MPU6050官方的DMP库，进行姿态解算。</p><p><mark>引脚说明</mark></p><blockquote><p>FSYNC：帧同步</p></blockquote><blockquote><p>通信接口：用于和STM32通信</p><img src="/posts/5621/image-20240525211535797.png" class="" title="image-20240525211535797"></blockquote><blockquote><p>xxxxxxxxxx&nbsp;python script_name.py --train_data_dir “path/to/train_data” --test_data_dir “path/to/test_data” --img_height 128 --img_width 128 --batch_size 64 --epochs 15python</p><p>​可以拓展连接磁力计</p><img src="/posts/5621/image-20240525211622949.png" class="" title="image-20240525211622949"></blockquote><hr><h2 id="软件iic读写mpu6050"><a class="markdownIt-Anchor" href="#软件iic读写mpu6050"></a> 软件IIC读写MPU6050</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MyIIC.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主机寻址MPU6050*/</span></span><br><span class="line">MyIIC_Init();</span><br><span class="line">MyIIC_Start();</span><br><span class="line">MyIIC_SendByte(<span class="number">0xD0</span>);<span class="comment">//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="type">uint8_t</span> Ack = MyIIC_ReceiveAck();</span><br><span class="line">MyIIC_Stop();</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Ack,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> <img src="/posts/5621/image-20240525224436566.png" class="" title="image-20240525224436566"><hr><p><strong>修改MPU6050地址</strong></p><p>可见，寻址无应答</p><img src="/posts/5621/image-20240526152458852.png" class="" title="image-20240526152458852"><hr><p><strong>读取MPU6050 ID号</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="comment">/*//主机寻址MPU6050</span></span><br><span class="line"><span class="comment">MyIIC_Init();</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(0xD2);//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="comment">uint8_t Ack = MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">OLED_ShowNum(1,1,Ack,3);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//读取MPU6050ID号</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154358599.png" class="" title="image-20240526154358599"><hr><p><strong>写MPU6050</strong>，需要关闭MPU6050的睡眠模式</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//在电源管理器1，写入0x00，接触睡眠模式</span></span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//更改采样频率</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x19</span>);<span class="comment">//读取MPU6050采样频率</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154723015.png" class="" title="image-20240526154723015"><p><strong>PS:某种程度上来说，对寄存器的读写操作可以看作读写一个存储器，但是寄存器能反应硬件电路的状态，对硬件电路进行操作</strong></p><hr><h2 id="mpu6050读取六轴姿态值"><a class="markdownIt-Anchor" href="#mpu6050读取六轴姿态值"></a> MPU6050读取六轴姿态值</h2><p><strong>函数定义</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用指针，实现函数多返回值的操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params"><span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> DataH ,DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">*AccX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">*AccY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">*AccZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">*GyroX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">*GyroY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">*GyroZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int16_t</span> Ax,Ay,Az,Gx,Gy,Gz;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">MPU6050_GetData(&amp;Ax,&amp;Ay,&amp;Az,&amp;Gx,&amp;Gy,&amp;Gz);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">1</span>,Ax,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">1</span>,Ay,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">1</span>,Az,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">8</span>,Gx,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">8</span>,Gy,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">8</span>,Gz,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>加速度计最大量程为16g</strong></p><img src="/posts/5621/image-20240526162104183.png" class="" title="image-20240526162104183"><p>左侧为加速度计，右侧为角速度测量值</p><hr><h2 id="硬件iic读写mpu6050"><a class="markdownIt-Anchor" href="#硬件iic读写mpu6050"></a> 硬件IIC读写MPU6050</h2><p>CR：控制寄存器</p><p>DR：数据寄存器</p><p>SR：状态寄存器</p><p><strong>STM32IIC外设</strong></p><img src="/posts/5621/image-20240526162959527.png" class="" title="image-20240526162959527"><h3 id="多主机模型"><a class="markdownIt-Anchor" href="#多主机模型"></a> 多主机模型</h3><p><strong>一主多从</strong></p><img src="/posts/5621/image-20240526163123491.png" class="" title="image-20240526163123491"><p><strong>多主多从</strong></p><p>固定多主机：</p><img src="/posts/5621/image-20240526163142347.png" class="" title="image-20240526163142347"><p>可变多主机：</p><img src="/posts/5621/image-20240526163226138.png" class="" title="image-20240526163226138"><p><strong>GPIO复用输入和复用输出</strong></p><img src="/posts/5621/image-20240526164412282.png" class="" title="image-20240526164412282"><p><strong>IIC主机发送流程图</strong></p><img src="/posts/5621/image-20240526165109626.png" class="" title="image-20240526165109626"><p><strong>IIC主机接收流程图</strong></p><img src="/posts/5621/image-20240526165718823.png" class="" title="image-20240526165718823"><h3 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h3><blockquote><p><strong>产生起始条件</strong></p><p>void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>生成终止条件</strong></p><p>void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>配置在收到一个字节后，是否给从机应答</strong></p><p>void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>写数据到数据寄存器DR</strong></p><p>void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);</p><p><strong>读取DR的数据，作为返回值</strong></p><p>uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);</p><p><strong>发送7位地址</strong></p><p>void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);</p></blockquote><p><strong>状态监控函数的官方说明</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> ****************************************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                         I2C State Monitoring Functions</span></span><br><span class="line"><span class="comment"> *                       </span></span><br><span class="line"><span class="comment"> ****************************************************************************************   </span></span><br><span class="line"><span class="comment"> * This I2C driver provides three different ways for I2C state monitoring</span></span><br><span class="line"><span class="comment"> *  depending on the application requirements and constraints:</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 1) Basic state monitoring:</span></span><br><span class="line"><span class="comment"> *    Using I2C_CheckEvent() function:</span></span><br><span class="line"><span class="comment"> *    It compares the status registers (SR1 and SR2) content to a given event</span></span><br><span class="line"><span class="comment"> *    (can be the combination of one or more flags).</span></span><br><span class="line"><span class="comment"> *    It returns SUCCESS if the current status includes the given flags </span></span><br><span class="line"><span class="comment"> *    and returns ERROR if one or more flags are missing in the current status.</span></span><br><span class="line"><span class="comment"> *    - When to use:</span></span><br><span class="line"><span class="comment"> *      - This function is suitable for most applications as well as for startup </span></span><br><span class="line"><span class="comment"> *      activity since the events are fully described in the product reference manual </span></span><br><span class="line"><span class="comment"> *      (RM0008).</span></span><br><span class="line"><span class="comment"> *      - It is also suitable for users who need to define their own events.</span></span><br><span class="line"><span class="comment"> *    - Limitations:</span></span><br><span class="line"><span class="comment"> *      - If an error occurs (ie. error flags are set besides to the monitored flags),</span></span><br><span class="line"><span class="comment"> *        the I2C_CheckEvent() function may return SUCCESS despite the communication</span></span><br><span class="line"><span class="comment"> *        hold or corrupted real state. </span></span><br><span class="line"><span class="comment"> *        In this case, it is advised to use error interrupts to monitor the error</span></span><br><span class="line"><span class="comment"> *        events and handle them in the interrupt IRQ handler.</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *        @note </span></span><br><span class="line"><span class="comment"> *        For error management, it is advised to use the following functions:</span></span><br><span class="line"><span class="comment"> *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).</span></span><br><span class="line"><span class="comment"> *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.</span></span><br><span class="line"><span class="comment"> *            Where x is the peripheral instance (I2C1, I2C2 ...)</span></span><br><span class="line"><span class="comment"> *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()</span></span><br><span class="line"><span class="comment"> *            in order to determine which error occurred.</span></span><br><span class="line"><span class="comment"> *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()</span></span><br><span class="line"><span class="comment"> *            and/or I2C_GenerateStop() in order to clear the error flag and source,</span></span><br><span class="line"><span class="comment"> *            and return to correct communication status.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  2) Advanced state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetLastEvent() which returns the image of both status </span></span><br><span class="line"><span class="comment"> *     registers in a single word (uint32_t) (Status Register 2 value is shifted left </span></span><br><span class="line"><span class="comment"> *     by 16 bits and concatenated to Status Register 1).</span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *       - This function is suitable for the same applications above but it allows to</span></span><br><span class="line"><span class="comment"> *         overcome the limitations of I2C_GetFlagStatus() function (see below).</span></span><br><span class="line"><span class="comment"> *         The returned value could be compared to events already defined in the </span></span><br><span class="line"><span class="comment"> *         library (stm32f10x_i2c.h) or to custom values defined by user.</span></span><br><span class="line"><span class="comment"> *       - This function is suitable when multiple flags are monitored at the same time.</span></span><br><span class="line"><span class="comment"> *       - At the opposite of I2C_CheckEvent() function, this function allows user to</span></span><br><span class="line"><span class="comment"> *         choose when an event is accepted (when all events flags are set and no </span></span><br><span class="line"><span class="comment"> *         other flags are set or just when the needed flags are set like </span></span><br><span class="line"><span class="comment"> *         I2C_CheckEvent() function).</span></span><br><span class="line"><span class="comment"> *     - Limitations:</span></span><br><span class="line"><span class="comment"> *       - User may need to define his own events.</span></span><br><span class="line"><span class="comment"> *       - Same remark concerning the error management is applicable for this </span></span><br><span class="line"><span class="comment"> *         function if user decides to check only regular communication flags (and </span></span><br><span class="line"><span class="comment"> *         ignores error flags).</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3) Flag-based state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetFlagStatus() which simply returns the status of </span></span><br><span class="line"><span class="comment"> *     one single flag (ie. I2C_FLAG_RXNE ...). </span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *        - This function could be used for specific applications or in debug phase.</span></span><br><span class="line"><span class="comment"> *        - It is suitable when only one flag checking is needed (most I2C events </span></span><br><span class="line"><span class="comment"> *          are monitored through multiple flags).</span></span><br><span class="line"><span class="comment"> *     - Limitations: </span></span><br><span class="line"><span class="comment"> *        - When calling this function, the Status register is accessed. Some flags are</span></span><br><span class="line"><span class="comment"> *          cleared when the status register is accessed. So checking the status</span></span><br><span class="line"><span class="comment"> *          of one Flag, may clear other ones.</span></span><br><span class="line"><span class="comment"> *        - Function may need to be called twice or more in order to monitor one </span></span><br><span class="line"><span class="comment"> *          single event.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="iic配置占空比的缘由"><a class="markdownIt-Anchor" href="#iic配置占空比的缘由"></a> #IIC配置占空比的缘由</h3><p><strong>上升沿变化较慢，下降沿比较迅速，标准速度下，时钟占空比接近1：1，快速状态，占空比接近2：1</strong></p><img src="/posts/5621/image-20240526174725131.png" class="" title="image-20240526174725131"><p>100KHZ</p><img src="/posts/5621/image-20240526174831972.png" class="" title="image-20240526174831972"><p>400KHZ</p><img src="/posts/5621/image-20240526174841651.png" class="" title="image-20240526174841651"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> *  <span class="number">1</span>) Basic state monitoring</span><br><span class="line"> *******************************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Checks whether the last I2Cx Event is equal to the one passed</span></span><br><span class="line"><span class="comment">  *   as parameter.</span></span><br><span class="line"><span class="comment">  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.</span></span><br><span class="line"><span class="comment">  * @param  I2C_EVENT: specifies the event to be checked. </span></span><br><span class="line"><span class="comment">  *   This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     </span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9</span></span><br><span class="line"><span class="comment">  *     </span></span><br><span class="line"><span class="comment">  * @note: For detailed description of Events, please refer to section </span></span><br><span class="line"><span class="comment">  *    I2C_Events in stm32f10x_i2c.h file.</span></span><br><span class="line"><span class="comment">  *    </span></span><br><span class="line"><span class="comment">  * @retval An ErrorStatus enumeration value:</span></span><br><span class="line"><span class="comment">  * - SUCCESS: Last event is equal to the I2C_EVENT</span></span><br><span class="line"><span class="comment">  * - ERROR: Last event is different from the I2C_EVENT</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解决while死循环等待的问题"><a class="markdownIt-Anchor" href="#解决while死循环等待的问题"></a> 解决WHILE死循环等待的问题</h3><p><strong>多个while,比较危险，一旦通信出现问题，程序直接卡死</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*软件I2C，阻塞式程序</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();//可以加判断，确保时序的正确</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(RegAddress);//指定要写入的寄存器</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(Data);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//硬件IIC，非阻塞式程序</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT ) !=SUCCESS);<span class="comment">//事件监测</span></span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//选择I2C外设，从机地址，从机地址最低位。此函数自带接收应答的功能</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,RegAddress);<span class="comment">//写入DR，需要等待EV8事件</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,Data);</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) !=SUCCESS);<span class="comment">//发送完最后一个字节，需要监测EB8_1事件</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTOP(I2C2,ENABLE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>保护程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Timeout;</span><br><span class="line">Timeout= <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2Cx,I2C_EVENT) != SUCCESS)</span><br><span class="line">{</span><br><span class="line">Timeout--;</span><br><span class="line"><span class="keyword">if</span>(Timeout==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="dmp库"><a class="markdownIt-Anchor" href="#dmp库"></a> DMP库</h1><p>digital motion processor数字运动处理器，mpu6050自带的一个硬件，可以直接输出用于姿态结算的四元数</p><h1 id="卡尔曼滤波"><a class="markdownIt-Anchor" href="#卡尔曼滤波"></a> 卡尔曼滤波</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> IIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[9]DMA数据转运</title>
      <link href="/posts/10712/"/>
      <url>/posts/10712/</url>
      
        <content type="html"><![CDATA[<h1 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h1><blockquote><p><strong>恢复缺省配置</strong></p><p>void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>初始化DMA</strong></p><p>void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>DMA使能</strong></p><p>void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);</p><p><strong>中断输出使能</strong></p><p>void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);</p><p><strong>DMA设置当前数据寄存器</strong></p><p>void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);</p><p><strong>DMA获取当前数据寄存器</strong></p><p>uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>获取DMA标志位状态</strong></p><p>FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);</p><p><strong>清除DMA标志位</strong></p><p>void DMA_ClearFlag(uint32_t DMAy_FLAG);</p><p><strong>获取DMA中断标志位状态</strong></p><p>ITStatus DMA_GetITStatus(uint32_t DMAy_IT);</p><p><strong>清除DMA中断标志位</strong></p><p>void DMA_ClearITPendingBit(uint32_t DMAy_IT);</p><p><strong>开启ADC DMA触发信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p></blockquote><ul><li><p><strong><mark>DMA是AHB总线的设备</mark></strong></p></li><li><p><strong><mark>DMA软件触发和硬件触发不能同时使用，如果同时使用DMA就会连续触发</mark></strong></p></li><li><p>DMA转运有三个条件：1.传输计数器大于0 2.触发源有触发信号 3.DMA使能</p></li></ul><h1 id="一-dma数据转运"><a class="markdownIt-Anchor" href="#一-dma数据转运"></a> 一、DMA数据转运</h1><h2 id="1stm32单片机ram和rom"><a class="markdownIt-Anchor" href="#1stm32单片机ram和rom"></a> 1.stm32单片机RAM和ROM</h2><h3 id="不加const修饰"><a class="markdownIt-Anchor" href="#不加const修饰"></a> 不加const修饰</h3><img src="/posts/10712/image-20240522115326572.png" class="" title="image-20240522115326572"><h3 id="加上const修饰"><a class="markdownIt-Anchor" href="#加上const修饰"></a> 加上const修饰</h3><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> aa =<span class="number">0x66</span>;<span class="comment">//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,aa,<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;aa,<span class="number">8</span>);<span class="comment">//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>现象</strong></p><p>flash里面编译的代码部分，地址位于flah最前面，所以这里变量的显示在靠后的地址</p><img src="/posts/10712/image-20240522115450140.png" class="" title="image-20240522115450140"><h2 id="const关键字节省sram空间"><a class="markdownIt-Anchor" href="#const关键字节省sram空间"></a> const关键字节省SRAM空间</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED字模库，宽8像素，高16像素*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> OLED_F8x16[][<span class="number">16</span>]=</span><br><span class="line">{</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//  0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="结构体访问寄存器ram地址"><a class="markdownIt-Anchor" href="#结构体访问寄存器ram地址"></a> 结构体访问寄存器RAM地址</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR,<span class="number">8</span>);</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522115913765.png" class="" title="image-20240522115913765"><p><strong><mark>外设的起始地址+寄存器的偏移地址=指定寄存器的地址</mark></strong></p><p><strong><mark>使用结构体访问，指定地址对应寄存器，这样，结构体访问就是寄存器的地址</mark></strong></p><h2 id="2dma转运数组"><a class="markdownIt-Anchor" href="#2dma转运数组"></a> 2.DMA转运数组</h2><p><strong>软件触发代码部分</strong></p> <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522143322783.png" class="" title="image-20240522143322783"><h2 id="3dma软件触发"><a class="markdownIt-Anchor" href="#3dma软件触发"></a> 3.DMA软件触发</h2><img src="/posts/10712/image-20240522144732279.png" class="" title="image-20240522144732279"><p><strong>DMA传输计数器软件重装</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyDMA_Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数DMA初始化配置</span></span><br><span class="line"><span class="comment">  * @参数要转运数据的首地址，存储器站点的起始地址，传输次数</span></span><br><span class="line"><span class="comment">  * @返回值</span></span><br><span class="line"><span class="comment">  * @特殊说明</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line">MyDMA_Size=Size;</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=Size;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Enable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=AddrB;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;<span class="comment">//以字节传输</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;</span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=AddrA;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte;<span class="comment">//转运数据宽度为一个字节</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，所以通道可以任意选择</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,MyDMA_Size);</span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"DataA"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">"DataB"</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataA,<span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataB,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">DataA[<span class="number">0</span>]++;</span><br><span class="line">DataA[<span class="number">1</span>]++;</span><br><span class="line">DataA[<span class="number">2</span>]++;</span><br><span class="line">DataA[<span class="number">3</span>]++;</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">MyDMA_Transfer();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522145131191.png" class="" title="image-20240522145131191"><p><strong>将DataA用const修饰</strong></p><p>DataA此时为flash里面的变量，所以地址为08开头</p><img src="/posts/10712/image-20240522145359406.png" class="" title="image-20240522145359406"><h1 id="adc-dma转运"><a class="markdownIt-Anchor" href="#adc-dma转运"></a> ADC+ DMA转运</h1><p><strong>ADC单次扫描，DMA单次转运+软件触发</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD_Value[<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=DISABLE;<span class="comment">//单次模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,<span class="number">4</span>);<span class="comment">//传输次数给4</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里选择了ADC触发DMA，标志位自动清零，所以不需要软件清零</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);//等待转换完成标志位置1</span></span><br><span class="line"><span class="comment">return ADC_GetConversionValue(ADC1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA转运完成总是在ADC完成之后的，所以这里等待DMA状态标志位即可*/</span></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>ADC连续扫描+DMA循环转运模式</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=ENABLE;<span class="comment">//连续模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Circular;<span class="comment">//传输模式，是否使用自动重装,DMA循环模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line"></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思考：</strong></p><ul><li>定时器触发ADC单词转换后通过DMA转运？</li><li>串口发送的数据使用DMA进行存储器到外设的转运</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> DMA数据转运 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[10]串口通信</title>
      <link href="/posts/19202/"/>
      <url>/posts/19202/</url>
      
        <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p><strong>结构体初始化配置</strong></p><p>void USART_DeInit(USART_TypeDef* USARTx);<br>void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);<br>void USART_StructInit(USART_InitTypeDef* USART_InitStruct);</p><p><strong>同步时钟配置</strong></p><p>void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);<br>void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);</p><p><strong>发送数据</strong></p><p>void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);</p><ul><li>写DR寄存器</li></ul><p><strong>接收数据</strong></p><p>uint16_t USART_ReceiveData(USART_TypeDef* USARTx);</p><ul><li>读DR寄存器</li></ul></blockquote><h1 id="microlib"><a class="markdownIt-Anchor" href="#microlib"></a> MicroLIB</h1><p><strong>MicroLIB是Keil为嵌入式平台优化的一个精简库</strong></p><img src="/posts/19202/image-20240520133336274.png" class="" title="image-20240520133336274"><h1 id="多个串口同时使用printf"><a class="markdownIt-Anchor" href="#多个串口同时使用printf"></a> 多个串口同时使用printf</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(String,<span class="string">"Num=%d\r\n"</span>,<span class="number">666</span>);<span class="comment">//sprintf.可以将指定的数据复制到数组中</span></span><br><span class="line">Serial_SendString(String);<span class="comment">//打印字符串</span></span><br></pre></td></tr></tbody></table></figure><h1 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_Prinf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="汉字编码发送"><a class="markdownIt-Anchor" href="#汉字编码发送"></a> 汉字编码发送</h1><img src="/posts/19202/image-20240520135012811.png" class="" title="image-20240520135012811"><p><strong>统一选定为UTF-8编码</strong></p><h1 id="串口接收"><a class="markdownIt-Anchor" href="#串口接收"></a> 串口接收</h1><h2 id="1查询方法"><a class="markdownIt-Anchor" href="#1查询方法"></a> 1.查询方法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">RXData=USART_ReceiveData(USART1);<span class="comment">//读DR可以自动清除标志位</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2中断方法"><a class="markdownIt-Anchor" href="#2中断方法"></a> 2.中断方法</h2><h3 id="子程序"><a class="markdownIt-Anchor" href="#子程序"></a> 子程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxData;</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GerRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> Serial_RxData;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2主程序"><a class="markdownIt-Anchor" href="#2主程序"></a> 2.主程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"RxData:"</span>);</span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_GerRxFlag()==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RXData = Serial_GetRxData();</span><br><span class="line">Serial_SendByte(RXData);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">RXData=USART_ReceiveData(USART1);//读DR可以自动清除标志位</span></span><br><span class="line"><span class="comment">OLED_ShowHexNum(1,1,RXData,2);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="串口数据包"><a class="markdownIt-Anchor" href="#串口数据包"></a> 串口数据包</h1><p><strong>打包多字节为一个数据包，方便发送多字节的数据。将同一批的数据进行打包和分割</strong></p><p><strong>包头、包尾：简易通信协议</strong></p><ul><li>文本数据包</li><li>Hex数据包</li></ul><h2 id="状态机的方法来接收数据包"><a class="markdownIt-Anchor" href="#状态机的方法来接收数据包"></a> 状态机的方法来接收数据包</h2><img src="/posts/19202/image-20240520150733732.png" class="" title="image-20240520150733732"><h2 id="1发送数据包"><a class="markdownIt-Anchor" href="#1发送数据包"></a> 1.发送数据包</h2><img src="/posts/19202/image-20240520152533465.png" class="" title="image-20240520152533465"><h2 id="2接收数据包"><a class="markdownIt-Anchor" href="#2接收数据包"></a> 2.接收数据包</h2><p><strong>串口中断子程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_TxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送数据包*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(<span class="number">0xFF</span>);</span><br><span class="line">Serial_SendArray(Serial_TxPacket,<span class="number">4</span>);</span><br><span class="line">Serial_SendByte(<span class="number">0xFE</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line"><span class="keyword">if</span>(++pRxState&gt;=<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">pRxState=<span class="number">0</span>;</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="number">0xFE</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Serial.h</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_TxPacket[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_RxPacket[];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="小操作"><a class="markdownIt-Anchor" href="#小操作"></a> 小操作</h2><p><strong>按住alt选择一列进行修改</strong></p><img src="/posts/19202/image-20240520154534025.png" class="" title="image-20240520154534025"><h2 id="3文本收发数据包"><a class="markdownIt-Anchor" href="#3文本收发数据包"></a> 3.文本收发数据包</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">100</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'@'</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'\r'</span>)<span class="comment">//第一个包尾</span></span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line">pRxState++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)<span class="comment">//第二个包尾</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="string">'\n'</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">Serial_RxPacket[pRxState]=<span class="string">'\0'</span>;<span class="comment">//字符串结束时加上\0,表示字符串的结束</span></span><br><span class="line">pRxState=<span class="number">0</span>;<span class="comment">//MARK:忘记清零</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="串口下载"><a class="markdownIt-Anchor" href="#串口下载"></a> #串口下载</h1><h2 id="boot引脚"><a class="markdownIt-Anchor" href="#boot引脚"></a> Boot引脚</h2><p>BootLoder的作用相当于刷机</p><h2 id="调试使用"><a class="markdownIt-Anchor" href="#调试使用"></a> 调试使用</h2><img src="/posts/19202/image-20240520163851412.png" class="" title="image-20240520163851412"><p>可以保持跳线帽置1，但是复位后程序丢失，所以仅用来调试</p><h2 id="读flash生成bin文件"><a class="markdownIt-Anchor" href="#读flash生成bin文件"></a> 读FLASH生成bin文件</h2><img src="/posts/19202/image-20240520164112095.png" class="" title="image-20240520164112095"><h2 id="读保护写保护"><a class="markdownIt-Anchor" href="#读保护写保护"></a> 读保护/写保护</h2><img src="/posts/19202/image-20240520164217951.png" class="" title="image-20240520164217951"><h1 id="蓝牙串口通信"><a class="markdownIt-Anchor" href="#蓝牙串口通信"></a> 蓝牙串口通信</h1><p><a href="https://blog.csdn.net/struggle_success/article/details/130440579">电赛|项目|课设：蓝牙模块HC05主从配置与连接_蓝牙 master和 slave 服务-CSDN博客</a></p><p><strong>AT指令集</strong></p><p>AT+NAME = xlg 设置蓝牙名称为xlg</p><p>AT+ROLE=0 蓝牙模式为从模式 AT+ROLE=1 蓝牙模式为主模式<br>AT+CMODE=0 蓝牙连接模式为任意地址连接模式<br>AT+PSWD=1234 蓝牙配对密码为1234<br>AT+UART=9600，0，0 蓝牙通信串口波特率为9600，停止位1位，无校验位<br>AT+RMAAD 清空配对列表</p><p>一、更改波特率<br>AT+UART=a,b,c<br>蓝牙通信串口波特率为a，<br>b:停止位1位，无校验位<br>返回响应为OK</p><p>二、修改蓝牙模块密码</p><p>修改密码的AT指令格式如下：（以修改后的密码为1314为例）</p><pre><code>        AT+PSWD=1314（这里加回车）</code></pre><p>1<br>三、修改蓝牙模块名字</p><p>修改模块名字的AT指令如下：</p><pre><code>            AT+NAME =</code></pre><p>1<br>1， AT+ROLE设置主从模式：<br>AT+ROLE=1是设成主，AT+ROLE=0是设成从，AT+ROLE=2设成回环模式Slave-Loop：被动连接，接收远程蓝 牙主设备数据并将数据原样返回给远程蓝牙<br>AT+ROLE?：查询主从状态<br>2， AT+RESET:HC-05复位</p><p>3， AT+VERSION?：获取HC-05的软件版本号，只能获取，不能修改。</p><p>4， AT+ORGL:恢复出厂默认设置，当把模块设置乱了，使用此命令进行恢复默认值。</p><p>5， AT+ADDR?：获取HC-05的蓝牙地址码，只能获取，不能修改。</p><p>6， AT+NAME？:获取HC-05的名字,AT+NAME=xlg，修改模块的名字为xlg，具体名字自行修改。</p><p>7， AT+CLASS?：设置查询设备的类型，尽量不要去修改此参数。默认是1F00。</p><p>8， AT+IAC?：查询设置查询访问码，默认是9E8B33，尽量不要去修改此参数。</p><p>9， AT+PSWD？:查询设置配对密码,AT+PSWD=”0000”,密码要有双引号,密码是四位数字.</p><p>10， AT+UART：AT+UART？是查询当前模块的波特率，AT+UART=波特率,0,0。</p><p>11， AT+CMODE：AT+CMODE？是查询当前连接模式。AT+CMODE=0，1，2(0——指定蓝牙地址连接模式（指定蓝牙地址由绑定指令设置）1——任意蓝牙地址连接模式（不受绑定指令设置地址的约束）2——回环角色（Slave-Loop）默认连接模式：0)。</p><p>12， AT+BIND:AT+BIND?查询当前绑定地址,AT+BIND=NAP，UAP，LAP(用逗号隔开)。</p><p>13， AT+RMADD:从蓝牙配对列表中删除所有认证设备.</p><p>14， AT+STATE？:获取蓝牙模块工作状态.</p><p>15， AT+LINK=NAP,UAP,LAP：与远程设备建立连接。</p><p>16， AT+DISC:断开连接.</p><p>17， AT+RNAME？NAP，UAP，LAP:获取远程蓝牙设备名称.</p><p>18， AT+ADCN?：获取蓝牙配对列表中认证设备数。</p><p>19， AT+MRAD？获取最近使用过的蓝牙认证设备地址。</p><p>20， AT+INQM:设置查询模式,AT+INQM=1，9，48(1-带RSSI信号强度指示,9-超过9个蓝牙设备响应则终止查询,48-设定超时为48*1.28=61.44秒)</p><p><strong>ps: HC05模块的AT指令，蓝牙命名AT+NAME= 以及密码设置AT+PSWD= 需要加双引号！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 串口 </tag>
            
            <tag> 蓝牙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python学习】[1] Python基础</title>
      <link href="/posts/23330/"/>
      <url>/posts/23330/</url>
      
        <content type="html"><![CDATA[<h1 id="第一个python程序"><a class="markdownIt-Anchor" href="#第一个python程序"></a> 第一个Python程序</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\Users\123&gt;python</span><br><span class="line">Python 3.11.7 | packaged by Anaconda, Inc. | (main, Dec 15 2023, 18:05:47) [MSC v.1916 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">&gt;&gt;&gt; print('Hello world')</span><br><span class="line">Hello world</span><br><span class="line">&gt;&gt;&gt; print("Hello world")</span><br><span class="line">Hello world</span><br><span class="line">&gt;&gt;&gt; name = input('请输入你的名字')</span><br><span class="line">请输入你的名字'Turin'</span><br><span class="line">&gt;&gt;&gt; print(name)</span><br><span class="line">'Turin'</span><br><span class="line">&gt;&gt;&gt; print('Hello',name)</span><br><span class="line">Hello 'Turin'</span><br><span class="line">&gt;&gt;&gt; 2**10</span><br><span class="line">1024</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017063826246112">数据类型和变量 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h2 id="prompt运行py"><a class="markdownIt-Anchor" href="#prompt运行py"></a> <a href="http://xn--prompt-8w2r549b.py">prompt运行.py</a></h2><p><strong>prompt窗口1</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">please enter your name: Turin</span><br><span class="line">hello, Turin</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>.py文件</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>); <span class="comment">#Python中的分号可以省略，主要通过换行来识别语句的结束</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span><span class="string">"hello world"</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>,<span class="string">"hello world"</span>); <span class="comment">#print()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是拼起来的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> + <span class="number">200</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'1024*1024 ='</span>,<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">'please enter your name: '</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'hello,'</span>, name)</span><br></pre></td></tr></tbody></table></figure><p><strong>prompt窗口2</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">版权所有 (C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">尝试新的跨平台 PowerShell https://aka.ms/pscore6</span><br><span class="line"></span><br><span class="line">PS D:\7_python_project&gt; cd '.\1-1 python base\'</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">Turin</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">w</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">w</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt;</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt;</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python</span><br><span class="line">Python 3.10.2 (tags/v3.10.2:a58ebcc, Jan 17 2022, 14:12:15) [MSC v.1929 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">&gt;&gt;&gt; name = input()</span><br><span class="line">Turin</span><br><span class="line">&gt;&gt;&gt; print(name)</span><br><span class="line">Turin</span><br><span class="line">&gt;&gt;&gt; name = input('please enter your name: ')</span><br><span class="line">please enter your name: print('hello,', name)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">KeyboardInterrupt</span><br><span class="line"></span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">please enter your name: Turin</span><br><span class="line">hello, Turin</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; print('1024 * 768 ='1024 * 768 )</span><br><span class="line">所在位置 行:1 字符: 21</span><br><span class="line">+ print('1024 * 768 ='1024 * 768 )</span><br><span class="line">+                     ~~~~</span><br><span class="line">表达式或语句中包含意外的标记“1024”。</span><br><span class="line">所在位置 行:1 字符: 21</span><br><span class="line">+ print('1024 * 768 ='1024 * 768 )</span><br><span class="line">+                     ~</span><br><span class="line">表达式中缺少右“)”。</span><br><span class="line">所在位置 行:1 字符: 32</span><br><span class="line">+ print('1024 * 768 ='1024 * 768 )</span><br><span class="line">+                                ~</span><br><span class="line">表达式或语句中包含意外的标记“)”。</span><br><span class="line">    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException</span><br><span class="line">    + FullyQualifiedErrorId : UnexpectedToken</span><br><span class="line"></span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; print('1024 * 768 ='1024 * 768 ^C</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; print('1024 * 768 ='1024 * 768 ^C</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; ^C</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python</span><br><span class="line">Python 3.10.2 (tags/v3.10.2:a58ebcc, Jan 17 2022, 14:12:15) [MSC v.1929 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">&gt;&gt;&gt; print('1024 * 768 ='1024 * 768 )</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    print('1024 * 768 ='1024 * 768 )</span><br><span class="line">          ^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">SyntaxError: invalid syntax. Perhaps you forgot a comma?</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt; print('\\\t\\')</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r'\\\t\\')</span><br><span class="line">\\\t\\</span><br><span class="line">&gt;&gt;&gt; print(''' line1</span><br><span class="line">... ...line2</span><br><span class="line">... ...line3''')</span><br><span class="line"> line1</span><br><span class="line">...line2</span><br><span class="line">...line3</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; print('''line1</span><br><span class="line">... line2</span><br><span class="line">... line3</span><br><span class="line">... '''</span><br><span class="line">... ^Z</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt; print('''line1</span><br><span class="line">... line2</span><br><span class="line">... line3''')</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 0</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; False or False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; not 1 = 1</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    not 1 = 1</span><br><span class="line">    ^^^^^</span><br><span class="line">SyntaxError: cannot assign to expression</span><br><span class="line">&gt;&gt;&gt; not 1==1</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; n = 123</span><br><span class="line">&gt;&gt;&gt; f = 456.789</span><br><span class="line">&gt;&gt;&gt; s1 = 'Hello, world'</span><br><span class="line">&gt;&gt;&gt; s2 = 'Hello, \'Adam\''</span><br><span class="line">&gt;&gt;&gt; s3 = r'Hello, "Bart"'</span><br><span class="line">&gt;&gt;&gt; s4 = r'''Hello,</span><br><span class="line">... Lisa!'''</span><br><span class="line">&gt;&gt;&gt; print(n\n,f,s1,s2,s3,s4)</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    print(n\n,f,s1,s2,s3,s4)</span><br><span class="line">            ^</span><br><span class="line">SyntaxError: unexpected character after line continuation character</span><br><span class="line">&gt;&gt;&gt; n = 123</span><br><span class="line">&gt;&gt;&gt; f = 456.789</span><br><span class="line">&gt;&gt;&gt; s1 = 'Hello, world'</span><br><span class="line">&gt;&gt;&gt; s2 = 'Hello, \'Adam\''</span><br><span class="line">&gt;&gt;&gt; s3 = r'Hello, "Bart"'</span><br><span class="line">&gt;&gt;&gt; s4 = r'''Hello,</span><br><span class="line">... Lisa!'''</span><br><span class="line">&gt;&gt;&gt; print(n\t,f,s1,s2,s3,s4)</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    print(n\t,f,s1,s2,s3,s4)</span><br><span class="line">            ^</span><br><span class="line">SyntaxError: unexpected character after line continuation character</span><br><span class="line">&gt;&gt;&gt; n = 123</span><br><span class="line">&gt;&gt;&gt; f = 456.789</span><br><span class="line">&gt;&gt;&gt; s1 = 'Hello, world'</span><br><span class="line">&gt;&gt;&gt; s2 = 'Hello, \'Adam\''</span><br><span class="line">&gt;&gt;&gt; s3 = r'Hello, "Bart"'</span><br><span class="line">&gt;&gt;&gt; s4 = r'''Hello,</span><br><span class="line">... Lisa!'''</span><br><span class="line">&gt;&gt;&gt; print('n\n,f,s1,s2,s3,s4')</span><br><span class="line">n</span><br><span class="line">,f,s1,s2,s3,s4</span><br><span class="line">&gt;&gt;&gt; ord('A')</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord('中')</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">'B'</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">'B'</span><br><span class="line">&gt;&gt;&gt; '\u4e2d\u6587'</span><br><span class="line">'中文'</span><br><span class="line">&gt;&gt;&gt; x = b'ABC'</span><br><span class="line">&gt;&gt;&gt; 'ABC'.encode('ascii')</span><br><span class="line">b'ABC'</span><br><span class="line">&gt;&gt;&gt; '中文'.encode('UTF-8')</span><br><span class="line">b'\xe4\xb8\xad\xe6\x96\x87'</span><br><span class="line">&gt;&gt;&gt; '中文'.encode('ascii')</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)</span><br><span class="line">&gt;&gt;&gt; b'ABC'.decode('UTF-8')</span><br><span class="line">'ABC'</span><br><span class="line">&gt;&gt;&gt; len('中文')</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; len('中文'.encode('utf-8'))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; 'Hello, %s' % 'world'</span><br><span class="line">'Hello, world'</span><br><span class="line">&gt;&gt;&gt; 'Hello,%s' &amp; 'world'</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) for &amp;: 'str' and 'str'</span><br><span class="line">&gt;&gt;&gt; 'Hello,%s' %'world'</span><br><span class="line">'Hello,world'</span><br><span class="line">&gt;&gt;&gt; 'Hi,&amp;s,You have %d$' %('Meter',100000)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">TypeError: %d format: a real number is required, not str</span><br><span class="line">&gt;&gt;&gt; 'Hi,%s,You have %d$' %('Meter',100000)</span><br><span class="line">'Hi,Meter,You have 100000$'</span><br><span class="line">&gt;&gt;&gt; 'Hi,&amp;s,You have %d$' %('Meter',100000)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">TypeError: %d format: a real number is required, not str</span><br><span class="line">&gt;&gt;&gt; print('%2d-%02d' % (3, 1))</span><br><span class="line"> 3-01</span><br><span class="line">&gt;&gt;&gt; print('%.2f' % 3.1415926)</span><br><span class="line">3.14</span><br><span class="line">&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)</span><br><span class="line">'Age: 25. Gender: True'</span><br><span class="line">&gt;&gt;&gt; 'growth rate: %d %%' % 7</span><br><span class="line">'growth rate: 7 %'</span><br><span class="line">&gt;&gt;&gt; '中文'.encode('gb2312')</span><br><span class="line">b'\xd6\xd0\xce\xc4'</span><br><span class="line">&gt;&gt;&gt; 'Hello,{0}的成绩提高了{1:.1f}'.format('小明',17.125)</span><br><span class="line">'Hello,小明的成绩提高了17.1'</span><br><span class="line">&gt;&gt;&gt; print(f'^Z')</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt; s = '小明'</span><br><span class="line">&gt;&gt;&gt; a = '85'</span><br><span class="line">&gt;&gt;&gt; print(f'Hello,{s}的成绩为{a}')</span><br><span class="line">Hello,小明的成绩为85</span><br><span class="line">&gt;&gt;&gt; s1=72</span><br><span class="line">&gt;&gt;&gt; s2=85</span><br><span class="line">&gt;&gt;&gt; rate = s1/85</span><br><span class="line">&gt;&gt;&gt; print(f'小明的成绩从去年的{s1}分提升到了今年的{s2}分，提升了{rate}%')</span><br><span class="line">小明的成绩从去年的72分提升到了今年的85分，提升了0.8470588235294118%</span><br><span class="line">&gt;&gt;&gt; s1=72</span><br><span class="line">&gt;&gt;&gt; s2=85</span><br><span class="line">&gt;&gt;&gt; rate = s1/85</span><br><span class="line">&gt;&gt;&gt; s2=85^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>PS:当<code>str</code>和<code>bytes</code>互相转换时,没有特殊要求，指定使用UTF-8编码</strong></p><h1 id="问题及解决方案"><a class="markdownIt-Anchor" href="#问题及解决方案"></a> 问题及解决方案</h1><ul><li><a href="https://blog.csdn.net/m0_52592128/article/details/120798138">Vscode提示“无法在只读编辑器中编辑”解决方法_vscode编辑器关闭只读模式-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【pid算法】[入门篇] 1-深入浅出pid控制算法原理</title>
      <link href="/posts/34110/"/>
      <url>/posts/34110/</url>
      
        <content type="html"><![CDATA[<h2 id="pid模拟调参无人机"><a class="markdownIt-Anchor" href="#pid模拟调参无人机"></a> pid模拟调参（无人机）</h2><p><a href="https://rossning92.github.io/pid-simulation/">Webpack App (rossning92.github.io)</a></p><img src="/posts/34110/image-20240512152800666.png" class="" title="image-20240512152800666"><h2 id="多环平衡小车"><a class="markdownIt-Anchor" href="#多环平衡小车"></a> 多环(平衡小车)</h2><img src="/posts/34110/image-20240512154358581.png" class="" title="image-20240512154358581"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Kp,Ki,Kd;</span><br><span class="line"><span class="type">int</span> Error;</span><br><span class="line"><span class="type">int</span> Error_old;</span><br><span class="line"><span class="type">int</span> Error_difference;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> Error_sum;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I_amplitude_limiting</span><span class="params">(<span class="type">int</span> number)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Error_sum&gt;number)</span><br><span class="line">{</span><br><span class="line">Error_sum=number;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//PID控制系统:P、I、D共同作用</span></span><br><span class="line"><span class="comment">//measure,calcu:系统的输入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PID_control</span><span class="params">(<span class="type">float</span> measure,<span class="type">float</span> calcu)</span></span><br><span class="line">{</span><br><span class="line">Error = measure - calcu;<span class="comment">//误差值</span></span><br><span class="line"></span><br><span class="line">Error_sum += Error;<span class="comment">//误差累加</span></span><br><span class="line">I_amplitude_limiting(<span class="number">2000</span>);<span class="comment">//限幅函数</span></span><br><span class="line"></span><br><span class="line">Error_difference = Error- Error_old;<span class="comment">//误差变化率(近似于对时间的微分)</span></span><br><span class="line">Error_old = Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(Kp*Error+Kd*Error_difference+Ki*Error_sum);<span class="comment">//PID控制器响应结果</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记,PID算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】红外通信系统</title>
      <link href="/posts/29338/"/>
      <url>/posts/29338/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> # 前言</h1><h2 id="一-红外通信系统"><a class="markdownIt-Anchor" href="#一-红外通信系统"></a> 一、红外通信系统</h2><h3 id="二-红外调制解调的原理"><a class="markdownIt-Anchor" href="#二-红外调制解调的原理"></a> 二、红外调制解调的原理</h3><ul><li>空闲状态：红外LED不亮，接收头输出高电平</li><li>发送低电平：红外LED以38KHz频率闪烁发光，接收头输出低电平</li><li>发送高电平：红外LED不亮，接收头输出高电平<br>总而言之，只有红外LED发送38KHZ的闪烁信号时，红外接收头OUT引脚才会对外输出低电平信号<br>红外发送–红外接收的本质是<mark>调制</mark>和<mark>解调</mark>，在这种条件下，可以过滤掉自然界中的“噪声信号”，只有38KHZ附近的红外信号才能被红外接收头识别转换为对应的低电平。</li></ul><p><strong>转换示意图：</strong><br>1.红外LED发出的信号</p><img src="/posts/29338/c97d453d8866482a8bc0a2191a565288.png" class="" title="在这里插入图片描述"><p>2.红外接收头发出的信号</p><img src="/posts/29338/3d972def937345fdb73a96eb875114b8.png" class="" title="在这里插入图片描述"><p>其中，红外接收头发出的低电平信号的宽度等价于红外LED发送的38KHz信号的时间。</p><h1 id="一-基于ccp1输入捕获模式的解调电路"><a class="markdownIt-Anchor" href="#一-基于ccp1输入捕获模式的解调电路"></a> 一、基于CCP1输入捕获模式的解调电路</h1><h2 id="1-proteus生成基带信号"><a class="markdownIt-Anchor" href="#1-proteus生成基带信号"></a> 1. Proteus生成基带信号</h2><img src="/posts/29338/image-20240511143825355.png" class="" title="image-20240511143825355"><h3 id="11脉冲最小单位"><a class="markdownIt-Anchor" href="#11脉冲最小单位"></a> 1.1脉冲最小单位</h3><img src="/posts/29338/image-20240511143912266.png" class="" title="image-20240511143912266"><h3 id="12特定脉冲序列"><a class="markdownIt-Anchor" href="#12特定脉冲序列"></a> 1.2特定脉冲序列</h3><img src="/posts/29338/image-20240511143937021.png" class="" title="image-20240511143937021"><img src="/posts/29338/image-20240519153450824.png" class="" title="image-20240519153450824"><p><strong>从左往右表示数据从高位到低位，如图所示为01001101</strong></p><h3 id="13仿真结果"><a class="markdownIt-Anchor" href="#13仿真结果"></a> 1.3仿真结果</h3><img src="/posts/29338/image-20240519153542254.png" class="" title="image-20240519153542254"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;<span class="comment">//接收数据储存变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获模式接收信号跳变*/</span></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次接收信号为下跳变</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;</span><br><span class="line">CCP1CON=<span class="number">0X05</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//本次接收信号为上跳变</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0</span> &amp;&amp; CCPR1H == <span class="number">0X00</span>){B=B&lt;&lt;<span class="number">1</span>;}<span class="comment">//'0'</span></span><br><span class="line"><span class="keyword">if</span>(CCPR1L &lt; <span class="number">0X50</span> &amp;&amp; CCPR1H == <span class="number">0X01</span>){B=B&lt;&lt;<span class="number">1</span>;B=B+<span class="number">1</span>;}  <span class="comment">//'1'</span></span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0XA0</span> &amp;&amp; CCPR1H == <span class="number">0X01</span>){PORTB = B;}  <span class="comment">//结束信号，电平宽度匹配时表示完整接收到1Byte数据</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;<span class="comment">//清空寄存器</span></span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;<span class="comment">//中断相关寄存器配置</span></span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line">B=<span class="number">0</span>;TRISB=<span class="number">0</span>; PORTB=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//开启定时器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二-基于ccp1输出比较模式的基带信号生成电路"><a class="markdownIt-Anchor" href="#二-基于ccp1输出比较模式的基带信号生成电路"></a> 二、基于CCP1输出比较模式的基带信号生成电路</h1><h2 id="1mpalb波形显示窗口显示rc2产生的基带信号"><a class="markdownIt-Anchor" href="#1mpalb波形显示窗口显示rc2产生的基带信号"></a> 1.MPALB波形显示窗口，显示RC2产生的基带信号</h2><img src="/posts/29338/image-20240519155221573.png" class="" title="image-20240519155221573"><h2 id="2代码解释"><a class="markdownIt-Anchor" href="#2代码解释"></a> 2.代码解释</h2><p><strong>CCP1模块每次发送1位二进制的负脉冲宽度，每次循环从data左移一位。PIC单片机C语言循环移位语句用汇编语句asm(“rlf _data,f”)，每次将最高位移入CARRY寄存器中，以最高的程序执行效率进行数据移位并生成基带信号的操作，并且每次发送1位二进制负脉冲宽度之后，会发送1位同步头的正脉冲宽度。发送完所有二进制数据之后，发送1位结束头低电平宽度</strong></p><img src="/posts/29338/image-20240519155522173.png" class="" title="image-20240519155522173"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data,data_cnt;<span class="comment">//发送的二进制代码，代码长度</span></span><br><span class="line"><span class="type">char</span> IR_SendSelect;</span><br><span class="line">bit a;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a=!a;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RC7=<span class="number">0</span>;</span><br><span class="line">data_cnt--;<span class="comment">//低电平。二进制代码位数减1</span></span><br><span class="line"><span class="keyword">if</span>(data_cnt == <span class="number">0</span>) <span class="keyword">goto</span> period_delty;<span class="comment">//位数为0，全部发送完，转624us延时</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"rlf _data,f"</span>);<span class="comment">//未发送完，取下一位待发送数据（数据移入CARRY中）</span></span><br><span class="line"><span class="keyword">if</span>(CARRY == <span class="number">1</span>) <span class="keyword">goto</span> data_5eh;<span class="comment">//待发送数据=1</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//待发送数据=0,叠加低电平时长68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;</span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">data_5eh:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X38</span>;<span class="comment">//待发送数据=1,叠加低电平时长138H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">1</span>;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">period_delty:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X70</span>;<span class="comment">//叠加624us的延时参数270H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">2</span>;<span class="comment">//高位字节加2及低位叠加时的进位和</span></span><br><span class="line">data=<span class="number">0B</span>01001101;<span class="comment">//=PORTB //从PORTB取数据</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;</span><br><span class="line">ret_fie:</span><br><span class="line">CCP1M0=<span class="number">0</span>;<span class="comment">//下次匹配时输出高电平</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//叠加同步头的延时参数68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line">CCP1M0=<span class="number">1</span>;<span class="comment">//下次匹配时输出低电平</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">nRBPU=<span class="number">0</span>;<span class="comment">//启用RB弱上拉</span></span><br><span class="line">TRISB=<span class="number">0xFF</span>;<span class="comment">//作输入口</span></span><br><span class="line">TRISC2=<span class="number">0</span>;<span class="comment">//C口定义为输入口，只定义RC2作为输出</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;<span class="comment">//设置预分频比为 = 1:1,开中断</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;<span class="comment">//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line">CCP1CON = <span class="number">0X08</span>;<span class="comment">//CCP1设为匹配时令CCP1/RC2引脚输出高电平</span></span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//启动TMR1</span></span><br><span class="line">data = <span class="number">0B</span>01001101;<span class="comment">//=PORTB;从PORTB取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三-将基带电路与调制电路配合组成简易的红外通信系统"><a class="markdownIt-Anchor" href="#三-将基带电路与调制电路配合组成简易的红外通信系统"></a> 三、将基带电路与调制电路配合，组成简易的红外通信系统</h1><p><strong>如图所示，因为RC2输出的红外基带信号带有毛刺，所以这里改为RC7引脚输出基带信号，这样，就能组成一个完整的红外发送-接收系统，运行仿真，此时红外接收端的LED同与发送端PORTB的逻辑</strong></p><img src="/posts/29338/image-20240519161843951.png" class="" title="image-20240519161843951"><h1 id="四-配合ccp1输出比较和ccp2-pwm输出模式构成载波-调制信号"><a class="markdownIt-Anchor" href="#四-配合ccp1输出比较和ccp2-pwm输出模式构成载波-调制信号"></a> 四、配合CCP1输出比较和CCP2 PWM输出模式，构成载波-调制信号</h1><p><strong>MPLAB仿真观测调制信号，与原基带信号进行对比，验证代码现象</strong></p><p><strong>调制信号在图像上有些地方在同步头结束后为高电平，但在经过红外发送管之后，发送的信号依然对应者基带信号的波形，所以实际上并没有影响</strong></p><img src="/posts/29338/image-20240514130203460.png" class="" title="image-20240514130203460"><h1 id="五-实物测试部分"><a class="markdownIt-Anchor" href="#五-实物测试部分"></a> 五、实物测试部分</h1><h2 id="1红外二极管收发"><a class="markdownIt-Anchor" href="#1红外二极管收发"></a> 1.红外二极管收发</h2><h3 id="使用电压表测试红外接收管压降"><a class="markdownIt-Anchor" href="#使用电压表测试红外接收管压降"></a> <mark>使用电压表测试红外接收管压降</mark></h3><img src="/posts/29338/b8287e8289bf096bd5da1196ff211612.jpg" class="" title="b8287e8289bf096bd5da1196ff211612"><h2 id="2测试红外接收模块是否能被触发"><a class="markdownIt-Anchor" href="#2测试红外接收模块是否能被触发"></a> 2.测试红外接收模块是否能被触发</h2><ul><li><mark><strong>首先测试能否顺利进入中断，用PIC板载LED进行观测，每次进入中断，代表接收到一次38KHZ的红外信号，同时PIC板的八位LED进行取反闪烁</strong></mark></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;</span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line">PORTD^=<span class="number">0xFF</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">if(CCPR1L &gt; 0 &amp;&amp; CCPR1H == 0X00){B=B&lt;&lt;1;}//'0'==0x685</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X01){B=B&lt;&lt;1;B=B+1;}  //'1'==0x12C</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X02){PORTD = B;}  //结束信号==0x270</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;</span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;</span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line">B=<span class="number">0</span>;TRISD=<span class="number">0</span>; PORTD=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3仿真软件测量接收信号时选定捕捉每个bit数据的范围"><a class="markdownIt-Anchor" href="#3仿真软件测量接收信号时选定捕捉每个bit数据的范围"></a> 3.仿真软件测量接收信号时，选定捕捉每个bit数据的范围</h2><h3 id="31-程序调试使得红外传输系统更加精确稳定"><a class="markdownIt-Anchor" href="#31-程序调试使得红外传输系统更加精确稳定"></a> 3.1 程序调试，使得红外传输系统更加精确稳定</h3><p><mark><strong>虽然在红外调制电路代码中，我们指定了每个二进制数据，停止位，起始位的电平长度，但是，因为程序设计以及单片机响应速度的原因，我们并不知道它最终生成信号各个部分的电平宽度具体值，如果将编写好的程序直接拿来用，可能得不到任何想要的现象。因此，要通过测量红外解调电路实际获取到的各个二进制电平的长度（通过LCD1602显示），然后再修改程序，使得红外接收单片机能够稳定接收红外发送单片机发送的信号。</strong></mark></p><p><strong>下面为用于测试接收端接收到各个bit数据电平宽度的代码，如：控制发送端发送的数据为0x00，然后接收端这边进行对’0’的电平宽度测量，显示在LCD1602上，其他任意宽度的bit位也是同理</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;</span><br><span class="line"><span class="type">int</span> Time_Data;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//PORTD^=0xFF;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次捕捉下降沿</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;</span><br><span class="line">CCP1CON=<span class="number">0X05</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>; Time_Data = CCPR1H &lt;&lt; <span class="number">8</span> | CCPR1L;</span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0</span> &amp;&amp; CCPR1H == <span class="number">0X00</span>){LCD1602_WriteNum(<span class="number">1</span>,<span class="number">0</span>,Time_Data,<span class="number">5</span>);CCP1IE=<span class="number">0</span>;}<span class="comment">//55</span></span><br><span class="line"><span class="comment">//if(CCPR1H == 0X01){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//263</span></span><br><span class="line"><span class="comment">//if(CCPR1H == 0X02){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)//本次捕捉下降沿</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;//清零TMR1寄存器值</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//下一次捕捉上升沿</span></span><br><span class="line"><span class="comment">CCP1IF=0;//清除输入捕捉标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;//下一次捕捉下降沿</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">if(CCPR1L &gt; 0 &amp;&amp; CCPR1H == 0X00){B=B&lt;&lt;1;}//0'068</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X01){B=B&lt;&lt;1;B=B+1;}  //'1'==0x12C</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X02){PORTD = B;}  //结束信号==0x270</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISD=<span class="number">0X00</span>;<span class="comment">//数据口</span></span><br><span class="line">    TRISA=<span class="number">0x00</span>;<span class="comment">//RA0配置为输出模式</span></span><br><span class="line">ADCON1=<span class="number">0X07</span>;<span class="comment">//RA端口与AD转换有关！！！，不然无法正常显示LCD1602</span></span><br><span class="line">LCD1602_Init();</span><br><span class="line">LCD1602_WriteString(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"OK"</span>);</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;</span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;</span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line"></span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line"></span><br><span class="line">B=<span class="number">0</span>;TRISD=<span class="number">0</span>; PORTD=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/29338/image-20240514001540423.png" class="" title="image-20240514001540423"><h2 id="发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据"><a class="markdownIt-Anchor" href="#发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据"></a> 发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据</h2><p><strong>如图所示，发送连续三个Byte的一帧数据</strong></p><img src="/posts/29338/image-20240514015916078.png" class="" title="image-20240514015916078"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data,data_cnt;<span class="comment">//发送的二进制代码，代码长度</span></span><br><span class="line"><span class="type">char</span> IR_SendSelect;</span><br><span class="line"><span class="type">char</span> measure_Flag;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1_HighByte;<span class="comment">//CCP1高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1_LowByte;<span class="comment">//CCP1低字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Over_Counter=<span class="number">0</span>;<span class="comment">//溢出计数值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Over_Counter_temp;<span class="comment">//溢出计数暂存值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1IF_TriggerFlag;<span class="comment">//CCP1中断触发标志位</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> TABLE[<span class="number">16</span>]={<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>,<span class="number">0x46</span>};</span><br><span class="line"><span class="type">char</span> Send_Counter;<span class="comment">//发送字节次数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Cycle;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data_new;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Cycle;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data_M;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稳定数据滤波器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">data_filter</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">T_data_new.Data[<span class="number">0</span>]=Over_Counter;</span><br><span class="line">T_data_new.Data[<span class="number">1</span>]=CCP1_HighByte;</span><br><span class="line">T_data_new.Data[<span class="number">2</span>]=CCP1_LowByte;</span><br><span class="line"></span><br><span class="line">T_data_M.Data[i++]= T_data_new.Cycle;</span><br><span class="line">i%=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T_data_M.Data[<span class="number">0</span>]==T_data_M.Data[<span class="number">1</span>] &amp;&amp; T_data_M.Data[<span class="number">1</span>] == T_data_M.Data[<span class="number">2</span>])<span class="comment">//当三次取值相等时，才为有效值</span></span><br><span class="line">{</span><br><span class="line">T_data.Cycle=T_data_new.Cycle;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(measure_Flag == 0)//为周期测量模式</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(TMR1IF==1)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">Over_Counter_temp++;//累加TMR1的溢出次数</span></span><br><span class="line"><span class="comment">TMR1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else if(CCP1IF==1)//判断是不是由CCP1引起的中断</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1IF_TriggerFlag^=1;//标志位取反</span></span><br><span class="line"><span class="comment">if(CCP1IF_TriggerFlag==1)//第一次捕捉到跳变</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;//清除定时器0计数寄存器值</span></span><br><span class="line"><span class="comment">TMR1L=0;</span></span><br><span class="line"><span class="comment">TMR1ON=1;//定时器1开始计时</span></span><br><span class="line"><span class="comment">CCP1IF=0;//清除中断标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else//第二次捕捉到跳变</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CCP1_LowByte=CCPR1L+31;//校准值</span></span><br><span class="line"><span class="comment">CCP1_HighByte=CCPR1H+CARRY;//加上进位标志位</span></span><br><span class="line"><span class="comment">Over_Counter=Over_Counter_temp;//将计数溢出暂存值赋值给显示值</span></span><br><span class="line"><span class="comment">data_filter();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Over_Counter_temp=0;//清除计数溢出暂存值</span></span><br><span class="line"><span class="comment">TMR1H=0;//清除定时器0计数寄存器值</span></span><br><span class="line"><span class="comment">TMR1L=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">LCD1602_WriteCommand(0x80);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[0]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[0]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[1]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[1]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[2]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[2]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData('H');</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TMR1ON=0;//定时器1停止计时</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*PWM,输出比较配置</span></span><br><span class="line"><span class="comment">T2CON=0;PR2=25;TMR2=0;//TMR2初始化，周期26us</span></span><br><span class="line"><span class="comment">CCP2CON=0X0C;</span></span><br><span class="line"><span class="comment">CCPR2L=13;//CCP2初始化，脉宽13us</span></span><br><span class="line"><span class="comment">T1CON=0;//设置预分频比为 = 1:1,开中断</span></span><br><span class="line"><span class="comment">data_cnt = 0x09;//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line"><span class="comment">CCP1CON = 0X08;//CCP1设为匹配时令CCP1/RC2引脚输出电平不变</span></span><br><span class="line"><span class="comment">TMR1ON=1;//启动TMR1</span></span><br><span class="line"><span class="comment">measure_Flag=1;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(measure_Flag == <span class="number">0</span>)<span class="comment">//将测量值发送(PWM(CCP2),输出比较(CCP1))</span></span><br><span class="line">{</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCP1M0==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RC7=<span class="number">0</span>;</span><br><span class="line">CCP2CON=<span class="number">0x00</span>;</span><br><span class="line">data_cnt--;<span class="comment">//低电平。二进制代码位数减1</span></span><br><span class="line"><span class="keyword">if</span>(data_cnt == <span class="number">0</span>){<span class="keyword">goto</span> period_delty;} <span class="comment">//位数为0，全部发送完，转624us延时</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"rlf _data,f"</span>);<span class="comment">//未发送完，取下一位待发送数据（数据移入CARRY中）</span></span><br><span class="line"><span class="keyword">if</span>(CARRY == <span class="number">1</span>) <span class="keyword">goto</span> data_5eh;<span class="comment">//待发送数据=1</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X04</span>;<span class="comment">//待发送数据=0,叠加低电平时长68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">data_5eh:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X18</span>;<span class="comment">//待发送数据=1,叠加低电平时长138H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">4</span>;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">period_delty:</span><br><span class="line">Send_Counter++;</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0XC0</span>;<span class="comment">//叠加624us的延时参数270H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">9</span>;<span class="comment">//高位字节加2及低位叠加时的进位和</span></span><br><span class="line">data=<span class="number">0B</span>10101001;<span class="comment">//=PORTB //从PORTB取数据</span></span><br><span class="line">data_cnt = <span class="number">9</span>;</span><br><span class="line">ret_fie:</span><br><span class="line">CCP1M0=<span class="number">0</span>;<span class="comment">//下次匹配时输出高电平</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCP2CON=<span class="number">0X0C</span>;</span><br><span class="line">RC7=<span class="number">1</span>;TMR2ON=<span class="number">1</span>;<span class="comment">//同步头时间，启动PWM信号输出</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//叠加同步头的延时参数68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line">CCP1M0=<span class="number">1</span>;<span class="comment">//下次匹配时输出低电平</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Send_Counter &gt;= <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">Send_Counter=<span class="number">0</span>;</span><br><span class="line">measure_Flag = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CCP1IF=0;//CCP标志位清零</span></span><br><span class="line"><span class="comment">TMR1IE=1;//定时器1中断使能</span></span><br><span class="line"><span class="comment">TMR1IF=0;//定时器1中断标志位清零</span></span><br><span class="line"><span class="comment">T1CON=0B00000000;//TMR1为定时器，预分频比1:1,不启动定时器1</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//使能CCP1捕捉每一个输入信号的上升沿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">TMR1ON=<span class="number">0</span>;<span class="comment">//关闭定时器1</span></span><br><span class="line">CCP2CON=<span class="number">0X00</span>;<span class="comment">//关闭PWM</span></span><br><span class="line">CCP1CON=<span class="number">0X00</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Send_Counter=<span class="number">0</span>;</span><br><span class="line">nRBPU=<span class="number">0</span>;<span class="comment">//启用RB弱上拉</span></span><br><span class="line">TRISB=<span class="number">0xFF</span>;<span class="comment">//作输入口</span></span><br><span class="line">TRISC7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;<span class="comment">//PWM信号（载波）输出引脚</span></span><br><span class="line">TRISC2=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">TRISD=<span class="number">0X00</span>;<span class="comment">//数据口</span></span><br><span class="line">    TRISA=<span class="number">0x00</span>;<span class="comment">//RA0配置为输出模式</span></span><br><span class="line">ADCON1=<span class="number">0X07</span>;<span class="comment">//RA端口与AD转换有关！！！，不然无法正常显示LCD1602 </span></span><br><span class="line">LCD1602_Init();</span><br><span class="line">LCD1602_WriteString(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CCP中断配置*/</span></span><br><span class="line">GIE=<span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">PEIE=<span class="number">1</span>;<span class="comment">//第二梯队中断打开</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;<span class="comment">//CCP中断打开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*周期测量</span></span><br><span class="line"><span class="comment">CCP1IF=0;//CCP标志位清零</span></span><br><span class="line"><span class="comment">TMR1IE=1;//定时器1中断使能</span></span><br><span class="line"><span class="comment">TMR1IF=0;//定时器1中断标志位清零</span></span><br><span class="line"><span class="comment">T1CON=0B00000000;//TMR1为定时器，预分频比1:1,不启动定时器1</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//使能CCP1捕捉每一个输入信号的上升沿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">T2CON=<span class="number">0</span>;PR2=<span class="number">25</span>;TMR2=<span class="number">0</span>;<span class="comment">//TMR2初始化，周期26us</span></span><br><span class="line">CCP2CON=<span class="number">0X0C</span>;</span><br><span class="line">CCPR2L=<span class="number">13</span>;<span class="comment">//CCP2初始化，脉宽13us</span></span><br><span class="line">T1CON=<span class="number">0</span>;<span class="comment">//设置预分频比为 = 1:1,开中断</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;<span class="comment">//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line">CCP1CON = <span class="number">0X08</span>;<span class="comment">//CCP1设为匹配时令CCP1/RC2引脚输出电平不变</span></span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//启动TMR1</span></span><br><span class="line"></span><br><span class="line">data = PORTB;<span class="comment">//=PORTB;从PORTB取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="猜测同步头的宽窄导致信号处理出现错误数据"><a class="markdownIt-Anchor" href="#猜测同步头的宽窄导致信号处理出现错误数据"></a> 猜测：同步头的宽窄，导致信号处理出现错误数据</h2><img src="/posts/29338/image-20240514130203460.png" class="" title="image-20240514130203460"><p><strong>解决方案：<mark>调整同步头宽度。每Byte数据需要等待一定的时间</mark></strong></p><h2 id="仿真测试结果没有完整移入数据实际上只接收到了7位"><a class="markdownIt-Anchor" href="#仿真测试结果没有完整移入数据实际上只接收到了7位"></a> 仿真测试结果：没有完整移入数据，实际上只接收到了7位</h2><img src="/posts/29338/image-20240514160814051.png" class="" title="image-20240514160814051"><p><strong>更改输入捕获中断内对各个二进制捕获的电平时间范围，使得红外解调的容允值更大，修改后，代码如下</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data_RecByte;</span><br><span class="line"><span class="type">int</span> Time_Data;</span><br><span class="line">bit Data_RecFlag;</span><br><span class="line"><span class="type">char</span> i;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> TABLE[<span class="number">16</span>]={<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>,<span class="number">0x46</span>};</span><br><span class="line">bit Start_Flag;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">5</span>];</span><br><span class="line">}T_Data_Rec;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//PORTD^=0xFF;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)//本次捕捉下降沿</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;</span></span><br><span class="line"><span class="comment">CCP1IF=0; Time_Data = CCPR1H &lt;&lt; 8 | CCPR1L;</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 400  &amp;&amp; Time_Data&lt; 500){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//55</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 800  &amp;&amp; Time_Data&lt; 1000){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//263</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 2300  &amp;&amp; Time_Data&lt; 2600){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line"><span class="comment">if(Time_Data &gt; 2900 ){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次捕捉下降沿</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;<span class="comment">//清零TMR1寄存器值</span></span><br><span class="line">CCP1CON=<span class="number">0X05</span>;<span class="comment">//下一次捕捉上升沿</span></span><br><span class="line">CCP1IF=<span class="number">0</span>;<span class="comment">//清除输入捕捉标志位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//本次捕捉上升沿</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//下一次捕捉下降沿</span></span><br><span class="line">CCP1IF=<span class="number">0</span>;Time_Data = CCPR1H &lt;&lt; <span class="number">8</span> | CCPR1L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;<span class="number">3200</span>){Start_Flag=<span class="number">1</span>;}  <span class="comment">//开始信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Flag)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">400</span>  &amp;&amp; Time_Data &lt;= <span class="number">500</span>){Data_RecByte=Data_RecByte&lt;&lt;<span class="number">1</span>;}<span class="comment">//0'068</span></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">800</span>  &amp;&amp; Time_Data&lt;= <span class="number">1200</span>){Data_RecByte=Data_RecByte&lt;&lt;<span class="number">1</span>;Data_RecByte=Data_RecByte+<span class="number">1</span>;} <span class="comment">//'1'</span></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">2200</span>  &amp;&amp; Time_Data&lt;= <span class="number">2500</span>){T_Data_Rec.Data[i++] = Data_RecByte;Start_Flag=<span class="number">0</span>;}  <span class="comment">//结束信号</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">{</span><br><span class="line">LCD1602_WriteNum(<span class="number">2</span>,<span class="number">0</span>,Time_Data,<span class="number">5</span>);</span><br><span class="line">LCD1602_WriteCommand(<span class="number">0x80</span>);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">0</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">0</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">1</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">1</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">2</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">2</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">3</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">3</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">4</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">4</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(<span class="string">'H'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>最终结果：实现了连续5Byte数据的接收</strong></p><img src="/posts/29338/image-20240514160944486.png" class="" title="image-20240514160944486"><h1 id="自定义通信协议"><a class="markdownIt-Anchor" href="#自定义通信协议"></a> 自定义通信协议</h1><p><strong><mark>在完整的红外传输系统工作在稳定可靠的状态后，我们可以拓展一些功能，如自己定义一个红外传输协议，使得单片机之间的红外通信能够实现更加复杂的功能，一次性能够传输更多的数据。</mark></strong></p><ul><li><p>添加一个起始位，长度位结束位的两倍</p></li><li><p>xxxxxxxxxx&nbsp;#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#include&lt;math.h&gt;​//写一个代码,打印100~200之间的素数//素数-质数//只能被1和他本身整除​//代码优化1：//m=a<em>b;//a和b中一定至少有一个数字是 &lt;=开平方m的//16 = 2</em>8 = 4*4//所以，大于开平方m的就不需要判断是否为m的因子，减少循环执行次数​//sqrt用于计算开平方的函数 -需要用到库函数 math.h//减少了循环的执行次数​//代码优化2：//偶数不可能是素数//修改for (i = 100; i &lt;= 200; i <ins>)为for (i = 101; i &lt;= 200; i += 2)​int main(){    int i, j = 0;​    //判断i是不是质数    for (i = 101; i &lt;= 200; i += 2)    {        int flag = 1;//定义一个参数，检测i是否能被 除了1和它本身的数 整除​        for (j = 2; j &lt;= sqrt(i); j</ins>)        {            if (i % j == 0)            {                flag = 0;//如果能被2到i-1之间的整除，记录flag=0;                //break;            }        }​        if (flag == 1)//不能被2到i-1之间的数整除        {            printf("%d是质数\n", i);//那么i就是质数        }    }    return 0;}c</p><ul><li>起始位：0xC30</li><li>‘0’: 0x204</li><li>‘1’:0x418</li><li>结束位:0x9C0</li></ul></li><li><p>修改同步头宽度，因为在实际使用红外通信时，单片机产生的红外信号可能没有那么理想，红外发射头发送出去的信号会衰减，因此我们可以适当增加同步头宽度，提高红外调制信号的“功率”，使得红外接收头能够正常接收到红外信号</p></li></ul><h1 id="周期信号测量红外收发系统"><a class="markdownIt-Anchor" href="#周期信号测量红外收发系统"></a> 周期信号测量+红外收发系统</h1><img src="/posts/29338/image-20240519165157774.png" class="" title="image-20240519165157774"><h1 id="红外双发双收双工系统"><a class="markdownIt-Anchor" href="#红外双发双收双工系统"></a> 红外双发双收（双工系统）</h1><img src="/posts/29338/image-20240519170223726.png" class="" title="image-20240519170223726"><h1 id="红外双工中继基站系统"><a class="markdownIt-Anchor" href="#红外双工中继基站系统"></a> 红外双工+中继基站系统</h1><p><strong><mark>如图所示，红外收发装置通过中继系统进行数据通信</mark></strong></p><img src="/posts/29338/image-20240519173118590.png" class="" title="image-20240519173118590"><h1 id="心得体会"><a class="markdownIt-Anchor" href="#心得体会"></a> 心得体会</h1><p>我在本次小组任务中，首先学习了红外通信系统的基本组成结构，了解了通信系统中调制/解调的原理以及实现方法。基于对第九章各个例子以及习题的学习以及编写相关代码，我熟悉了CCP模块的输入捕获、输出比较、PWM模式的工作原理。通过将这些模块组合，协同工作，在代码中利用定义的各个“标志位"，配置好了这些CCP各个功能模块协同工作的代码结构。</p><p>在准备进行本次小组任务的工作前，我们首先大概预览了一下本次小组任务需要用到的知识点，因为整个红外通信系统的构成需要多个单片机协同工作，所以必须要循循渐进地进行代码的编写、调试、验证。为了设计出最终包含红外双工通信+中继器的复杂系统，我们首先编写完成了一个简易的红外通信系统，不过这个系统的信号发送端发送的是基带信号，没有经过红外管，直接送给接收端单片机进行信号的解调。虽然我们在发送端设置好了各个不同数据位的电平宽度，比如’0‘，’1‘，’停止位‘的电平宽度有按照一定的比例用于区分，但课本上一开始给的例子，各个数据位电平宽度仅仅在微妙级，不管是仿真还是实物验证接收端都有可能无法解调出正确的信号，因为这些数据位的电平宽度太短，没有明显的区分度，一旦程序运行效率不行或者单片机电路上的微小延迟都有可能造成数据读取的错误。因此，我们等比例放大了每个数据位的电平宽度，以及同步头的宽度（保证调制信号的功率）。这样的话，不同bit的区分度就大大提高了。然后，我们自己再编写一段调试代码，即接收到任意的上边沿+下边沿的输入捕获，输出端改为固定指定的数据位发送，然后在接收端那边通过LCD1602显示实际上捕获到的电平宽度，这样就能知道红外接收端实际容允的电平宽度范围，确保整个红外通信系统的稳定性。</p><p>本次小组任务，更像一个小课程设计，我们设计出了一个功能完备的红外通信系统，在每个阶段的调试过程中，我们遇到了很多的问题，这些问题大多数是由于寄存器的配置引起的（因为单片机中CCP各个模块要协同工作，这就涉及到大量寄存器的状态切换），一旦寄存器配置冲突，而我们又不熟悉寄存器，就无法认识到代码的问题所在。我们通过MPLAB强大轻量化的Debug窗口，以及Proteus的调试功能，反复验证，循序渐进，最终设计出来了一个具备双工通信+中继器（基站）的完备通信系统，并且我们的通信系统可以通过修改代码中的参数实现连续任意位Byte的收发。</p><p>本次小组任务是有挑战性的，但是这也为我们后续学习更多复杂的通信系统打下基础。我们学会了化繁为简，分模块和层次，熟练配置单片机上所有相关功能寄存器的技巧，这不仅是我们单片机编程、电路系统设计技术上的显著提升，也是对理论基础是否扎实的考验。我想，通过本次小组任务，我们可以设计出各种功能强大，效率高的通信系统，利用自身专业编写出完备的通信协议等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HEXO】[2] 多线程部署常见问题</title>
      <link href="/posts/45608/"/>
      <url>/posts/45608/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo更新日志"><a class="markdownIt-Anchor" href="#hexo更新日志"></a> HEXO更新日志</h1><p><strong>2024.5.3</strong></p><ul><li>重要更新：将HEXO博客部署到腾讯云轻量化服务器，极大提升国内访问速度，访问ip地址：<a href="http://122.51.23.7/">Turin’s Blog - 数理照亮世界</a></li><li>优化主页文章卡片界面，参考文章：<a href="https://butterfly.zhheo.com/home.html">首页 | Butterfly主题美化教程 (zhheo.com)</a></li><li>优化网站页面显示效果：透明度。<a href="https://qianchenggit.github.io/2021/10/06/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E4%BD%BF%E7%94%A8%E4%B8%80%E5%9B%BE%E6%B5%81/">博客背景使用一图流 | QianChengGit の小森林</a></li></ul><hr><p>xxxxxxxxxx&nbsp;git remote add [alias] [url]//参数[alias]为别名， [url]为远程仓库的地址bash</p><h1 id="一-hexo部署到云服务器ubuntu系统"><a class="markdownIt-Anchor" href="#一-hexo部署到云服务器ubuntu系统"></a> 一、HEXO部署到云服务器(Ubuntu系统)</h1><p><strong><a href="https://cloud.tencent.com/developer/article/1945550">Hexo部署至服务器（Ubuntu 20.04）-腾讯云开发者社区-腾讯云 (tencent.com)</a></strong></p><p><strong><a href="https://blog.cpen.top/posts/38874.html">04_Hexo-多平台部署-云服务器-GitHub-Gitee | Mycpen</a></strong></p><h1 id="二-ubuntu允许root连接服务器"><a class="markdownIt-Anchor" href="#二-ubuntu允许root连接服务器"></a> 二、Ubuntu允许root连接服务器</h1><p><a href="https://blog.csdn.net/crayon0/article/details/122272001">Linux开启ssh并允许root登录（ubuntu、centos、kalilinux）_ssh允许root远程登录-CSDN博客</a></p><blockquote><p>报错信息 “E45: ‘readonly’ option is set (add ! to override)” 是在使用 Vim 或 Neovim 文本编辑器时可能遇到的一个错误信息。当您尝试将更改写入以只读模式打开的文件时，就会出现这条信息。这种情况可能由几个原因引起，例如，您正在编辑的文件在文件系统级别启用了写保护，或者 Vim 打开了一个它认为不应该修改的文件（例如，系统配置文件或标记为“只读”的文件）。</p><p>要解决这个问题并强制 Vim 或 Neovim 尽管文件处于只读状态也要写入更改，您可以使用 <code>:w!</code> 命令，其中 <code>w</code> 代表“写入”，<code>!</code> 实际上意味着“强制”或“覆盖”。</p><p>下面是如何处理这种情况：</p><h3 id="如果您打算修改文件"><a class="markdownIt-Anchor" href="#如果您打算修改文件"></a> 如果您打算修改文件</h3><ol><li><p><strong>强制保存更改</strong>：如果您知道文件是安全可编辑的，且打算保存更改，可以使用 <code>:w!</code> 命令强制保存更改。这告诉 Vim 覆盖只读限制。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w!</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>更改文件权限</strong>：如果文件是只读的是因为文件系统权限，您可能需要在 Vim 外部更改其权限。例如，在类 Unix 系统（Linux、macOS）上，您可以使用 <code>chmod</code> 命令使文件可写。假设文件名为 <code>example.txt</code>；您可以使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +w example.txt</span><br></pre></td></tr></tbody></table></figure><p>然后，在 Vim 内尝试再次保存文件。</p></li></ol><h3 id="如果文件应保持不变"><a class="markdownIt-Anchor" href="#如果文件应保持不变"></a> 如果文件应保持不变</h3><p>如果文件应该是只读的，且您不小心做了更改或重新考虑了您的编辑，有几个操作您可以执行：</p><ol><li><p><strong>撤销更改</strong>：通过使用 Vim 中的撤销命令 <code>u</code> 手动撤销更改，直到您恢复到文件的原始状态。</p></li><li><p><strong>不保存并退出</strong>：如果您想退出 Vim 而不保存任何更改，可以使用 <code>:q!</code> 命令，它退出 Vim 且不保存。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="理解只读文件"><a class="markdownIt-Anchor" href="#理解只读文件"></a> 理解只读文件</h3><p>在决定覆盖其只读状态之前，了解文件为什么可能处于只读模式是很重要的。文件可以因各种原因而被设置为只读：</p><ul><li>文件可能在文件系统级别被标记为只读，以防止意外更改。</li><li>文件可能属于另一个用户或需要管理员权限才能修改。</li><li>Vim 可能会在检测到文件正在被另一个进程使用时，以只读模式打开文件。</li><li>某些配置或命令（如使用 <code>vim -R &lt;filename&gt;</code> 打开文件）可以指示 Vim 以只读模式打开文件。</li></ul><p>在尝试覆盖文件的只读状态之前，始终确保修改文件是恰当的。</p></blockquote><p><strong>root终端连接效果</strong></p><img src="/posts/45608/image-20240503134748284.png" class="" title="image-20240503134748284"><h2 id="公网ip访问blog网站"><a class="markdownIt-Anchor" href="#公网ip访问blog网站"></a> 公网ip访问Blog网站</h2><img src="/posts/45608/image-20240503135033425.png" class="" title="image-20240503135033425"><p><strong>总结：使用腾讯云服务器（Unbuntu系统）部署Hexo博客，踩雷无数。此次部署博主理解了Linux服务器的详细配置流程，blog网站的访问速度得到了大幅度的提升，免受”科学上网“之苦</strong></p><h1 id="三-问题待解决"><a class="markdownIt-Anchor" href="#三-问题待解决"></a> 三、问题（待解决）</h1><h2 id="一-每次deploy需要输入服务器root密码"><a class="markdownIt-Anchor" href="#一-每次deploy需要输入服务器root密码"></a> 一、每次deploy需要输入服务器root密码</h2><ul><li><p><strong>解决方案：配置SSH公钥</strong></p></li><li><p><strong>参考文章：</strong><a href="https://zhuanlan.zhihu.com/p/549151974">Hexo历险记之八SSH远程链接服务器 - 知乎 (zhihu.com)</a></p></li></ul><p><strong>将git环境下的ssh公钥配置到服务器中的authorized_keys，并且修改sshd_config文件，配置好ssh各项权限</strong></p><img src="/posts/45608/image-20240503153851704.png" class="" title="image-20240503153851704"><p>**最终效果：**免密连接</p><img src="/posts/45608/image-20240503154119191.png" class="" title="image-20240503154119191"><p><strong>PS: 允许不同环境的终端配对的公钥可能不一样，这里使用git bash，要连接的服务器那边就需要使用git bash生成的公钥，才能实现免密登录，这样每次deploy时无需输入密码</strong></p><h2 id="二-blog域名"><a class="markdownIt-Anchor" href="#二-blog域名"></a> 二、Blog域名</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 博客搭建 </category>
          
          <category> Linux </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 博客 </tag>
            
            <tag> github </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS2】“人在回路”---与生成式人工智能交互的视觉医疗机器人</title>
      <link href="/posts/17498/"/>
      <url>/posts/17498/</url>
      
        <content type="html"><![CDATA[<h1 id="人在回路与生成式人工智能交互的视觉服务机器人"><a class="markdownIt-Anchor" href="#人在回路与生成式人工智能交互的视觉服务机器人"></a> “人在回路”—与生成式人工智能交互的视觉服务机器人</h1><p><strong>第一次更新：2024.4.28</strong></p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><ul><li>人在回路（Human-in-the-loop）是一种模式，类似于人机闭环系统或人机互助系统。这种模式被认为是机器学习、人工智能和机器智能的一种可行发展模式，需要人与机器之间的相互作用。在这种模式下，人类始终是模型的一部分，影响着模型的结果，并且需要人类的智能来帮助机器更加智能化。</li><li>ChatGPT是一款强大的基于深度学习的自然语言处理模型，能够生成高质量的自然语言文本。使用ChatGPT+TogetheROS，即ChatRobot将文字描述转化为小车控制指令，根据描述生成特定功能的代码，使机器人按照描述执行相应的任务。–转自NodeHube社区。–转自NobeHube</li></ul><h2 id="项目信息"><a class="markdownIt-Anchor" href="#项目信息"></a> 项目信息：</h2><p><strong>我们的机器人定位为医疗看护机器人（无人车），使用RDK X3 嵌入式AI开发板作为主控，通过Opencv等进行视觉识别，基于类似激光雷达测距的方法实现自主导航运动，满足不同场景下的控制需求。通过ROS2系统使小车与计算机进行通信。</strong></p><p><strong>我们计划使用OpenAI提供的API接口写入小车系统，实现初步的语音交互到控制的过程。基于搭载ROS2系统的RDK X3开发板，使用"人在回路"的模型训练方法，完善机器人行为模型的逻辑，提升机器学习的算法和模型的zhi在后续对GPT接口的开发中，我们设想可以与Chatgpt进行“人在回路”的系统训练，基本实现我们的设想目标。</strong></p><p>基于"人在回路"的模型训练：</p><p><strong>传统的机器人设计，往往是按照设定好的行为逻辑，这种设计过于机械化。而在医疗领域，传统的机器人显然不足以应对以人为核心的服务化需要。所以我们设想，利用“人在回路“的人机闭环互助系统对机器人进行训练，是否可以使得机器人简单地接近于人类的思维模式。应用在医疗服务等领域</strong></p><p><strong>人类能够根据实际情况灵活调整策略和方法，这种能力是当前机器人或人工智能难以完全实现的。通过人在回路，机器人在执行任务时可以依据人类的指示灵活调整其行为和策略，更好地适应复杂多变的环境，这就是我们设计的初步思想，虽然从技术的角度出发还有非常遥远的距离，但是我们可以通过这种方法和思想，逐步完善机器人的基本功能。</strong></p><p><mark><strong>我们将搭载地平线公司的RDK X3作为主控， 配合32位单片机与各类传感器模块进行数据交互，制作一个能够应用于医疗、后勤等领域的复杂多场景的无人车型机器人，能够先实现以下的基本功能：</strong></mark></p><ul><li><p>送药：前期阶段实现小车的所有控制部分，通过Opencv，Openmv组成双摄系统。Opencv负责深度学习相关的视觉识别，Openmv通过SPI协议与单片机进行通信，搭建基础的路径检测控制功能。==实现房号识别，自动药物配送。==中期阶段部署利用Simulink或者Gazebo进行小车的运动仿真。</p></li><li><p>自主导航：通过激光雷达进行SLAM建图，使得机器人具备在不同地环境下进行路径规划避障的功能。</p></li><li><p>语言交互：通过API接口与ChatGPT初步实现计算机的文字交互-&gt;控制小车基本运动-&gt;搭载语音模块控制ChatGPT-&gt;完成更复杂的人机交互系统（图像识别+传感器+语音模块）。</p></li><li><p>环境检测：实现小车上述的基本功能后，进行深度学习相关的视觉开发，使用时下热门的YOLO目标检测算法。能够实现对病人如：跌倒检测（识别人体关节点）等视觉应用。</p></li></ul><h2 id="队伍信息"><a class="markdownIt-Anchor" href="#队伍信息"></a> 队伍信息</h2><p><strong>我们队伍命名为FFT队，FFT即为快速傅立叶变换（Fast Fourier Transform），它是一种算法，在信号处理、图像处理、音频处理等领域广泛使用的技术，在如今5G大规模普及的时代，5G具有mMTC(超大规模机器连接)，eMBB(超低延时)的特点，”物联网“，“边缘计算”，“自动驾驶”等技术得到显著的发展。队伍成员基本为为通信系学生。FFT意为我们队伍追求高效、灵活、准确的开发学习，秉持创新思维、以赛促学的思想，能够将创意与专业知识运用在前沿领域。我们希望基于RDK X3 实现一些基于AI与物联网的idea，利用自身的专业知识，能够在本次项目中通信部分进行着重地设计，提高云平台与机器人的通信效率与可靠性。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> ROS2 </category>
          
          <category> Linux </category>
          
          <category> RDK X3 </category>
          
          <category> 人工智能 </category>
          
          <category> Ubuntu </category>
          
          <category> ROS2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> RDK X3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】[软件操作]仿真调试</title>
      <link href="/posts/45531/"/>
      <url>/posts/45531/</url>
      
        <content type="html"><![CDATA[<h1 id="软键盘"><a class="markdownIt-Anchor" href="#软键盘"></a> 软键盘</h1><img src="/posts/45531/image-20240427152809497.png" class="" title="image-20240427152809497"><h1 id="选择使用按键的属性"><a class="markdownIt-Anchor" href="#选择使用按键的属性"></a> 选择使用按键的属性</h1><img src="/posts/45531/image-20240427152840915.png" class="" title="image-20240427152840915">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> PIC单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PIC单片机 </tag>
            
            <tag> MPLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[8]AD/DA转换</title>
      <link href="/posts/56223/"/>
      <url>/posts/56223/</url>
      
        <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p>void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);</p><p><strong>恢复缺省配置</strong></p><p>void ADC_DeInit(ADC_TypeDef* ADCx);</p><p><strong>ADC初始化</strong></p><p>void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>ADC上电</strong></p><p>void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>开启DMA输出信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>中断输出控制</strong></p><p>void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);</p><ul><li>用于控制某个中断能否通往NVIC</li></ul><p><strong>复位校准</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取复位校准状态</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>开始校准</strong></p><p>void ADC_StartCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取开始校准状态</strong></p><p>FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);</p><p><strong>ADC软件触发的函数</strong></p><p>void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>ADC获取软件转换状态</strong></p><p>FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);</p><ul><li><p>实际上是获取CR2的SWSTART这一位,但是SWSTART在开始ADC转换后直接清除，所以并不能通过这个函数获得是否开始转换的信息</p><img src="/posts/56223/image-20240423220300035.png" class="" title="image-20240423220300035"></li></ul><p><strong><mark>如何获取ADC是否开启的状态？</mark></strong></p><p><strong>获取标志位状态</strong></p><p>FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);</p><ul><li>可以调用这个函数,ADC_FLAG选择EOC,判断EOC标志位是否置1</li></ul><p><strong>每隔几个通道间断一次</strong></p><p>void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);</p><p><strong>是否启动间断模式</strong></p><p>void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC规则组通道配置</strong></mark></p><p>void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);</p><ul><li>ADCx</li><li>ADC_Channel：指定的通道</li><li>Rank：序列的位置</li><li>ADC_SampleTime：指定通道的采样时间</li></ul><p><strong>ADC外部触发转换控制（是否允许外部触发转换）</strong></p><p>void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC获取转换值</strong></mark></p><p>uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);</p><ul><li>获取AD转换的数据寄存器，读取转换结果</li></ul><p><strong>ADC获取双模式转换值</strong></p><p>uint32_t ADC_GetDualModeConversionValue(void);</p><p><strong>是否启动模拟看门狗</strong></p><p>void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);</p><p><strong>配置高低阈值</strong></p><p>void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);</p><p><strong>配置看门的通道</strong></p><p>void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);</p><p><strong>ADC温度传感器、内部参考电压控制</strong></p><p>void ADC_TempSensorVrefintCmd(FunctionalState NewState);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> AD/DA转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[7]编码器接口测速</title>
      <link href="/posts/37664/"/>
      <url>/posts/37664/</url>
      
        <content type="html"><![CDATA[<h2 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h2><blockquote><p><strong>定时器编码器配置</strong></p><p>void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,<br>uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);</p><ul><li>TIMx:选择定时器</li><li>TIM_EncoderMode: 选择编码器模式，T1单独计数，T2单独计数，T1/T2同时计数</li></ul><img src="/posts/37664/image-20240420235549817.png" class="" title="image-20240420235549817"><ul><li>TIM_IC1Polarity：电平极性</li><li>TIM_IC2Polarity：电平极性  可以通过配置这两个参数，设置正相和反相</li></ul><img src="/posts/37664/image-20240420235814820.png" class="" title="image-20240420235814820"></blockquote><h2 id="编码器测计数"><a class="markdownIt-Anchor" href="#编码器测计数"></a> 编码器测计数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM3);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">1</span><span class="number">-1</span>;<span class="comment">//PSC 不分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">65536</span> - <span class="number">1</span>;<span class="comment">//ARR </span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line">TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获单元配置*/</span></span><br><span class="line"><span class="comment">/**通道1配置**/</span></span><br><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">    TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="comment">//给结构体赋初始值，防止出现不确定的状态</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发  TIM_EncoderInterfaceConfig重复配置了相同的寄存器</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line">    <span class="comment">/**通道2配置**/</span> <span class="comment">//注意：这里不需要再定义新的结构体。因为上一次的值已经写入硬件寄存器</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_2;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置编码器接口*/</span></span><br><span class="line">    TIM_EncoderInterfaceConfig(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//定时器3 ，T1T2同时使用，极性相同(上升沿/下降沿两个都是有效的)，即为正相</span></span><br><span class="line">    <span class="comment">//若要反相，那么一个配置位上升沿，一个配置为下降沿有效</span></span><br><span class="line">TIM_Cmd(TIM3,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//int16_t 表示有符号数，能把unint16_相比最高位变为了符号位,这里利用到了补码的特性</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> TIM_GetCounter(TIM3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="编码器测速"><a class="markdownIt-Anchor" href="#编码器测速"></a> 编码器测速</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 输入捕获 </tag>
            
            <tag> 输出比较 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】方波发生器-电子琴</title>
      <link href="/posts/46544/"/>
      <url>/posts/46544/</url>
      
        <content type="html"><![CDATA[<h1 id="如何得到精准的250us定时"><a class="markdownIt-Anchor" href="#如何得到精准的250us定时"></a> 如何得到精准的250us定时？</h1><p><strong>先确认大概的定时器计数器值，再利用跑马表调整误差</strong></p><img src="/posts/46544/image-20240416182439723.png" class="" title="image-20240416182439723">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> PIC单片机 </category>
          
          <category> 项目设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PIC单片机 </tag>
            
            <tag> MPLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】[软件操作]-跑马表</title>
      <link href="/posts/15341/"/>
      <url>/posts/15341/</url>
      
        <content type="html"><![CDATA[<h1 id="如何打开stop-watch窗口"><a class="markdownIt-Anchor" href="#如何打开stop-watch窗口"></a> 如何打开Stop Watch窗口？</h1><blockquote><p><strong>在DEBUG下选mplab sim后，再点DEBUGSETTING来设好频率，设好后点stopwatch</strong></p></blockquote><h1 id="跑马表仿真测试"><a class="markdownIt-Anchor" href="#跑马表仿真测试"></a> 跑马表仿真测试</h1><p><mark>在中断<strong>对应</strong>的位置打上断点，点击仿真运行，即可通过跑马表查看每次进中断的运行时间</mark></p><img src="/posts/15341/image-20240405155601030.png" class="" title="image-20240405155601030"><h1 id="车辆里程表"><a class="markdownIt-Anchor" href="#车辆里程表"></a> 车辆里程表</h1><h2 id="proteus仿真"><a class="markdownIt-Anchor" href="#proteus仿真"></a> proteus仿真</h2><p><mark>可以通过工具栏<strong>调试</strong>选项</mark>，查看各个所需的调试窗口，运行调试工具。</p><p>ps:<strong>step into</strong>可以跳过断点</p><img src="/posts/15341/image-20240405170845407.png" class="" title="image-20240405170845407"><p>第二次进中断，LED灯点亮</p><img src="/posts/15341/image-20240405171351683.png" class="" title="image-20240405171351683"><p>ps:<strong>cof为仿真文件,hex为下载文件</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> PIC单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PIC单片机 </tag>
            
            <tag> MPLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】[2]中断系统</title>
      <link href="/posts/18816/"/>
      <url>/posts/18816/</url>
      
        <content type="html"><![CDATA[<h2 id="保护现场"><a class="markdownIt-Anchor" href="#保护现场"></a> 保护现场</h2><img src="/posts/18816/image-20240327212904491.png" class="" title="image-20240327212904491">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> PIC单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PIC单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单片机】串口通信</title>
      <link href="/posts/25165/"/>
      <url>/posts/25165/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯部分"><a class="markdownIt-Anchor" href="#蓝桥杯部分"></a> 蓝桥杯部分</h1><h2 id="1串口底层"><a class="markdownIt-Anchor" href="#1串口底层"></a> 1.串口底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字节发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line">SBUF=dat;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Send_String</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(*dat != <span class="string">'\0'</span>)<span class="comment">//当字符不为空时，继续发送</span></span><br><span class="line">SendByte(*dat++);<span class="comment">//发送后指针dat加1，指向下一个字节</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2单片机发送字符串给上位机"><a class="markdownIt-Anchor" href="#2单片机发送字符串给上位机"></a> 2.单片机发送字符串给上位机</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0x7F</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0xF0</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL0 = <span class="number">0x18</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF0 = <span class="number">0</span>;<span class="comment">//清除TF0标志</span></span><br><span class="line">TR0 = <span class="number">1</span>;<span class="comment">//定时器0开始计时</span></span><br><span class="line">ET0 = <span class="number">1</span>;    <span class="comment">//定时器中断0打开</span></span><br><span class="line">EA = <span class="number">1</span>;     <span class="comment">//总中断打开</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay500ms</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">23</span>;</span><br><span class="line">j = <span class="number">205</span>;</span><br><span class="line">k = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (--k);</span><br><span class="line">} <span class="keyword">while</span> (--j);</span><br><span class="line">} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"></span><br><span class="line">Uart1_Init();</span><br><span class="line"></span><br><span class="line">Delay500ms();<span class="comment">//mark:初始化后若立即发送数据，第一个字节会重复发送，所以先延时500ms,等待UART稳定工作，再发送字符串</span></span><br><span class="line"></span><br><span class="line">Uart1_SendString(<span class="string">"Hello UART"</span>);<span class="comment">//字符串发送数据在开启定时器中断时容易被打断,第一个字节刚好卡在没发完的时刻,造成死循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行任务</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//Key_Proc();</span></span><br><span class="line"><span class="comment">//Nixie_Proc();</span></span><br><span class="line"><span class="comment">//LED_Proc();</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3上位机发送字符串给单片机"><a class="markdownIt-Anchor" href="#3上位机发送字符串给单片机"></a> 3.上位机发送字符串给单片机</h2><p><strong><mark>PS:按键4可发送单片机接收到的字符串给上位机</mark></strong></p><h3 id="串口处理模块"><a class="markdownIt-Anchor" href="#串口处理模块"></a> 串口处理模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData[Uart_RecData_Index]=SBUF;</span><br><span class="line">Uart_RecData_Index++;</span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="按键程序"><a class="markdownIt-Anchor" href="#按键程序"></a> 按键程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Key_Down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">Uart_SendDataFlag=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中断程序"><a class="markdownIt-Anchor" href="#中断程序"></a> 中断程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData[Uart_RecData_Index]=SBUF;</span><br><span class="line">Uart_RecData_Index++;</span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Uart_Timer==<span class="number">100</span>){Uart_Timer=<span class="number">0</span>;}</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">10</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Uart_SendDataFlag==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_SendDataFlag=<span class="number">0</span>;</span><br><span class="line">Uart1_SendString(Uart_RecData);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4上位机发送数据控制单片机led"><a class="markdownIt-Anchor" href="#4上位机发送数据控制单片机led"></a> 4.上位机发送数据控制单片机LED</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Uart_Timer)<span class="keyword">return</span>;</span><br><span class="line">Uart_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if(Uart_RecData[Uart_RecData_Index-1]==0x0a &amp;&amp; Uart_RecData[Uart_RecData_Index-2]==0x0d) //0x0a--&gt;'\n' 0x0d--&gt;'\r'</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//if(Uart_RecData_Index==9 &amp;&amp; Uart_RecData[0]=='L' &amp;&amp; Uart_RecData[1]=='E' &amp;&amp; Uart_RecData[2]=='D' &amp;&amp; Uart_RecData[3]=='1' &amp;&amp; Uart_RecData[4]=='='&amp;&amp;Uart_RecData[5]=='1')</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//ucLED[0]=1;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="keyword">if</span>(Uart_RecData[Uart_RecData_Index<span class="number">-1</span>]==<span class="number">0x0a</span> &amp;&amp; Uart_RecData[Uart_RecData_Index<span class="number">-2</span>]==<span class="number">0x0d</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Uart_RecData_Index==<span class="number">8</span> &amp;&amp; Uart_RecData[<span class="number">0</span>]==<span class="string">'L'</span> &amp;&amp; Uart_RecData[<span class="number">1</span>]==<span class="string">'E'</span> &amp;&amp; Uart_RecData[<span class="number">2</span>]==<span class="string">'D'</span> &amp;&amp; Uart_RecData[<span class="number">3</span>]==<span class="string">'1'</span> &amp;&amp; Uart_RecData[<span class="number">4</span>]==<span class="string">'='</span>&amp;&amp;Uart_RecData[<span class="number">5</span>]==<span class="string">'1'</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2串口优化"><a class="markdownIt-Anchor" href="#2串口优化"></a> 2.串口优化</h2><h3 id="putchar重定向"><a class="markdownIt-Anchor" href="#putchar重定向"></a> putchar重定向</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> <span class="title function_">putchar</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">    SBUF=ch; <span class="comment">///将dat数据</span></span><br><span class="line">    <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">    TI=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>(ch);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【蓝桥杯单片机】考点复盘1</title>
      <link href="/posts/5903/"/>
      <url>/posts/5903/</url>
      
        <content type="html"><![CDATA[<h1 id="一-led模块"><a class="markdownIt-Anchor" href="#一-led模块"></a> 一、LED模块</h1><h2 id="1led底层代码"><a class="markdownIt-Anchor" href="#1led底层代码"></a> 1.LED底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Led_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr, enable)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp = <span class="number">0x00</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span> (enable)</span><br><span class="line">        temp |= <span class="number">0x01</span> &lt;&lt; addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp &amp;= ~(<span class="number">0x01</span> &lt;&lt; addr);</span><br><span class="line">   <span class="keyword">if</span> (temp != temp_old)</span><br><span class="line">    {</span><br><span class="line">        P0 = ~temp;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0x80</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式"><a class="markdownIt-Anchor" href="#2基本调用方式"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ucLED[n]=x;</span><br><span class="line"></span><br><span class="line">中断程序</span><br><span class="line">{</span><br><span class="line">    Led_Disp(Nixie_Pos,ucLED[Nixie_Pos]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二-按键模块"><a class="markdownIt-Anchor" href="#二-按键模块"></a> 二、按键模块</h1><h2 id="1按键底层代码"><a class="markdownIt-Anchor" href="#1按键底层代码"></a> 1.按键底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Read</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp = <span class="number">0</span>;</span><br><span class="line">    ET0 = <span class="number">0</span>;</span><br><span class="line">    P44 = <span class="number">0</span>;P42 = <span class="number">1</span>;P35 = <span class="number">1</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">7</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">0</span>;P35 = <span class="number">1</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">11</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">1</span>;P35 = <span class="number">0</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">15</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">1</span>;P35 = <span class="number">1</span>;P34 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">19</span>;</span><br><span class="line">    P3 = <span class="number">0xff</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式-2"><a class="markdownIt-Anchor" href="#2基本调用方式-2"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(Key_Down)<span class="comment">//下降沿</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">case</span> X:</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="23-模式切换"><a class="markdownIt-Anchor" href="#23-模式切换"></a> <strong>2.3</strong> <strong>模式切换</strong></h4><img src="/posts/5903/clip_image002.jpg" class="" title="img"><p>第十届省赛真题</p><img src="/posts/5903/clip_image004.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="24-参数设置"><a class="markdownIt-Anchor" href="#24-参数设置"></a> <strong>2.4</strong> <strong>参数设置</strong></h4><img src="/posts/5903/clip_image006.jpg" class="" title="img"><p>第九届省赛真题</p><img src="/posts/5903/clip_image008.jpg" class="" title="img"><p>第八届省赛真题</p><h4 id="25-参数保存"><a class="markdownIt-Anchor" href="#25-参数保存"></a> <strong>2.5</strong> <strong>参数保存</strong></h4><img src="/posts/5903/clip_image010.jpg" class="" title="img"><p>第五届省赛真题</p><img src="/posts/5903/clip_image012.jpg" class="" title="img"><p>第十一届省赛真题</p><h4 id="26-特定使能"><a class="markdownIt-Anchor" href="#26-特定使能"></a> <strong>2.6</strong> <strong>特定使能</strong></h4><img src="/posts/5903/clip_image014.jpg" class="" title="img"><p>第十一届省赛真题</p><h4 id="27-长按跳转-松手返回"><a class="markdownIt-Anchor" href="#27-长按跳转-松手返回"></a> <strong>2.7</strong> <strong>长按跳转 松手返回</strong></h4><img src="/posts/5903/clip_image016.jpg" class="" title="img"><p>第八届省赛真题</p><h4 id="28-键盘输入"><a class="markdownIt-Anchor" href="#28-键盘输入"></a> <strong>2.8</strong> <strong>键盘输入</strong></h4><img src="/posts/5903/clip_image017.png" class="" title="img"><p>模拟训练二</p><h4 id="29-长按短按-效果不同"><a class="markdownIt-Anchor" href="#29-长按短按-效果不同"></a> <strong>2.9</strong> <strong>长按短按 效果不同</strong></h4><img src="/posts/5903/clip_image019.jpg" class="" title="img"><h1 id="三-数码管模块"><a class="markdownIt-Anchor" href="#三-数码管模块"></a> 三、数码管模块</h1><h2 id="1数码管底层代码"><a class="markdownIt-Anchor" href="#1数码管底层代码"></a> 1.数码管底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg_dula[] = {<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0xff</span>};</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg_wela[] = {<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Seg_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> wela,dula,point)</span></span><br><span class="line">{</span><br><span class="line">    P0 = <span class="number">0xff</span>;</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xe0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line"></span><br><span class="line">    P0 = seg_wela[wela];</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xc0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">    </span><br><span class="line">    P0 = seg_dula[dula];</span><br><span class="line">    <span class="keyword">if</span>(point)</span><br><span class="line">        P0 &amp;= <span class="number">0x7f</span>;</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xe0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>; </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式-3"><a class="markdownIt-Anchor" href="#2基本调用方式-3"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Seg_Buf[X] = Y;</span><br><span class="line">Seg_Point[X] = Y;</span><br></pre></td></tr></tbody></table></figure><h4 id="33-显示整数变量"><a class="markdownIt-Anchor" href="#33-显示整数变量"></a> <strong>3.3</strong> <strong>显示整数变量</strong></h4><img src="/posts/5903/clip_image002-1711183567913-109.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="34-显示小数点变量"><a class="markdownIt-Anchor" href="#34-显示小数点变量"></a> <strong>3.4</strong> <strong>显示小数点变量</strong></h4><img src="/posts/5903/clip_image004-1711183567913-110.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="35-不同状态显示不同内容"><a class="markdownIt-Anchor" href="#35-不同状态显示不同内容"></a> <strong>3.5</strong> <strong>不同状态显示不同内容</strong></h4><img src="/posts/5903/clip_image006-1711183567914-112.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="36-高位熄灭"><a class="markdownIt-Anchor" href="#36-高位熄灭"></a> <strong>3.6</strong> <strong>高位熄灭</strong></h4><img src="/posts/5903/clip_image008-1711183567913-111.jpg" class="" title="img"><p>第十届省赛真题</p><h4 id="37-选中单元闪烁"><a class="markdownIt-Anchor" href="#37-选中单元闪烁"></a> <strong>3.7</strong> <strong>选中单元闪烁</strong></h4><img src="/posts/5903/clip_image010-1711183567914-113.jpg" class="" title="img"><p>第八届省赛真题</p><h1 id="四-继电器蜂鸣器"><a class="markdownIt-Anchor" href="#四-继电器蜂鸣器"></a> 四、继电器蜂鸣器</h1><h2 id="1底层代码"><a class="markdownIt-Anchor" href="#1底层代码"></a> 1.底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_1 = <span class="number">0x00</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old_1 = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Beep</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        temp_1 |= <span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp_1 &amp;= ~<span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">    {</span><br><span class="line">        P0 = temp_1;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old_1 = temp_1;        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Relay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        temp_1 |= <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp_1 &amp;= ~<span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">    {</span><br><span class="line">        P0 = temp_1;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old_1 = temp_1;        </span><br><span class="line">    }   </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>…</p><h1 id="ne555"><a class="markdownIt-Anchor" href="#ne555"></a> NE555</h1><p>绑定定时器0，应采用计数器模式</p><h1 id="超声波"><a class="markdownIt-Anchor" href="#超声波"></a> #超声波</h1><h2 id="1超声波底层代码"><a class="markdownIt-Anchor" href="#1超声波底层代码"></a> 1.超声波底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">()</span>        <span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">()</span> <span class="comment">//超声波初始化函数 产生8个40Mhz的方波信号</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        Tx = <span class="number">1</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">        Tx = <span class="number">0</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0f</span>;<span class="comment">//配置定时器1计时模式</span></span><br><span class="line">    TH1 = TL1 = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    TR1 = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (TF1 == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    TR1 = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(TF1 == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = TH1 &lt;&lt; <span class="number">8</span> | TL1;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        TF1 = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2pca写法"><a class="markdownIt-Anchor" href="#2pca写法"></a> 2.PCA写法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    CMOD =  <span class="number">0x00</span>;<span class="comment">//配置PCA工作模式</span></span><br><span class="line">    CH = CL = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    CR = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (CF == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    CR = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(CF == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = CH &lt;&lt; <span class="number">8</span> | CL;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        CF = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="串口"><a class="markdownIt-Anchor" href="#串口"></a> #串口</h1><h2 id="1串口底层"><a class="markdownIt-Anchor" href="#1串口底层"></a> 1.串口底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span>     <span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">    SCON = <span class="number">0x50</span>;        <span class="comment">//8位数据,可变波特率</span></span><br><span class="line">    AUXR |= <span class="number">0x01</span>;       <span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">    AUXR |= <span class="number">0x04</span>;       <span class="comment">//定时器时钟1T模式</span></span><br><span class="line">    T2L = <span class="number">0xC7</span>;     <span class="comment">//设置定时初始值</span></span><br><span class="line">    T2H = <span class="number">0xFE</span>;     <span class="comment">//设置定时初始值</span></span><br><span class="line">    AUXR |= <span class="number">0x10</span>;       <span class="comment">//定时器2开始计时</span></span><br><span class="line">    ES = <span class="number">1</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字节发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line">    SBUF=dat;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">    TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Send_String</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(*dat != <span class="string">'\0'</span>)<span class="comment">//当字符不为空时，继续发送</span></span><br><span class="line">        SendByte(*dat++);<span class="comment">//发送后指针dat加1，指向下一个字节</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口1中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1Server</span><span class="params">()</span> interrupt 4</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(RI == <span class="number">1</span>) <span class="comment">//串口接收数据</span></span><br><span class="line">    {</span><br><span class="line">        Uart_Recv[Uart_Recv_Index] = SBUF;</span><br><span class="line">        Uart_Recv_Index++;</span><br><span class="line">        RI = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-串口接收数据"><a class="markdownIt-Anchor" href="#2-串口接收数据"></a> **2. **串口接收数据</h2><p><strong>模拟题</strong></p><hr><img src="/posts/5903/clip_image002-1711190784499-119.jpg" class="" title="img"><hr><img src="/posts/5903/clip_image004-1711190784499-120.jpg" class="" title="img"><h2 id="3-串口发送数据"><a class="markdownIt-Anchor" href="#3-串口发送数据"></a> **3. **串口发送数据</h2><p><strong>模拟题</strong></p><hr><img src="/posts/5903/clip_image005.jpg" class="" title="img"><hr><img src="/posts/5903/clip_image006-1711190784499-121.jpg" class="" title="img"><ul><li><strong>内存溢出：idata/xdata/data/code</strong></li></ul><h2 id="第三部分-大模板"><a class="markdownIt-Anchor" href="#第三部分-大模板"></a> <mark>第三部分 大模板</mark></h2><h3 id="一-头文件声明区域"><a class="markdownIt-Anchor" href="#一-头文件声明区域"></a> 一、头文件声明区域</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件声明区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC15F2K60S2.H&gt;</span><span class="comment">//单片机寄存器专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span><span class="comment">//初始化底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Led.h&gt;</span><span class="comment">//Led底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span><span class="comment">//按键底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Seg.h&gt;</span><span class="comment">//数码管底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span><span class="comment">//串口底层驱动专用头文件</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="二-变量声明区域"><a class="markdownIt-Anchor" href="#二-变量声明区域"></a> 二、变量声明区域</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 变量声明区 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Val,Key_Down,Key_Old,Key_Up;<span class="comment">//按键专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Slow_Down;<span class="comment">//按键减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Buf[<span class="number">8</span>] = {<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Point[<span class="number">8</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管小数点数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Pos;<span class="comment">//数码管扫描专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Seg_Slow_Down;<span class="comment">//数码管减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLed[<span class="number">8</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//Led显示数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Slow_Down;<span class="comment">//串口减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Recv[<span class="number">10</span>];<span class="comment">//串口接收数据储存数组 默认10个字节 若接收数据较长 可更改最大字节数</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Recv_Index;<span class="comment">//串口接收数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Send[<span class="number">10</span>];<span class="comment">//串口接收数据储存数组 默认10个字节 若发送数据较长 可更改最大字节数</span></span><br></pre></td></tr></tbody></table></figure><h3 id="三-按键处理函数"><a class="markdownIt-Anchor" href="#三-按键处理函数"></a> 三、按键处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 键盘处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Key_Slow_Down) <span class="keyword">return</span>;<span class="comment">//作用：使得程序在每次定时扫描过程只执行一次，即Key_Slow_Down=0时立即置1，向下执行。</span></span><br><span class="line"></span><br><span class="line">  Key_Slow_Down = <span class="number">1</span>;<span class="comment">//键盘减速程序</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  Key_Val = Key_Read();<span class="comment">//实时读取键码值</span></span><br><span class="line"></span><br><span class="line">  Key_Down = Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//捕捉按键下降沿</span></span><br><span class="line"></span><br><span class="line">  Key_Up = ~Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//捕捉按键上降沿</span></span><br><span class="line"></span><br><span class="line">  Key_Old = Key_Val;<span class="comment">//辅助扫描变量</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="四-信息处理函数"><a class="markdownIt-Anchor" href="#四-信息处理函数"></a> 四、信息处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信息处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Seg_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Seg_Slow_Down) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Seg_Slow_Down = <span class="number">1</span>;<span class="comment">//数码管减速程序</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="五-其他显示函数"><a class="markdownIt-Anchor" href="#五-其他显示函数"></a> 五、其他显示函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 其他显示函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Led_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="六-串口处理函数"><a class="markdownIt-Anchor" href="#六-串口处理函数"></a> 六、串口处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Uart_Slow_Down) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Uart_Slow_Down = <span class="number">1</span>;<span class="comment">//串口减速程序 </span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="七-定时器初始化函数"><a class="markdownIt-Anchor" href="#七-定时器初始化函数"></a> 七、定时器初始化函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器0中断初始化函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0Init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  AUXR &amp;= <span class="number">0x7F</span>;    <span class="comment">//定时器时钟12T模式</span></span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;    <span class="comment">//设置定时器模式</span></span><br><span class="line"></span><br><span class="line">  TL0 = <span class="number">0x18</span>;   <span class="comment">//设置定时初始值</span></span><br><span class="line"></span><br><span class="line">  TH0 = <span class="number">0xFC</span>;   <span class="comment">//设置定时初始值</span></span><br><span class="line"></span><br><span class="line">  TF0 = <span class="number">0</span>;     <span class="comment">//清除TF0标志</span></span><br><span class="line"></span><br><span class="line">  TR0 = <span class="number">1</span>;     <span class="comment">//定时器0开始计时</span></span><br><span class="line"></span><br><span class="line">  ET0 = <span class="number">1</span>;   <span class="comment">//定时器中断0打开</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;   <span class="comment">//总中断打开</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="八-中断服务函数"><a class="markdownIt-Anchor" href="#八-中断服务函数"></a> 八、中断服务函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器0中断服务函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0Server</span><span class="params">()</span> interrupt 1</span><br><span class="line"></span><br><span class="line">{  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Key_Slow_Down == <span class="number">10</span>) Key_Slow_Down = <span class="number">0</span>;<span class="comment">//键盘减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Seg_Slow_Down == <span class="number">500</span>) Seg_Slow_Down = <span class="number">0</span>;<span class="comment">//数码管减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Uart_Slow_Down == <span class="number">200</span>) Uart_Slow_Down = <span class="number">0</span>;<span class="comment">//串口减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Seg_Pos == <span class="number">8</span>) Seg_Pos = <span class="number">0</span>;<span class="comment">//数码管显示专用</span></span><br><span class="line"></span><br><span class="line">  Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">  Led_Disp(Seg_Pos,ucLed[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="九-串口服务函数"><a class="markdownIt-Anchor" href="#九-串口服务函数"></a> 九、串口服务函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口1中断服务函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1Server</span><span class="params">()</span> interrupt 4</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(RI == <span class="number">1</span>) <span class="comment">//串口接收数据</span></span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line">      Uart_Recv[Uart_Recv_Index] = SBUF;</span><br><span class="line">  Uart_Recv_Index++;</span><br><span class="line">      RI = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="十-主函数"><a class="markdownIt-Anchor" href="#十-主函数"></a> 十、主函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  System_Init();</span><br><span class="line"></span><br><span class="line">  Timer0Init();</span><br><span class="line"></span><br><span class="line">  UartInit();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    Key_Proc();</span><br><span class="line"></span><br><span class="line">    Seg_Proc();</span><br><span class="line"></span><br><span class="line">    Led_Proc();</span><br><span class="line"></span><br><span class="line">    Uart_Proc();</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
          <category> 蓝桥杯 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> STC15 </tag>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[6]输入捕获和输出比较</title>
      <link href="/posts/64385/"/>
      <url>/posts/64385/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><p>xxxxxxxxxx&nbsp;$ tags: -数字电路与VHDL设计"bash</p><p>另外它们的CH1到CH4，4个通道的引脚，也是公用的</p><p>所以对于同一个定时器，输入捕获和输出比较只能用其中一个。</p><h2 id="一-输出比较"><a class="markdownIt-Anchor" href="#一-输出比较"></a> 一、输出比较</h2><img src="/posts/64385/image-20240317124437632.png" class="" title="image-20240317124437632"><img src="/posts/64385/image-20240317124510956.png" class="" title="image-20240317124510956"><p><strong>根据CNT和CCR的大小关系，从通道引脚输出高低电平</strong></p><h2 id="二-输入捕获"><a class="markdownIt-Anchor" href="#二-输入捕获"></a> 二、输入捕获</h2><img src="/posts/64385/image-20240317124716864.png" class="" title="image-20240317124716864"><img src="/posts/64385/image-20240317124815682.png" class="" title="image-20240317124815682"><p>输入滤波器：可以对毛刺信号进行滤波</p><p>交叉输入的作用？</p><p>TRC?</p><p>CNT计数器是由内部的标准时钟进行驱动的，可以用于测量外部检测两个上升沿的时间间隔，</p><p>所以需要在检测到一个上升沿过后，清零CNT，这样在第二次上升沿后，CNT值就是测周法的N，可以通过主从触发模式，自动完成。</p><p><strong>总结：</strong></p><p>输入捕获类似于外部中断。都是检测边沿，然后执行相应的动嘴，而在输入捕获中。检测到指定电平跳变后，CNT的值所存到CCR中。</p><ul><li><p>输出比较。引脚是输出端口，根据CNT和CCR的大小关系执行输出的动作。</p></li><li><p>输入捕获。引脚是输入端口，接收到输入信号，执行锁存的动作。</p></li></ul><p><strong>#主从触发模式：</strong></p><p>将主从触发模式和PWMI模式相结合，可以让硬件自动测量频率和占空比，软件无需进行干预。</p><h2 id="三-频率测量"><a class="markdownIt-Anchor" href="#三-频率测量"></a> 三、频率测量</h2><img src="/posts/64385/image-20240317125647320.png" class="" title="image-20240317125647320"><p><strong>PS：STM32测频率只能测量数字信号，若测量正选波，可以用运放电路搭建一个比较器。若测量的信号电压较高，需要考虑隔离的问题，比如隔离放大器，电压互感器等元件。总而言之，要用STM32测量频率，只能用数字信号，高电平3.3V，低电平0V</strong></p><p><strong>#区别</strong></p><ul><li><p>测频法：规定时间，记录上升沿次数，<mark>适合测量高频信号</mark>。在计次N过少时，误差会比较大。</p><p>​测频法自带均值滤波，得到的其实是平均频率。</p></li><li><p>测周法：从待测频率的第一个上升沿开始，以一个标准的频率计次，记录计数器的次数，直到检测到待测频率信号的第二个上升沿。<mark>适合测量低频信号</mark>，低频信号，周期长，计次多，有利于减小误差。</p><p>一般情况下，待测信号几百几千HZ以上，测周法更新更快，又因为测周法只测量一个周期，所以结果容易收到噪声的影响，波动较大。</p></li><li><p>两种方法都会出现正负1误差</p></li></ul><p>#<strong>中界频率</strong></p><ul><li>用于界定选用测频法还是测周法的频率</li></ul><h2 id="四-输入捕获通道"><a class="markdownIt-Anchor" href="#四-输入捕获通道"></a> 四、输入捕获通道</h2><img src="/posts/64385/image-20240317133236546.png" class="" title="image-20240317133236546"><p><mark>fDTS是滤波器的采样时钟来源。TI1是输入信号，TI1F是滤波后的信号，CCMR1寄存器中的ICF位可以控制滤波器的参数</mark></p><p>​ICF相关定义</p><img src="/posts/64385/image-20240317133728716.png" class="" title="image-20240317133728716"><p>滤波之后的信号通过后续的边沿检测器，并且可以通过CCIP选择极性。最终得到TI1FP1的触发信号，进入通道1后续的捕获电路。同样的，通道2也是一样的流程，不过图中省略了。</p><p>CC1E位，控制输出使能或失能。</p><p><strong>如何自动清零CNT？</strong></p><h3 id="主从触发模式"><a class="markdownIt-Anchor" href="#主从触发模式"></a> 主从触发模式</h3><img src="/posts/64385/image-20240317134635166.png" class="" title="image-20240317134635166"><ul><li><p>主模式可以将定时器内部的信号，映射到TRGO引脚，用于触发别的外设</p></li><li><p>从模式接收其他外设或者自身外设的一些信号，用于控制自身定时器的运行。</p></li></ul><p><strong>这里将TI1FP1作为触发源，从模式执行Reset操作，这样就可以实现CNT自动清零。</strong></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><h3 id="输入捕获基本结构"><a class="markdownIt-Anchor" href="#输入捕获基本结构"></a> 输入捕获基本结构</h3><img src="/posts/64385/image-20240317135641144.png" class="" title="image-20240317135641144"><p>这个结构只使用了一个通道，只能用于测量频率。</p><p>先转运CNT，再对CNT进行清零。</p><p>使用从模式自动清零CNT，只能用通道1和通道2。</p><h3 id="pwmi基本结构"><a class="markdownIt-Anchor" href="#pwmi基本结构"></a> PWMI基本结构</h3><img src="/posts/64385/image-20240317140209540.png" class="" title="image-20240317140209540"><p>开始，第一个上升沿，CCR1捕获并且清零CNT，CNT++。第一个下降沿，CCR2捕获CNT，但不会执行CNT清零。第二个上升沿，CCR1捕获CNT，同时CNT清零。</p><p>这样CCR1值就是整个周期的计数值，CCR2就是高电平期间的计数值。这样可以同时得到PWM的频率和占空比。</p><p>这里也可以配置两个通道同时捕获第二个引脚的输入，使用TI2FP1和TI2FP2两个引脚。</p><h1 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> 代码部分</h1><blockquote><hr><p><strong>单独修改PSR值</strong></p><p>void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)</p><ul><li>TIMx：定时器</li><li>Prescaler：PSR值</li><li>TIM_PSCReloadMode：指定定时器预分频器的重装模式<ul><li>@arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event. 在更新事件中 重装<ul><li><pre><code>@arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately. 立即重装</code></pre></li></ul></li></ul></li></ul><hr><p><strong>输入捕获</strong></p><p>void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);</p><p>输入捕获函数，4个通道共用一个函数</p><hr><p><strong>给输入捕获结构体赋初值</strong></p><p>void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);</p><hr><p><strong>选择输入触发源TIGI</strong></p><p>void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><p>配置从模式的输入触发源</p><hr><p><strong>选择输出触发源TRGO</strong></p><p>void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><p>配置主模式的输出触发源</p><hr><p><strong>配置从模式</strong></p><p>void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);</p><img src="/posts/64385/image-20240317150206255.png" class="" title="image-20240317150206255"><p><mark>ps:这三个从模式是给编码器接口用的，会有另外的函数进行配置</mark></p><hr><p><strong>配置通道1234的定时器</strong></p><p>void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);</p><hr><p><strong>读取4个通道的CCR</strong></p><p>uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);</p><p><strong>对于写4个通道CCR的函数</strong></p><p>void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);<br>void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);<br>void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);<br>void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);</p><p><mark>输入捕获模式下，CCR是只读的，要用GetCapture读出</mark></p><hr><p><strong><mark>TIM_PWMIConfig(TIM3,&amp;TIM_ICInitStructure);//标准库中已将上述注释部分封装好,即会将以及配置号的部分，再配置另外的通道将参数进行相反的设置</mark></strong></p><hr></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 输入捕获 </tag>
            
            <tag> 输出比较 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【蓝桥杯单片机】第九届省赛题</title>
      <link href="/posts/25039/"/>
      <url>/posts/25039/</url>
      
        <content type="html"><![CDATA[<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1><img src="/posts/25039/image-20240308235630315.png" class="" title="image-20240308235630315"><h2 id="题目分析思路"><a class="markdownIt-Anchor" href="#题目分析思路"></a> 题目分析（思路）</h2><ol><li><p>首先，定义按键所控制的相关变量</p></li><li><p>编写数码管显示的逻辑，以”设置状态为准“，测试按键是否能正常控制相关参数(工作模式、流转间隔)</p><ul><li>因为一共有四个工作模式，流转间隔定义为一个数组，存放各个元素的流转时长</li></ul></li><li><p>将工作模式1的相关逻辑（LED流转方式）编写出来</p><ul><li>这里使用一个指针用于LED的点亮(LED_OFF)，另一个用于LED的熄灭(LED_ON)</li></ul></li><li><p>将工作模式，流转间隔的逻辑与LED工作模式1关联，测试按键功能是否正常，LED是否能被流转间隔控制</p></li><li><p>如果以上程序测试正确，编写其他三个工作模式的LED模块</p><ul><li>此时进行程序测试，功能正常，但是切换其他流转模式会有上一个模式的LED”残留“ (如双LED模式切换到单LED模式时)，因此需要进行LED的复位（在按键控制模块中编写）</li></ul></li><li><p>修改完毕后，编写亮度控制，此时注意到，一个定时器0无法满足对LED扫描的同时进行亮度控制，因此再调用定时器1，用于LED的<strong>扫描指针偏移</strong>，以及LED的<strong>PWM控制亮度</strong>。</p><ul><li>这里修改完程序后，发现数码管闪烁，这是因为定时器1的频率较高，会打断主函数中数码管显示模块，因此将Nixie_Proc()函数放入定时器1中进行运行</li></ul></li><li><p>当以上各个功能全部测试完毕后，调用EEPROM模块，保存流转间隔</p></li></ol><h1 id="程序部分"><a class="markdownIt-Anchor" href="#程序部分"></a> 程序部分</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Work_Mode;<span class="comment">//工作模式参数 0-模式1 1-模式2 2-模式3 3-模式4</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Set_Mode;<span class="comment">// 0-数码管熄灭 1-模式编号 2-流转间隔</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_FlashFlag;<span class="comment">//闪烁标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Timer_800ms;<span class="comment">//0.8s定时（闪烁用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> LED_Flow_Timer_Set[]={<span class="number">400</span>,<span class="number">400</span>,<span class="number">400</span>,<span class="number">400</span>};<span class="comment">//流转间隔参数,控制流转速度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> LED_Flow_Timer;<span class="comment">//流转定时</span></span><br><span class="line">bit LED_Enable=<span class="number">0</span>;<span class="comment">//LED流转使能位，1时LED流转使能，默认LED流转启动</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Level_ShowFlag;<span class="comment">//按下按键4显示LED亮度等级</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_OFF=<span class="number">7</span>;<span class="comment">//LED熄灭指针</span></span><br><span class="line"><span class="comment">/*LED亮度控制相关参数*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Count;<span class="comment">//LED显示周期</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Level;<span class="comment">//LED等级</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Pos;<span class="comment">//LED扫描位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键扫描模块*/</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键4按下*/</span></span><br><span class="line"><span class="keyword">if</span>(Key_Old==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">LED_Level_ShowFlag=<span class="number">1</span>;<span class="comment">//显示LED亮度等级</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_Level_ShowFlag=<span class="number">0</span>;<span class="comment">//松开，LED亮度等级标志位失效</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键控制模块*/</span></span><br><span class="line"><span class="keyword">switch</span>(Key_Down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:<span class="comment">//按键7，用于控制LED的启动和暂停</span></span><br><span class="line">LED_Enable^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:<span class="comment">//按键6，控制设置界面</span></span><br><span class="line"><span class="keyword">if</span>(++Set_Mode==<span class="number">3</span>)</span><br><span class="line">Set_Mode=<span class="number">0</span>;</span><br><span class="line">EEPROM_Write(LED_Flow_Timer_Set,<span class="number">0x00</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//按键5</span></span><br><span class="line"><span class="keyword">if</span>(Set_Mode==<span class="number">2</span>)<span class="comment">//设置界面位于“流转间隔“对应”运行模式“的流转间隔+100ms</span></span><br><span class="line">{</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]+=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer_Set[Work_Mode]&gt;=<span class="number">1300</span>)</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]=<span class="number">400</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Set_Mode==<span class="number">1</span>)<span class="comment">//设置界面位于“运行模式”运行模式切换</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Work_Mode==<span class="number">4</span>)</span><br><span class="line">Work_Mode=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每次模式切换，对LED指针进行复位*/</span></span><br><span class="line"><span class="keyword">if</span>(Work_Mode==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为4</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为1</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">7</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为2</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为3</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">3</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span>(Set_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]-=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer_Set[Work_Mode]&lt;=<span class="number">300</span>)</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]=<span class="number">1200</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Set_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--Work_Mode==<span class="number">255</span>)</span><br><span class="line">Work_Mode=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每次模式切换，对LED指针进行复位*/</span></span><br><span class="line"><span class="keyword">if</span>(Work_Mode==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">7</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line">LED_Level=<span class="number">4</span>-((AD_Read(<span class="number">0x01</span>))/<span class="number">64</span>);</span><br><span class="line"><span class="keyword">switch</span>(Set_Mode)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Level_ShowFlag)</span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Level;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">17</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=Nixie_FlashFlag?Work_Mode:<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=(LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>)?LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>:<span class="number">10</span>;<span class="comment">//高位熄灭</span></span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Flow_Timer_Set[Work_Mode]%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=Work_Mode;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(Nixie_FlashFlag)</span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=(LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>)?LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>:<span class="number">10</span>;<span class="comment">//高位熄灭</span></span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Flow_Timer_Set[Work_Mode]%<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer)<span class="keyword">return</span>;</span><br><span class="line">LED_Flow_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*LED工作模式控制模块*/</span></span><br><span class="line"><span class="keyword">switch</span>(Work_Mode)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)<span class="comment">//LED流转使能位有效</span></span><br><span class="line">{</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(++LED_ON==<span class="number">8</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">0</span>;LED_OFF=<span class="number">7</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--LED_ON==<span class="number">255</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">7</span>;LED_OFF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++LED_ON==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">0</span>;LED_OFF=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--LED_ON==<span class="number">255</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">3</span>;LED_OFF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer1_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//125微秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0xBF</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL1 = <span class="number">0x83</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH1 = <span class="number">0xFF</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF1 = <span class="number">0</span>;<span class="comment">//清除TF1标志</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">ET1 = <span class="number">1</span>; <span class="comment">//定时器i打开</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">EEPROM_Read(LED_Flow_Timer_Set,<span class="number">0x00</span>,<span class="number">4</span>);<span class="comment">//读取AT24C02中的数据</span></span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">Timer1_Init();</span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行任务</span></span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line"><span class="comment">//Nixie_Proc();</span></span><br><span class="line">LED_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">300</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line"><span class="keyword">if</span>(++LED_Flow_Timer&gt;=LED_Flow_Timer_Set[Work_Mode]){LED_Flow_Timer=<span class="number">0</span>;}<span class="comment">//控制LED流转速度</span></span><br><span class="line"><span class="keyword">if</span>(++LED_Count==<span class="number">13</span>){LED_Count=<span class="number">0</span>;}<span class="comment">//LED亮起的周期（PWM周期），12MS</span></span><br><span class="line"><span class="keyword">if</span>(++Timer_800ms==<span class="number">800</span>){Timer_800ms=<span class="number">0</span>;Nixie_FlashFlag^=<span class="number">1</span>;}</span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer1_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 3</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++LED_Pos==<span class="number">8</span>){LED_Pos=<span class="number">0</span>;}<span class="comment">//LED每1ms完成一次扫描</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(LED_Count&lt;((LED_Level<span class="number">-1</span>)*<span class="number">3</span>))<span class="comment">//LED占空比</span></span><br><span class="line">{</span><br><span class="line">LED_Disp(LED_Pos,ucLED[LED_Pos]);<span class="comment">//LED点亮，1ms</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_Disp(LED_Pos,<span class="number">0</span>);<span class="comment">//LED熄灭,1ms</span></span><br><span class="line">}</span><br><span class="line">Nixie_Proc();<span class="comment">//如果数码管放置在主程序中，由于定时器1频率高，优先级高，主函数会被频繁打断出现闪烁现象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
          <category> 蓝桥杯 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> STC15 </tag>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单片机】SPI协议</title>
      <link href="/posts/23815/"/>
      <url>/posts/23815/</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h1><h3 id="什么是spi"><a class="markdownIt-Anchor" href="#什么是spi"></a> 什么是SPI？</h3><p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一 种同步串行接口技术，是一种高速的，全双工，同步的通信总线。</p><p><strong>SPI优点</strong>:支持全双工通信 通信简单 数据传输速率块</p><p><strong>缺点</strong> :没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据 可靠性上有一定的缺陷。</p><p><strong>特点</strong>:</p><ol><li>高速、同步、全双工、非差分、总线式</li><li>主从机通信模式</li></ol><h1 id="蓝桥杯相关暂未使用spi"><a class="markdownIt-Anchor" href="#蓝桥杯相关暂未使用spi"></a> 蓝桥杯相关（暂未使用SPI）</h1><h2 id="ds1302时钟芯片底层"><a class="markdownIt-Anchor" href="#ds1302时钟芯片底层"></a> DS1302（时钟芯片）底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ds1302.h"</span></span></span><br><span class="line">sbit SCK=P1^<span class="number">7</span>;</span><br><span class="line">sbit SDA=P2^<span class="number">3</span>;</span><br><span class="line">sbit RST = P1^<span class="number">3</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302</span><span class="params">(<span class="type">unsigned</span>  <span class="type">char</span> temp)</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)     </span><br><span class="line">{ </span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">SDA=temp&amp;<span class="number">0x01</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">SCK=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302_Byte</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address,<span class="type">unsigned</span> <span class="type">char</span> dat )</span>     </span><br><span class="line">{</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>; _nop_();  </span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> Write_Ds1302(dat);</span><br><span class="line"> RST=<span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_Ds1302_Byte</span> <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address )</span></span><br><span class="line">{</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> i,temp=<span class="number">0x00</span>;</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>;_nop_();</span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) </span><br><span class="line"> {</span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(SDA)</span><br><span class="line"> temp|=<span class="number">0x80</span>;</span><br><span class="line"> SCK=<span class="number">1</span>;</span><br><span class="line">} </span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line">SCK=<span class="number">1</span>;_nop_();</span><br><span class="line">SDA=<span class="number">0</span>;_nop_();</span><br><span class="line">SDA=<span class="number">1</span>;_nop_();</span><br><span class="line"><span class="keyword">return</span> (temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写"><a class="markdownIt-Anchor" href="#基于底层的时序编写"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Set_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0</span>);<span class="comment">//关闭写保护</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x84</span>-i*<span class="number">2</span>,ucRtc[i]);<span class="comment">//给ds1302写入数据,0x84时 0x82分 0x80秒</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">1</span>);<span class="comment">//打开写保护</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">ucRtc[i] = Read_Ds1302_Byte(<span class="number">0x85</span>-i*<span class="number">2</span>);<span class="comment">//读取ds1302的数据</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0</span>);<span class="comment">//关闭写保护</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8c</span>,ucDate[<span class="number">0</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x88</span>,ucDate[<span class="number">1</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x86</span>,ucDate[<span class="number">2</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">ucDate[<span class="number">0</span>] = Read_Ds1302_Byte(<span class="number">0x8d</span>);</span><br><span class="line">ucDate[<span class="number">1</span>] = Read_Ds1302_Byte(<span class="number">0x89</span>);</span><br><span class="line">ucDate[<span class="number">2</span>] = Read_Ds1302_Byte(<span class="number">0x87</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="超声波底层"><a class="markdownIt-Anchor" href="#超声波底层"></a> 超声波底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ultrasonic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit TX = P1^<span class="number">0</span>;</span><br><span class="line">sbit RX = P1^<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//超声波初始化函数 产生8个40Mhz的方波信号</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        TX=<span class="number">1</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">        TX=<span class="number">0</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写-2"><a class="markdownIt-Anchor" href="#基于底层的时序编写-2"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Ut_Wave_Data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;</span><br><span class="line">    TL1=TH1=<span class="number">0</span>;</span><br><span class="line">    Ut_Wave_Init();</span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((RX==<span class="number">1</span>) &amp;&amp; (TF1==<span class="number">0</span>));<span class="comment">//等待超声波返回或定时器溢出</span></span><br><span class="line"></span><br><span class="line">    TR1=<span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(TF1==<span class="number">0</span>)<span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = TH1&lt;&lt;<span class="number">8</span> | TL1;</span><br><span class="line">        <span class="keyword">return</span> (time *<span class="number">0.017</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        TF1=<span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单片机】OneWire通信协议</title>
      <link href="/posts/46163/"/>
      <url>/posts/46163/</url>
      
        <content type="html"><![CDATA[<h3 id="一-onewire单总线协议"><a class="markdownIt-Anchor" href="#一-onewire单总线协议"></a> 一、OneWire（单总线）协议</h3><p>•单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线</p><p>•一根通信线：DQ</p><p>•异步、半双工</p><p>•单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线</p><h3 id="二-单总线电路规范"><a class="markdownIt-Anchor" href="#二-单总线电路规范"></a> 二、单总线电路规范</h3><p>•设备的DQ均要配置成开漏输出模式</p><p>•DQ添加一个上拉电阻，阻值一般为4.7KΩ左右</p><p>•若此总线的从机采取寄生供电，则主机还应配一个强上拉输出电路</p><img src="/posts/46163/image-20240302232447437.png" class="" title="image-20240302232447437"><h3 id="三-单总线的时序结构"><a class="markdownIt-Anchor" href="#三-单总线的时序结构"></a> 三、单总线的时序结构</h3><img src="/posts/46163/image-20240302232633388.png" class="" title="image-20240302232633388"><img src="/posts/46163/image-20240302232648244.png" class="" title="image-20240302232648244"><img src="/posts/46163/image-20240302232700200.png" class="" title="image-20240302232700200"><img src="/posts/46163/image-20240302232708528.png" class="" title="image-20240302232708528"><hr><h1 id="蓝桥杯相关"><a class="markdownIt-Anchor" href="#蓝桥杯相关"></a> 蓝桥杯相关</h1><h2 id="onewire底层"><a class="markdownIt-Anchor" href="#onewire底层"></a> OneWire底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"onewire.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"reg52.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit DQ = P1^<span class="number">4</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线内部延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_OneWire</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>  </span><br><span class="line">{</span><br><span class="line">t *= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线写操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_DS18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">DQ = dat&amp;<span class="number">0x01</span>;</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线读操作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_DS18B20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(DQ)</span><br><span class="line">{</span><br><span class="line">dat |= <span class="number">0x80</span>;</span><br><span class="line">}    </span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//DS18B20初始化</span></span><br><span class="line">bit <span class="title function_">init_ds18b20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  bit initflag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">12</span>);</span><br><span class="line">  DQ = <span class="number">0</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">80</span>);</span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">10</span>); </span><br><span class="line">    initflag = DQ;     </span><br><span class="line">  Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> initflag;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ds18b20温度读取时序"><a class="markdownIt-Anchor" href="#ds18b20温度读取时序"></a> DS18B20温度读取时序</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基于底层编写*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">ds18b20_read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> low,high;<span class="comment">//高八位，低八位，DS18B20温度数据是十六位二进制</span></span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0x44</span>);<span class="comment">//ds18b20开始温度转换</span></span><br><span class="line">    </span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0xbe</span>);<span class="comment">//ds18b20开始温度读取</span></span><br><span class="line">low=Read_DS18B20();</span><br><span class="line">high=Read_DS18B20();</span><br><span class="line"><span class="keyword">return</span>((high &lt;&lt; <span class="number">8</span> )| low) /<span class="number">16.0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单片机】IIC通信协议</title>
      <link href="/posts/19787/"/>
      <url>/posts/19787/</url>
      
        <content type="html"><![CDATA[<h3 id="一-单片机通信基础概念"><a class="markdownIt-Anchor" href="#一-单片机通信基础概念"></a> 一、单片机通信基础概念</h3><p><strong>全双工和半双工的区别：</strong></p><p>一、全双工（Full Duplex）通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。</p><p>二、半双工（Half Duplex）数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。</p><p><strong>MCU中常见的通信协议：</strong></p><img src="/posts/19787/5490adeb2e9d43dcae940a3b83a35b73.png" class="" title="在这里插入图片描述"><h3 id="二-推挽输出和开漏输出"><a class="markdownIt-Anchor" href="#二-推挽输出和开漏输出"></a> 二、推挽输出和开漏输出</h3><p><strong>推挽输出：</strong></p><blockquote><p>推挽输出结构是由两个MOS或者<a href="https://so.csdn.net/so/search?q=%E4%B8%89%E6%9E%81%E7%AE%A1&amp;spm=1001.2101.3001.7020">三极管</a>收到互补控制的信号控制，两个管子时钟一个在导通，一个在截止，如图1所示：</p></blockquote><img src="/posts/19787/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdHRsZV9veA==,size_16,color_FFFFFF,t_70.png" class="" title="图1 推挽输出结构"><p>特点:</p><ul><li>推挽输出可以输出高电平和低电平，在两种电平下都具有驱动能力。</li><li>相比于后面介绍的开漏输出，输出高电平时的驱动能力强很多</li><li>缺点：推挽输出不能实现" 线与"。</li></ul><p><strong>开漏输出：</strong></p><blockquote><p>常说的与推挽输出相对的就是开漏输出，抽象地说就是COMS反相器去掉了NMOS部分，PMOS管漏极输出，即开漏输出。PMOS管由高电平导通输出低电平，高电平没有驱动能力，需要借助“上拉电阻” (一般上拉电阻值较大，即弱上拉模式)<a href="https://blog.csdn.net/monkey_d_xue/article/details/129802153">什么是弱上拉?</a></p></blockquote><img src="/posts/19787/20201208174916607.png" class="" title="图4 OD"><h5 id="开漏输出的另一个优点在于可以实现线与功能所谓的线与指的是多个信号线直接连接在一起只有当所有信号全部为高电平时合在一起的总线为高电平只要有任意一个或者多个信号为低电平则总线为低电平这就是为什么后面用到iic通信当一个信号线为低电平要释放总线"><a class="markdownIt-Anchor" href="#开漏输出的另一个优点在于可以实现线与功能所谓的线与指的是多个信号线直接连接在一起只有当所有信号全部为高电平时合在一起的总线为高电平只要有任意一个或者多个信号为低电平则总线为低电平这就是为什么后面用到iic通信当一个信号线为低电平要释放总线"></a> <strong>开漏输出的另一个优点在于可以实现"线与"功能，所谓的"线与"指的是多个信号线直接连接在一起，只有当所有信号全部为高电平时，合在一起的总线为高电平；只要有任意一个或者多个信号为低电平，则总线为低电平(这就是为什么后面用到IIC通信,当一个信号线为低电平,要"释放总线")。</strong></h5><h5 id="而推挽输出就不行如果高电平和低电平连在一起会出现电流倒灌损坏器件"><a class="markdownIt-Anchor" href="#而推挽输出就不行如果高电平和低电平连在一起会出现电流倒灌损坏器件"></a> <strong>而推挽输出就不行，如果高电平和低电平连在一起，会出现电流倒灌，损坏器件</strong></h5><p><mark><strong>IIC为什么要开漏输出模式？</strong></mark></p><ul><li>输出端浮空，电平易受外界干扰，不稳定</li></ul><h3 id="三-i2c总线介绍"><a class="markdownIt-Anchor" href="#三-i2c总线介绍"></a> 三、I2C总线介绍：</h3><ul><li>I2C总线（Inter IC BUS）是由Philips公司开发的一种通用数据总线</li><li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</li><li>同步、半双工，带数据应答</li><li>通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度</li></ul><h3 id="四-i2c电路规范"><a class="markdownIt-Anchor" href="#四-i2c电路规范"></a> 四、I2C电路规范</h3><ul><li><p>所有I2C设备的SCL连在一起，SDA连在一起</p></li><li><p>设备的SCL和SDA均要配置成开漏输出模式</p></li><li><p>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</p></li><li><p>开漏输出和上拉电阻的共同作用实现了“线与”的功能，此设计主要是为了解决多机通信互相干扰的问题</p></li></ul><h3 id="五-i2c时序结构"><a class="markdownIt-Anchor" href="#五-i2c时序结构"></a> 五、I2C时序结构</h3><hr><img src="/posts/19787/1baf27e6e69a429394f21dd1a30900f1.png" class="" title="在这里插入图片描述"><img src="/posts/19787/115006bca35b4b2a8193651f437b65fc.png" class="" title="在这里插入图片描述"><img src="/posts/19787/a1ec063743594e96bb853e3fe69a3800.png" class="" title="在这里插入图片描述"><img src="/posts/19787/image-20240302223549490.png" class="" title="image-20240302223549490"><img src="/posts/19787/72b48d4af46f41ec9fe40720751e4a39.png" class="" title="在这里插入图片描述"><img src="/posts/19787/image-20240302225440107.png" class="" title="image-20240302225440107"><hr><p><strong>总结：IIC的 时序模块</strong></p><ul><li>起始条件</li><li>中止条件</li><li>发送一个字节</li><li>接收一个字节</li><li>接收应答</li><li>发送应答</li></ul><h1 id="蓝桥杯相关"><a class="markdownIt-Anchor" href="#蓝桥杯相关"></a> 蓝桥杯相关</h1><h2 id="iic模块"><a class="markdownIt-Anchor" href="#iic模块"></a> IIC模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iic.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME 5</span></span><br><span class="line"><span class="comment">// I2C总线内部延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        _nop_();</span><br><span class="line">    } <span class="keyword">while</span> (i--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线启动信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应答或非应答信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendAck</span><span class="params">(bit ackbit)</span></span><br><span class="line">{</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = ackbit;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答</span></span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    <span class="keyword">return</span> ackbit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线发送一个字节数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        <span class="keyword">if</span> (byt &amp; <span class="number">0x80</span>)</span><br><span class="line">            SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SDA = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        byt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线接收一个字节数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i, da;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        da &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SDA)</span><br><span class="line">            da |= <span class="number">1</span>;</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> da;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="adda转换模块"><a class="markdownIt-Anchor" href="#adda转换模块"></a> AD/DA转换模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">AD_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line">    </span><br><span class="line">    IIC_Start();       <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr); <span class="comment">//主机发送一个字节(要操作数据的地址),对应AD转换的通道</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    </span><br><span class="line">    IIC_Start(); <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x91</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    temp = IIC_RecByte(); <span class="comment">//从机送出数据,主机读入的数据用变量存储</span></span><br><span class="line">    IIC_SendAck(<span class="number">1</span>);<span class="comment">//主机发送应答,1表示完成数据的接收,从机停止发送数据</span></span><br><span class="line">    IIC_Stop();<span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DA_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>);<span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x41</span>); <span class="comment">//主机发送一个字节(要操作数据的地址),对应DA转换的通道</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(Data); <span class="comment">//主机送出DA输出的数据字节</span></span><br><span class="line">    IIC_WaitAck(); <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_Stop(); <span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="at24c02epprom模块"><a class="markdownIt-Anchor" href="#at24c02epprom模块"></a> AT24C02（EPPROM）模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环发送数据字节,存入AT24C02</span></span><br><span class="line">    {</span><br><span class="line">        IIC_SendByte(*EEPROM_String++);<span class="comment">//发送数据字节,要存入AT24C02的数据,字节个数为num</span></span><br><span class="line">        IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">        IIC_Delay(<span class="number">200</span>);<span class="comment">//延时200ms,保证从机(AT24C02能够完整收到数据)</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答  </span></span><br><span class="line"></span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA1</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环接收数据字节,存入EEPROM_String指向的地址</span></span><br><span class="line">    {</span><br><span class="line">        *EEPROM_String++=IIC_RecByte();<span class="comment">//指针移位读取数据到对应的地址中</span></span><br><span class="line">        <span class="keyword">if</span>(num)<span class="comment">//判断是否读取完数据</span></span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">0</span>);<span class="comment">//发送应答0,表示继续接收数据</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">1</span>);<span class="comment">//发送应答1,表示停止接收数据</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】AT24C02(EEPROM储存)</title>
      <link href="/posts/4799/"/>
      <url>/posts/4799/</url>
      
        <content type="html"><![CDATA[<p>2.26更新</p><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><h2 id="前置概念"><a class="markdownIt-Anchor" href="#前置概念"></a> #前置概念</h2><blockquote><p>所用外设：</p><p><mark>AT24C02(EEPROM储存) 使用IIC协议</mark></p></blockquote><h3 id="一-单片机通信协议本文以iic为重点"><a class="markdownIt-Anchor" href="#一-单片机通信协议本文以iic为重点"></a> 一、单片机通信协议（本文以IIC为重点）</h3><p><strong>全双工和半双工的区别：</strong></p><p>一、全双工（Full Duplex）通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。</p><p>二、半双工（Half Duplex）数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。</p><p><strong>MCU中常见的通信协议：</strong></p><img src="/posts/4799/5490adeb2e9d43dcae940a3b83a35b73.png" class="" title="在这里插入图片描述"><h3 id="二-推挽输出和开漏输出"><a class="markdownIt-Anchor" href="#二-推挽输出和开漏输出"></a> 二、推挽输出和开漏输出</h3><p><strong>推挽输出：</strong></p><ul><li>推挽输出可以输出高电平和低电平，在两种电平下都具有驱动能力。</li><li>相比于后面介绍的开漏输出，输出高电平时的驱动能力强很多</li><li>缺点：推挽输出不能实现" 线与"。</li></ul><p><strong>开漏输出：</strong></p><ul><li>常说的与推挽输出相对的就是开漏输出，抽象地说就是COMS反相器去掉了NMOS部分，PMOS管漏极输出，即开漏输出。PMOS管由高电平导通输出低电平，高电平没有驱动能力，需要借助“上拉电阻” (一般上拉电阻值较大，即弱上拉模式)<a href="https://blog.csdn.net/monkey_d_xue/article/details/129802153">什么是弱上拉?</a></li></ul><p><mark><strong>IIC为什么要开漏输出模式？</strong></mark></p><ul><li>输出端浮空，电平易受外界干扰，不稳定</li></ul><h3 id="三-i2c总线介绍"><a class="markdownIt-Anchor" href="#三-i2c总线介绍"></a> 三、I2C总线介绍：</h3><ul><li>I2C总线（Inter IC BUS）是由Philips公司开发的一种通用数据总线</li><li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</li><li>同步、半双工，带数据应答</li><li>通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度</li></ul><h3 id="四-i2c电路规范"><a class="markdownIt-Anchor" href="#四-i2c电路规范"></a> 四、I2C电路规范</h3><ul><li><p>所有I2C设备的SCL连在一起，SDA连在一起</p></li><li><p>设备的SCL和SDA均要配置成开漏输出模式</p></li><li><p>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</p></li><li><p>开漏输出和上拉电阻的共同作用实现了“线与”的功能，此设计主要是为了解决多机通信互相干扰的问题</p></li></ul><h3 id="五-i2c时序结构"><a class="markdownIt-Anchor" href="#五-i2c时序结构"></a> 五、I2C时序结构</h3><hr><img src="/posts/4799/1baf27e6e69a429394f21dd1a30900f1.png" class="" title="在这里插入图片描述"><img src="/posts/4799/115006bca35b4b2a8193651f437b65fc.png" class="" title="在这里插入图片描述"><img src="/posts/4799/a1ec063743594e96bb853e3fe69a3800.png" class="" title="在这里插入图片描述"><img src="/posts/4799/image-20240302223549490.png" class="" title="image-20240302223549490"><img src="/posts/4799/72b48d4af46f41ec9fe40720751e4a39.png" class="" title="在这里插入图片描述"><img src="/posts/4799/image-20240302225440107.png" class="" title="image-20240302225440107"><hr><p><strong>总结：IIC的工作模块</strong></p><ul><li>起始条件</li><li>中止条件</li><li>发送一个字节</li><li>接收一个字节</li><li>接收应答</li><li>发送应答</li></ul><hr><h2 id="存储器at24c02"><a class="markdownIt-Anchor" href="#存储器at24c02"></a> #存储器/AT24C02</h2><h3 id="一-ram和rom"><a class="markdownIt-Anchor" href="#一-ram和rom"></a> 一、RAM和ROM</h3><blockquote><p>**RAM : 易失性存储器 (高速存储） **</p><p><mark>单片机内RAM为中间数据存储器</mark></p></blockquote><ul><li>SRAM：静态RAM，电脑中的CPU，高速缓存，容量少，成本高</li><li>DRAM：动态RAM，使用电容存储，电容容值小，需要补电能，成本相较于SRAM更低，容量更大</li><li>掉电丢失</li></ul><blockquote><p><strong>ROM:非易失性存储器</strong></p><p><mark>单片机内ROM为指令存储器</mark></p></blockquote><ul><li>Mask ROM(掩膜ROM），只能读，不能写</li><li>PROM：可编程ROM，可以写，但是只能写入一次</li><li>EPROM：可擦除可编程ROM，可以编程，也可以清除（30分钟紫外线）</li><li>E2PROM： 电可擦除可编程ROM，5V电可擦除，掉电不丢失</li><li>Flash（闪存）：</li><li>硬盘、软盘、光盘等：磁介质、光信号</li></ul><hr><img src="/posts/4799/image-20240302224153992.png" class="" title="image-20240302224153992"><blockquote><p>单片机烧录的由来：早期通过编程储存数据，实际上是将特殊的二极管击穿，相当于“烧毁”（PROM）</p></blockquote><hr><h3 id="二-at24c02"><a class="markdownIt-Anchor" href="#二-at24c02"></a> 二、AT24C02</h3><img src="/posts/4799/image-20240302224329935.png" class="" title="image-20240302224329935"><img src="/posts/4799/7b07f23e9e7640f1b8db85bc873a9e36.png" class="" title="在这里插入图片描述"><h1 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> 代码部分</h1><h2 id="一-给at24c02写入数据"><a class="markdownIt-Anchor" href="#一-给at24c02写入数据"></a> 一、给AT24C02写入数据</h2><blockquote><p><strong>实现：AT24C02掉电不丢失</strong></p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LCD1602.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AT24C02.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Hello World"</span>);</span><br><span class="line"><span class="comment">//AT24C02_WriteByte(1,123);</span></span><br><span class="line">Delay(<span class="number">5</span>);<span class="comment">//AT21C02写一个序列的有效停止条件开始至内部写周期结束的时间</span></span><br><span class="line">Data=AT24C02_ReadByte(<span class="number">1</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,Data,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完善代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LCD1602.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AT24C02.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum;</span><br><span class="line"><span class="comment">//unsigned char Num; 这里要用到整型</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key();</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">Num--;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">AT24C02_WriteByte(<span class="number">0</span>,Num%<span class="number">256</span>);<span class="comment">//低八位</span></span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">1</span>,Num/<span class="number">256</span>);<span class="comment">//高八位</span></span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"Write OK"</span>);<span class="comment">//完成写入数据，提示</span></span><br><span class="line">Delay(<span class="number">1000</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"        "</span>);<span class="comment">//延时清除</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">4</span>)<span class="comment">//读的时候不需要Delay</span></span><br><span class="line">{</span><br><span class="line">Num=AT24C02_ReadByte(<span class="number">0</span>);</span><br><span class="line">Num|=AT24C02_ReadByte(<span class="number">1</span>)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"Read OK"</span>);<span class="comment">//完成读取数据，提示</span></span><br><span class="line">Delay(<span class="number">1000</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"        "</span>);<span class="comment">//延时清除</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为什么要写:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AT24C02_WriteByte(<span class="number">0</span>,Num%<span class="number">256</span>);<span class="comment">//低八位</span></span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">1</span>,Num/<span class="number">256</span>);<span class="comment">//高八位</span></span><br></pre></td></tr></tbody></table></figure><p>因为：int类型最高65535,对应的二进制为16位</p><h2 id="二-定时器扫描按键"><a class="markdownIt-Anchor" href="#二-定时器扫描按键"></a> 二、定时器扫描按键</h2><blockquote><p><strong>实验：定时器按键扫描，<mark>实现键值的数码管显示</mark></strong></p><p><strong>实验结果：如果直接让Nixie在判断键码后显示Keynum值，只能显示一瞬间，数码管的显示方式不同于LCD1602，所以需要一个缓存量Temp</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*错误写法*/</span><br><span class="line">Temp=Key();</span><br><span class="line">if(KeyNum)//显示结果只在一瞬间显示</span><br><span class="line">{</span><br><span class="line">Nixie(1,KeyNum);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*正确写法*/</span><br><span class="line">if(Temp)</span><br><span class="line">{</span><br><span class="line">KeyNum=Temp;</span><br><span class="line">}</span><br><span class="line">Nixie(1,KeyNum);</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>实验：定时器按键扫描实列2</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;REGX52.H&gt;</span><br><span class="line">#include "Key.h"</span><br><span class="line">#include "AT24C02.h"</span><br><span class="line">#include "Timer0.h"</span><br><span class="line">#include "Nixie.h"</span><br><span class="line">#include "Delay.h"</span><br><span class="line">unsigned char KeyNum;</span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line">Timer0_Init();</span><br><span class="line">while(1)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key();</span><br><span class="line">if(KeyNum)</span><br><span class="line">{</span><br><span class="line">Nixie_SetBuf(1,KeyNum);</span><br><span class="line">Nixie_SetBuf(2,KeyNum);</span><br><span class="line">Nixie_SetBuf(3,KeyNum);</span><br><span class="line">Delay(1000);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Timer0_Routine() interrupt 1 //中断子程序</span><br><span class="line">{</span><br><span class="line">static unsigned int T0Count1,T0Count2;//静态局部变量，保证退出函数之后不销毁</span><br><span class="line">TL0 = 0x66;//设置定时初始值</span><br><span class="line">TH0 = 0xFC;//设置定时初始值</span><br><span class="line">T0Count1++;//每次进入中断子程序，秒控制器自加一</span><br><span class="line">if(T0Count1&gt;=20)//每隔20ms，按键函数会被调用一次</span><br><span class="line">{</span><br><span class="line">T0Count1=0;</span><br><span class="line">Key_Loop(); </span><br><span class="line">}</span><br><span class="line">T0Count2++;</span><br><span class="line">if(T0Count2&gt;=2)</span><br><span class="line">{</span><br><span class="line"> T0Count2=0;</span><br><span class="line"> Nixie_Loop();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>实验结果：</strong></p><img src="/posts/4799/cd3ca4af62f4478d9e79c4a31087a160.jpeg" class="" title="请添加图片描述"><img src="/posts/4799/858d834686d84ec7b7dab21610cca5db.jpeg" class="" title="请添加图片描述"><p><strong><mark>这时，按下按键，数码管显示会延时一秒改变，可见，使用定时器扫描按键，不会被延时函数影响，相较于延时函数使单片机的工作更具有可靠性</mark></strong></p></blockquote><hr><blockquote><p><strong>秒表源代码：</strong><br>操作方式：</p><ul><li>按键1暂停</li><li>按键2清零</li><li>按键3通过AT24C02写入数据</li><li>按键4通过AT24C02读取数据</li></ul></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AT24C02.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Timer0.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Nixie.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Min,Sec,MiniSec;<span class="comment">//单位：分，秒，1/100s=10ms</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> RunFlag;<span class="comment">//启动暂定标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">P2_5=<span class="number">0</span>;<span class="comment">//蜂鸣器关闭</span></span><br><span class="line">Timer0_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key();</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RunFlag=!RunFlag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">Min=<span class="number">0</span>;Sec=<span class="number">0</span>;MiniSec=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">AT24C02_WriteByte(<span class="number">0</span>,Min);</span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">1</span>,Sec);</span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">2</span>,MiniSec);</span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">Min=AT24C02_ReadByte(<span class="number">0</span>);</span><br><span class="line">Sec=AT24C02_ReadByte(<span class="number">1</span>);</span><br><span class="line">MiniSec=AT24C02_ReadByte(<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Nixie_SetBuf(<span class="number">1</span>,Min/<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">2</span>,Min%<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">3</span>,<span class="number">11</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">4</span>,Sec/<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">5</span>,Sec%<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">6</span>,<span class="number">11</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">7</span>,MiniSec/<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">8</span>,MiniSec%<span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sec_Loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RunFlag)</span><br><span class="line">{</span><br><span class="line">MiniSec++;</span><br><span class="line"><span class="keyword">if</span>(MiniSec&gt;=<span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">MiniSec=<span class="number">0</span>;</span><br><span class="line">Sec++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Sec&gt;=<span class="number">60</span>)</span><br><span class="line">{</span><br><span class="line">Sec=<span class="number">0</span>;</span><br><span class="line">Min++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Min&gt;=<span class="number">60</span>)</span><br><span class="line">{</span><br><span class="line">Min=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 <span class="comment">//中断子程序</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count1,T0Count2,T0Count3;<span class="comment">//静态局部变量，保证退出函数之后不销毁</span></span><br><span class="line">TL0 = <span class="number">0x66</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T0Count1++;<span class="comment">//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"><span class="keyword">if</span>(T0Count1&gt;=<span class="number">20</span>)<span class="comment">//每隔20ms，按键函数会被调用一次</span></span><br><span class="line">{</span><br><span class="line">T0Count1=<span class="number">0</span>;</span><br><span class="line">Key_Loop(); </span><br><span class="line">}</span><br><span class="line">T0Count2++;</span><br><span class="line"><span class="keyword">if</span>(T0Count2&gt;=<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"> T0Count2=<span class="number">0</span>;</span><br><span class="line"> Nixie_Loop();</span><br><span class="line">}</span><br><span class="line">T0Count3++;</span><br><span class="line"><span class="keyword">if</span>(T0Count3&gt;=<span class="number">10</span>)<span class="comment">//10ms</span></span><br><span class="line">{</span><br><span class="line"> T0Count3=<span class="number">0</span>;</span><br><span class="line"> Sec_Loop();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>题外话: 6-1矩阵键盘密码锁：为什么密码不能设置为0开头?<br>因为0开头代表八进制,比如0123实际上对应的十进制数是83</p></blockquote><hr><h1 id="蓝桥杯stc15拓展"><a class="markdownIt-Anchor" href="#蓝桥杯stc15拓展"></a> #蓝桥杯(STC15)拓展</h1><p><strong>IIC通信底层</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iic.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME 5</span></span><br><span class="line"><span class="comment">// I2C总线内部延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        _nop_();</span><br><span class="line">    } <span class="keyword">while</span> (i--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线启动信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应答或非应答信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendAck</span><span class="params">(bit ackbit)</span></span><br><span class="line">{</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = ackbit;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答</span></span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    <span class="keyword">return</span> ackbit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线发送一个字节数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        <span class="keyword">if</span> (byt &amp; <span class="number">0x80</span>)</span><br><span class="line">            SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SDA = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        byt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线接收一个字节数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i, da;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        da &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SDA)</span><br><span class="line">            da |= <span class="number">1</span>;</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> da;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基于IIC底层，编写AT24C02函数模块*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 写入EEPROM</span></span><br><span class="line"><span class="comment">  * @param  需要写的字符串，写入的地址，写入数量</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">IIC_Start();<span class="comment">//发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line">    </span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//写入要储存的数据地址,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        IIC_SendByte(*EEPROM_String++);<span class="comment">//要存入AT24C02的数据,按位存</span></span><br><span class="line">        IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line">        IIC_Delay(<span class="number">200</span>);</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//停止IIC命令</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 读取EEPROM数据,替换需要读取字符串的数据</span></span><br><span class="line"><span class="comment">  * @param  需要读取的字符串，写入的地址，写入数量</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//写入要读取的数据地址,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答  </span></span><br><span class="line"></span><br><span class="line">    IIC_Start();<span class="comment">//发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA1</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        *EEPROM_String++=IIC_RecByte();<span class="comment">//按位取数据</span></span><br><span class="line">        <span class="keyword">if</span>(num)<span class="comment">//未取完数据</span></span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">1</span>);<span class="comment">//主机接收完数据，发送应答</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//停止IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[5]定时器控制PWM</title>
      <link href="/posts/32351/"/>
      <url>/posts/32351/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>配置结构体初始化输出比较单元</strong></p><p>void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);<br>void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);<br>void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);<br>void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);</p><p><strong>设置结构体初始值</strong></p><p>void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);</p><hr><p><strong>*配置强制输出</strong></p><p>void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);</p><p><strong>*配置影子寄存器</strong></p><p>void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);</p><p><strong>*配置快速使能</strong></p><p>xxxxxxxxxx&nbsp;typedef struct//typedef为成员列表提供了一个GPIO_InitTypeDef的名字{}GPIO_InitTypeDef;c</p><p><strong>*清除REF信号</strong></p><p>void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);<br>void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);<br>void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);<br>void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);</p><p><strong>配置输出极性</strong></p><blockquote><p>带N即高级定时器里互补通道的配置</p><p>OC4无互补通道</p><p>结构体初始化中也可以设置极性</p></blockquote><p>void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);<br>void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);<br>void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);<br>void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);<br>void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);<br>void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);<br>void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);</p><p>void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);<br>void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);</p><p><strong>单独修改输出使能参数</strong></p><p>void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);<br>void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);</p><p><strong>单独更改输出比较模式</strong></p><p>void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);</p><p><strong>单独更改CCR寄存器的函数</strong></p><p>void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);<br>void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);<br>void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);<br>void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);</p><p><strong>高级定时器，使能PWM，否则无法正常输出</strong></p><p>void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 定时器 </tag>
            
            <tag> PWM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【蓝桥杯单片机】程序模板设计</title>
      <link href="/posts/18220/"/>
      <url>/posts/18220/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p><strong>为了确保程序的准确性，总结了以下要点</strong></p><ol><li><mark>保证程序<strong>逻辑正确</strong>，其次再是“基于现象上”的正确，保证程序不会出现<strong>隐性问题</strong></mark></li><li><mark>在逻辑正确的前提下，保证数据读取的<strong>实时性</strong>，尽量优化代码执行效率</mark></li><li><mark>对数据的处理，在确保程序完全正常运行的前提下，最大限度地提高内存空间的<strong>利用率</strong></mark></li><li><mark>编写程序时，先写主框架，验证逻辑后，再依次验证其他模块</mark></li></ol><h1 id="数码管led模块工作原理"><a class="markdownIt-Anchor" href="#数码管led模块工作原理"></a> 数码管/LED模块工作原理</h1><p><mark>例如：数码管的段选/位选输出由两个74HC573锁存器控制</mark></p><img src="/posts/18220/image-20240301234539921.png" class="" title="image-20240301234539921"><blockquote><p><strong>锁存器送出数据的过程</strong></p><ol><li><p>P0输出8位数据</p></li><li><p>锁存器不使能，Q0~Q7为之前的数据，D0 ~ D7等待被送出</p></li><li><p>锁存器使能，数据送出，Q0~Q7即为P00 ~ P07的信号</p><p>注意：OE此处默认接GND</p></li></ol></blockquote><blockquote><p>**如何控制锁存器送出数据的顺序/使锁存器单个送出数据? **</p><ul><li>由一个或非门(U25)的四个输出控制四个锁存器的输入使能信号(Y7C~Y4C)</li></ul><img src="/posts/18220/image-20240301235153721.png" class="" title="image-20240301235153721"><ul><li>或非门的输入Y7 ~ Y4由一个译码器的输出控制，或非门的一端WR默认为低电平，那么这里的或非门就相当于一个输入为Y（n）的非门</li><li>其中74HC138(U24)的输入为P2口的P27~P25</li><li>通过推导可知，P27 ~ P25对应的三位二进制数即为后面会使能的锁存器，即111使得Y7=0，继而使得与非门输出Y7C=1，使得控制数码管段选的锁存器使能，送出数据。</li></ul><img src="/posts/18220/image-20240301235438487.png" class="" title="image-20240301235438487"><p>总结：P27~P25对应组成的二进制值即为使能的锁存器, LED/数码管/外设控制都是由锁存器控制，锁存器的输入共用<mark>P0口</mark>，这样通过多个锁存器，以及逻辑电路，节省了单片机的IO口</p></blockquote><h1 id="程序设计与分析"><a class="markdownIt-Anchor" href="#程序设计与分析"></a> 程序设计与分析</h1><h2 id="ct107d初始化"><a class="markdownIt-Anchor" href="#ct107d初始化"></a> CT107D初始化</h2><p><strong><mark>上电时，默认所有IO口为高电平，未被使能过的锁存器默认输出低电平，这会导致全部LED被点亮，有源蜂鸣器响(也是低电平有效),这就需要我们写一个程序初始化函数，关闭这些影响后续功能的现象</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief系统初始化函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">System_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*关闭LED*/</span></span><br><span class="line">P0 = <span class="number">0xFF</span>;</span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0x80</span>;    <span class="comment">//100X XXXX 锁存器Y4C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*关闭蜂鸣器*/</span></span><br><span class="line">P0=<span class="number">0x00</span>;<span class="comment">//锁存器输出会经过ULN2003，相当于反相器，预载值应为全低电平，这样最终输出的是高电平</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xA0</span>;    <span class="comment">//101X XXXX 锁存器Y5C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注意：锁存器输出会经过ULN2003，相当于(增强驱动能力)反相器，预载值(P2)应为全低电平，这样最终输出的是高电平。</strong></p><p>ULN2003：<a href="https://blog.csdn.net/qq_38410730/article/details/79787766">【常用芯片】ULN2003工作原理及中文资料（实例：STM32驱动28BYJ48步进电机）_uln2003驱动板说明书-CSDN博客</a></p><p><strong>由于单片机的引脚输出电流太低了，无法驱动大部分的设备。而ULN2003只相当于是一个开关，设备（负载）的供电是在外围电路上，而它能够通过微弱的单片机输出电流来控制外围电路的开闭。这某种程度上也可以说是，放大电流，增加驱动能力</strong></p><img src="/posts/18220/image-20240302002932910.png" class="" title="image-20240302002932910"><img src="/posts/18220/image-20240302003020482.png" class="" title="image-20240302003020482"><h2 id="led模块"><a class="markdownIt-Anchor" href="#led模块"></a> LED模块</h2><p>原理图</p><img src="/posts/18220/image-20240302002203560.png" class="" title="image-20240302002203560"><img src="/posts/18220/image-20240302002230011.png" class="" title="image-20240302002230011"><h2 id="led蜂鸣器继电器"><a class="markdownIt-Anchor" href="#led蜂鸣器继电器"></a> LED/蜂鸣器/继电器</h2><p>ps:~(0x01&lt;&lt;addr); 一定要加括号，否则会出现逻辑错误，如 0000 0001–&gt; 1110 1111 变成 1111 1110 – &gt; 1110 0000 ，最终经过一系列运行导致<mark>LED亮度降低</mark>(待考究)。</p><p>ps:<mark>一定要仔细注意逻辑，不能记忆性写程序！</mark></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  LED控制函数</span></span><br><span class="line"><span class="comment">  * @param  LED位，使能标志位</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_1;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old_1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Disp</span><span class="params">(<span class="type">unsigned</span> addr,enable)</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp=<span class="number">0x00</span>;   <span class="comment">// led暂存值</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old=<span class="number">0xFF</span>; <span class="comment">//上下两个变量应当赋不想等的初值</span></span><br><span class="line"><span class="keyword">if</span>(enable)<span class="comment">//LED使能时</span></span><br><span class="line">{</span><br><span class="line">temp|=<span class="number">0x01</span>&lt;&lt;addr; <span class="comment">//点亮第一位, 即 0x01&lt;&lt;0 temp=xxxx xxx1</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">temp&amp;=~(<span class="number">0x01</span>&lt;&lt;addr); <span class="comment">//熄灭第一位，即~ (0x01&lt;&lt;0) temp=xxxx xxx0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(temp!=temp_old) <span class="comment">// temp的值发生变化时（即外部调用此函数，想要改变LED的状态），才会对P0进行赋值操作，因为P0口负责多个锁存器的预载值，LED一般是静态的，不应该对P0进行反复赋值</span></span><br><span class="line">{</span><br><span class="line">P0=~temp; <span class="comment">//低电平有效，故按位取反</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0x80</span>;    <span class="comment">//100X XXXX 锁存器（Y4C使能）</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//000 x xxxx</span></span><br><span class="line">temp_old=temp;<span class="comment">//记录当前的led暂存值</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Beep</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">temp_1 |= <span class="number">0x40</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp_1 &amp;= ~<span class="number">0x40</span>;</span><br><span class="line"><span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">{</span><br><span class="line">P0 = temp_1;</span><br><span class="line">P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>; <span class="comment">//锁存器（Y5C使能）</span></span><br><span class="line">P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">temp_old_1 = temp_1;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Relay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">temp_1 |= <span class="number">0x10</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp_1 &amp;= ~<span class="number">0x10</span>;</span><br><span class="line"><span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">{</span><br><span class="line">P0 = temp_1;</span><br><span class="line">P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;<span class="comment">//锁存器（Y5C使能）</span></span><br><span class="line">P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">temp_old_1 = temp_1;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>PS:按位取或/按位取与，通常用于对单个BIT位进行操作</strong></p><h2 id="数码管模块"><a class="markdownIt-Anchor" href="#数码管模块"></a> 数码管模块</h2><p>ps:<strong><mark>蓝桥杯单片机开发板使用的是共阳极数码管，注意段码和位码，以及Disp函数的逻辑</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//共阳极数码管</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_seg[] = <span class="comment">//段码</span></span><br><span class="line">{</span><br><span class="line"><span class="number">0xc0</span>, <span class="comment">//0</span></span><br><span class="line"><span class="number">0xf9</span>, <span class="comment">//1</span></span><br><span class="line"><span class="number">0xa4</span>, <span class="comment">//2</span></span><br><span class="line"><span class="number">0xb0</span>, <span class="comment">//3</span></span><br><span class="line"><span class="number">0x99</span>, <span class="comment">//4</span></span><br><span class="line"><span class="number">0x92</span>, <span class="comment">//5</span></span><br><span class="line"><span class="number">0x82</span>, <span class="comment">//6</span></span><br><span class="line"><span class="number">0xf8</span>, <span class="comment">//7</span></span><br><span class="line"><span class="number">0x80</span>, <span class="comment">//8</span></span><br><span class="line"><span class="number">0x90</span>, <span class="comment">//9</span></span><br><span class="line"><span class="number">0xFF</span>, <span class="comment">//熄灭&lt;10&gt;</span></span><br><span class="line"><span class="number">0x88</span>, <span class="comment">//A &lt;11&gt;</span></span><br><span class="line"><span class="number">0x83</span>, <span class="comment">//b&lt;12&gt;</span></span><br><span class="line"><span class="number">0xc6</span>, <span class="comment">//C&lt;13&gt;</span></span><br><span class="line"><span class="number">0xa1</span>, <span class="comment">//d&lt;14&gt;</span></span><br><span class="line"><span class="number">0x86</span>, <span class="comment">//E&lt;15&gt;</span></span><br><span class="line"><span class="number">0x8e</span>  <span class="comment">//F&lt;16&gt;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Location[] =  <span class="comment">//位码</span></span><br><span class="line">{</span><br><span class="line"><span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x02</span>,</span><br><span class="line"><span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x08</span>,</span><br><span class="line"><span class="number">0x10</span>,</span><br><span class="line"><span class="number">0x20</span>,</span><br><span class="line"><span class="number">0x40</span>,</span><br><span class="line"><span class="number">0x80</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief数码管点亮函数</span></span><br><span class="line"><span class="comment">  * @param  位选，段选，小数点</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,Seg,Point)</span></span><br><span class="line">{</span><br><span class="line">P0=<span class="number">0xFF</span>; <span class="comment">//段码，数码管熄灭，消影</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xE0</span>;    <span class="comment">//111X XXXX 锁存器 Y7C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//关闭锁存器</span></span><br><span class="line"></span><br><span class="line">P0=Nixie_Location[Location];<span class="comment">//位选预载值</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xC0</span>;    <span class="comment">//101X XXXX 锁存器 Y5C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//关闭锁存器</span></span><br><span class="line"></span><br><span class="line">P0=Nixie_seg[Seg];<span class="comment">//段选预载值</span></span><br><span class="line">    <span class="comment">//这里的Point即为数码管‘点’的使能位，实质上‘点’对应的是数码管段码的BIT7，最高位</span></span><br><span class="line"><span class="keyword">if</span>(Point){P0 &amp;= <span class="number">0x7F</span>;}    <span class="comment">//错误写法：P0|=0x80; 共阳极数码管！，逻辑0点亮！</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xE0</span>;   <span class="comment">//111X XXXX 锁存器 Y7C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//关闭锁存器</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定时器模块"><a class="markdownIt-Anchor" href="#定时器模块"></a> 定时器模块</h2><p><strong><mark>注意，STC15单片机的定时器是支持自动重装载的，这里不需要在中断子程序中赋初值，否则会出现定时器定时值的混乱</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief定时器初始化</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0x7F</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0xF0</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL0 = <span class="number">0x18</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF0 = <span class="number">0</span>;<span class="comment">//清除TF0标志</span></span><br><span class="line">TR0 = <span class="number">1</span>;<span class="comment">//定时器0开始计时</span></span><br><span class="line">ET0 = <span class="number">1</span>;<span class="comment">//定时器中断0打开</span></span><br><span class="line">EA  = <span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">PT0 = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void Timer0_Server(void)  interrupt 1</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="按键模块"><a class="markdownIt-Anchor" href="#按键模块"></a> 按键模块</h2><p>ps:<strong><mark>键值读取函数中定义局部变量temp一定要赋初值！！！否则会出现在没有按键按下时键值读取异常值的情况。</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief矩阵按键读取函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/*矩阵按键模式*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp=<span class="number">0</span>;<span class="comment">//局部变量初始化为0</span></span><br><span class="line">    ET0=<span class="number">0</span>;<span class="comment">//串口使用屏蔽</span></span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">4</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">5</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">6</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">7</span>;}</span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">8</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">9</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">10</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">11</span>;}</span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">12</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">13</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">14</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">15</span>;}</span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">16</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">17</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">18</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">19</span>;}</span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//串口使用打开</span></span><br><span class="line">    P3=<span class="number">0xff</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief独立按键读取函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/*独立按键模式*/</span></span><br><span class="line"><span class="comment">/*unsigned char Key_Read(void)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(P33==0){temp=4;}</span></span><br><span class="line"><span class="comment">if(P32==0){temp=5;}</span></span><br><span class="line"><span class="comment">if(P31==0){temp=6;}</span></span><br><span class="line"><span class="comment">if(P30==0){temp=7;}</span></span><br><span class="line"><span class="comment">return temp;</span></span><br><span class="line"><span class="comment">}*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="主函数模块"><a class="markdownIt-Anchor" href="#主函数模块"></a> 主函数模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信息（数码管）显示处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*其他信息处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行程序模块</span></span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line">Nixie_Proc();</span><br><span class="line">LED_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="超声波模块使用pca"><a class="markdownIt-Anchor" href="#超声波模块使用pca"></a> 超声波模块（使用PCA）</h2><p><strong>ps:<mark>返回值的单位是cm,可以根据题目要求更改底层</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ultrasound.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"intrins.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit Tx = P1^<span class="number">0</span>;</span><br><span class="line">sbit Rx = P1^<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">()</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">38</span>;</span><br><span class="line"><span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">()</span> <span class="comment">//超声波模块初始化</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">Tx = <span class="number">1</span>;</span><br><span class="line">Delay12us();</span><br><span class="line">Tx = <span class="number">0</span>;</span><br><span class="line">Delay12us();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    CCON =  <span class="number">0x00</span>;<span class="comment">// 初始化PCA控制寄存器，PCA定时器停止，清除CF</span></span><br><span class="line">    CH = CL = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    EA=<span class="number">0</span>;<span class="comment">//总中断关闭</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">    CR = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (CF == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    CR = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(CF == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = CH &lt;&lt; <span class="number">8</span> | CL;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        CF = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="串口模块putchar重定向"><a class="markdownIt-Anchor" href="#串口模块putchar重定向"></a> 串口模块（putchar重定向）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* putchar重定向 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">putchar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">SBUF= ch;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line"><span class="keyword">return</span> (ch);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="串口中断服务程序"><a class="markdownIt-Anchor" href="#串口中断服务程序"></a> 串口中断服务程序</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart_Server</span><span class="params">()</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI == <span class="number">1</span> &amp;&amp; Uart_RecData_Index &lt;<span class="number">8</span>)</span><br><span class="line">    {</span><br><span class="line">        Uart_RecData[Uart_RecData_Index++]=SBUF;</span><br><span class="line">        RI=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Uart_RecData_Index == <span class="number">6</span>)</span><br><span class="line">    {</span><br><span class="line">        Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定时器使用注意事项"><a class="markdownIt-Anchor" href="#定时器使用注意事项"></a> 定时器使用注意事项：</h2><ul><li>定时器0：主要工作定时器.NE555方波发生器</li><li>定时器1：一般用于PWM,使用NE555时,主要定时器选为定时器1</li><li>定时器2：串口中断1绑定</li><li>PCA：用于超声波模块</li></ul><h1 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> #补充</h1><h2 id="一-iic模块"><a class="markdownIt-Anchor" href="#一-iic模块"></a> 一、IIC模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  程序说明: IIC总线驱动程序</span></span><br><span class="line"><span class="comment">  软件环境: Keil uVision 4.10 </span></span><br><span class="line"><span class="comment">  硬件环境: CT107单片机综合实训平台 8051，12MHz</span></span><br><span class="line"><span class="comment">  日    期: 2011-8-9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iic.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"intrins.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Photo_Res_Channel 0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Adj_Res_Channel 0x43</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//总线引脚定义</span></span><br><span class="line">sbit SDA = P2^<span class="number">1</span>;  <span class="comment">/* 数据线 */</span></span><br><span class="line">sbit SCL = P2^<span class="number">0</span>;  <span class="comment">/* 时钟线 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">do</span>{_nop_();}</span><br><span class="line">    <span class="keyword">while</span>(i--);        </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay200us</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span>;</span><br><span class="line">j = <span class="number">82</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//总线启动条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//总线停止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应答</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendAck</span><span class="params">(bit ackbit)</span></span><br><span class="line">{</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = ackbit;  <span class="comment">// 0：应答，1：非应答</span></span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>; </span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答</span></span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL  = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    <span class="keyword">return</span> ackbit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过I2C总线发送数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL  = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        <span class="keyword">if</span>(byt &amp; <span class="number">0x80</span>) SDA  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> SDA  = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        byt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    SCL  = <span class="number">0</span>;  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//从I2C总线上接收数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i, da;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    {   </span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">IIC_Delay(DELAY_TIME);</span><br><span class="line">da &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(SDA) da |= <span class="number">1</span>;</span><br><span class="line">SCL = <span class="number">0</span>;</span><br><span class="line">IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> da;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于iic的adda转换"><a class="markdownIt-Anchor" href="#基于iic的adda转换"></a> 基于IIC的AD/DA转换</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">AD_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line">    </span><br><span class="line">    IIC_Start();       <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr); <span class="comment">//主机发送一个字节(要操作数据的地址),对应AD转换的通道</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    </span><br><span class="line">    IIC_Start(); <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x91</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    temp = IIC_RecByte(); <span class="comment">//从机送出数据,主机读入的数据用变量存储</span></span><br><span class="line">    IIC_SendAck(<span class="number">1</span>);<span class="comment">//主机不发送应答,1表示完成数据的接收,从机停止发送数据</span></span><br><span class="line">    IIC_Stop();<span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DA_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>);<span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x41</span>); <span class="comment">//主机发送一个字节(要操作数据的地址),对应DA转换的通道</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(Data); <span class="comment">//主机送出DA输出的数据字节</span></span><br><span class="line">    IIC_WaitAck(); <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_Stop(); <span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于iic的at24c02epprom储存器"><a class="markdownIt-Anchor" href="#基于iic的at24c02epprom储存器"></a> 基于IIC的AT24C02(EPPROM)储存器</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环发送数据字节,存入AT24C02</span></span><br><span class="line">    {</span><br><span class="line">        IIC_SendByte(*EEPROM_String++);<span class="comment">//发送数据字节,要存入AT24C02的数据,字节个数为num</span></span><br><span class="line">        IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">        IIC_Delay(<span class="number">200</span>);<span class="comment">//延时200ms,保证从机(AT24C02能够完整收到数据)</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答  </span></span><br><span class="line"></span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA1</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环接收数据字节,存入EEPROM_String指向的地址</span></span><br><span class="line">    {</span><br><span class="line">        *EEPROM_String++=IIC_RecByte();<span class="comment">//指针移位读取数据到对应的地址中</span></span><br><span class="line">        <span class="keyword">if</span>(num)<span class="comment">//判断是否读取完数据</span></span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">0</span>);<span class="comment">//发送应答0,表示继续接收数据</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">1</span>);<span class="comment">//发送应答1,表示停止接收数据</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二-onewire模块"><a class="markdownIt-Anchor" href="#二-onewire模块"></a> 二、onewire模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"onewire.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"reg52.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit DQ = P1^<span class="number">4</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线内部延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_OneWire</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>  </span><br><span class="line">{</span><br><span class="line">t *= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线写操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_DS18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">DQ = dat&amp;<span class="number">0x01</span>;</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线读操作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_DS18B20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(DQ)</span><br><span class="line">{</span><br><span class="line">dat |= <span class="number">0x80</span>;</span><br><span class="line">}    </span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//DS18B20初始化</span></span><br><span class="line">bit <span class="title function_">init_ds18b20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  bit initflag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">12</span>);</span><br><span class="line">  DQ = <span class="number">0</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">80</span>);</span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">10</span>); </span><br><span class="line">    initflag = DQ;     </span><br><span class="line">  Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> initflag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">rd_temperature</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> low,high;</span><br><span class="line">init_ds18b20();<span class="comment">//初始化ds18b20;</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//跳过ROM指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0x44</span>);<span class="comment">//开始温度转换</span></span><br><span class="line"></span><br><span class="line">init_ds18b20();<span class="comment">//初始化ds18b20;</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//跳过ROM指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0xBe</span>);<span class="comment">//开始温度读取</span></span><br><span class="line"></span><br><span class="line">low = Read_DS18B20();</span><br><span class="line">high = Read_DS18B20();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (high &lt;&lt; <span class="number">8</span> | low)/<span class="number">16.0</span>;<span class="comment">//二进制转十进制</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ds1302模块"><a class="markdownIt-Anchor" href="#ds1302模块"></a> #DS1302模块</h2><h3 id="ds1302时钟芯片底层"><a class="markdownIt-Anchor" href="#ds1302时钟芯片底层"></a> DS1302（时钟芯片）底层</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ds1302.h"</span></span></span><br><span class="line">sbit SCK=P1^<span class="number">7</span>;</span><br><span class="line">sbit SDA=P2^<span class="number">3</span>;</span><br><span class="line">sbit RST = P1^<span class="number">3</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302</span><span class="params">(<span class="type">unsigned</span>  <span class="type">char</span> temp)</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)     </span><br><span class="line">{ </span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">SDA=temp&amp;<span class="number">0x01</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">SCK=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302_Byte</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address,<span class="type">unsigned</span> <span class="type">char</span> dat )</span>     </span><br><span class="line">{</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>; _nop_();  </span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> Write_Ds1302(dat);</span><br><span class="line"> RST=<span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_Ds1302_Byte</span> <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address )</span></span><br><span class="line">{</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> i,temp=<span class="number">0x00</span>;</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>;_nop_();</span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) </span><br><span class="line"> {</span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(SDA)</span><br><span class="line"> temp|=<span class="number">0x80</span>;</span><br><span class="line"> SCK=<span class="number">1</span>;</span><br><span class="line">} </span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line">SCK=<span class="number">1</span>;_nop_();</span><br><span class="line">SDA=<span class="number">0</span>;_nop_();</span><br><span class="line">SDA=<span class="number">1</span>;_nop_();</span><br><span class="line"><span class="keyword">return</span> (temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写"><a class="markdownIt-Anchor" href="#基于底层的时序编写"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Set_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x00</span>);<span class="comment">//关闭写保护</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x84</span>-i*<span class="number">2</span>,ucRtc[i]);<span class="comment">//给ds1302写入数据,0x84时 0x82分 0x80秒</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x80</span>);<span class="comment">//打开写保护</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">ucRtc[i] = Read_Ds1302_Byte(<span class="number">0x85</span>-i*<span class="number">2</span>);<span class="comment">//读取ds1302的数据</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x00</span>);<span class="comment">//关闭写保护</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8c</span>,ucDate[<span class="number">0</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x88</span>,ucDate[<span class="number">1</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x86</span>,ucDate[<span class="number">2</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x80</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">ucDate[<span class="number">0</span>] = Read_Ds1302_Byte(<span class="number">0x8d</span>);</span><br><span class="line">ucDate[<span class="number">1</span>] = Read_Ds1302_Byte(<span class="number">0x89</span>);</span><br><span class="line">ucDate[<span class="number">2</span>] = Read_Ds1302_Byte(<span class="number">0x87</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li><p><strong>程序模板使用到的模块：</strong></p><ul><li>系统初始化、按键、数码管、LED（继电器、蜂鸣器）</li><li>串口(定时器2)、超声波(PCA)，NE555(定时器0（计数器模式))，定时器1</li><li>IIC（AD/DA转换、AT24C02存储器）、OneWire（ds18b20温度读取）</li><li>DS1302时钟芯片</li></ul></li><li><p><strong>单片机程序设计，模块化，可读性强，执行效率高，占用储存空间小，以及契合硬件电路底层原理是最重要的思路</strong></p></li><li><p><strong>后续设计功能更复杂，更强的单片机/嵌入式系统时，就要拓展相关的知识面，进一步提升对单片机/各种芯片/电路的认识。</strong></p></li></ul><h1 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h1><h2 id="eeprom存入多字节大小变量"><a class="markdownIt-Anchor" href="#eeprom存入多字节大小变量"></a> EEPROM存入多字节大小变量</h2><h3 id="方法一-多个变量值传递"><a class="markdownIt-Anchor" href="#方法一-多个变量值传递"></a> 方法一 多个变量值传递</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> change_counter=<span class="number">0</span>;<span class="comment">//参数更改计次</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> EEPROM_Data[<span class="number">2</span>]={<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//EEPROM流数组，存储int类型</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EEPROM_Read(EEPROM_Data,<span class="number">0x00</span>,<span class="number">2</span>);<span class="comment">//EEPROM初始化读取</span></span><br><span class="line">change_counter=EEPROM_Data[<span class="number">0</span>] | EEPROM_Data[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>;<span class="comment">//将EEPROM数据流转存入整型变量</span></span><br></pre></td></tr></tbody></table></figure><p><strong><mark>缺点：浪费了内存空间，逻辑繁琐</mark></strong></p><h3 id="方法二-联合体"><a class="markdownIt-Anchor" href="#方法二-联合体"></a> 方法二 联合体</h3><p><strong><mark>使用联合体，联合体内的元素公用一段内存空间。指定的变量只有在调用时才会使用内存空间，节省资源同时逻辑简洁直观</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> change_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Temp[<span class="number">2</span>];</span><br><span class="line">}EEPROM_DATA;</span><br></pre></td></tr></tbody></table></figure><p><strong>对比</strong></p><blockquote><p><strong>方法一</strong></p><blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.change_counter++;<span class="comment">//参数改变次数加一</span></span><br><span class="line"><span class="comment">/*将整数型变量存入数组中*/</span></span><br><span class="line">EEPROM_Data[<span class="number">0</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(change_counter &amp; <span class="number">0xFF</span>);<span class="comment">//低八位写入</span></span><br><span class="line">EEPROM_Data[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(change_counter&gt;&gt;<span class="number">8</span> &amp; <span class="number">0xFF</span>);<span class="comment">//高八位写入</span></span><br><span class="line">EEPROM_Write(&amp;EEPROM_Data[<span class="number">0</span>],<span class="number">0x00</span>,<span class="number">2</span>);<span class="comment">//将EEPROM数据流存入AT24C02</span></span><br></pre></td></tr></tbody></table></figure></blockquote><p><strong>方法二</strong></p><blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EEPROM_Data.change_counter++;</span><br><span class="line">EEPROM_Write(&amp;EEPROM_Data.Temp[<span class="number">0</span>],<span class="number">0x00</span>,<span class="number">2</span>);<span class="comment">//将EEPROM数据流写入AT24C02</span></span><br></pre></td></tr></tbody></table></figure></blockquote></blockquote><h2 id="eeprom"><a class="markdownIt-Anchor" href="#eeprom"></a> EEPROM</h2><p><strong>EEPROM读取数据需要在开中断之前，本身时序较长，容易被打断</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">EEPROM_Read(EEPROM_Data_T.Temp,<span class="number">0x00</span>,<span class="number">2</span>);<span class="comment">//EEPROM</span></span><br><span class="line"></span><br><span class="line">System_Init();<span class="comment">//系统初始化，关闭LED、继电器、蜂鸣器                                                                         </span></span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">Uart1_Init();<span class="comment">//串口初始化</span></span><br><span class="line">Ultrasound_Init();<span class="comment">//超声波初始化</span></span><br><span class="line">rd_temperature();<span class="comment">//读取上电的默认温度</span></span><br><span class="line">Delay(<span class="number">750</span>);<span class="comment">//延时750ms,等待温度读取正常稳定</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line">Nixie_Proc();</span><br><span class="line">LED_Proc();</span><br><span class="line">Uart_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
          <category> 蓝桥杯 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> STC15 </tag>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【微机原理】[1] 文件寄存器RAM</title>
      <link href="/posts/52613/"/>
      <url>/posts/52613/</url>
      
        <content type="html"><![CDATA[<h2 id="课堂记录"><a class="markdownIt-Anchor" href="#课堂记录"></a> 课堂记录</h2><img src="/posts/52613/image-20240229103029035.png" class="" title="image-20240229103029035"><h2 id="配置位"><a class="markdownIt-Anchor" href="#配置位"></a> 配置位</h2><img src="/posts/52613/image-20240229205150184.png" class="" title="image-20240229205150184">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> PIC单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PIC单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[4]定时器中断</title>
      <link href="/posts/57601/"/>
      <url>/posts/57601/</url>
      
        <content type="html"><![CDATA[<ul><li><p>打开RCC内部时钟</p></li><li><p>选择时基单元时钟源</p></li><li><p>配置时基单元</p></li><li><p>配置输出中断控制，允许更新中断输出到NVIC</p></li><li><p>配置NVIC，打开定时器通道，并分配一个优先级</p></li><li><p>运行控制</p></li></ul><h1 id="相关函数"><a class="markdownIt-Anchor" href="#相关函数"></a> 相关函数</h1><blockquote><ul><li>恢复缺省配置</li></ul><p>TIM_DeInit(TIM_TypeDef* TIMx);</p><ul><li>时基单元初始化</li></ul><p>TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</p><blockquote><p>TIMx：选择定时器</p><p>TIM_TimeBaseInitStruct：结构体，定时器有关的配置</p></blockquote><ul><li>结构体初始化</li></ul><p>TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</p><ul><li>使能计数器，对应<mark>运行控制</mark></li></ul><p>TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);</p><ul><li>中断输出使能控制</li></ul><p>TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState); 使能中断输出</p><blockquote><p>uint16_t TIM 选择中断输出</p><p>NewState：使能状态</p></blockquote><p><strong>时基单元的时钟选择部分函数：</strong></p><ul><li>选择内部时钟</li></ul><p>void TIM_InternalClockConfig(TIM_TypeDef* TIMx);</p><ul><li>选择ITRX其他定时器的时钟</li></ul><p>void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><blockquote><p>TIMx 选择要配置的寄存器</p><p>TIM_InputTriggerSource 选择接入的寄存器</p></blockquote><ul><li>选择TIX捕获通道的时钟</li></ul><p>void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,uint16_t TIM_ICPolarity, uint16_t ICFilter);</p><blockquote><p>TIM_TIxExternalCLKSource,uint16_t  选择TIX具体的引脚</p><p>TIM_ICPolarity 输入的极性</p><p>ICFilter 滤波器</p></blockquote><ul><li>选择ETR通过外部时钟模式1输入的时钟</li></ul><p>void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,  uint16_t ExtTRGFilter);</p><blockquote><p>TIM_ExtTRGPrescaler 可以对ETR外部时钟再次分频</p><p>ExtTRGPolarity/ExtTRGFilter 极性/滤波器</p></blockquote><ul><li>选择ETR通过外部时钟模式1输入的时钟</li></ul><p>void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);</p><blockquote><p>同TIM_ETRClockMode1Config(</p></blockquote><ul><li>单独配置ETR引脚的预分频器、极性、滤波器这些参数</li></ul><p>void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,<br>uint16_t ExtTRGFilter);</p></blockquote><p><strong>初始化后，像自动重装值和预分频值等等，可能需要修改，有一些函数可以单独修改这些参数</strong></p><blockquote><ul><li>单独修改预分频值</li></ul><p>void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);</p><blockquote><p>uint16_t Prescaler 要写入的预分频值</p><p>PSCReloadMode 写入的模式</p></blockquote><ul><li>改变计数器的计数模式</li></ul><p>void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);</p><blockquote><p>TIM_CounterMode 计数器的计数模式</p></blockquote><ul><li>自动重装器<mark>预装功能</mark>配置</li></ul><p>void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);</p><blockquote><p>NewState 使能状态</p></blockquote><ul><li>给计数器写入一个值</li></ul><p>xxxxxxxxxx&nbsp;python script_name.py --train_data_dir “path/to/train_data” --test_data_dir “path/to/test_data” --img_height 128 --img_width 128 --batch_size 64 --epochs 15python</p><ul><li>给自动重装器写入一个值</li></ul><p>void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);</p><ul><li>获取当前计数器的值</li></ul><p>uint16_t TIM_GetCounter(TIM_TypeDef* TIMx);</p><ul><li>获取当前预分频器的值</li></ul><p>uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);</p><ul><li>获取/清除标志位相关函数</li></ul><p>FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);<br>void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);<br>ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);<br>void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);</p></blockquote><h2 id="编写定时器初始化框架"><a class="markdownIt-Anchor" href="#编写定时器初始化框架"></a> 编写定时器初始化框架</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="滤波原理"><a class="markdownIt-Anchor" href="#滤波原理"></a> 滤波原理</h2><img src="/posts/57601/image-20240229000125982.png" class="" title="image-20240229000125982"><ul><li><p>在一个固定的时钟频率f下进行采样，如果连续N个采样点都是相同的电平，说明信号稳定，如果N个采样点抖动，就让输出保持不变，这样就能保证输出信号在一定程度上被滤波保护。</p></li><li><p>采样点数越多，滤波效果越好，但是同时信号延迟越大</p></li><li><p>采样频率的来源？</p><ul><li>由内部时钟直接而来</li><li>也可是内部时钟+一个时钟分频而来</li></ul></li></ul><p><strong>TIM_Clock_Division_CKD的取值</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define TIM_CKD_DIV1                       ((uint16_t)0x0000)//1分频</span><br><span class="line">#define TIM_CKD_DIV2                       ((uint16_t)0x0100)</span><br><span class="line">#define TIM_CKD_DIV4                       ((uint16_t)0x0200)</span><br></pre></td></tr></tbody></table></figure><h2 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> 代码部分</h2><h3 id="一-定时器中断内部时钟"><a class="markdownIt-Anchor" href="#一-定时器中断内部时钟"></a> 一、定时器中断（内部时钟）</h3><p><strong>定时器底层程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line"><span class="comment">/*时基单元关键寄存器*/</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">7200</span> - <span class="number">1</span>;<span class="comment">//ARR ， 对72MHZ进行7200分频 也就是10MHZ</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">10000</span> - <span class="number">1</span>;<span class="comment">//PSC，计数器重装载值，10000次清零,控制ARR和PSC可以控制计数频率</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"><span class="comment">//1--&gt;注意：更新中断和更新事件同时发生，初始化会立刻进入中断</span></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//2--&gt;手动清理中断标志位</span></span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//中断配置，选择更新中断,使能</span></span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel= TIM2_IRQn;<span class="comment">//定时器通道设置，选择TIM2_IRQn</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd= ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//定时器初始化</span></span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断服务程序模板</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);//清除标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Encoder.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Num;<span class="comment">//定义一个16位的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Num:"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"CNT:"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);<span class="comment">//计时的值</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);<span class="comment">//CNT计数器的值</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)<span class="comment">//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);<span class="comment">//清除标志位</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二-外部时钟"><a class="markdownIt-Anchor" href="#二-外部时钟"></a> 二、外部时钟</h3><p><strong>定时器底层程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA时钟</span></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIM_InternalClockConfig(TIM2);//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line">TIM_ETRClockMode2Config(TIM2,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted,<span class="number">0x00</span>);<span class="comment">//通过ETR引脚的外部时钟模式2配置</span></span><br><span class="line"><span class="comment">//定时器选择    不需要分频    外部触发的极性：不反相     外部触发滤波器,决定F和N，这里不需要滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line"><span class="comment">/**时基单元关键寄存器**/</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">1</span> - <span class="number">1</span>;<span class="comment">//ARR ， 对72MHZ进行7200分频 也就是10MHZ</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">10</span> - <span class="number">1</span>;<span class="comment">//PSC，计数器重装载值，10000次清零,控制ARR和PSC可以控制计数频率</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"><span class="comment">//1--&gt;注意：更新中断和更新事件同时发生，初始化会立刻进入中断</span></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//2--&gt;手动清理中断标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//中断配置，选择更新中断,使能</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel= TIM2_IRQn;<span class="comment">//定时器通道设置，选择TIM2_IRQn</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd= ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//NVIC初始化</span></span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//CNT值封装函数</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">Timer_GetCounter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> TIM_GetCounter(TIM2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);//清除标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Encoder.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Num=<span class="number">0</span>;<span class="comment">//定义一个16位的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Num:"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"CNT:"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);<span class="comment">//计时的值</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Timer_GetCounter(),<span class="number">5</span>);<span class="comment">//CNT计数器的值</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)<span class="comment">//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);<span class="comment">//清除标志位</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><mark><strong>什么时候可以使用浮空输入？</strong></mark></p><p>如果外部输入的信号功率很小时，内部的上拉电阻可能影响到外部输入信号，这时候就使用浮空输入模式，防止影响外部输入电平。</p><h1 id="高级定时器"><a class="markdownIt-Anchor" href="#高级定时器"></a> 高级定时器</h1><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p><strong>没有初始化重复计数器造成定时器计数出现计数缓慢，被其他中断程序干扰的现象</strong></p><p><strong>解决方法：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在,</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[3]EXTI外部中断</title>
      <link href="/posts/44123/"/>
      <url>/posts/44123/</url>
      
        <content type="html"><![CDATA[<h1 id="stm32的中断结构"><a class="markdownIt-Anchor" href="#stm32的中断结构"></a> stm32的中断结构</h1><img src="/posts/44123/image-20240228002139630.png" class="" title="image-20240228002139630"><h2 id="nvic"><a class="markdownIt-Anchor" href="#nvic"></a> NVIC</h2><p><a href="https://blog.csdn.net/liuqi3256797/article/details/89891621">STM32中的NVIC详解_stm32 nvic-CSDN博客</a></p><h2 id="exti"><a class="markdownIt-Anchor" href="#exti"></a> EXTI</h2><img src="/posts/44123/image-20240228002339511.png" class="" title="image-20240228002339511"><img src="/posts/44123/image-20240228002507136.png" class="" title="image-20240228002507136"><h2 id="一-对射式红外传感器计次"><a class="markdownIt-Anchor" href="#一-对射式红外传感器计次"></a> 一、对射式红外传感器计次</h2><h3 id="红外传感器底层程序"><a class="markdownIt-Anchor" href="#红外传感器底层程序"></a> 红外传感器底层程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count;<span class="comment">//全局变量，用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：计数传感器初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*外部中断的定义*/</span></span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);<span class="comment">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO初始化*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//将PB14引脚初始化为上拉输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*AFIO选择中断引脚*/</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);<span class="comment">//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*EXTI初始化*/</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">EXTI_InitStructure.EXTI_Line = EXTI_Line14;<span class="comment">//选择配置外部中断的14号线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;<span class="comment">//指定外部中断线使能</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;<span class="comment">//指定外部中断线为中断模式</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//指定外部中断线为下降沿触发</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);<span class="comment">//将结构体变量交给EXTI_Init，配置EXTI外设</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//配置NVIC为分组2</span></span><br><span class="line"><span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line"><span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line"><span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line"><span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;<span class="comment">//选择配置NVIC的EXTI15_10线</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：获取计数传感器的计数值</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：计数值，范围：0~65535</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：EXTI15_10外部中断函数</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span></span><br><span class="line"><span class="comment">  *           函数名为预留的指定名称，可以从启动文件复制</span></span><br><span class="line"><span class="comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//每次进入中断服务程序，中断标志位都会置1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line14) == SET)<span class="comment">//判断是否是外部中断14号线触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">CountSensor_Count ++;<span class="comment">//计数值自增一次</span></span><br><span class="line">}</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line14);<span class="comment">//清除外部中断14号线的中断标志位</span></span><br><span class="line"><span class="comment">//中断标志位必须清除</span></span><br><span class="line"><span class="comment">//否则中断将连续不断地触发，导致主程序卡死</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="xxxxxxxxxx-typedef-structtypedef为成员列表提供了一个gpio_inittypedef的名字gpio_inittypedefc"><a class="markdownIt-Anchor" href="#xxxxxxxxxx-typedef-structtypedef为成员列表提供了一个gpio_inittypedef的名字gpio_inittypedefc"></a> xxxxxxxxxx&nbsp;typedef struct//typedef为成员列表提供了一个GPIO_InitTypeDef的名字{}GPIO_InitTypeDef;c</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Count:"</span>);</span><br><span class="line">CountSensor_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">7</span>,CountSensor_Get(),<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="二-旋转编码器"><a class="markdownIt-Anchor" href="#二-旋转编码器"></a> 二、旋转编码器</h2><h3 id="底层程序"><a class="markdownIt-Anchor" href="#底层程序"></a> 底层程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count;<span class="comment">//全局变量，用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：计数传感器初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*外部中断的定义*/</span></span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);<span class="comment">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO初始化*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//将PB14引脚初始化为上拉输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*AFIO选择中断引脚*/</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);<span class="comment">//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*EXTI初始化*/</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">EXTI_InitStructure.EXTI_Line = EXTI_Line14;<span class="comment">//选择配置外部中断的14号线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;<span class="comment">//指定外部中断线使能</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;<span class="comment">//指定外部中断线为中断模式</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//指定外部中断线为下降沿触发</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);<span class="comment">//将结构体变量交给EXTI_Init，配置EXTI外设</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//配置NVIC为分组2</span></span><br><span class="line"><span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line"><span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line"><span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line"><span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;<span class="comment">//选择配置NVIC的EXTI15_10线</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：获取计数传感器的计数值</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：计数值，范围：0~65535</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：EXTI15_10外部中断函数</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span></span><br><span class="line"><span class="comment">  *           函数名为预留的指定名称，可以从启动文件复制</span></span><br><span class="line"><span class="comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//每次进入中断服务程序，中断标志位都会置1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line14) == SET)<span class="comment">//判断是否是外部中断14号线触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">CountSensor_Count ++;<span class="comment">//计数值自增一次</span></span><br><span class="line">}</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line14);<span class="comment">//清除外部中断14号线的中断标志位</span></span><br><span class="line"><span class="comment">//中断标志位必须清除</span></span><br><span class="line"><span class="comment">//否则中断将连续不断地触发，导致主程序卡死</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="主程序"><a class="markdownIt-Anchor" href="#主程序"></a> 主程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Encoder.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">Encoder_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"Encoder_Count:"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">n += Encoder_Get_Change_value();</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">1</span>, n, <span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> 外部中断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[2]stm32GPIO输出</title>
      <link href="/posts/56552/"/>
      <url>/posts/56552/</url>
      
        <content type="html"><![CDATA[<h1 id="gpio输入"><a class="markdownIt-Anchor" href="#gpio输入"></a> GPIO输入</h1><h2 id="一-led闪烁"><a class="markdownIt-Anchor" href="#一-led闪烁"></a> 一、LED闪烁</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//配置GPIOA外部时钟</span></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;<span class="comment">//一般输出用推挽输出模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0  ;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//四个基本的输出电平设置函数</span></span><br><span class="line"><span class="comment">//GPIO_SetBits(GPIOA,GPIO_Pin_0);//LED灭</span></span><br><span class="line"><span class="comment">//GPIO_ResetBits(GPIOA,GPIO_Pin_0);//LED亮</span></span><br><span class="line"><span class="comment">//GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);//LED亮</span></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);<span class="comment">//LED灭</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二-led流水灯"><a class="markdownIt-Anchor" href="#二-led流水灯"></a> 二、LED流水灯</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;<span class="comment">//一般输出用推挽输出模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_All;<span class="comment">//可以用按位或的方式同时初始化多个引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">GPIO_Write(GPIOA,~(<span class="number">0x0001</span>&lt;&lt;i)); <span class="comment">//0000 0000 0000 0001</span></span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="三-蜂鸣器"><a class="markdownIt-Anchor" href="#三-蜂鸣器"></a> 三、蜂鸣器</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;<span class="comment">//一般输出用推挽输出模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_12;<span class="comment">//可以用按位或的方式同时初始化多个引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">50</span>);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">50</span>);</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">50</span>);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">700</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="gpio常用函数"><a class="markdownIt-Anchor" href="#gpio常用函数"></a> GPIO常用函数</h1><ul><li>xxxxxxxxxx&nbsp;typedef struct//typedef为成员列表提供了一个GPIO_InitTypeDef的名字{}GPIO_InitTypeDef;c</li><li>GPIO_ResetBits(GPIOA,GPIO_Pin_0);<strong>将GPIOA_0设置为低电平</strong></li><li>GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);<strong>将GPIOA_0<mark>选择</mark>为高电平</strong></li></ul><img src="/posts/56552/image-20240228000033935.png" class="" title="image-20240228000033935"><ul><li>GPIO_DeInit(*GPIO_InitTypeDef,GPIOX) <strong>初始化指定的GPIO的时钟</strong></li></ul><h1 id="gpio输出"><a class="markdownIt-Anchor" href="#gpio输出"></a> GPIO输出</h1><h2 id="一-按键控制led"><a class="markdownIt-Anchor" href="#一-按键控制led"></a> 一、按键控制LED</h2><h3 id="led底层代码"><a class="markdownIt-Anchor" href="#led底层代码"></a> LED底层代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_All;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_All);<span class="comment">//初始化默认低电平输出，所以要置高电平</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_OFF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_OFF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief </span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_Turn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二-按键底层代码"><a class="markdownIt-Anchor" href="#二-按键底层代码"></a> 二、按键底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);<span class="comment">//GPIOB外部时钟配置</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<span class="comment">//输入最大频率</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_1|GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);<span class="comment">//引脚初始化</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Key_GetNum</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//uint8_t相当于unsigned char </span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> KeyNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==<span class="number">0</span>);</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line">KeyNum= <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>);</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line">KeyNum= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> KeyNum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="三-主程序"><a class="markdownIt-Anchor" href="#三-主程序"></a> 三、主程序</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*初始化，配置按键输入引脚/LED电平输出引脚*/</span></span><br><span class="line">LED_Init();</span><br><span class="line">Key_Init();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key_GetNum();</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">LED1_Turn();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">LED2_Turn();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
            <tag> GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【stm32单片机】[1] stm32工程创建</title>
      <link href="/posts/5499/"/>
      <url>/posts/5499/</url>
      
        <content type="html"><![CDATA[<h1 id="stm32点亮led"><a class="markdownIt-Anchor" href="#stm32点亮led"></a> stm32点亮LED</h1><h2 id="一-配置寄存器方式"><a class="markdownIt-Anchor" href="#一-配置寄存器方式"></a> 一、配置寄存器方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*使用配置寄存器的方式进行点灯操作*/</span></span><br><span class="line">RCC-&gt;APB2ENR = <span class="number">0x00000010</span>;</span><br><span class="line">GPIOC-&gt;CRH = <span class="number">0x00300000</span>;</span><br><span class="line">GPIOC-&gt;ODR = <span class="number">0x00002000</span>; </span><br><span class="line"><span class="comment">//缺点：配置繁琐，操作多</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二-库函数方式"><a class="markdownIt-Anchor" href="#二-库函数方式"></a> 二、库函数方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*使用库函数的方式进行点灯操作*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);<span class="comment">//配置GPIOC的外设时钟</span></span><br><span class="line"><span class="comment">//函数的本质还是配置寄存器，但是封装好了完整可靠的功能</span></span><br><span class="line"><span class="comment">//不会影响到寄存器的其他位，不需要手动计算寄存器</span></span><br><span class="line">    </span><br><span class="line">GPIO_InitTypeDef GPIO_InitSructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">GPIO_InitSructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//选择推挽输出模式</span></span><br><span class="line">GPIO_InitSructure.GPIO_Pin = GPIO_Pin_13;<span class="comment">//选择13号引脚</span></span><br><span class="line">GPIO_InitSructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//GPIO最大频率50MHZ</span></span><br><span class="line">    </span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitSructure);<span class="comment">//根据配置的结构体，各个成员变量的参数，初始化GPIO口</span></span><br><span class="line"><span class="comment">//GPIO_SetBits(GPIOC,GPIO_Pin_13);//设置PC13口为高电平</span></span><br><span class="line">GPIO_ResetBits(GPIOC,GPIO_Pin_13);<span class="comment">//设置PC13口为低电平</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>对GPIO_InitTypeDef GPIO_InitSructure的理解</p><p>转到GPIO_InitTypeDef的定义</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;             <span class="comment">/*!&lt; Specifies the GPIO pins to be configured.</span></span><br><span class="line"><span class="comment">                                      This parameter can be any value of @ref GPIO_pins_define */</span></span><br><span class="line"></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">/*!&lt; Specifies the speed for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">/*!&lt; Specifies the operating mode for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span></span><br><span class="line">}GPIO_InitTypeDef;</span><br></pre></td></tr></tbody></table></figure><h3 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> #结构体</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>//类</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">sb</span>;</span><span class="comment">//结构体的成员可以是另外的结构体</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line"><span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> id[<span class="number">20</span>];</span><br><span class="line">} s1, s2;<span class="comment">//s1和s2也是结构体变量</span></span><br><span class="line"><span class="comment">//s1,s2是全局变量</span></span><br><span class="line"><span class="comment">//结构体的调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//s是局部变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span> =</span> { {<span class="string">'w'</span>,<span class="number">20</span>,<span class="number">3.14</span> }, <span class="string">"张三"</span>, <span class="number">30</span>, <span class="string">"20200534"</span> };<span class="comment">//对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>,s.sb.c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s.id);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>* <span class="title">ps</span> =</span> &amp;s;<span class="comment">//结构体指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>,(*ps).sb.c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, ps-&gt;sb.c);<span class="comment">//ps是指针可以用-&gt;操作符,sb是变量不是指针只能用.操作符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//<span class="title">typedef</span>为成员列表提供了一个<span class="title">GPIO_InitTypeDef</span>的名字</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">}GPIO_InitTypeDef;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】[1]线性规划</title>
      <link href="/posts/32828/"/>
      <url>/posts/32828/</url>
      
        <content type="html"><![CDATA[<figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c=[<span class="number">2</span>;<span class="number">3</span>;<span class="number">1</span>];</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>];</span><br><span class="line">b=[<span class="number">8</span>,<span class="number">6</span>];</span><br><span class="line">[x,frav]=linprog(c,-a,-b,[],[],<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>))</span><br></pre></td></tr></tbody></table></figure><p><strong>zeros 的作用 ？</strong></p><blockquote><p>在这个问题中，<code>zeros(3,1)</code> 是用来设置线性规划问题的变量的下界为零的约束条件。</p></blockquote><ul><li><p>在 MATLAB 的 <code>linprog</code> 函数中，第五个参数是用来指定变量的下界约束条件的。在这个例子中，我们希望所有的变量都不能小于零，所以我们使用 <code>zeros(3,1)</code> 来创建一个全部元素为零的列向量作为下界约束条件。</p></li><li><p>这样设置下界约束条件后，线性规划求解器就会确保求解结果中的所有变量都大于等于零，符合我们的约束要求。</p></li><li><p>简而言之，<code>zeros(3,1)</code> 的作用是设置变量的<mark>下界为零</mark>，以满足线性规划问题的<mark>约束条件</mark>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 数学建模 </category>
          
          <category> Matlab </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言入门学习】函数01</title>
      <link href="/posts/36172/"/>
      <url>/posts/36172/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言入门学习函数的概念01"><a class="markdownIt-Anchor" href="#c语言入门学习函数的概念01"></a> 【C语言入门学习】函数的概念01</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p>数学中我们常见到函数的概念，函数是数学学习的核心思想，而计算机语言中的函数是编程的核心思想。</p><hr><h3 id="一-函数的定义"><a class="markdownIt-Anchor" href="#一-函数的定义"></a> 一、函数的定义：</h3><p>维基百科中对函数的定义：<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">子程序</a></p><ul><li>在计算机科学中，子程序（英语：Subroutine, procedure, function, routine, method,subprogram, callable unit），是一个大型程序中的某部分代码， 由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代 码，具备相对的独立性。</li><li>一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏。这些代码通常被集成为软件库。</li></ul><h3 id="二-函数的分类"><a class="markdownIt-Anchor" href="#二-函数的分类"></a> 二、函数的分类</h3><ul><li>库函数</li><li>自定义函数</li></ul><h4 id="为什么会有库函数"><a class="markdownIt-Anchor" href="#为什么会有库函数"></a> 为什么会有库函数？</h4><p>c语言的基础库中提供了一系列函数库，便于我们对一些经常使用的函数进行调用，<mark>避免重复造轮子</mark></p><h4 id="如何查找库函数"><a class="markdownIt-Anchor" href="#如何查找库函数"></a> 如何查找库函数？</h4><p>以下为常用的网站：<br><a href="https://cplusplus.com/reference/">cplusplus.com</a><br><a href="https://en.cppreference.com/w/">cppreference.com</a></p><ul><li>其中 <strong>cppreference</strong> 在edge上支持插件，在URL搜索框输入"cc"+"空格"即可实现快速查询函数的定义、使用方式、对应的封装库</li></ul><h4 id="常见的库函数"><a class="markdownIt-Anchor" href="#常见的库函数"></a> 常见的库函数</h4><ul><li>IO函数:如printf、scanf、</li><li>字符串操作函数：如strlen</li><li>字符操作函数</li><li>内存操作函数</li><li>时间/日期函数</li><li>数学函数</li><li>其他库函数</li></ul><p>示例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//库函数的认识</span></span><br><span class="line"><span class="comment">//学习c语言过程中，遇到陌生函数，主动参考文档网站（学会使用工具搜索）</span></span><br><span class="line"><span class="type">char</span> arr1[<span class="number">20</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="type">char</span> arr2[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(arr1, arr2);<span class="comment">//字符串拷贝</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, arr1);</span><br><span class="line"><span class="built_in">memset</span>(arr1, <span class="string">'x'</span>, <span class="number">5</span>);<span class="comment">//设置内存块</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, arr1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//学习重点：自定义函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>总而言之，要使用库函数，必须通过#inlcude包含对应的头文件</strong></p><ul><li>include&lt;&gt;：程序语言的标准库头文件，指向的是语言安装的根目录</li><li>include" "：我们自己创建的头文件，指向的是工程的根目录</li></ul><h4 id="为什么要写自定义的函数"><a class="markdownIt-Anchor" href="#为什么要写自定义的函数"></a> 为什么要写自定义的函数？</h4><p>由我们程序员自由设计函数，能够更好地加深我们的代码编写思维，更加灵活地编写程序，使我们地代码具有更大地发挥空间。</p><p><strong>函数的组成：</strong></p><p><mark>函数返回值类型</mark> <mark>函数名</mark>(<mark>形参</mark>，<mark>形参</mark>）<br>{<br><mark>函数体</mark>；<br><mark>返回值</mark>（若需要）；<br>}</p><img src="/posts/36172/784deb65dd214e76b6c971f2d2b4c04f.png" class="" title="在这里插入图片描述"><p>头文件调用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>示例1：找出两个数中的最大值</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">z = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">z = y;</span><br><span class="line"><span class="keyword">return</span> z;<span class="comment">//返回z</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>示例2：交换两个数的值</p><ul><li>Swap1</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> temp = x;<span class="comment">//temp = 0</span></span><br><span class="line">x = y;<span class="comment">// x = 1</span></span><br><span class="line">y = temp;<span class="comment">//y = 0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Swap2</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过指针，操作变量的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap2</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span>* pb)</span><span class="comment">//实际上，这里也创建了两个新的变量（形参），用于存放地址</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//将值，传递给对应地址的内存空间，成功改变了变量a,b的值</span></span><br><span class="line"><span class="type">int</span> temp = *pa;</span><br><span class="line">*pa = *pb;</span><br><span class="line">*pb = temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>main函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//函数的调用</span></span><br><span class="line"><span class="type">int</span> max = get_max(a, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个函数 -交换两个整型变量的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"交换前：a=%d b=%d\n"</span>, a, b);</span><br><span class="line">Swap1(a, b);<span class="comment">//形参不影响实参，实际上Swap函数创建了另外地址，操纵的是完全不同的内存空间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"交换后：a=%d b=%d\n"</span>, a, b);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pa = &amp;a;<span class="comment">//pa就是一个指针变量</span></span><br><span class="line">*pa = <span class="number">15</span>;<span class="comment">//通过pa，操纵指定地址的变量的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"交换前：a=%d b=%d\n"</span>, a, b);</span><br><span class="line">Swap2(&amp;a, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"交换后：a=%d b=%d\n"</span>, a, b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>示例1 运行结果</strong><br>&gt;&gt;20<br><em>正确</em><br><strong>示例2 运行结果1</strong><br>&gt;&gt;交换前：a=10 b=20<br>&gt;&gt;交换后：a=10 b=20<br><mark>未实现交换两个变量值的作用</mark></p><p><strong>分析：</strong></p><blockquote><p><strong>交换两个整型变量的值：void表示这个函数不返回任何值，也不需要返回<br>swap1在被调用的时候，实参传给形参，其实形参是实参的一份临时拷贝<br>改变形参，不能改变实参</strong></p></blockquote><p>ps:markdown也使用转义字符,实现特定符号的显示</p><p><strong>示例2 运行结果2</strong><br>&gt;&gt;15<br>&gt;&gt;交换前：a=15 b=20<br>&gt;&gt;交换后：a=20 b=15<br><mark>未实现交换两个变量值的作用</mark></p><blockquote><p><strong>通过指针，操作变量的值，实际上Swap2函数，定义了两个变量pa，pb用于存放地址，通过解引用直接操纵对应地址的内存空间，进而实现了对外部变量的改变</strong></p></blockquote><p>板书：</p><img src="/posts/36172/5ba991b9b5174ae489ff70b38066536d.png" class="" title="在这里插入图片描述"><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2><ol><li>学会通过网站查询标准库</li><li><strong>形参不会改变实参，要通过函数实现对形参的改变，需要用到指针（地址），操纵指定的内存空间。</strong></li><li>学会自定义函数</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言入门学习】[3]代码书写的规范</title>
      <link href="/posts/15339/"/>
      <url>/posts/15339/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>c语言代码书写规范：</strong></p><ul><li><strong>if语句，while语句等等，尽量要带上{}</strong></li><li><strong>判断语句如if(a==1)最好改写成if(1==a)，因为一但写成if(a=)形式，  编译也能通过，但会导致程序执行完全不同的结果。<br>如果写成if(1=a)，<mark>因为语法规定</mark>,只能将值赋给等号左边的变量，不然编译不通过，这样的话，能够对编写语句起到 <em>约束作用</em> 避免了 “程序能跑就行”的局面</strong></li></ul></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main1()</span><br><span class="line">{</span><br><span class="line">int a = 0;</span><br><span class="line">printf("请输入：\n");</span><br><span class="line">scanf("%d", &amp;a);//不要加转义字符</span><br><span class="line">if (a % 2 == 1)</span><br><span class="line">{</span><br><span class="line">printf("为奇数\n");</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">printf("为偶数\n");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int num = 0;</span><br><span class="line">for (num = 1; num &lt;= 100; num++)</span><br><span class="line">{</span><br><span class="line">if (num % 2 == 1)</span><br><span class="line">{</span><br><span class="line">printf("奇数：%d\n", num);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://blog.csdn.net/weixin_44967885/article/details/108994960">scanf中的\n问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git学习】[1]基本命令</title>
      <link href="/posts/8948/"/>
      <url>/posts/8948/</url>
      
        <content type="html"><![CDATA[<h1 id="一-git仓库的创建"><a class="markdownIt-Anchor" href="#一-git仓库的创建"></a> 一、Git仓库的创建</h1><h2 id="1-git仓库的创建"><a class="markdownIt-Anchor" href="#1-git仓库的创建"></a> 1. Git仓库的创建：</h2><p>将当前目录变成可以GIT管理的目录</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init//创建初始化仓库</span><br></pre></td></tr></tbody></table></figure><h2 id="2-将文件添加到版本库repository"><a class="markdownIt-Anchor" href="#2-将文件添加到版本库repository"></a> 2. 将文件添加到版本库（Repository）:</h2><p>实际上就是把文件修改添加到暂存区</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . //将当前文件目录下所有文件移入暂存区`` </span><br></pre></td></tr></tbody></table></figure><h2 id="3-将暂存区内容添加到版本库repository中"><a class="markdownIt-Anchor" href="#3-将暂存区内容添加到版本库repository中"></a> 3. 将暂存区内容添加到版本库（Repository）中：</h2><p>仓库创建后，<code>head</code>默认指向master分支</p><p>实际上就是把暂存区的所有内容提交到当前分支</p><p>每一次的commit相当于一次快照，一但把项目文件该乱了，可以从最近的一次commit恢复</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"第一次版本提交"</span> //在后面加-m选项，以在命令行中提供提交注释</span><br><span class="line">git commit -am <span class="string">"第一次版本提交"</span>//跳过add这一步，可以直接使用 -a选项</span><br></pre></td></tr></tbody></table></figure><p>注意：每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中</p><h2 id="4-修改日志"><a class="markdownIt-Anchor" href="#4-修改日志"></a> 4. 修改日志</h2><p>版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看</p><img src="/posts/8948/image-20240903174408863.png" class="" title="image-20240903174408863"><h2 id="5-版本回退"><a class="markdownIt-Anchor" href="#5-版本回退"></a> 5. 版本回退</h2><p>1094a…是版本号</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1094a...</span><br></pre></td></tr></tbody></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──▶ ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></tbody></table></figure><p>改为指向<code>add distributed</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──▶ ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></tbody></table></figure><p>当主机重启后，之前回溯到了旧版本，这次又想回到新版本，Git提供了一个命令git reflog用来记录你的每一次命令：</p><img src="/posts/8948/image-20240903175257889.png" class="" title="image-20240903175257889"><h2 id="6-撤销修改"><a class="markdownIt-Anchor" href="#6-撤销修改"></a> 6. 撤销修改</h2><p>checkout可以丢弃工作区的修改</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></tbody></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><h2 id="其他命令"><a class="markdownIt-Anchor" href="#其他命令"></a> # 其他命令</h2><p><code>git status</code>查看状态</p><img src="/posts/8948/image-20240903175945894.png" class="" title="image-20240903175945894"><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>，<code>git rm</code>使用后相当于修改后将工作区的文件提交到暂存区，相当于<code>rm</code>文件后，使用<code>add</code>提交。</p><h1 id="二-远程仓库"><a class="markdownIt-Anchor" href="#二-远程仓库"></a> 二、远程仓库</h1><h2 id="1-git连接到远程仓库github"><a class="markdownIt-Anchor" href="#1-git连接到远程仓库github"></a> 1. Git连接到远程仓库（github）</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin [url]//参数[<span class="built_in">alias</span>]为别名， [url]为远程仓库的地址</span><br></pre></td></tr></tbody></table></figure><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上</p><h2 id="2-本地内容推送到远程仓库"><a class="markdownIt-Anchor" href="#2-本地内容推送到远程仓库"></a> 2. 本地内容推送到远程仓库</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></tbody></table></figure><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令</p><p>从现在开始，可以通过<code>git push -u origin main</code>直接推送到远程仓库</p><h2 id="3-删除远程库"><a class="markdownIt-Anchor" href="#3-删除远程库"></a> 3. 删除远程库</h2><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></tbody></table></figure><img src="/posts/8948/image-20240903182037631.png" class="" title="image-20240903182037631"><p>然后，根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></tbody></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h2 id="4-从远程库克隆"><a class="markdownIt-Anchor" href="#4-从远程库克隆"></a> 4. 从远程库克隆</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [address]</span><br></pre></td></tr></tbody></table></figure><p><a href="https://liaoxuefeng.com/books/git/remote/clone/index.html">从远程库克隆 - Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p>注意：Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快</p><h1 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> &gt; 常见问题</h1><h2 id="1-git-push-u-origin-main-报错"><a class="markdownIt-Anchor" href="#1-git-push-u-origin-main-报错"></a> 1. <code>git push -u origin main</code> 报错：</h2><p><img src="%E3%80%90Git%E5%AD%A6%E4%B9%A0%E3%80%91-1-%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4/image-20240830004335755.png" alt="image-20240830004335755"></p><blockquote><p><strong>解决方案：</strong></p><p>要解决这个问题，你需要先将远程仓库的更改合并到你的本地分支中，然后再进行推送。你可以按照以下步骤操作：</p><ol><li><strong>执行 <code>git pull</code></strong><br>在你的本地仓库中执行以下命令来获取并合并远程仓库的更改：</li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></tbody></table></figure><p>这将从远程的 <code>main</code> 分支拉取最新的提交，并尝试将这些更改合并到你本地的 <code>main</code> 分支中。</p><ol start="2"><li><p><strong>解决冲突（如果有的话）</strong><br>如果 Git 在合并过程中遇到冲突，它会提示你有冲突需要手动解决。你需要打开冲突的文件，手动编辑解决冲突，然后使用 <code>git add</code> 命令将解决冲突后的文件标记为已解决。</p></li><li><p><strong>提交合并（如果有冲突）</strong><br>解决冲突后，你需要提交这些更改：</p></li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></tbody></table></figure><p>如果没有冲突，Git 会自动完成合并。</p><ol start="4"><li><strong>重新推送到远程仓库</strong><br>一旦你已经合并了远程的更改，你可以再次尝试推送到远程仓库：</li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></tbody></table></figure><p>按照上述步骤操作，你应该能够成功地将本地更改推送到远程仓库。如果你对合并操作不太熟悉，可以提前备份你的代码库以防万一</p></blockquote><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://liaoxuefeng.com/books/git/remote/add-remote/index.html">添加远程库 - Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h1 id="更新日志"><a class="markdownIt-Anchor" href="#更新日志"></a> # 更新日志</h1><blockquote><p>date:2024.1.10</p><ul><li>优化blog内容</li></ul><p>date:2024.2.18</p><ul><li>优化blog内容</li></ul><p>date:2024.8.30</p><ul><li>优化blog内容</li></ul><p>date:2024.9.3</p><ul><li>优化blog内容</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Git </category>
          
          <category> 分布式系统 </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言入门学习】[2]初识C语言 02</title>
      <link href="/posts/32291/"/>
      <url>/posts/32291/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言入门学习2初识c语言-02"><a class="markdownIt-Anchor" href="#c语言入门学习2初识c语言-02"></a> 【C语言入门学习】[2]初识C语言 02</h1><h3 id="2024110更新"><a class="markdownIt-Anchor" href="#2024110更新"></a> 2024.1.10更新</h3><h4 id="常见操作符-关键字2"><a class="markdownIt-Anchor" href="#常见操作符-关键字2"></a> 常见操作符 关键字（2）</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.static 修饰局部变量</span></span><br><span class="line"><span class="comment">//2.static 修饰全局变量</span></span><br><span class="line"><span class="comment">//3.static 修饰函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_val;<span class="comment">//声明外部变量</span></span><br><span class="line"><span class="comment">//static int g_val = 100;  //static 修饰全局变量使得全局变量只能在自己所在的源文件内部使用</span></span><br><span class="line"><span class="comment">//extern int g_val;报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量，在其他源文件内部可以被使用，是因为全局变量具有外部链接属性</span></span><br><span class="line"><span class="comment">//但是被static修饰之后，就变成了内部链接属性，其他源文件就不能链接到这个静态的全局变量了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static int Add(int x, int y)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//return x + y;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//static 修饰函数，使得函数只能在自己的源文件内部使用，不能在其他源文件内部使用，</span></span><br><span class="line"><span class="comment">//本质上：static是将函数的外部链接属性变成内部链接属性（与static修饰全局变量类似）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//int a =1; 10个2</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">1</span>; <span class="comment">//2到11 , a 出函数体不会销毁，再次进入函数体保持上一次的值</span></span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;<span class="comment">//定义在test01.c中</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">{</span><br><span class="line">test();</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, g_val);</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> sum = Add(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sum = %d"</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//static修饰局部变量，改变了局部变量的生命周期（本质上是改变了变量的存储类型） </span></span><br></pre></td></tr></tbody></table></figure><h4 id="define定义常量和宏"><a class="markdownIt-Anchor" href="#define定义常量和宏"></a> define定义常量和宏</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//define定义符号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX = 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//define定义宏</span></span><br><span class="line"><span class="comment">//#define ADD(X,Y) X+Y //printf结果为11</span></span><br><span class="line"><span class="comment">//#define ADD(X,Y) （X+Y）错误写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(X,Y) ((X)+(Y)) <span class="comment">//模式替换</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">4</span> * ADD(<span class="number">2</span>, <span class="number">3</span>));<span class="comment">//4*2+3</span></span><br><span class="line"><span class="comment">//宏是实现替换的</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//一个内存单元是一个byte:字节 </span></span><br><span class="line"><span class="comment">//一个byte由8个bit构成,1个bit为一个地址，所以一共8个地址  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);<span class="comment">//%p用于打印地址;</span></span><br><span class="line"><span class="type">int</span> *pa = &amp;a;<span class="comment">//pa是用来存放地址的，在c语言中pa叫指针变量</span></span><br><span class="line"><span class="comment">//* 说明 pa是指针变量</span></span><br><span class="line"><span class="comment">//int 说明pa执行对象是int类型的</span></span><br><span class="line"><span class="type">char</span> ch = <span class="string">'w'</span>;</span><br><span class="line"><span class="type">char</span>* pc = &amp;ch;</span><br><span class="line"></span><br><span class="line">*pa = <span class="number">20</span>;<span class="comment">//*解引用操作，*pa就是通过pa里面的地址，找到a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">float</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>*));</span><br><span class="line"><span class="comment">//32位机器，4个字节</span></span><br><span class="line"><span class="comment">//64位机器，8个字节</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体可以让c语言创建出新的类型出来</span></span><br><span class="line"><span class="comment">//创建一个学生</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line"><span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> sex[<span class="number">5</span>];<span class="comment">//性别</span></span><br><span class="line"><span class="type">char</span> id[<span class="number">15</span>];<span class="comment">//学号</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//结构体的初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span> =</span> { <span class="string">"张三"</span>,<span class="number">18</span>,<span class="string">"男"</span>,<span class="string">"20241574"</span> };</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"名字:%s 年龄:%d 性别:%s 学号:%s\n"</span>, s.name, s.age, s.sex, s.id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作符：-&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>* <span class="title">ps</span> =</span> &amp;s;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"名字:%s 年龄:%d 性别:%s 学号:%s\n"</span>, ps-&gt;name, ps-&gt;age, ps-&gt;sex, ps-&gt;id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结：</strong></h1><h4 id="c语言的基本语法初步了解以及补充完成"><a class="markdownIt-Anchor" href="#c语言的基本语法初步了解以及补充完成"></a> c语言的基本语法初步了解以及补充完成</h4>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】定时器和中断 02</title>
      <link href="/posts/32229/"/>
      <url>/posts/32229/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机-第七节-定时器和中断总结代码部分"><a class="markdownIt-Anchor" href="#51单片机-第七节-定时器和中断总结代码部分"></a> [51单片机] 第七节 定时器和中断总结&lt;代码部分&gt;</h1><h3 id="ps-单片机的可位寻址不可位寻址"><a class="markdownIt-Anchor" href="#ps-单片机的可位寻址不可位寻址"></a> ps: 单片机的可位寻址/不可位寻址</h3><ul><li>可位寻址：可以对单个位赋值</li><li>不可位寻址：只能整体赋值</li></ul><p>代码示例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TMOD=<span class="number">0x01</span>; <span class="comment">//0000 0001</span></span><br><span class="line">TF=<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="定时器的快捷配置"><a class="markdownIt-Anchor" href="#定时器的快捷配置"></a> 定时器的快捷配置</h3><img src="/posts/32229/b094f812549147d6b17d96fc95302cb2.png" class="" title="在这里插入图片描述"><h2 id="晶振电路简介这里所使用晶振为110592mhz"><a class="markdownIt-Anchor" href="#晶振电路简介这里所使用晶振为110592mhz"></a> 晶振电路简介（这里所使用晶振为11.0592MHZ)</h2><img src="/posts/32229/e6afeca057c945fb9d15dc14a78c676c.png" class="" title="在这里插入图片描述"><h2 id="一-中断测试代码"><a class="markdownIt-Anchor" href="#一-中断测试代码"></a> 一、中断测试代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Tmier0.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void Timer0_Init()//定时器配置</span></span><br><span class="line"><span class="comment">// {</span></span><br><span class="line"><span class="comment">// //TMOD=0x01; //0000 0001 //缺点：会影响到其他定时器</span></span><br><span class="line"><span class="comment">// TMOD &amp;= 0xF0;//把TMOD的低四位清零，高四位保持不变 //优点：不影响高四位（其他定时器的配置）</span></span><br><span class="line"><span class="comment">// TMOD |=  0X01;//把TMOD的最低为置1，高四位保持不变</span></span><br><span class="line"><span class="comment">// TF0=0; // Gate = 0;</span></span><br><span class="line"><span class="comment">// TR0 = 1;//定时器0允许计数</span></span><br><span class="line"><span class="comment">// //mark</span></span><br><span class="line"><span class="comment">// TH0=64535/256;//16进制 取高八位</span></span><br><span class="line"><span class="comment">// TL0=64535%256;//取低八位</span></span><br><span class="line"><span class="comment">// ET0=1;//T0的中断溢出允许位</span></span><br><span class="line"><span class="comment">// EA=1;//总的允许位</span></span><br><span class="line"><span class="comment">// PT0=0;// IP</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//mark</span></span><br><span class="line"><span class="comment">//分析：如何计1s？</span></span><br><span class="line"><span class="comment">//0~65535</span></span><br><span class="line"><span class="comment">//每隔1us计数加一 12M 12分频</span></span><br><span class="line"><span class="comment">//总共定时时间65535us</span></span><br><span class="line"><span class="comment">//64535离计数器溢出差值1000，所以计时时间为1ms</span></span><br><span class="line"><span class="comment">//最大计65ms,所以这里分出1ms比较合适，再定义其他变量进行秒的计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化，中断溢出会跳到  Timer0_Routine() interrupt 1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//unsigned int T0Count;//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 <span class="comment">//中断子程序</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count;<span class="comment">//静态局部变量，保证退出函数之后不销毁</span></span><br><span class="line"><span class="comment">//TH0=64535/256;//计数器溢出中断后，计数会清理，所以每次进入中断后需要再赋初值</span></span><br><span class="line"><span class="comment">//TL0=64535%256;</span></span><br><span class="line">TL0 = <span class="number">0x66</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T0Count++;<span class="comment">//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"><span class="keyword">if</span>(T0Count&gt;=<span class="number">1000</span>)<span class="comment">//每1s执行对P2_0的操作</span></span><br><span class="line">{</span><br><span class="line">T0Count=<span class="number">0</span>;</span><br><span class="line">P2_0 =~P2_0;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ps-中断执行模块不宜存在过于复杂的任务"><a class="markdownIt-Anchor" href="#ps-中断执行模块不宜存在过于复杂的任务"></a> ps: 中断执行模块不宜存在过于复杂的任务</h2><h2 id="二-基于中断系统的流水灯按键控制"><a class="markdownIt-Anchor" href="#二-基于中断系统的流水灯按键控制"></a> 二、基于中断系统的流水灯按键控制</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Timer0.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void Timer0_Init()//定时器配置</span></span><br><span class="line"><span class="comment">// {</span></span><br><span class="line"><span class="comment">// //TMOD=0x01; //0000 0001 //缺点：会影响到其他定时器</span></span><br><span class="line"><span class="comment">// TMOD &amp;= 0xF0;//把TMOD的低四位清零，高四位保持不变 //优点：不影响高四位（其他定时器的配置）</span></span><br><span class="line"><span class="comment">// TMOD |=  0X01;//把TMOD的最低为置1，高四位保持不变</span></span><br><span class="line"><span class="comment">// TF0=0; // Gate = 0;</span></span><br><span class="line"><span class="comment">// TR0 = 1;//定时器0允许计数</span></span><br><span class="line"><span class="comment">// //mark</span></span><br><span class="line"><span class="comment">// TH0=64535/256;//16进制 取高八位</span></span><br><span class="line"><span class="comment">// TL0=64535%256;//取低八位</span></span><br><span class="line"><span class="comment">// ET0=1;//T0的中断溢出允许位</span></span><br><span class="line"><span class="comment">// EA=1;//总的允许位</span></span><br><span class="line"><span class="comment">// PT0=0;// IP</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//mark</span></span><br><span class="line"><span class="comment">//分析：如何计1s？</span></span><br><span class="line"><span class="comment">//0~65535</span></span><br><span class="line"><span class="comment">//每隔1us计数加一 12M 12分频</span></span><br><span class="line"><span class="comment">//总共定时时间65535us</span></span><br><span class="line"><span class="comment">//64535离计数器溢出差值1000，所以计时时间为1ms</span></span><br><span class="line"><span class="comment">//最大计65ms,所以这里分出1ms比较合适，再定义其他变量进行秒的计数</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> keynum,LEDMode;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">P2=<span class="number">0xFE</span>;<span class="comment">//初始化，点亮第一个LED</span></span><br><span class="line">  Timer0_Init();<span class="comment">//定时器初始化，中断溢出会跳到  Timer0_Routine() interrupt 1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">keynum = Key();</span><br><span class="line"><span class="keyword">if</span>(keynum)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(keynum == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">LEDMode++;</span><br><span class="line"><span class="keyword">if</span>(LEDMode&gt;=<span class="number">2</span>)LEDMode=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//unsigned int T0Count;//全局变量</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 <span class="comment">//中断子程序</span></span><br><span class="line"> {</span><br><span class="line"></span><br><span class="line"> <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count;<span class="comment">//静态局部变量，保证退出函数之后不销毁</span></span><br><span class="line"> <span class="comment">//TH0=64535/256;//计数器溢出中断后，计数会清理，所以每次进入中断后需要再赋初值</span></span><br><span class="line"> <span class="comment">//TL0=64535%256;</span></span><br><span class="line"> TL0 = <span class="number">0x66</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line"> TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line"> T0Count++;<span class="comment">//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"> <span class="keyword">if</span>(T0Count&gt;=<span class="number">500</span>)</span><br><span class="line"> {</span><br><span class="line"> T0Count=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(LEDMode == <span class="number">0</span>)</span><br><span class="line">P2=_crol_(P2,<span class="number">1</span>);<span class="comment">//循环左移</span></span><br><span class="line"><span class="keyword">if</span>(LEDMode == <span class="number">1</span>)</span><br><span class="line">P2=_cror_(P2,<span class="number">1</span>);<span class="comment">//循环右移，类似于移位寄存器（存在反馈电路）</span></span><br><span class="line"> }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p><mark>crol和cror函数区别于&lt;&lt;，&gt;&gt;移位操作符，具有“循环移位”的特性，不需要考虑移位“溢出”；</mark></p><h2 id="三-基于定时器的lcd数字时钟"><a class="markdownIt-Anchor" href="#三-基于定时器的lcd数字时钟"></a> 三、基于定时器的LCD数字时钟</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LCD1602.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Timer0.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sec=<span class="number">55</span>,min=<span class="number">59</span>,hour=<span class="number">23</span>; <span class="comment">//秒时钟 分时钟 小时时钟 这里我们赋上初值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">  LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"CLOCK:"</span>);<span class="comment">//字符串静态显示不需要放在while中</span></span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">3</span>,<span class="string">":  :  "</span>);</span><br><span class="line"><span class="comment">//LCD_ShowNum(2,1,sec,2);//需要更新显示</span></span><br><span class="line">Timer0_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,hour,<span class="number">2</span>);<span class="comment">//思考：动态的信号需要更新显示，静态的信号一般不用放在while循环中</span></span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">4</span>,min,<span class="number">2</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">7</span>,sec,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 <span class="comment">//中断子程序 秒控制计数器</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count;<span class="comment">//静态局部变量，保证退出函数之后不销毁  //不定义为全局变量是为了作为子函数内容，方便调用这个函数模板</span></span><br><span class="line">TL0 = <span class="number">0x66</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T0Count++;<span class="comment">//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"><span class="keyword">if</span>(T0Count&gt;=<span class="number">1000</span>)<span class="comment">//每1s执行对P2_0的操作</span></span><br><span class="line">{</span><br><span class="line">T0Count=<span class="number">0</span>;</span><br><span class="line">P2_0=~P2_0;</span><br><span class="line">sec++;</span><br><span class="line"><span class="keyword">if</span>(sec &gt;=<span class="number">60</span>)</span><br><span class="line">{</span><br><span class="line">sec=<span class="number">0</span>;</span><br><span class="line">min++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(min &gt;=<span class="number">60</span>)</span><br><span class="line">{</span><br><span class="line">min=<span class="number">0</span>;</span><br><span class="line">hour++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(hour &gt;=<span class="number">24</span>)</span><br><span class="line">{</span><br><span class="line">hour=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思考：Verilog/VHDL和单片机（c语言) 程序执行区别？</strong></p><ul><li><mark>c语言程序为顺序执行，而非并行执行，单片机中需要动态执行的任务要放在while循环体中</mark></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> 单片机定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】定时器和中断 01</title>
      <link href="/posts/31909/"/>
      <url>/posts/31909/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机-第七节-定时器和中断总结"><a class="markdownIt-Anchor" href="#51单片机-第七节-定时器和中断总结"></a> [51单片机] 第七节 定时器和中断总结</h1><h2 id="前言定时器中断-寄存器都是单片机中非常重要的概念涉及到许多交叉的控制掌握好这些知识点是学习单片机的关键"><a class="markdownIt-Anchor" href="#前言定时器中断-寄存器都是单片机中非常重要的概念涉及到许多交叉的控制掌握好这些知识点是学习单片机的关键"></a> <mark>前言：定时器中断 ，寄存器都是单片机中非常重要的概念，涉及到许多交叉的控制，掌握好这些知识点是学习单片机的关键。</mark></h2><h2 id="51单片机的时钟源"><a class="markdownIt-Anchor" href="#51单片机的时钟源"></a> 51单片机的时钟源</h2><p>1.外部脉冲<br>2.系统时钟（晶振），开发板上周期为12MHZ</p><h2 id="一-定时器简介-swig0-"><a class="markdownIt-Anchor" href="#一-定时器简介-swig0-"></a> 一、定时器简介<img src="/posts/31909/67e820f0a50c4166b9d09e96323cbbfc.png" class="" title="在这里插入图片描述"></h2><ul><li>注意：当时钟源为外部(T0)引脚提供时，定时器作为“计数器”作用，当外部每输入一个脉冲信号，计数器计数加一（不是常用功能）。</li></ul><h2 id="二-定时器工作模式"><a class="markdownIt-Anchor" href="#二-定时器工作模式"></a> 二、定时器工作模式</h2><img src="/posts/31909/64a2475b0b6249149499e02ab139f2f3.png" class="" title="在这里插入图片描述"><p>C/NT：当次开关为1时，为计数器功能(counter)，配置T0引脚，当为0时，即定时器功能(timer)，配置系统时钟。</p><p><strong>定时器整个工作系统分为三个模块：</strong></p><ul><li>时钟模块: SYSclk,T0 pin ，此图为12分频的模式</li><li>计数模块/中断系统：计数范围：0~65530：计数溢出时会置标志位TF0,申请中断</li><li>控制模块:  GATE,NINT0,TR0</li></ul><h2 id="三-中断系统简介"><a class="markdownIt-Anchor" href="#三-中断系统简介"></a> 三、中断系统简介</h2><img src="/posts/31909/bebdac2cb7844406bba4299a353e6c6b.png" class="" title="在这里插入图片描述"><ul><li>高优先级的中断可以打断低优先级的中断</li><li>中断系统即对紧急事件的实时处理</li></ul><h2 id="四-中断系统工作流程"><a class="markdownIt-Anchor" href="#四-中断系统工作流程"></a> 四、中断系统工作流程</h2><img src="/posts/31909/6e8e07edeeb447a2b59d06efb8eec845.png" class="" title="在这里插入图片描述"><h2 id="五-stc89c52的中断资源"><a class="markdownIt-Anchor" href="#五-stc89c52的中断资源"></a> 五、stc89c52的中断资源</h2><img src="/posts/31909/ddd0c3d15aef430fbd38dc6b8a28716d.png" class="" title="在这里插入图片描述"><h2 id="六-中断系统的结构"><a class="markdownIt-Anchor" href="#六-中断系统的结构"></a> 六、中断系统的结构</h2><img src="/posts/31909/1214475b0c524bdbb01c7d3ed8ce5353.png" class="" title="在这里插入图片描述"><ul><li><mark>寄存器解释，中断系统的详细原理见数据手册（养成良好的阅读素养）</mark></li></ul><h2 id="寄存器的简介"><a class="markdownIt-Anchor" href="#寄存器的简介"></a> 寄存器的简介</h2><img src="/posts/31909/def0dec741e3438db3d0698a194ad54e-17087026380168.png" class="" title="在这里插入图片描述"><ul><li><strong><mark>寄存器相当于连接单片机中电路的“特殊开关”</mark></strong></li></ul><img src="/posts/31909/df18bf435b3048e0be9d65398f023462.png" class="" title="在这里插入图片描述"><p><strong>ps: GATE直接给0 ，一级或门输出一，二级与门输出由TR0控制是否进行计数</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> 单片机定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】串口通信</title>
      <link href="/posts/17620/"/>
      <url>/posts/17620/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机-第八节-串口通信总结"><a class="markdownIt-Anchor" href="#51单片机-第八节-串口通信总结"></a> [51单片机] 第八节 串口通信总结</h1><p><mark><strong>51单片机中的自动重载概念实际上就是当计数溢出后自动赋初值</strong></mark><br><mark><strong>同步通信中波特率为通信双方约定好的通信速率</strong></mark></p><h2 id="前置部分"><a class="markdownIt-Anchor" href="#前置部分"></a> &lt;前置部分&gt;</h2><h3 id="一-串口简介"><a class="markdownIt-Anchor" href="#一-串口简介"></a> 一、串口简介：</h3><ul><li>串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信。</li><li>单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大的扩展了单片机的应用范围，增强了单片机系统的硬件实力。</li><li>51单片机内部自带UART（Universal Asynchronous Receiver Transmitter，通用异步收发器），可实现单片机的串口通信。</li></ul><p>CH340串口模块</p><img src="/posts/17620/27446b4622ad4a0cbcb38f713983f81b.png" class="" title="在这里插入图片描述"><p>蓝牙串口模块</p><img src="/posts/17620/8a2079d378f24b61ad22949edbdb3807.png" class="" title="在这里插入图片描述"><h3 id="二-串口通信方式"><a class="markdownIt-Anchor" href="#二-串口通信方式"></a> 二、串口通信方式：</h3><img src="/posts/17620/5e2154d6b0284aeea4bf2085df848fcd.png" class="" title="在这里插入图片描述"><img src="/posts/17620/f53dddcf5aa24cb9b527df57abb8439e.png" class="" title="在这里插入图片描述"><img src="/posts/17620/1aef41579afb4053bc396a79ed0acbba.png" class="" title="在这里插入图片描述"><h3 id="串口模式图"><a class="markdownIt-Anchor" href="#串口模式图"></a> #串口模式图：</h3><img src="/posts/17620/f0cfb31d68bb4a9e911fb4d194cbc5b4.png" class="" title="在这里插入图片描述"><ul><li>SBUF：串口数据缓存寄存器，物理上是两个独立的寄存器，但占用相同的地址。写操作时，写入的是发送寄存器，读操作时，读出的是接收寄存器，因此要<mark>通过检测TI和RI的信号</mark>判断是发送还是接收操作。</li></ul><h3 id="ps用串口端控制发送接收时要注意对应上hex文本模式"><a class="markdownIt-Anchor" href="#ps用串口端控制发送接收时要注意对应上hex文本模式"></a> ps:用串口端控制发送/接收时，要注意对应上HEX/文本模式</h3><ul><li>HEX模式/十六进制模式/二进制模式：以原始数据的形式显示</li><li>文本模式/字符模式：以原始数据编码后的形式显示</li></ul><h3 id="stc-isp-串口波特率代码生成"><a class="markdownIt-Anchor" href="#stc-isp-串口波特率代码生成"></a> # stc-isp 串口波特率代码生成</h3><img src="/posts/17620/0cd1dd1144844719857702f92b85defa.png" class="" title="在这里插入图片描述"><h3 id="三-串行口通信相关寄存器"><a class="markdownIt-Anchor" href="#三-串行口通信相关寄存器"></a> 三、串（行）口通信相关寄存器</h3><img src="/posts/17620/fb06092740624f0e9f0f842f86e67c71.png" class="" title="在这里插入图片描述"><img src="/posts/17620/239d9f30d5e948e9bb6b021a20d73cce.png" class="" title="在这里插入图片描述"><img src="/posts/17620/358ab45096b14af0b704f528e22fece1.png" class="" title="在这里插入图片描述"><img src="/posts/17620/1d59a35042d74b2bb9bd05c1212373b9.png" class="" title="在这里插入图片描述"><h3 id="串口通信的寄存器解释"><a class="markdownIt-Anchor" href="#串口通信的寄存器解释"></a> #串口通信的寄存器解释</h3><hr><h4 id="scon串行控制寄存器"><a class="markdownIt-Anchor" href="#scon串行控制寄存器"></a> SCON:串行控制寄存器</h4><ul><li><strong>SMO/FE：当PCON为1，FE生效，用于帧检测，当PCON为0，SM0生效，与SM1共同作用</strong></li><li>这里我们选择工作方式1，SM0=0,SM1=1，SM2=0（没有用到停止位），REN=0（暂不接收数据）,TB8=0,RB8=0,T1=0（方式1），RI=0(<mark>在收到一个Byte的数据时RI会自动置1</mark>);</li><li><mark>SCON = 0x40;</mark></li></ul><p><strong>ps:主机响应中断不能判断是接收还是发送中断，必须在中断服务程序中判断TI和RI的值</strong></p><hr><h4 id="pcon波特率选择寄存器"><a class="markdownIt-Anchor" href="#pcon波特率选择寄存器"></a> PCON:波特率选择寄存器</h4><ul><li>由常用串口软件如：stp-isp进行计算</li></ul><hr><h4 id="sbuf数据缓冲寄存器"><a class="markdownIt-Anchor" href="#sbuf数据缓冲寄存器"></a> SBUF:数据缓冲寄存器</h4><ul><li>通过程序，控制SBUF的内容，实现电脑端和单片机端的双向通信数据传输</li></ul><hr><h2 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> &lt;代码部分&gt;</h2><h3 id="一-串口向电脑端发送数据"><a class="markdownIt-Anchor" href="#一-串口向电脑端发送数据"></a> 一、串口向电脑端发送数据</h3><p>UART.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 串口初始化，//4800bps@11.0592MHz</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span><span class="comment">//串口初始化</span></span><br><span class="line">{<span class="comment">//波特率：通信双方约定的通信速率</span></span><br><span class="line">SCON=<span class="number">0x40</span>;</span><br><span class="line">PCON &amp;= <span class="number">0x7F</span>;<span class="comment">//波特率不倍速</span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">  TL1 = <span class="number">0xFA</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">  TH1 = <span class="number">0xFA</span>;<span class="comment">//设置定时重载值</span></span><br><span class="line">   ET1 = <span class="number">0</span>;<span class="comment">//禁止定时器中断</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 串口发送一个字节数据</span></span><br><span class="line"><span class="comment">  * @param  Byte 要发送的一个字节数据</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">SBUF=Byte;<span class="comment">//发送缓存器中的数据为Byte</span></span><br><span class="line"><span class="keyword">while</span>(TI==<span class="number">0</span>);<span class="comment">//发送完数据后，电脑端接收，然后TI=1，跳过while循环</span></span><br><span class="line">TI=<span class="number">0</span>;<span class="comment">//每次发送完数据,程序置0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>main.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"UART.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Sec;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">UART_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">UART_SendByte(Sec);</span><br><span class="line">Sec++;</span><br><span class="line">Delay(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二-电脑通过串口控制led"><a class="markdownIt-Anchor" href="#二-电脑通过串口控制led"></a> 二、电脑通过串口控制LED</h3><p>UART.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 串口初始化，//4800bps@11.0592MHz</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span><span class="comment">//串口初始化</span></span><br><span class="line">{<span class="comment">//波特率：通信双方约定的通信速率</span></span><br><span class="line">SCON=<span class="number">0x50</span>;</span><br><span class="line">PCON &amp;= <span class="number">0x7F</span>;<span class="comment">//波特率不倍速</span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">  TL1 = <span class="number">0xFA</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">  TH1 = <span class="number">0xFA</span>;<span class="comment">//设置定时重载值</span></span><br><span class="line">   ET1 = <span class="number">0</span>;<span class="comment">//禁止定时器中断</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//启动所有中断</span></span><br><span class="line">ES=<span class="number">1</span>;<span class="comment">//启动串口中断</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动重装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 串口发送一个字节数据</span></span><br><span class="line"><span class="comment">  * @param  Byte 要发送的一个字节数据</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">SBUF=Byte;</span><br><span class="line"><span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">TI=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口中断函数模板</span></span><br><span class="line"><span class="comment">void UART_Routine() interrupt 4</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(RI==1)// 接收 中断</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">RI=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>main.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"UART.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">UART_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Routine</span><span class="params">()</span> interrupt 4 <span class="comment">//带上interrupt 4表示UART_Routine()为中断服务子函数</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)<span class="comment">// 接收 中断</span></span><br><span class="line">{</span><br><span class="line">P2=~SBUF;</span><br><span class="line">UART_SendByte(SBUF);<span class="comment">//这里，单片机接收电脑端发送的数据，一个函数不能既在主函数里出现，也在中断中出现</span></span><br><span class="line">RI=<span class="number">0</span>;<span class="comment">//程序置0</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><mark><strong>总结：UART：同步双向，即向电脑端发送数据，也可接收电脑端发送的数据，通过内部程序执行相应的任务</strong></mark></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> 串口通信 </tag>
            
            <tag> UART通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】红外通信</title>
      <link href="/posts/50684/"/>
      <url>/posts/50684/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机第十七讲-红外通信"><a class="markdownIt-Anchor" href="#51单片机第十七讲-红外通信"></a> 【51单片机】第十七讲 红外通信</h1><p>2024.2.2日更新</p><h2 id="一-使用模块"><a class="markdownIt-Anchor" href="#一-使用模块"></a> 一、使用模块</h2><h3 id="红外遥控"><a class="markdownIt-Anchor" href="#红外遥控"></a> 红外遥控</h3><ol><li>介绍：红外遥控是利用红外光进行通信的设备，由红外LED将<mark>调制</mark>后的信号发出，由专用的红外接收头进行<mark>解调</mark>输出。</li><li>红外LED波长：940nm，红外信号属于电磁波</li><li>通信协议标准：<mark>NEC标准</mark></li></ol><h3 id="红外接收管"><a class="markdownIt-Anchor" href="#红外接收管"></a> 红外接收管</h3><img src="/posts/50684/6090cf36fd3340cc9904d8646fbe34b9.png" class="" title="img"><h2 id="二-原理部分"><a class="markdownIt-Anchor" href="#二-原理部分"></a> 二、原理部分</h2><h3 id="一-红外通信的原理"><a class="markdownIt-Anchor" href="#一-红外通信的原理"></a> 一、红外通信的原理</h3><ul><li>空闲状态：红外LED不亮，接收头输出高电平</li><li>发送低电平：红外LED以38KHz频率闪烁发光，接收头输出低电平</li><li>发送高电平：红外LED不亮，接收头输出高电平<br>总而言之，只有红外LED发送38KHZ的闪烁信号时，红外接收头OUT引脚才会对外输出低电平信号<br>红外发送–红外接收的本质是<mark>调制</mark>和<mark>解调</mark>，在这种条件下，可以过滤掉自然界中的“噪声信号”，只有38KHZ附近的红外信号才能被红外接收头识别转换为对应的低电平。</li></ul><p><strong>转换示意图：</strong><br>1.红外LED发出的信号</p><img src="/posts/50684/c97d453d8866482a8bc0a2191a565288.png" class="" title="在这里插入图片描述"><p>2.红外接收头发出的信号</p><img src="/posts/50684/3d972def937345fdb73a96eb875114b8.png" class="" title="在这里插入图片描述"><p>其中，红外接收头发出的低电平信号的宽度等价于红外LED发送的38KHz信号的时间。</p><h3 id="二-nec通信的原理"><a class="markdownIt-Anchor" href="#二-nec通信的原理"></a> 二、NEC通信的原理</h3><h4 id="一-红外nec协议"><a class="markdownIt-Anchor" href="#一-红外nec协议"></a> 一、红外NEC协议</h4><img src="/posts/50684/ac77a0c0463b43ec87199921737332ea.png" class="" title="在这里插入图片描述"><p>在51单片机中，使用NEC通信协议，虽然NEC标准上要求（比如说Start信号）低电平持续时间9ms,高电平持续时间4.5ms，但是stc89c52用红外通信要使用到外部中断，外部中断检测方式有两种：低电平/下降沿，我们这里使用下降沿检测方式，一个完整的Start信号，包含两个下降沿，即触发两次中断，所以只要从第一次中断开始起始，第二次中断判断时间长度，即可分辨是Start还是Repeat信号。</p><h4 id="二-nec编码"><a class="markdownIt-Anchor" href="#二-nec编码"></a> 二、NEC编码</h4><img src="/posts/50684/bfdf6d289ff1423ca951eba5640917c6.png" class="" title="在这里插入图片描述"><p><strong>NEC编码包括地址码和命令码，其中地址吗和命令码都会进行一次反码校验。因此，一段完整的NEC数据码一共有4个字节，32位bit</strong></p><p>遥控器键码</p><img src="/posts/50684/7a07fa67c2f145da96d22f3cd2c6d79a.png" class="" title="在这里插入图片描述"><p>这里，我们定义地址码为<mark>Address</mark>,命令码为<mark>Command</mark>, 完整的数据码为<mark>DATA</mark>，如果我们按下0,那么发送的<strong>Address=0x00; Command =0x16; 那么DATA一共包含0X00,0XFF,0X16,~0X16四个字节的先后数据。</strong></p><h3 id="三-外部中断的原理"><a class="markdownIt-Anchor" href="#三-外部中断的原理"></a> 三、外部中断的原理</h3><ul><li>STC89C52有四个外部中断</li><li>STC89C52外部中断有两种方式：下降沿/低电平触发</li><li>中断号</li></ul><img src="/posts/50684/371dbb882c974ce58699b8ceaa32e092.png" class="" title="在这里插入图片描述"><p>外部中断配置的寄存器：</p><img src="/posts/50684/53bd99d1486c4427aff48442fad5ee50.png" class="" title="在这里插入图片描述"><h1 id="三-代码部分"><a class="markdownIt-Anchor" href="#三-代码部分"></a> 三、代码部分</h1><h2 id="重要调试过程"><a class="markdownIt-Anchor" href="#重要调试过程"></a> #重要调试过程</h2><p><strong>11.0592MHZ和12MHZ的定时器计数速率不一致，硬件电路或者程序运行速度相关问题，可能导致实际的（比如Start命令）宽度并不是很接近于标准的通信协议，需要我们自己去调试，这里我在调试的过程中遇到了一些问题，以下为相关代码和解决方法</strong></p><p>外部中断</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"><span class="comment">#include "Delay.h"</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "INT0.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char Num;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">Int0_Init();</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line">LCD_ShowNum(1,1,Num,2);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Int0_Rountine(void)interrupt 0</span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @brief </span><br><span class="line">  * @param  </span><br><span class="line">  * @retval </span><br><span class="line"></span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">void Int0_Init(void)//@11.0592MHz</span><br><span class="line">{</span><br><span class="line">IT0=1;</span><br><span class="line">IE0=0;</span><br><span class="line">EX0=1;</span><br><span class="line">EA=1;</span><br><span class="line">PX0=1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">void Int0_Rountine(void)interrupt 0;</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><p>Timer0计时模块编写,用作跟红外通信相关的编码时序计时</p><img src="/posts/50684/353ffadddfd04e0f9e71870ae7e8448a.png" class="" title="在这里插入图片描述"><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Timer0_Init(void)//@11.0592MHz</span><br><span class="line">{</span><br><span class="line">TMOD &amp;= 0xF0;</span><br><span class="line">TMOD |= 0x01;</span><br><span class="line">TL0 = 0x00;</span><br><span class="line">TH0 = 0x00;</span><br><span class="line">TF0 = 0;</span><br><span class="line">TR0 = 0;</span><br><span class="line">ET0=1;</span><br><span class="line">EA=1;</span><br><span class="line">PT0=0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Time0_SetCounter(unsigned int Number)</span><br><span class="line">{</span><br><span class="line">TL0=0x0F&amp;Number;</span><br><span class="line">TH0=0xF0&amp;Number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned int <span class="function"><span class="title">Time0_GetCounter</span></span>()</span><br><span class="line">{</span><br><span class="line">unsigned int number;</span><br><span class="line">number=TL0+TH0;</span><br><span class="line"><span class="built_in">return</span> number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Time0_Run(unsigned char Flag)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Flag)</span><br><span class="line">{</span><br><span class="line">TR0=1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">TR0=0;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">/*定时器中断函数模板</span><br><span class="line">void Timer0_Routine() interrupt 1 //中断子程序</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">static unsigned int T0Count;//静态局部变量，保证退出函数之后不销毁</span><br><span class="line">TL0 = 0x66;//设置定时初始值</span><br><span class="line">TH0 = 0xFC;//设置定时初始值</span><br><span class="line">T0Count++;//每次进入中断子程序，秒控制器自加一</span><br><span class="line"><span class="keyword">if</span>(T0Count&gt;=1000)//每1s执行对P2_0的操作</span><br><span class="line">{</span><br><span class="line">T0Count=0;</span><br><span class="line">P2_0 =~P2_0;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><p><strong>红外通信模块</strong></p><blockquote><p>测试结果：红外可以接收，但是无法发送起始命令（按下按键后，LED不亮）<br>问题分析 ：计时器计数的时长不在我们 &gt; if(IR_Time&gt;=13500-500 &amp;&amp; IR_Time&lt;=13500+500) &lt; 语句的判断范围内<br>解决方案：修改if语句的判断范围，使之能检测到Start命令，并用LCD1602显示定时器发送Start命令实际的定时器计数数值IR_Time。</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"><span class="comment">#include "INT0.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char IR_ADDRESS;</span><br><span class="line">unsigned char IR_State;</span><br><span class="line">unsigned char IR_Time;</span><br><span class="line"></span><br><span class="line">void IR_Init()//红外中断初始化</span><br><span class="line">{</span><br><span class="line">Timer0_Init();</span><br><span class="line">Int0_Init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Int0_Rountine(void)interrupt 0 //外部中断函数，使用状态机方法</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IR_State==0)//起始时，一但红外管检测到按键按下，就会进入外部中断程序，从状态0开始</span><br><span class="line">{</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">Timer0_Run(1);</span><br><span class="line">IR_State=1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_State==1)//状态1</span><br><span class="line">{</span><br><span class="line">IR_Time=Timer0_GetCounter();</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line"><span class="keyword">if</span>(IR_Time&gt;=13500-500 &amp;&amp; IR_Time&lt;=13500+500)//检测红外管是否发送起始命令</span><br><span class="line">{</span><br><span class="line">P2=0;</span><br><span class="line">IR_State=2;</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_Time&gt;=11250-500 &amp;&amp; IR_Time&lt;=11250+500)//重复命令</span><br><span class="line">{</span><br><span class="line">IR_State=0;</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">IR_State=1;//自循环</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试定时器是否正常计数<br>问题1：延时函数用到12MHZ,需要改写<br>问题2:   Timer0模块多个函数编写存在问题</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"><span class="comment">#include "Delay.h"</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "INT0.h"</span></span><br><span class="line"><span class="comment">#include "IR.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char Num;//Num只能到255</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">Timer0_Init();</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">Timer0_Run(1);</span><br><span class="line">Delay(1);</span><br><span class="line">LCD_ShowNum(1,1,Timer0_GetCounter(),5);</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改后，再次测试…<br>延时13ms观察定时器计数，通过LCD可以看到,13ms对应的计数居然是12076, 不符合12MHZ的通信要求，由此，我们要重新运算通信时序时长</p><p>使用时间转换器Timer0_usCount ，对比结果，显示真实的13500ms对应的定时器计数值</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Timer0.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LCD1602.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"INT0.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"IR.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">Timer0_Init();Timer0_SetCounter(<span class="number">0</span>);Timer0_Run(<span class="number">1</span>);</span><br><span class="line">Delay(<span class="number">13</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Timer0_GetCounter(),<span class="number">5</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,Timer0_usCount(<span class="number">0x66</span>,<span class="number">0xCF</span>),<span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/50684/a2b23e45c4a744b79a619ced79a72ee2.png" class="" title="在这里插入图片描述"><p>实际红外管，起始命令的时长为"12926"</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"><span class="comment">#include "INT0.h"</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char IR_ADDRESS;</span><br><span class="line">unsigned char IR_State;</span><br><span class="line"></span><br><span class="line">//unsigned char IR_Time; 错误！！！这里定义为字符类型，对应的数值仅有255，对应的13500无法赋值给IR_Time</span><br><span class="line">unsigned int IR_Time;</span><br><span class="line"></span><br><span class="line">void IR_Init()//红外中断初始化</span><br><span class="line">{</span><br><span class="line">Timer0_Init();</span><br><span class="line">Int0_Init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Int0_Rountine(void)interrupt 0 //外部中断函数，使用状态机方法</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IR_State==0)//起始时，一但红外管检测到按键按下，就会进入外部中断程序，从状态0开始</span><br><span class="line">{</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">Timer0_Run(1);</span><br><span class="line">IR_State=1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_State==1)//状态1</span><br><span class="line">{</span><br><span class="line">IR_Time=Timer0_GetCounter();</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line"><span class="keyword">if</span>(IR_Time&gt;12926-500 &amp;&amp; IR_Time&lt;12926+500)//检测红外管是否发送起始命令</span><br><span class="line">{</span><br><span class="line">LCD_ShowNum(1,1,IR_Time,5);</span><br><span class="line">P2=0;</span><br><span class="line">IR_State=2;</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_Time&gt;=1000 &amp;&amp; IR_Time&lt;=2000)//重复命令</span><br><span class="line">{</span><br><span class="line">IR_State=0;</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">P2_5=1;</span><br><span class="line">P2_5=0;</span><br><span class="line">P2_5=1;</span><br><span class="line">IR_State=1;//自循环</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>经过对代码的修改后，将程序烧录到单片机上，在LCD1602上显示能够进入&gt;if(IR_Time&gt;12926-500 &amp;&amp; IR_Time&lt;12926+500)语句的命令时长&lt;</strong></p><img src="/posts/50684/353560c64d1f47b7b4af420f04f8b1ef.jpeg" class="" title="在这里插入图片描述"><p><strong>IR_Time在12926附近浮动，可见用标准的13500作为代码中的时长判断并不合适，同理，后续的其他命令时长（低电平/高电平/Repeat/)也用这种方法测试（调大判断范围、显示真实时长、修改合适的范围）</strong></p><h2 id="一-外部中断"><a class="markdownIt-Anchor" href="#一-外部中断"></a> 一、外部中断</h2><p>1.外部中断寄存器配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @brief </span><br><span class="line">  * @param  </span><br><span class="line">  * @retval </span><br><span class="line"></span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">void Int0_Init(void)//@11.0592MHz</span><br><span class="line">{</span><br><span class="line">IT0=1;//下降沿触发中断</span><br><span class="line">IE0=0;</span><br><span class="line">EX0=1;</span><br><span class="line">EA=1;</span><br><span class="line">PX0=1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">void Int0_Rountine(void)interrupt 0;</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><p>2.对定时器0进行重编写</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Timer0_Init(void)//@11.0592MHz</span><br><span class="line">{</span><br><span class="line">TMOD &amp;= 0xF0;</span><br><span class="line">TMOD |= 0x01;</span><br><span class="line">TL0 = 0x00;</span><br><span class="line">TH0 = 0x00;</span><br><span class="line">TF0 = 0;</span><br><span class="line">TR0 = 0;</span><br><span class="line">ET0=1;</span><br><span class="line">EA=1;</span><br><span class="line">PT0=0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">///TH0 TL0不能随便给Number的，有高低位之分！</span><br><span class="line">void Timer0_SetCounter(unsigned int Number)</span><br><span class="line">{</span><br><span class="line">TH0=Number/256;</span><br><span class="line">TL0=Number%256;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//!!!</span><br><span class="line">unsigned int Timer0_GetCounter(void)</span><br><span class="line">{</span><br><span class="line">//number=TL0+TH0;</span><br><span class="line"><span class="built_in">return</span> (TH0&lt;&lt;<span class="string">8)|TL0;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//!!!</span></span><br><span class="line"><span class="string">void Timer0_Run(unsigned char Flag)</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">//if(Flag)</span></span><br><span class="line"><span class="string">//{</span></span><br><span class="line"><span class="string">//TR0=1;</span></span><br><span class="line"><span class="string">//}</span></span><br><span class="line"><span class="string">//else</span></span><br><span class="line"><span class="string">//{</span></span><br><span class="line"><span class="string">//TR0=0;</span></span><br><span class="line"><span class="string">//}</span></span><br><span class="line"><span class="string">TR0=Flag;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unsigned int Timer0_usCount(unsigned int TL,unsigned int TH)//时间转换器</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">unsigned int us = (0xFF-TH)*16*16 + (0xFF-TL);</span></span><br><span class="line"><span class="string">return us;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*定时器中断函数模板</span></span><br><span class="line"><span class="string">void Timer0_Routine() interrupt 1 //中断子程序</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static unsigned int T0Count;//静态局部变量，保证退出函数之后不销毁</span></span><br><span class="line"><span class="string">TL0 = 0x66;//设置定时初始值</span></span><br><span class="line"><span class="string">TH0 = 0xFC;//设置定时初始值</span></span><br><span class="line"><span class="string">T0Count++;//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"><span class="string">if(T0Count&gt;=1000)//每1s执行对P2_0的操作</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">T0Count=0;</span></span><br><span class="line"><span class="string">P2_0 =~P2_0;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></tbody></table></figure><p>3.红外通信模块</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"><span class="comment">#include "INT0.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//unsigned char IR_Time; 错误！！！这里定义为字符类型，对应的数值仅有255，对应的13500无法赋值给IR_Time</span><br><span class="line">unsigned int IR_Time;</span><br><span class="line">unsigned char IR_State;</span><br><span class="line"></span><br><span class="line">unsigned char IR_Data[4];</span><br><span class="line">unsigned char IR_Data_p;</span><br><span class="line"></span><br><span class="line">unsigned char IR_DataFlag;</span><br><span class="line">unsigned char IR_RepeatFlag;</span><br><span class="line"></span><br><span class="line">unsigned char IR_Address;</span><br><span class="line">unsigned char IR_Command;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void IR_Init()//红外中断初始化</span><br><span class="line">{</span><br><span class="line">Timer0_Init();</span><br><span class="line">Int0_Init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char IR_GetAdress(void)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">return</span> IR_Address;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char IR_GetCommand(void)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">return</span> IR_Command;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char IR_GetDataFlag(void)</span><br><span class="line">{</span><br><span class="line">unsigned int Flag = IR_DataFlag;</span><br><span class="line">IR_DataFlag=0;</span><br><span class="line"><span class="built_in">return</span> Flag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char IR_GetRepeatFlag(void)</span><br><span class="line">{</span><br><span class="line">unsigned int Flag = IR_RepeatFlag;</span><br><span class="line">IR_RepeatFlag=0;</span><br><span class="line"><span class="built_in">return</span> Flag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Int0_Rountine(void)interrupt 0 //外部中断函数，使用状态机方法</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IR_State==0)//起始时，一但红外管检测到按键按下，就会进入外部中断程序，从状态0开始</span><br><span class="line">{</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line">Timer0_Run(1);</span><br><span class="line">IR_State=1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_State==1)//状态1</span><br><span class="line">{</span><br><span class="line">IR_Time=Timer0_GetCounter();</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line"><span class="keyword">if</span>(IR_Time&gt;12926-500 &amp;&amp; IR_Time&lt;12926+500)//检测红外管是否发送起始命令</span><br><span class="line">{</span><br><span class="line">P2=0;</span><br><span class="line">IR_State=2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_Time&gt;11250-500 &amp;&amp; IR_Time&lt;11250+500)//重复命令</span><br><span class="line">{</span><br><span class="line">IR_RepeatFlag=1;</span><br><span class="line">IR_State=0;</span><br><span class="line">Timer0_Run(0);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">IR_State=1;//自循环</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_State==2)//状态2</span><br><span class="line">{</span><br><span class="line">IR_Time=Timer0_GetCounter();</span><br><span class="line">Timer0_SetCounter(0);</span><br><span class="line"><span class="keyword">if</span>(IR_Time&gt;1032-500 &amp;&amp; IR_Time&lt;1032+500)//将IR_Data中的某一位置零</span><br><span class="line">{</span><br><span class="line">IR_Data[IR_Data_p/8] &amp;= ~(0x01&lt;&lt;(IR_Data_p%8)); // 0x01&lt;&lt;<span class="string">1 0000 0001 0000 0010 ~(0x01&lt;&lt;1</span>) 1111 1110 1111 1101</span><br><span class="line">//IR_Data_p++/8,对应的值从0到3</span><br><span class="line">//IR_Data_p++%8,对应的值0~7循环四轮</span><br><span class="line">IR_Data_p++;//Data的二进制位指针,0~31</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(IR_Time&gt;2074-500 &amp;&amp; IR_Time&lt;2074+500)</span><br><span class="line">{</span><br><span class="line">IR_Data[IR_Data_p/8] |= (0x01&lt;&lt;(IR_Data_p%8)); // 0x01&lt;&lt;<span class="string">1 0000 0001 0000 0010 ~(0x01&lt;&lt;1</span>) 1111 1110 1111 1101</span><br><span class="line">//IR_Data_p++/8,对应的值从0到3</span><br><span class="line">//IR_Data_p++%8,对应的值0~7循环四轮</span><br><span class="line">IR_Data_p++;//Data的二进制位指针,0~31</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">IR_Data_p=0;</span><br><span class="line">IR_State=1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(IR_Data_p&gt;=32)</span><br><span class="line">{</span><br><span class="line">IR_Data_p=0;//位指针清零</span><br><span class="line"><span class="keyword">if</span>((IR_Data[<span class="number">0</span>] == ~IR_Data[<span class="number">1</span>]) &amp;&amp; (IR_Data[<span class="number">2</span>] == ~IR_Data[<span class="number">3</span>]))</span><br><span class="line">{</span><br><span class="line">IR_DataFlag=1;</span><br><span class="line">IR_Address=IR_Data[0];</span><br><span class="line">IR_Command=IR_Data[2];</span><br><span class="line">}</span><br><span class="line">Timer0_Run(0);</span><br><span class="line">IR_State=0;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3.主函数<br>运行问题1：在没有&gt;IR_GetDataFlag()||IR_GetRepeatFlag()&lt;的情况下，按下对应的红外按键也会产生连加的现象，这里<br>//if(Command==0x15)<br>//{<br>//Num–;<br>//}<br>//if(Command==0x09)<br>//{<br>//Num++;<br>//}跳出了&gt;if(IR_GetDataFlag())，<strong>只要红外遥控发出信号，红外发送管会产生对应的数据码，只要红外发送管产生单个方波信号，NUM也能自加，正确情况下应该是产生完整的数据码，然后标志位=1，NUM才能加一，这里出现了代码书写逻辑的错误</strong>&lt;</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "IR.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char Num;</span><br><span class="line">unsigned char Command,Address;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">IR_Init();</span><br><span class="line">LCD_ShowString(1,1,<span class="string">"ADR  COM  NUM"</span>);//tab键会被识别</span><br><span class="line">LCD_ShowHexNum(2,1,00,2);</span><br><span class="line">LCD_ShowHexNum(2,6,00,2);</span><br><span class="line">LCD_ShowNum(2,11,00,3);</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IR_GetDataFlag()||IR_GetRepeatFlag())//IR_GetRepeatFlag连加标志位</span><br><span class="line">{</span><br><span class="line">Command=IR_GetCommand();</span><br><span class="line">Address=IR_GetAdress();</span><br><span class="line">LCD_ShowHexNum(2,1,Address,2);</span><br><span class="line">LCD_ShowHexNum(2,6,Command,2);</span><br><span class="line"><span class="keyword">if</span>(Command==0x15)</span><br><span class="line">{</span><br><span class="line">Num--;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Command==0x09)</span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">}</span><br><span class="line">LCD_ShowNum(2,11,Num,3);</span><br><span class="line">}</span><br><span class="line">//<span class="keyword">if</span>(Command==0x15)</span><br><span class="line">//{</span><br><span class="line">//Num--;</span><br><span class="line">//}</span><br><span class="line">//<span class="keyword">if</span>(Command==0x09)</span><br><span class="line">//{</span><br><span class="line">//Num++;</span><br><span class="line">//}</span><br><span class="line">//LCD_ShowNum(2,8,Num,2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改完成后，运行正常</p><blockquote><p><strong>现象：按下对应的按键，LCD1602上会显示对应的地址码，键码，以及NUM，按下控制NUM加减的按键，NUM会正确地进行自加减，并且具备连加/减地功能</strong><br><strong><mark>本程序用到了大量函数封装的方法，便于我们进行调用以及参数的判断，模块化编程极大地优化了代码的结构以及可移植性</mark></strong></p></blockquote><h2 id="二-红外通信pwm控制电机转速"><a class="markdownIt-Anchor" href="#二-红外通信pwm控制电机转速"></a> 二、红外通信+PWM控制电机转速</h2><p>1.主函数<br><strong>由于红外通信和PWM都要用到定时器/中断，这里同时使用到STC89C52中的定时器0和定时器1，使用定时器/红外中断时要注意区分优先级</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "IR.h"</span></span><br><span class="line"><span class="comment">#include "Timer1.h"</span></span><br><span class="line"><span class="comment">#include "Nixie.h"</span></span><br><span class="line"><span class="comment">#include "Motor.h"</span></span><br><span class="line"></span><br><span class="line">unsigned char Num;</span><br><span class="line">unsigned char Command,Address;</span><br><span class="line">unsigned char Speed;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">Motor_Init();</span><br><span class="line">IR_Init();</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line">Command=IR_GetCommand();</span><br><span class="line"><span class="keyword">if</span>(IR_GetDataFlag())</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Command==IR_VOL_ADD)</span><br><span class="line">{</span><br><span class="line">Speed++;</span><br><span class="line">Speed%=4;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">switch(Speed)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> 0:Motor_CompareSet(0);<span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span> 1:Motor_CompareSet(50);<span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span> 2:Motor_CompareSet(75);<span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span> 3:Motor_CompareSet(100);<span class="built_in">break</span>;</span><br><span class="line">}</span><br><span class="line">Nixie(1,Speed);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2.直流电机模块（定时器1）<br>这里将占空比封装成函数<br><strong>思考：直接将子模块中的参数封装成函数，和直接调用全局变量的区别？</strong><br>封装成函数更便于调用</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Timer1.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned char Count,Compare;</span><br><span class="line"></span><br><span class="line">sbit Motor = P1^3;</span><br><span class="line"></span><br><span class="line">void Motor_Init(void)</span><br><span class="line">{</span><br><span class="line">Timer1_Init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Motor_CompareSet(unsigned char num)//占空比设置</span><br><span class="line">{</span><br><span class="line">Compare=num;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Timer1_Routine() interrupt 3 //PWM控速</span><br><span class="line">{</span><br><span class="line">TL1 = 0x9C;</span><br><span class="line">TH1 = 0xFF;</span><br><span class="line">Count++;</span><br><span class="line">Count%=100;</span><br><span class="line"><span class="keyword">if</span>(Count&lt;Compare)</span><br><span class="line">{</span><br><span class="line">Motor=1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor=0;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>现象：按下红外遥控上对应的按键，直流电机速度发生变化</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> 红外通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言入门学习】分支和循环</title>
      <link href="/posts/6621/"/>
      <url>/posts/6621/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言入门学习分支和循环"><a class="markdownIt-Anchor" href="#c语言入门学习分支和循环"></a> 【C语言入门学习】分支和循环</h1><p><strong>2024.2.20更新</strong></p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> #基本概念</h2><h3 id="一-语句"><a class="markdownIt-Anchor" href="#一-语句"></a> 一、语句</h3><p><strong>什么是语句？</strong><br>c语言中语句是用于控制计算机执行相关操作的指令，一个<mark>语句</mark>会被<mark>编译</mark>成若干条<mark>机器命令</mark>继而由计算机执行。</p><p><strong>语句的类型</strong></p><ul><li>表达式语句</li><li>函数调用语句</li><li>控制语句</li><li>复合语句</li><li>空语句</li></ul><blockquote><p>控制语句用于<mark>控制程序的执行流程</mark>，以实现程序的各种结构方式，它们由特定的语句定义符组成，C语言有九种控制语句。可分成以下三类：</p><ol><li>条件判断语句也叫分支语句：if语句、switch语句；</li><li>循环执行语句：do while语句、while语句、for语句；</li><li>转向语句：break语句、goto语句、continue语句、return语句</li></ol></blockquote><hr><h2 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> #代码部分</h2><h3 id="一-if分支语句"><a class="markdownIt-Anchor" href="#一-if分支语句"></a> 一、if分支语句</h3><p>if语句的书写规范，跳转<a href="https://blog.csdn.net/qq_63100905/article/details/135834241?spm=1001.2014.3001.5502">【c语言入门学习】代码的书写规范</a></p><h3 id="二-switch分支语句"><a class="markdownIt-Anchor" href="#二-switch分支语句"></a> 二、switch分支语句</h3><p>switch中break的实际作用是把语句列表划分为不同的分支部分，不加break，会一直向下执行程序</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">int n = 1;</span><br><span class="line">int m = 2;</span><br><span class="line">switch (n)//switch执行一次条件判断，然后指定到对应的<span class="keyword">case</span>语句中</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> 1:</span><br><span class="line">m++;//n=1,m=3</span><br><span class="line"><span class="keyword">case</span> 2://此处也会执行，因为没有上句没有<span class="built_in">break</span>跳出, <span class="keyword">case</span>不需要判断条件,直接执行语句内容</span><br><span class="line">n++;//n=2,m=3</span><br><span class="line"><span class="keyword">case</span> 3://执行</span><br><span class="line">switch (n)</span><br><span class="line">{//switch允许嵌套使用</span><br><span class="line"><span class="keyword">case</span> 1:</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">case</span> 2:</span><br><span class="line">m++;</span><br><span class="line">n++;//m=4,n=3</span><br><span class="line"><span class="built_in">break</span>;//break跳出自己所在的switch语句</span><br><span class="line">}</span><br><span class="line"><span class="keyword">case</span> 4:</span><br><span class="line">m++;//m=5,n=3</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">default:</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"m = %d, n = %d\n"</span>, m, n);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="三-while循环语句"><a class="markdownIt-Anchor" href="#三-while循环语句"></a> 三、while循环语句</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">//在<span class="keyword">while</span>循环中，<span class="built_in">break</span>用于永久中止循环</span><br><span class="line">int i = 1;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= 10)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i == 5)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">//在<span class="keyword">while</span>循环中，<span class="built_in">continue</span>的作用是跳过本次循环,直接去判断部分，看是否进行下一次循环体</span><br><span class="line">int i = 1;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= 10)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i == 5)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">}//执行结果：<span class="built_in">continue</span>执行时会直接跳转到<span class="keyword">while</span>判断部分，而i=5保持不变，程序无限循环</span><br></pre></td></tr></tbody></table></figure><h3 id="do-while循环语句"><a class="markdownIt-Anchor" href="#do-while循环语句"></a> #do while循环语句</h3><p>先执行循环体，在执行循环判断</p><ul><li>do while较为少用</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">int i = 0;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hi\n"</span>);</span><br><span class="line">i++;</span><br><span class="line">} <span class="keyword">while</span> (i &lt; 5);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="三-for循环语句"><a class="markdownIt-Anchor" href="#三-for循环语句"></a> 三、for循环语句</h3><ul><li>for循环泛用性比while更好</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">int i = 0;//c语言风格<span class="keyword">for</span>语句之前需要定义变量,c++可以在<span class="keyword">for</span>循环内部定义</span><br><span class="line"><span class="keyword">for</span> (i = 1; i &lt;= 10; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i == 5)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">}//会执行i++，之后i=6</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);//结果跳过5</span><br><span class="line">}</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="for循环范例"><a class="markdownIt-Anchor" href="#for循环范例"></a> for循环范例：</h4><p><strong>for循环实现阶乘</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入n："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">{</span><br><span class="line">num = num * i;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()// <span class="keyword">for</span>循环 中最好不要在 循环体 内部 进行 变量再定义</span><br><span class="line">{</span><br><span class="line">int i = 0;</span><br><span class="line"><span class="keyword">for</span> (i = 0; i &lt; 10; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">i = 5;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>for循环实现1到10的阶乘和</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;<span class="comment">//1到10的阶乘</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//1到10的阶乘总和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">{</span><br><span class="line">num *= i;</span><br><span class="line">sum += num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d次和为:%d\n"</span>, i, sum);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//时间复杂度低，更高效的写法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"总的和为:%d\n"</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>for循环输出1到100中3的倍数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//写一个代码打印1-100之间所有3的倍数的数字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main008</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//判断i是否为3的倍数</span></span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="字符操作语句"><a class="markdownIt-Anchor" href="#字符操作语句"></a> #字符操作语句</h3><blockquote><p><strong>getchar</strong><br>作用：read/print “abcde” from stdin<br>可能的输出:<br>1.End of File reached<br>2.字符</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">//getchar() 获取一个字符</span><br><span class="line">//EOF end of file 文件结束的标识</span><br><span class="line">//putchar() 输出一个字符</span><br><span class="line">//int ch = getchar();</span><br><span class="line">//putchar(ch);</span><br><span class="line"></span><br><span class="line">int ch = 0;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line">{</span><br><span class="line">putchar(ch);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">//ctrl + z 读取到EOF结束</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">v</span><br><span class="line">v</span><br><span class="line">c</span><br><span class="line">c</span><br><span class="line">^Z</span><br><span class="line">D:\2_c++_项目\0_C_Project\01 分支和循环\Release\01 选择结构.exe (进程 39324)已退出，代码为 0。</span><br></pre></td></tr></tbody></table></figure><h4 id="范例密码程序"><a class="markdownIt-Anchor" href="#范例密码程序"></a> 范例：密码程序</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">char password[20] = { 0 };</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入密码："</span>);</span><br><span class="line">scanf(<span class="string">"%s"</span>, password);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请确认密码(Y/N)："</span>);</span><br><span class="line"></span><br><span class="line">//清除缓存区</span><br><span class="line">//getchar();//得到\n:回车</span><br><span class="line">//getchar();执行一次只能获取一个字符</span><br><span class="line"></span><br><span class="line">//清理缓冲区的多个字符</span><br><span class="line">int tmp = 0;</span><br><span class="line"><span class="keyword">while</span> ((tmp = getchar()) != <span class="string">'\n'</span>) //getchar函数得到的是字符，但是返回值是ASCII值等等，所以可以用整型变量获取</span><br><span class="line">{</span><br><span class="line">;//空操作</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int ch = getchar();</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'Y'</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"确认成功\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"确认失败\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>固定范围字符</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main07</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (ch &lt; <span class="string">'0'</span> || ch &gt;<span class="string">'9'</span>)<span class="comment">//这里为字符0和字符9</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="猜数字游戏"><a class="markdownIt-Anchor" href="#猜数字游戏"></a> 猜数字游戏</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个猜数字游戏</span></span><br><span class="line"><span class="comment">//1.自动产生一个1-100之间的数字</span></span><br><span class="line"><span class="comment">//2.猜数字</span></span><br><span class="line"><span class="comment">//a.猜对了，游戏结束</span></span><br><span class="line"><span class="comment">//b.猜错了，会告诉猜大了，还是猜小了，继续猜，直到猜对</span></span><br><span class="line"><span class="comment">//3.游戏可以一直玩，除非退出游戏</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">meun</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" ************************ \n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"******  猜数字游戏  ******\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****     1.开始      *****\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****     0.结束      *****\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" ************************ \n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Game</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//srand((unsigned int)time(NULL));//一个程序设置一次随机数种子函数就足够了，这里重复使用</span></span><br><span class="line"><span class="type">int</span> ret = rand() &amp; <span class="number">100</span> + <span class="number">1</span>;<span class="comment">//定义随机数，生成随机数的范围为0~32767,取模</span></span><br><span class="line"><span class="type">int</span> guess = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请猜数字："</span>);<span class="comment">//输入猜测的数字</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;guess);</span><br><span class="line"><span class="keyword">if</span> (guess &gt; ret)<span class="comment">//判断比较</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"猜大了\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (guess &lt; ret)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"猜小了\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" *         *\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"* *       * *\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"恭喜你猜对了！\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//退出循环</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));<span class="comment">//时间 - 时间戳</span></span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">meun();<span class="comment">//显示菜单</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请选择:&gt;"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (input)<span class="comment">//输入选择</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&lt;游戏开始&gt;\n"</span>);</span><br><span class="line">Game();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&lt;游戏结束&gt;\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&lt;输错了，请重新输入！&gt;\n"</span>);</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">while</span> (input); <span class="comment">//只要input不为0,程序继续执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="关机程序"><a class="markdownIt-Anchor" href="#关机程序"></a> 关机程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//关机</span></span><br><span class="line"><span class="comment">//c语言提供了一个函数:system() -执行系统命令的</span></span><br><span class="line"><span class="type">char</span> input[<span class="number">20</span>] = { <span class="number">0</span> }; <span class="comment">//存放输入的信息</span></span><br><span class="line">system(<span class="string">"shutdown -s -t 60"</span>);</span><br><span class="line">again:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请注意，你的电脑将在1分钟内关机，如果输入：我爱玩原神，就取消关机\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, input);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">"我爱玩原神"</span>) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">system(<span class="string">"shutdown -a"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二分值法"><a class="markdownIt-Anchor" href="#二分值法"></a> 二分值法</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个有序数组中查找具体的某个数字n。</span></span><br><span class="line"><span class="comment">//算法：二分值法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> };</span><br><span class="line"><span class="type">int</span> k = <span class="number">7</span>;<span class="comment">//要查找的数字</span></span><br><span class="line"><span class="comment">//在arr这个有序的数组中查找k对应的值</span></span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> mid = left + right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; k)</span><br><span class="line">{</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; k)</span><br><span class="line">{</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"要查找的值对应数组中的下标[%d]\n"</span>, mid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (left &gt; right)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组中没有待查找的值"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//当查找的范围在 6 ~ 7时，下标为5和6 ， 5+6/2 = 5 ，此时left +1 , mid = 6+6/2 =6 ，成功找到了7对应的下标</span></span><br></pre></td></tr></tbody></table></figure><h3 id="字符汇聚"><a class="markdownIt-Anchor" href="#字符汇聚"></a> 字符汇聚</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> arr1[] = <span class="string">"Welcome to bit!!!!!!"</span>;</span><br><span class="line"><span class="type">char</span> arr2[] = <span class="string">"####################"</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="built_in">strlen</span>(arr1) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;left &lt;= right; left++, right--)</span><br><span class="line">{</span><br><span class="line">arr2[left] = arr1[left];</span><br><span class="line">arr2[right] = arr1[right];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, arr2);</span><br><span class="line">Sleep(<span class="number">1000</span>);<span class="comment">//休眠一秒</span></span><br><span class="line">system(<span class="string">"cls"</span>);<span class="comment">//清空屏幕</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="密码验证程序"><a class="markdownIt-Anchor" href="#密码验证程序"></a> 密码验证程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span><span class="comment">//strlen strcmp</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> password[<span class="number">20</span>] = {<span class="number">0</span>};<span class="comment">//定义字符串 ， 假设密码为123456</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)<span class="comment">//限制三次循环</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入密码:&gt;"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, password);<span class="comment">//数组名本身就是地址</span></span><br><span class="line"><span class="comment">//if(password == "123456") //字符串不能用判断操作符</span></span><br><span class="line"><span class="comment">//if (strcmp(password, "123456")) //错误示例，if内要写条件“判断”，不然会直接执行！</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(password, <span class="string">"123456"</span>)) == <span class="number">0</span>)<span class="comment">//strcmp,依次比较ascii码值</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"密码正确\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"密码错误\n"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//printf("连续三次输入错误密码，程序退出..."); 直接写这一句，不正确，会导致输入正确密码后，跳出循环，也打印这句内容</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"连续三次输入错误密码，程序退出...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">1</span>, c = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = { a,b,c };</span><br><span class="line"><span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"原始数组为:"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 a,b,c的值不能直接改变arr中元素的值,实际上在初始定义arr时将a,b,c的值传入了arr而不是变量本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[j + <span class="number">1</span>])</span><br><span class="line">{</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"从高到低排序："</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>, arr[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="求最大公约数"><a class="markdownIt-Anchor" href="#求最大公约数"></a> 求最大公约数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);<span class="comment">//24 18</span></span><br><span class="line"><span class="comment">//如果两个数分别为24和18，最大公约数只能在18及以下</span></span><br><span class="line"><span class="type">int</span> min = <span class="number">0</span>;<span class="comment">//判断两个数谁更小</span></span><br><span class="line"><span class="keyword">if</span> (m &gt; n)</span><br><span class="line">{</span><br><span class="line">min = n;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m &lt; n)</span><br><span class="line">{</span><br><span class="line">min = m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">min = m;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="comment">//int maxgy = 0;//最大公约数</span></span><br><span class="line"><span class="comment">//for (i = 1; i &lt;= min; i++)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//if (m % i || n % i == 0)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//maxgy = i;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////方法二</span></span><br><span class="line"><span class="comment">//while (1)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//if (m % min == 0 &amp;&amp; n % min == 0)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//printf("最大公约数是：%d\n", min);</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//min--;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//辗转相除法</span></span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (t = m % n)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//t = m % n;</span></span><br><span class="line">m = n;</span><br><span class="line">n = t;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最大公约数是：%d\n"</span>, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="闰年判断程序"><a class="markdownIt-Anchor" href="#闰年判断程序"></a> 闰年判断程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断 1000~2000年 之间哪些年份是闰年</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> y, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">1000</span>; y &lt;= <span class="number">2000</span>; y++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> ((y % <span class="number">100</span> != <span class="number">0</span> &amp;&amp; y % <span class="number">4</span> == <span class="number">0</span>) || (y % <span class="number">400</span> == <span class="number">0</span>)) <span class="comment">//y % 100 == n  n不是非零即1 n是任意整数</span></span><br><span class="line"><span class="comment">//y % 100 == 0 &amp; y % 400 == 0</span></span><br><span class="line"><span class="comment">//y % 400 = 0 更简洁</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"闰年为：%d年\n"</span>, y);</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"闰年个数为：%d"</span>, count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="素数判断程序"><a class="markdownIt-Anchor" href="#素数判断程序"></a> 素数判断程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个代码, 打印100~200之间的素数</span></span><br><span class="line"><span class="comment">//素数-质数</span></span><br><span class="line"><span class="comment">//只能被1和他本身整除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码优化</span></span><br><span class="line"><span class="comment">//执行次数更少</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">100</span>; i &lt;= <span class="number">200</span>; i++)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; i; j++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (j == i)<span class="comment">//如果i是素数,j会一直自加一直到等于i</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d为素数\n"</span>, i);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个代码,打印100~200之间的素数</span></span><br><span class="line"><span class="comment">//素数-质数</span></span><br><span class="line"><span class="comment">//只能被1和他本身整除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码优化1：</span></span><br><span class="line"><span class="comment">//m=a*b;</span></span><br><span class="line"><span class="comment">//a和b中一定至少有一个数字是 &lt;=开平方m的</span></span><br><span class="line"><span class="comment">//16 = 2*8 = 4*4</span></span><br><span class="line"><span class="comment">//所以，大于开平方m的就不需要判断是否为m的因子，减少循环执行次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sqrt用于计算开平方的函数 -需要用到库函数 math.h</span></span><br><span class="line"><span class="comment">//减少了循环的执行次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码优化2：</span></span><br><span class="line"><span class="comment">//偶数不可能是素数</span></span><br><span class="line"><span class="comment">//修改for (i = 100; i &lt;= 200; i ++)为for (i = 101; i &lt;= 200; i += 2)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断i是不是质数</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">101</span>; i &lt;= <span class="number">200</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//定义一个参数，检测i是否能被 除了1和它本身的数 整除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= <span class="built_in">sqrt</span>(i); j++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">flag = <span class="number">0</span>;<span class="comment">//如果能被2到i-1之间的整除，记录flag=0;</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)<span class="comment">//不能被2到i-1之间的数整除</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d是质数\n"</span>, i);<span class="comment">//那么i就是质数</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【5G】[1]基本术语-1</title>
      <link href="/posts/29791/"/>
      <url>/posts/29791/</url>
      
        <content type="html"><![CDATA[<h1 id="5g基本概念"><a class="markdownIt-Anchor" href="#5g基本概念"></a> 5G基本概念</h1><ul><li>接入网：所谓<mark>接入网是指骨干网络到用户终端之间的所有设备</mark>。其长度一般为几百米到几公里，因而被形象地称为"最后一公里"。由于骨干网一般采用光纤结构，传输速度快，因此，接入网便成为了整个网络系统的瓶颈。接入网的接入方式包括铜线（普通电话线）接入、光纤接入、光纤同轴电缆（有线电视电缆）混合接入和无线接入等几种方式。</li></ul><blockquote><p><strong>信道：信道就是信息传递的通道，是将信号进行传输、存储和处理的媒介</strong><br><strong>信令：信令就是通信两端，有一端在进行状态转移的时候，要发送信息（信令）来通知另外一端做状态同步，然后顺便捎带一些配置信息和控制信息等。所以通信信令的设计本质就是状态机设计，信令主要是用来通信连接的两侧做状态同步使用。</strong></p></blockquote><hr><blockquote><p><strong>接口：</strong><br><strong>1. 接口（硬件类接口）是指同一计算机不同功能层之间的通信规则称为接口。</strong><br><strong>2. 接口（软件类接口）是指对协定进行定义的引用类型。其他类型实现接口，以保证它们支持某些操作。接口指定必须由类提供的成员或实现它的其他接口。与类相似，接口可以包含方法、属性、索引器和事件作为成员。</strong></p></blockquote><ul><li>协议栈：<a href="https://blog.csdn.net/Hello_MyDream/article/details/85096070">什么是协议栈</a><br>协议栈是指网络中各层协议的总和，其形象的反映了一个网络中文件传输的过程，由上层协议到底层协议，再由底层协议到上层协议。</li></ul><p>场景与技术需求：</p><ol><li>MMTC（大规模链接）：物联网、远程抄表、路灯</li><li>EM88（大带宽）：4K、8K视频、VR、AR</li><li>URLLC（低延时、超可靠）：车联网、远程医疗</li></ol><p>组网部署的特点：</p><ul><li>NSA:非独立组网，4G和5G并存</li><li>SA:独立组网（支持URLLC）</li></ul><p>5G接入网：口空、无线基站部分<br>网元：功能模块</p><ul><li>UDM</li><li>AUSF</li><li>UPF<br>5G协议栈和协议栈的接口：网元之间的接口<br>5G系统参数：测量参数、寻呼</li></ul><p>PS：频率高、波长短</p><p>2G:救援通信</p><p>5G物理信道和信号：</p><p>6G移动通信：</p><ol><li>发展背景</li><li>性能指标</li><li>发展趋势、关键技术</li><li>基本概念</li><li>网络安全</li></ol><p>IPV4：<br>IPV6：</p><p>白皮书：</p><p>5G+垂直行业应用：</p><ol><li>车联网</li></ol><ul><li>DSRC、IEEE</li><li>C-V2X、3GPP</li></ul><ol start="2"><li>人工智能</li><li>物联网</li><li>边缘计算</li><li>元宇宙</li><li>区块链</li></ol><h1 id="5g网络架构基本概念名词解释"><a class="markdownIt-Anchor" href="#5g网络架构基本概念名词解释"></a> 5G网络架构基本概念（名词解释）</h1><p>5GC：5G核心网，中枢系统；处理+分配承载网的数据（路由交换）</p><p>NG-RAN：接入网，收集终端数据</p><p>UE：终端</p><p>网元是一个独立的功能实体</p><p>eNB：4G基站</p><p>ng-eNB; 增强型4G基站，连接5G核心网</p><p>gNB：5G基站</p><p>en-gNB:与4G核心网连接的5G基站</p><p>AMF: 接入性移动管理</p><p>SMF：会话管理功能</p><p>UDM：统一数据管理</p><p>AUSF:  认证服务器功能</p><p>UPF:  用户面功能</p><p>PCF：策略控制功能</p><p>NRF：网络储存功能</p><p>NEF：网络开放功能</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 大唐杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大唐杯 </tag>
            
            <tag> 5G </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【51单片机】DS18B20</title>
      <link href="/posts/18830/"/>
      <url>/posts/18830/</url>
      
        <content type="html"><![CDATA[<p>2024.1.29更新</p><p>2024.3.2</p><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><blockquote><p>所用外设：</p></blockquote><blockquote><p><mark>DS18B20温度传感器（OneWire协议）</mark></p></blockquote><h2 id="前置概念"><a class="markdownIt-Anchor" href="#前置概念"></a> #前置概念</h2><h3 id="一-onewire单总线协议"><a class="markdownIt-Anchor" href="#一-onewire单总线协议"></a> 一、OneWire（单总线）协议</h3><p>•单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线</p><p>•一根通信线：DQ</p><p>•异步、半双工</p><p>•单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线</p><h3 id="二-单总线电路规范"><a class="markdownIt-Anchor" href="#二-单总线电路规范"></a> 二、单总线电路规范</h3><p>•设备的DQ均要配置成开漏输出模式</p><p>•DQ添加一个上拉电阻，阻值一般为4.7KΩ左右</p><p>•若此总线的从机采取寄生供电，则主机还应配一个强上拉输出电路</p><img src="/posts/18830/image-20240302232447437.png" class="" title="image-20240302232447437"><h3 id="三-单总线的时序结构"><a class="markdownIt-Anchor" href="#三-单总线的时序结构"></a> 三、单总线的时序结构</h3><img src="/posts/18830/image-20240302232633388.png" class="" title="image-20240302232633388"><img src="/posts/18830/image-20240302232648244.png" class="" title="image-20240302232648244"><img src="/posts/18830/image-20240302232700200.png" class="" title="image-20240302232700200"><img src="/posts/18830/image-20240302232708528.png" class="" title="image-20240302232708528"><hr><h2 id="ds18b20介绍"><a class="markdownIt-Anchor" href="#ds18b20介绍"></a> DS18B20介绍</h2><p>•DS18B20是一种常见的数字温度传感器，其控制命令和数据都是以数字信号的方式输入输出，相比较于模拟温度传感器，具有功能强大、硬件简单、易扩展、抗干扰性强等特点</p><p>•测温范围：-55°C 到 +125°C</p><p>•通信接口：1-Wire（单总线）</p><p>•其它特征：可形成总线结构、内置温度报警功能、可寄生供电</p><h3 id="一-ds18b20温度存储格式"><a class="markdownIt-Anchor" href="#一-ds18b20温度存储格式"></a> 一、DS18B20温度存储格式</h3><img src="/posts/18830/1c9c55dd044b4cdb9e2c305088ccec28.png" class="" title="在这里插入图片描述"><blockquote><p><strong>MS BYTE和LS BYTE两个字节中BIT的解释：<br>BIT16~BIT11作为符号位，表示温度的正负<br>BIT10~BIT4存储温度的整数部分<br>BIT3~BIT0存储温度的小数部分（<mark>精度</mark>），BIT0 ‘1’对应 "0.0625"</strong></p></blockquote><h3 id="二-ds18b20时序"><a class="markdownIt-Anchor" href="#二-ds18b20时序"></a> 二、DS18B20时序</h3><img src="/posts/18830/image-20240302232951493.png" class="" title="image-20240302232951493"><img src="/posts/18830/image-20240302232958679.png" class="" title="image-20240302232958679"><h3 id="三-程序编写"><a class="markdownIt-Anchor" href="#三-程序编写"></a> 三、程序编写</h3><p>首先写第一个函数，用于初始化，其中添加Askbit，在LCD1602上显示一个数值，观察初始化函数是否有效，即从机是否响应。</p><p>首先编写好单总线的初始化程序，如果代码正确，根据单总线的通信协议，从机会发送一个应答信号（拉低总线）。<br>进行应答测试，通过LCD1602观察应答位，检测代码是否有效</p><h2 id="-code0-"><a class="markdownIt-Anchor" href="#-code0-"></a> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">sbit OneWire_DQ=P3^7;//通信口</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_Init(void)</span><br><span class="line">{</span><br><span class="line">unsigned char i,Askbit;</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 227;<span class="keyword">while</span> (--i);//500um</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">i = 29;<span class="keyword">while</span> (--i);//70um</span><br><span class="line">Askbit = OneWire_DQ;</span><br><span class="line"><span class="built_in">return</span> Askbit;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></h2><h2 id="一-ds18b20温度读取"><a class="markdownIt-Anchor" href="#一-ds18b20温度读取"></a> 一、DS18B20温度读取</h2><p>将程序下载到单片机上，运行<br>如下为main.c文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "DS18B20.h"</span></span><br><span class="line"><span class="comment">#include "OneWire.h"</span></span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(1,1,<span class="string">"Temperture:"</span>);</span><br><span class="line">DS18B20_Start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line">unsigned int temp=DS18B20_Read()*10000;</span><br><span class="line"><span class="keyword">if</span>(temp&gt;0)</span><br><span class="line">{</span><br><span class="line">LCD_ShowString(2,1,<span class="string">"+"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(temp&lt;0)</span><br><span class="line">{</span><br><span class="line">LCD_ShowString(2,1,<span class="string">"-"</span>);</span><br><span class="line">}</span><br><span class="line">LCD_ShowNum(2,2,temp/10000,4);</span><br><span class="line">LCD_ShowNum(2,6,temp%10000,4);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>结果异常：LCD1602第二行显示不正确数据/显示-000.0625<br>分析：<br>main.c中存在语法错误<br>OneWire.c DS18B20.c中的函数时序定义有误</p><img src="/posts/18830/d0595a62616c4d33a0f28a153c487761.jpeg" class="" title="请添加图片描述"></blockquote><p>对main.c进行更改</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Delay.h"</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "DS18B20.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> T;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">DS18B20_Convert();</span><br><span class="line">Delay(1000);</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(1,1,<span class="string">"Temperature:"</span>);</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line">DS18B20_Convert();</span><br><span class="line">T=DS18B20_Read();</span><br><span class="line"><span class="keyword">if</span>(T&lt;0)</span><br><span class="line">{</span><br><span class="line">LCD_ShowChar(2,1,<span class="string">'-'</span>);</span><br><span class="line">T=-T;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LCD_ShowChar(2,1,<span class="string">'+'</span>);</span><br><span class="line">}</span><br><span class="line">LCD_ShowNum(2,2,T,3);</span><br><span class="line">LCD_ShowChar(2,5,<span class="string">'.'</span>);</span><br><span class="line">LCD_ShowNum(2,6,(unsigned long)(T*10000)%10000,4);//强制类型转换</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>OneWire.c 错误分析：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">sbit OneWire_DQ=P3^7;//通信口</span><br><span class="line"></span><br><span class="line">void OneWire_Init(void)</span><br><span class="line">{</span><br><span class="line">unsigned char i,AskBit;</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 227;<span class="keyword">while</span> (--i);//500um</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 29;<span class="keyword">while</span> (--i);//70um</span><br><span class="line">AskBit=OneWire_DQ;//主机判断从机是否发送应答</span><br><span class="line">i = 227;<span class="keyword">while</span> (--i);//500um,要根据时序图构造代码</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_SendBit(unsigned char Bit)//发送一位</span><br><span class="line">{</span><br><span class="line">unsigned char i;</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">i = 2;<span class="keyword">while</span> (--i);//10um</span><br><span class="line">OneWire_DQ=Bit;</span><br><span class="line">i = 22;<span class="keyword">while</span> (--i);//54um</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_ReadBit(void)//接收一位</span><br><span class="line">{</span><br><span class="line">unsigned char i,Bit;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 2;<span class="keyword">while</span> (--i);//10um</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 2;<span class="keyword">while</span> (--i);//10um</span><br><span class="line">Bit=OneWire_DQ;</span><br><span class="line">i = 22;<span class="keyword">while</span> (--i);//54um</span><br><span class="line"><span class="built_in">return</span> Bit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_WriteByte(int Byte)</span><br><span class="line">{</span><br><span class="line">unsigned int i;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line">OneWire_SendBit(Byte&amp;(0x01&lt;&lt;<span class="string">i));//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unsigned char OneWire_ReadByte()</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">unsigned int i</span>;</span><br><span class="line">unsigned int Byte;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line">Byte=OneWire_ReadBit()|(0x01&lt;&lt;<span class="string">i);//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">return Byte;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure><p><mark>对OneWire.c进行更改</mark></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">sbit OneWire_DQ=P3^7;//通信口</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_Init(void)</span><br><span class="line">{</span><br><span class="line">unsigned char i,AskBit;</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 247;<span class="keyword">while</span> (--i);//500us</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 29;<span class="keyword">while</span> (--i);//70us</span><br><span class="line">AskBit=OneWire_DQ;//主机判断从机是否发送应答</span><br><span class="line">i = 247;<span class="keyword">while</span> (--i);//500um,要根据时序图构造代码</span><br><span class="line"><span class="built_in">return</span> AskBit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_SendBit(unsigned char Bit)//发送一位</span><br><span class="line">{</span><br><span class="line">unsigned char i;</span><br><span class="line">OneWire_DQ=0;//错误，应为0</span><br><span class="line">i = 2;<span class="keyword">while</span> (--i);//10us</span><br><span class="line">OneWire_DQ=Bit;</span><br><span class="line">i = 20;<span class="keyword">while</span> (--i);//50us</span><br><span class="line">OneWire_DQ=1;//遗漏</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_ReadBit(void)//接收一位</span><br><span class="line">{</span><br><span class="line">unsigned char i,Bit;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 1;<span class="keyword">while</span> (--i);//8us</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 1;<span class="keyword">while</span> (--i);//8us</span><br><span class="line">Bit=OneWire_DQ;</span><br><span class="line">i = 20;<span class="keyword">while</span> (--i);//50us</span><br><span class="line"><span class="built_in">return</span> Bit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_WriteByte(unsigned char Byte)</span><br><span class="line">{</span><br><span class="line">unsigned char i;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line">OneWire_SendBit(Byte&amp;(0x01&lt;&lt;<span class="string">i));//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unsigned char OneWire_ReadByte(void)</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">unsigned char i</span>;</span><br><span class="line">unsigned char Byte=0x00;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(OneWire_ReadBit()){Byte|=(0x01&lt;&lt;<span class="string">i);}//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">return Byte;</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>结论：OneWire_SendBit函数对总线的电平处理不正确</strong><br>void OneWire_SendBit(unsigned char Bit)//发送一位<br>{<br>unsigned char i;<br>OneWire_DQ=1;//<mark>此处错误，应为0</mark><br>i = 2;while (–i);//10us<br>OneWire_DQ=Bit;<br>i = 20;while (–i);//50us<br>OneWire_DQ=1;//遗漏<br>}</p><h2 id="二-ds18b20温度报警器"><a class="markdownIt-Anchor" href="#二-ds18b20温度报警器"></a> 二、DS18B20温度报警器</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include "Delay.h"</span></span><br><span class="line"><span class="comment">#include "LCD1602.h"</span></span><br><span class="line"><span class="comment">#include "DS18B20.h"</span></span><br><span class="line"><span class="comment">#include "AT24C02.h"</span></span><br><span class="line"><span class="comment">#include "I2C.h"</span></span><br><span class="line"><span class="comment">#include "Key.h"</span></span><br><span class="line"><span class="comment">#include "Timer0.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//mark</span><br><span class="line">//在编写单片机程序时，要考虑到运行的高效性，定义变量的数据类型，优先选择较低内存占用的类型</span><br><span class="line"><span class="built_in">float</span> T;</span><br><span class="line"><span class="built_in">float</span> Tshow;</span><br><span class="line">char Thigh,Tlow;</span><br><span class="line">unsigned char KeyNum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">{</span><br><span class="line">Thigh=AT24C02_ReadByte(0);//每次开机，读取存储器中的数据</span><br><span class="line">Tlow=AT24C02_ReadByte(1);</span><br><span class="line"></span><br><span class="line">DS18B20_Convert();//温度装载，防止T第一次读取到的是默认值20，消除多余现象</span><br><span class="line">Delay(1000);</span><br><span class="line"></span><br><span class="line">LCD_Init();</span><br><span class="line">Timer0_Init();</span><br><span class="line">LCD_ShowString(1,1,<span class="string">"T:"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">{</span><br><span class="line">DS18B20_Convert();//温度装载</span><br><span class="line">T=DS18B20_Read();</span><br><span class="line"><span class="keyword">if</span>(T&lt;0)</span><br><span class="line">{</span><br><span class="line">LCD_ShowChar(1,3,<span class="string">'-'</span>);</span><br><span class="line">//T=-T,这里T=-T的话，进行温度预置判断有问题，所以再定义一个变量Tshow</span><br><span class="line">Tshow=-T;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LCD_ShowChar(1,3,<span class="string">'+'</span>);</span><br><span class="line">Tshow=T;</span><br><span class="line">}</span><br><span class="line">LCD_ShowNum(1,4,Tshow,3);</span><br><span class="line">LCD_ShowChar(1,7,<span class="string">'.'</span>);</span><br><span class="line">LCD_ShowNum(1,8,(unsigned char)(Tshow*100)%100,2);</span><br><span class="line"></span><br><span class="line">//温度阈值控制</span><br><span class="line">KeyNum=Key();</span><br><span class="line"><span class="keyword">if</span>(KeyNum)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(KeyNum==1)</span><br><span class="line">{</span><br><span class="line">Thigh++;</span><br><span class="line"><span class="keyword">if</span>(Thigh&gt;125)</span><br><span class="line">{</span><br><span class="line">Thigh--;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KeyNum==2)</span><br><span class="line">{</span><br><span class="line">Thigh--;</span><br><span class="line"><span class="keyword">if</span>(Thigh&lt;=Tlow)</span><br><span class="line">{</span><br><span class="line">Thigh++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KeyNum==3)</span><br><span class="line">{</span><br><span class="line">Tlow++;</span><br><span class="line"><span class="keyword">if</span>(Tlow&gt;=Thigh)</span><br><span class="line">{</span><br><span class="line">Tlow--;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KeyNum==4)</span><br><span class="line">{</span><br><span class="line">Tlow--;</span><br><span class="line"><span class="keyword">if</span>(Tlow&lt;-125)</span><br><span class="line">{</span><br><span class="line">Tlow++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">AT24C02_WriteByte(0,Thigh);</span><br><span class="line">Delay(5);</span><br><span class="line">AT24C02_WriteByte(1,Tlow);</span><br><span class="line">Delay(5);</span><br><span class="line">}</span><br><span class="line">//Thigh=AT24C02_ReadByte(1);</span><br><span class="line">    //Tlow=AT24C02_ReadByte(2);错误写法，会导致出现短暂的Thigh或者Tlow被赋值0,AT24C02没来得及读取数据就赋值给变量</span><br><span class="line">LCD_ShowString(2,1,<span class="string">"TH:"</span>);</span><br><span class="line">LCD_ShowString(2,10,<span class="string">"TL:"</span>);</span><br><span class="line">LCD_ShowSignedNum(2,4,Thigh,3);//显示带符号的数字</span><br><span class="line">LCD_ShowSignedNum(2,13,Tlow,3);</span><br><span class="line"></span><br><span class="line">//温度报警，LCD1602显示</span><br><span class="line"><span class="keyword">if</span>(T&gt;Thigh)</span><br><span class="line">{</span><br><span class="line">LCD_ShowString(1,13,<span class="string">"OV:H"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T&lt;Tlow)</span><br><span class="line">{</span><br><span class="line">LCD_ShowString(1,13,<span class="string">"OV:L"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LCD_ShowString(1,13,<span class="string">"    "</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Timer0_Routine() interrupt 1 //中断子程序</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">static unsigned int T0Count1;//静态局部变量，保证退出函数之后不销毁</span><br><span class="line">TL0 = 0x66;//设置定时初始值</span><br><span class="line">TH0 = 0xFC;//设置定时初始值</span><br><span class="line">T0Count1++;//每次进入中断子程序，秒控制器自加一</span><br><span class="line"><span class="keyword">if</span>(T0Count1&gt;=20)</span><br><span class="line">{</span><br><span class="line">T0Count1=0;</span><br><span class="line">Key_Loop();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>实验现象1：加入定时器扫描按键后，按下按键不影响温度的读取和显示，但是LCD1602上显示的温度数值会出现闪烁的状态<br>分析：每隔20ms进入中断程序，对按键进行扫描检测，但是，单总线上对数据的发送和接受，部分过程时间在几十us，远远小于20ms,中断程序打断了温度的正常读取<br>解决方案：每个OneWire的读写操作加入定时器的关闭动作，这样不会对OneWire的读写操作产生影响</strong><br><mark>如下:</mark></p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"></span><br><span class="line">sbit OneWire_DQ=P3^7;//通信口</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_Init(void)</span><br><span class="line">{</span><br><span class="line">unsigned char i,AskBit;</span><br><span class="line">EA=0;</span><br><span class="line">OneWire_DQ=1;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 247;<span class="keyword">while</span> (--i);//500us</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 29;<span class="keyword">while</span> (--i);//70us</span><br><span class="line">AskBit=OneWire_DQ;//主机判断从机是否发送应答</span><br><span class="line">i = 247;<span class="keyword">while</span> (--i);//500um,要根据时序图构造代码</span><br><span class="line">EA=1;</span><br><span class="line"><span class="built_in">return</span> AskBit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_SendBit(unsigned char Bit)//发送一位</span><br><span class="line">{</span><br><span class="line">unsigned char i;</span><br><span class="line">EA=0;</span><br><span class="line">OneWire_DQ=0;//错误，应为0</span><br><span class="line">i = 2;<span class="keyword">while</span> (--i);//10us</span><br><span class="line">OneWire_DQ=Bit;</span><br><span class="line">i = 20;<span class="keyword">while</span> (--i);//50us</span><br><span class="line">OneWire_DQ=1;//遗漏</span><br><span class="line">EA=1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">unsigned char OneWire_ReadBit(void)//接收一位</span><br><span class="line">{</span><br><span class="line">unsigned char i,Bit;</span><br><span class="line">EA=0;</span><br><span class="line">OneWire_DQ=0;</span><br><span class="line">i = 1;<span class="keyword">while</span> (--i);//8us</span><br><span class="line">OneWire_DQ=1;//释放总线</span><br><span class="line">i = 1;<span class="keyword">while</span> (--i);//8us</span><br><span class="line">Bit=OneWire_DQ;</span><br><span class="line">i = 20;<span class="keyword">while</span> (--i);//50us</span><br><span class="line">EA=1;</span><br><span class="line"><span class="built_in">return</span> Bit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void OneWire_WriteByte(unsigned char Byte)</span><br><span class="line">{</span><br><span class="line">unsigned char i;</span><br><span class="line">EA=0;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line">OneWire_SendBit(Byte&amp;(0x01&lt;&lt;<span class="string">i));//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">EA=1;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unsigned char OneWire_ReadByte(void)</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">unsigned char i</span>;</span><br><span class="line">unsigned char Byte=0x00;</span><br><span class="line">EA=0;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(OneWire_ReadBit()){Byte|=(0x01&lt;&lt;<span class="string">i);}//低位在前</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">EA=1;</span></span><br><span class="line"><span class="string">return Byte;</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p><mark>缺点：对定时器有较大影响，需要区分任务的优先级，这里我们只有对温度进行处理的任务，一但存在多个任务，比如这里同时在数码管上显示一个时钟，使用单总线的局限性会非常大</mark><br><mark>IIC通信方式一般比单总线广泛地多</mark><br><mark>思考：IIC和单总线地区别</mark></p><hr><h1 id="蓝桥杯stc15拓展"><a class="markdownIt-Anchor" href="#蓝桥杯stc15拓展"></a> 蓝桥杯(STC15)拓展</h1><p><strong>OneWire底层</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*# 单总线代码片段说明</span></span><br><span class="line"><span class="comment">1. 本文件夹中提供的驱动代码供参赛选手完成程序设计参考。</span></span><br><span class="line"><span class="comment">2. 参赛选手可以自行编写相关代码或以该代码为基础，根据所选单片机类型、运行速度和试题</span></span><br><span class="line"><span class="comment">中对单片机时钟频率的要求，进行代码调试和修改。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;onewire.h&gt;</span></span></span><br><span class="line">sbit DQ= P1^<span class="number">4</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_OneWire</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>  </span><br><span class="line">{</span><br><span class="line">t *= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_DS18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">DQ = dat&amp;<span class="number">0x01</span>;</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_DS18B20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(DQ)</span><br><span class="line">{</span><br><span class="line">dat |= <span class="number">0x80</span>;</span><br><span class="line">}    </span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">bit <span class="title function_">init_ds18b20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  bit initflag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">12</span>);</span><br><span class="line">  DQ = <span class="number">0</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">80</span>);</span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">10</span>); </span><br><span class="line">    initflag = DQ;     </span><br><span class="line">  Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> initflag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基于底层编写*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">ds18b20_read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> low,high;<span class="comment">//高八位，低八位，DS18B20温度数据是十六位二进制</span></span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0x44</span>);<span class="comment">//ds18b20开始温度转换</span></span><br><span class="line">    </span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0xbe</span>);<span class="comment">//ds18b20开始温度读取</span></span><br><span class="line">low=Read_DS18B20();</span><br><span class="line">high=Read_DS18B20();</span><br><span class="line"><span class="keyword">return</span>((high &lt;&lt; <span class="number">8</span> )| low) /<span class="number">16.0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="主模块ds18b20模拟题"><a class="markdownIt-Anchor" href="#主模块ds18b20模拟题"></a> 主模块(DS18B20模拟题)</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;onewire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Disp_Mode;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Tempture=<span class="number">0</span>;<span class="comment">//实时温度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Tempture_Disp=<span class="number">25</span>;<span class="comment">//温度暂存设置参数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Tempture_Control=<span class="number">25</span>;<span class="comment">//温度阈值参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> DAC_Output=<span class="number">3.25</span>;<span class="comment">//DAC输出电压</span></span><br><span class="line">bit DAC_Output_MODE;<span class="comment">//DAC输出模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();<span class="comment">//读取键值</span></span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//读取上升沿键值</span></span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//读取下降沿键值</span></span><br><span class="line">Key_Old=Key_Val;<span class="comment">//保存键值（旧键值）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Key_Down) </span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span>(Nixie_Disp_Mode==<span class="number">0</span>){Tempture_Disp=Tempture_Control;}<span class="comment">//上一个界面为实时温度显示界面时</span></span><br><span class="line"><span class="keyword">if</span>(Nixie_Disp_Mode==<span class="number">1</span>){Tempture_Control=Tempture_Disp;}<span class="comment">//上一个界面为温度阈值设置显示界面时</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Disp_Mode==<span class="number">3</span>){Nixie_Disp_Mode=<span class="number">0</span>;}<span class="comment">//模式切换 0~模式1 1~模式2</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">DAC_Output_MODE^=<span class="number">1</span>;<span class="comment">//DAC输出模式切换</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="keyword">if</span>(Nixie_Disp_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Tempture_Disp==<span class="number">100</span>){Tempture_Disp=<span class="number">0</span>;}<span class="comment">//前置+1,判断条件刚好为溢出值</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="keyword">if</span>(Nixie_Disp_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--Tempture_Disp==<span class="number">255</span>){Tempture_Disp=<span class="number">99</span>;}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信息处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line">Tempture=ds18b20_read();<span class="comment">//实时温度读取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Nixie_Disp_Mode)<span class="comment">//数码管多模式显示</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">13</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)Tempture/<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)Tempture%<span class="number">10</span>;</span><br><span class="line">Nixie_Point[<span class="number">5</span>]=<span class="number">1</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=(<span class="type">unsigned</span> <span class="type">int</span>)(Tempture*<span class="number">10</span>)%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=(<span class="type">unsigned</span> <span class="type">int</span>)(Tempture*<span class="number">100</span>)%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Point[<span class="number">5</span>]=<span class="number">0</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=Tempture_Disp/<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=Tempture_Disp%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">11</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)DAC_Output;</span><br><span class="line">Nixie_Point[<span class="number">5</span>]=<span class="number">1</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)(DAC_Output*<span class="number">10</span>)%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=(<span class="type">unsigned</span> <span class="type">int</span>)(DAC_Output*<span class="number">100</span>)%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他显示函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="comment">/*实时输出DAC电压*/</span></span><br><span class="line">DA_Write((<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">51</span>*DAC_Output));<span class="comment">//DAC输出</span></span><br><span class="line"><span class="keyword">if</span>(DAC_Output_MODE==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Tempture&lt;Tempture_Control)</span><br><span class="line">{</span><br><span class="line">DAC_Output=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">DAC_Output=<span class="number">5.0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Tempture&lt;<span class="number">20</span>)</span><br><span class="line">{</span><br><span class="line">DAC_Output=<span class="number">1.0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Tempture&gt;<span class="number">40</span>)</span><br><span class="line">{</span><br><span class="line">DAC_Output=<span class="number">4.0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">DAC_Output=<span class="number">0.15</span>*(Tempture<span class="number">-20</span>)+<span class="number">1.0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">ucLED[<span class="number">0</span>]=~DAC_Output_MODE;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">{</span><br><span class="line">ucLED[i+<span class="number">1</span>]= (i==Nixie_Disp_Mode);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay750ms</span><span class="params">()</span> <span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j, k;</span><br><span class="line">i = <span class="number">35</span>;</span><br><span class="line">j = <span class="number">51</span>;</span><br><span class="line">k = <span class="number">182</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (--k)</span><br><span class="line">;</span><br><span class="line">} <span class="keyword">while</span> (--j);</span><br><span class="line">} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Tempture=ds18b20_read();<span class="comment">//ds18b20第一次默认读取的是85</span></span><br><span class="line">Delay750ms();</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行任务</span></span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line">Nixie_Proc();</span><br><span class="line">LED_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">300</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//300ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">10</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//10ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED循环“值”检测，发生变化则对LED相关IO发生电平变化</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数字电路】课程设计</title>
      <link href="/posts/24146/"/>
      <url>/posts/24146/</url>
      
        <content type="html"><![CDATA[<h2 id="设计题目-智能消防系统"><a class="markdownIt-Anchor" href="#设计题目-智能消防系统"></a> 设计题目： 智能消防系统</h2><p><strong>题目来源： 2023 年全国大学生电子设计竞赛试题试题 G 题</strong></p><h3 id="一-任务"><a class="markdownIt-Anchor" href="#一-任务"></a> 一、 任务：</h3><ul><li>设计一套智能消防系统， 采用 FPGA 实验板。 防区区域为 40dm× 48dm，</li><li>可能出现的火源如图所示的 1、 2、 3、 4。 当消防车接收到火源地点位置信息即刻前往熄灭火源， 消防工作完成时间越短越好。 其中白色部分是街区， 消防车不得驶入， 红色区域是消防车停车点。<img src="/posts/24146/dac9932d16494eaf88b83d8983639dfd-17086935318804.png" class="" title="在这里插入图片描述"></li></ul><h3 id="二-要求"><a class="markdownIt-Anchor" href="#二-要求"></a> 二、 要求：</h3><ul><li>消防车起始停留在红色区域， 接收到火情信息并显示火源地点位置坐标后，</li><li>出发前往火源地点， 途中不得碾压街区及其边界线。 消防车距离火源地点 5dm内停车， 发出声光报警， 持续 5 秒， 表示将模拟火源熄灭， 之后消防车返回红色区域。 从消防车出发到返回红色区域， 用时越短越好</li></ul><h3 id="三-硬件部分"><a class="markdownIt-Anchor" href="#三-硬件部分"></a> 三、硬件部分</h3><ul><li>主要结构：4驱直流电机小车</li><li>主控：FPGA</li><li>传感器：1.四路循迹模块（避线）   2.红外计数器（测速/里程计算）</li><li>代码主要语法：状态机</li></ul><h3 id="四-解题四路"><a class="markdownIt-Anchor" href="#四-解题四路"></a> 四、解题四路</h3><h4 id="一-调试小车基本运动模式"><a class="markdownIt-Anchor" href="#一-调试小车基本运动模式"></a> 一、调试小车基本运动模式</h4><img src="/posts/24146/e8fb6a097cd9432cb9c084fee621ae42-17086935318806.png" class="" title="在这里插入图片描述"><h3 id="什么是分频器"><a class="markdownIt-Anchor" href="#什么是分频器"></a> 什么是分频器？</h3><p><strong>分频器原理</strong></p><ul><li>通过检测输入时钟信号下降沿（上升沿），或者说采样的方法，控制输出的时钟信号频率。</li></ul><p><strong>如将50MHZ的时钟信号12分频：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process(clk,q1)</span><br><span class="line">begin</span><br><span class="line">if clk'event and clk='1' then</span><br><span class="line">if q1&lt;=2 then CLKFMQ&lt;='1';q1&lt;=q1+1;</span><br><span class="line">--改变q1&lt;=2参数可变更占空比</span><br><span class="line"> elsif q1=11 then CLKFMQ&lt;='0';q1&lt;=0;</span><br><span class="line"> --改变q1=11参数可以变更CLKFMQ的频率</span><br><span class="line"> else CLKFMQ&lt;='0';q1&lt;=q1+1;</span><br><span class="line">end if;</span><br><span class="line">end if;</span><br><span class="line">end process ;</span><br></pre></td></tr></tbody></table></figure><p><strong>分频器模块</strong></p><ul><li>用于产生各种所需频率的方波信号</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------</span><br><span class="line">LIBRARY IEEE;</span><br><span class="line">USE IEEE.STD_LOGIC_1164.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_ARITH.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_UNSIGNED.ALL;</span><br><span class="line">--------------------------------------</span><br><span class="line">ENTITY   CLK_mode is--分频器模块                              </span><br><span class="line">PORT(clk:in std_logic; --系统晶振源 50MHZ              </span><br><span class="line">      CLK1hz,clk01s,CLKFMQ,clk1ms:out std_logic--1hz,1000hz,蜂鸣器频率</span><br><span class="line">);</span><br><span class="line">END CLK_mode   ;                                           </span><br><span class="line">--------------------------------------</span><br><span class="line">ARCHITECTURE abc OF CLK_mode   IS  </span><br><span class="line">signal q1:integer range 0 to 24999; --中间信号</span><br><span class="line">signal q2:integer range 0 to 4999999;</span><br><span class="line">signal q3:integer range 0 to 49999;</span><br><span class="line">BEGIN</span><br><span class="line">--蜂鸣器频率--</span><br><span class="line">process(clk,q1)</span><br><span class="line">begin</span><br><span class="line">if clk'event and clk='1' then</span><br><span class="line">if q1&lt;=12999 then CLKFMQ&lt;='1';q1&lt;=q1+1;</span><br><span class="line"> elsif q1=24999 then CLKFMQ&lt;='0';q1&lt;=0;</span><br><span class="line"> else CLKFMQ&lt;='0';q1&lt;=q1+1;</span><br><span class="line">end if;</span><br><span class="line">end if;</span><br><span class="line">end process ;</span><br><span class="line">--0.1s的分频--</span><br><span class="line">process(clk)</span><br><span class="line">begin</span><br><span class="line">if clk'event and clk='1'then</span><br><span class="line">if q2&lt;=5 then clk01s&lt;='1';q2&lt;=q2+1;</span><br><span class="line">elsif q2=4999999 then clk01s&lt;='0';q2&lt;=0;</span><br><span class="line">else clk01s&lt;='0';q2&lt;=q2+1;</span><br><span class="line">end if;</span><br><span class="line">end if;</span><br><span class="line">end process;</span><br><span class="line">--1ms--</span><br><span class="line">process(clk)</span><br><span class="line">begin</span><br><span class="line">if clk'event and clk='1'then</span><br><span class="line">if q3&lt;=40000 then clk1ms&lt;='1';q3&lt;=q3+1;</span><br><span class="line">elsif q3=49999 then clk1ms&lt;='0';q3&lt;=0;</span><br><span class="line">else clk1ms&lt;='0';q3&lt;=q3+1;</span><br><span class="line">end if;</span><br><span class="line">end if;</span><br><span class="line">end process;</span><br><span class="line">end abc;</span><br></pre></td></tr></tbody></table></figure><h3 id="什么是pwm"><a class="markdownIt-Anchor" href="#什么是pwm"></a> 什么是PWM？</h3><ul><li>PWM（Pulse Width Modulation）即脉冲宽度调制，在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速、开关电源等领域</li><li>PWM重要参数：      频率 = 1 / TS            占空比 = TON / TS           精度 = 占空比变化步距</li></ul><img src="/posts/24146/64ab8ccb124f48e1867bd21f1717fba2-17086935318808.png" class="" title="在这里插入图片描述"><p><strong>信号接口/变量定义：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">LIBRARY IEEE;</span><br><span class="line">USE IEEE.STD_LOGIC_1164.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_ARITH.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_UNSIGNED.ALL;</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">ENTITY   Carcontrol_4  is--路线四控制模块                             </span><br><span class="line">PORT(CLK,CLKFMQ,clk01s,clk1ms:in std_logic; --pwm,时钟信号,复位信号</span><br><span class="line">RESET:IN STD_LOGIC;</span><br><span class="line">Mapan:in std_logic;--码盘信号</span><br><span class="line">X1,X2:in std_logic_vector(<span class="number">3</span> downto <span class="number">0</span>);--巡线信号</span><br><span class="line">en11,en12,en21,en22,FMQ:OUT std_logic;--通道A B 的驱动电压</span><br><span class="line">turn_timer1,LED:out std_logic_vector(<span class="number">7</span> downto <span class="number">0</span>):=<span class="string">"00000000"</span>;--计数器</span><br><span class="line">contrologic:OUT std_logic_vector(<span class="number">7</span> downto <span class="number">0</span>):=<span class="string">"00000000"</span>--电机驱动/制动的信号--输出到数据选择器上</span><br><span class="line">);</span><br><span class="line">END Carcontrol_4;                                           </span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">ARCHITECTURE abc OF  Carcontrol_4  IS  </span><br><span class="line">  type Sreg0_type is--状态枚举</span><br><span class="line">  (T0,T00,T01,T20,T1,T2,T21,T3,</span><br><span class="line">  stop1,stop2,stop3,stop4,</span><br><span class="line">  TX1,TX1fix,TX1end,</span><br><span class="line">  TX2,TX2fix,TX2end,</span><br><span class="line">  TX3,TX3fix,TX3end,</span><br><span class="line">  TBX1,TBX1fix,TBX1end,</span><br><span class="line">  TBX2,TBX2fix,TBX2end,</span><br><span class="line">  TBX3,TBX3fix,TBX3end,</span><br><span class="line">  TB1,TB2,TB3,TB4,TB5,HT);</span><br><span class="line">  signal XJ :std_logic_vector(<span class="number">7</span> downto <span class="number">0</span>);--两个四路循迹模块的并置信号</span><br><span class="line">  signal Sreg0: Sreg0_type;--状态类型</span><br><span class="line">  signal FMQEN: std_logic:=<span class="string">'1'</span>;--蜂鸣器的使能信号，低电平有效</span><br><span class="line">  signal Z11,Z12,Z21,Z22:integer;--PWM脉宽调制占空比</span><br><span class="line">  signal left1,left2,right1,right2:std_logic;</span><br><span class="line">  signal q1:integer range <span class="number">0</span> to <span class="number">100</span>;</span><br><span class="line">  signal q2:integer range <span class="number">0</span> to <span class="number">100</span>;</span><br><span class="line">  signal q3:integer range <span class="number">0</span> to <span class="number">100</span>;</span><br><span class="line">  signal q4:integer range <span class="number">0</span> to <span class="number">100</span>;</span><br><span class="line">  signal turn_timer:INTEGER  range <span class="number">0</span> to <span class="number">100000</span> ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">XJ&lt;=X1&amp;X2;--循迹信号（八位）</span><br><span class="line">LED&lt;=XJ;--通过LED观察循迹模块是否正常运行</span><br><span class="line">EN11&lt;=left1;EN12&lt;=right1;EN21&lt;=left2;EN22&lt;=right2;--电机的PWM信号输入</span><br><span class="line">--------------------------------------------</span><br><span class="line">--四个模块，分别控制小车四个电机的PWM信号输入</span><br><span class="line">--占空比定义为 变量（整型），在没有pid控制的情况下，便于对小车进行校准，以及调速。</span><br><span class="line">process(clk,q1)</span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> clk<span class="number">'</span>event and clk=<span class="string">'1'</span> then</span><br><span class="line"><span class="keyword">if</span> q1&lt;=Z11 then left1&lt;=<span class="string">'1'</span>;q1&lt;=q1+<span class="number">1</span>;--高电平有效值定义为整型，便于在状态机中进行变速</span><br><span class="line"> elsif q1=<span class="number">100</span> then left1&lt;=<span class="string">'0'</span>;q1&lt;=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span> left1&lt;=<span class="string">'0'</span>;q1&lt;=q1+<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process;</span><br><span class="line">process(clk,q2)</span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> clk<span class="number">'</span>event and clk=<span class="string">'1'</span> then</span><br><span class="line"><span class="keyword">if</span> q2&lt;=Z12 then right1&lt;=<span class="string">'1'</span>;q2&lt;=q2+<span class="number">1</span>;</span><br><span class="line"> elsif q2=<span class="number">100</span> then right1&lt;=<span class="string">'0'</span>;q2&lt;=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span> right1&lt;=<span class="string">'0'</span>;q2&lt;=q2+<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process;</span><br><span class="line">process(clk,q3)</span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> clk<span class="number">'</span>event and clk=<span class="string">'1'</span> then</span><br><span class="line"><span class="keyword">if</span> q3&lt;=Z21 then left2&lt;=<span class="string">'1'</span>;q3&lt;=q3+<span class="number">1</span>;</span><br><span class="line"> elsif q3=<span class="number">100</span> then left2&lt;=<span class="string">'0'</span>;q3&lt;=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span> left2&lt;=<span class="string">'0'</span>;q3&lt;=q3+<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process;</span><br><span class="line">process(clk,q4)</span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> clk<span class="number">'</span>event and clk=<span class="string">'1'</span> then</span><br><span class="line"><span class="keyword">if</span> q4&lt;=Z22 then right2&lt;=<span class="string">'1'</span>; q4&lt;= q4+<span class="number">1</span>;</span><br><span class="line"> elsif  q4=<span class="number">100</span> then right2&lt;=<span class="string">'0'</span>; q4&lt;=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span> right2&lt;=<span class="string">'0'</span>;q4&lt;=q4+<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process;</span><br><span class="line">-----------------------------------------------------------------------------</span><br></pre></td></tr></tbody></table></figure><h2 id="路线规划以路线4为例"><a class="markdownIt-Anchor" href="#路线规划以路线4为例"></a> 路线规划（以路线4为例）</h2><h3 id="计时器控制小车在不同状态下定时运动"><a class="markdownIt-Anchor" href="#计时器控制小车在不同状态下定时运动"></a> 计时器（控制小车在不同状态下定时运动）</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process(clk1ms,Timer_flag)</span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> Timer_flag = <span class="number">1</span> THEN</span><br><span class="line"><span class="keyword">if</span> rising_edge(clk1ms) THEN</span><br><span class="line">turn_timer &lt;= turn_timer +<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">turn_timer&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process;</span><br></pre></td></tr></tbody></table></figure><h3 id="程序主要部分状态机"><a class="markdownIt-Anchor" href="#程序主要部分状态机"></a> 程序主要部分（状态机）</h3><blockquote><p><strong>不同状态下，根据路径规划，小车的运动姿态（转向，直行）不同，每个状态有特定的<mark>状态转移条件</mark>（运动时间（用红外计数里程判断更精准），特征值（黑线）</strong></p></blockquote><ul><li>小车碰到黑线（居民楼）进行偏移转向</li><li>车头碰到黑线（关键点检测）进行直角转弯</li><li>小车要精确地行驶，到底指定地点，需要利用好黑线，既不能触线，也不能过偏，即贴线行驶，这就要使得小车在贴线行驶的路段在规定的 时间 / 里程 内，进行<mark>贴线行驶</mark>-&gt;<mark>避线</mark>-&gt;<mark>贴线行驶</mark>，三个状态的闭环，在小车行驶姿态垂直于黑线时的路径，循迹模块检测黑线直接进行直角转弯即可（这样就不需要控制里程/时间）。</li><li>规划好前往火源点的路径后，返回的路径按照相反的逻辑控制即可。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">PROCESS(reset, clk1ms)-<span class="number">-1</span>ms的时钟信号，用于状态机的状态检测以及计时器的计时精度</span><br><span class="line">BEGIN</span><br><span class="line">    IF reset = <span class="string">'1'</span> THEN--复位信号</span><br><span class="line">      Sreg0 &lt;= T0;FMQEN&lt;=<span class="string">'1'</span>;Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--蜂鸣器无效，状态机初始化</span><br><span class="line">      contrologic &lt;= <span class="string">"00000000"</span>;--控制逻辑均置零</span><br><span class="line">turn_timer&lt;= <span class="number">0</span> ;--计数器清零</span><br><span class="line">    ELSIF <span class="title function_">rising_edge</span><span class="params">(clk1ms)</span> THEN</span><br><span class="line">      CASE Sreg0 IS </span><br><span class="line">        WHEN T0 =&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --直行</span><br><span class="line">   <span class="keyword">if</span> turn_timer = <span class="number">1000</span> then</span><br><span class="line">   Sreg0 &lt;= T00;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;  </span><br><span class="line">WHEN T00 =&gt;</span><br><span class="line">          <span class="keyword">if</span>  XJ(<span class="number">3</span>)=<span class="string">'0'</span> then--检测黑线</span><br><span class="line">    Sreg0&lt;=T01;</span><br><span class="line"> ELSE  Sreg0&lt;=T00;</span><br><span class="line">          end <span class="keyword">if</span>;</span><br><span class="line">  WHEN T01 =&gt;contrologic &lt;= <span class="string">"10011001"</span>; Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--碰到黑线回退</span><br><span class="line">   <span class="keyword">if</span> turn_timer = <span class="number">700</span> then -<span class="number">-1450</span></span><br><span class="line">   Sreg0 &lt;= T1;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;  </span><br><span class="line">        WHEN T1 =&gt;contrologic &lt;= <span class="string">"00100010"</span>;Z12&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;--转弯</span><br><span class="line"><span class="keyword">if</span> turn_timer = <span class="number">1250</span> then</span><br><span class="line">   Sreg0 &lt;= stop1;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;  </span><br><span class="line">  WHEN stop1 =&gt;contrologic &lt;= <span class="string">"00000000"</span> ;--停止</span><br><span class="line"><span class="keyword">if</span> turn_timer = <span class="number">300</span> then</span><br><span class="line">   Sreg0 &lt;= T2;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">--贴线 </span><br><span class="line">  WHEN T2 =&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --空白区域直行</span><br><span class="line">  <span class="keyword">if</span> turn_timer = <span class="number">1500</span> then</span><br><span class="line">   Sreg0 &lt;= TX1;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;</span><br><span class="line"> When TX1 =&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --贴线循迹(街区<span class="number">2</span>）</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>))  = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TX1fix; </span><br><span class="line">elsif turn_timer = <span class="number">2800</span> then--完成贴线</span><br><span class="line">   Sreg0 &lt;= TX1end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> WHEN TX1fix =&gt; contrologic &lt;= <span class="string">"10101010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;--修正</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'1'</span>then Sreg0 &lt;= TX1; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> When TX1end =&gt; contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --完成贴线,直行小段</span><br><span class="line"> <span class="keyword">if</span> turn_timer = <span class="number">500</span> then </span><br><span class="line">   Sreg0 &lt;= T20;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">    end <span class="keyword">if</span>;</span><br><span class="line">----------------------------------------------------------------------------- </span><br><span class="line">       WHEN T20 =&gt;</span><br><span class="line">          <span class="keyword">if</span>  XJ(<span class="number">3</span>)=<span class="string">'0'</span> then  --前端检测黑线</span><br><span class="line">    Sreg0&lt;=T21;</span><br><span class="line">          end <span class="keyword">if</span>;</span><br><span class="line">  WHEN T21 =&gt;contrologic &lt;= <span class="string">"10011001"</span>; Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--检测到黑线，回退</span><br><span class="line">  <span class="keyword">if</span> turn_timer = <span class="number">600</span> then</span><br><span class="line">   Sreg0 &lt;= T3;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;  </span><br><span class="line">  WHEN T3 =&gt;contrologic &lt;= <span class="string">"00100010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;--直角转弯</span><br><span class="line"><span class="keyword">if</span> turn_timer = <span class="number">1500</span> then</span><br><span class="line">   Sreg0 &lt;= TX2; --进入第二段循迹贴线（火源区<span class="number">3</span>）</span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;</span><br><span class="line">----------------------------------------------------------------------------- </span><br><span class="line">  WHEN TX2 =&gt;contrologic &lt;= <span class="string">"10011001"</span>; Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--进入第二段循迹贴线（火源区<span class="number">3</span>）</span><br><span class="line"><span class="keyword">if</span> XJ(<span class="number">4</span>) = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TX2fix; </span><br><span class="line">elsif turn_timer = <span class="number">2000</span> then--限制贴线时间</span><br><span class="line">   Sreg0 &lt;= TX2end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> WHEN TX2fix =&gt; contrologic &lt;= <span class="string">"01010101"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span> XJ(<span class="number">4</span>) = <span class="string">'1'</span>then Sreg0 &lt;= TX2; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> When TX2end =&gt; contrologic &lt;= <span class="string">"10011001"</span>; Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;</span><br><span class="line"> <span class="keyword">if</span> turn_timer = <span class="number">500</span> then --贴线结束，空白区直行</span><br><span class="line">   Sreg0 &lt;= TX3;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">    end <span class="keyword">if</span>;</span><br><span class="line">----------------------------------------------------------------------------- </span><br><span class="line">  WHEN TX3 =&gt;contrologic &lt;= <span class="string">"10011001"</span>;  Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--进入第三段循迹贴线（火源区<span class="number">4</span>）</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">4</span>) and XJ(<span class="number">5</span>) and XJ(<span class="number">6</span>) and XJ(<span class="number">7</span>)) = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TX3fix; </span><br><span class="line">elsif turn_timer = <span class="number">1900</span> then--限制时间</span><br><span class="line">   Sreg0 &lt;= TX3end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> WHEN TX3fix =&gt; contrologic &lt;= <span class="string">"01010101"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">4</span>) and XJ(<span class="number">5</span>) and XJ(<span class="number">6</span>) and XJ(<span class="number">7</span>)) = <span class="string">'1'</span>then Sreg0 &lt;= TX3; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">  WHEN TX3end=&gt;FMQEN&lt;=<span class="string">'0'</span>;contrologic &lt;= <span class="string">"00000000"</span>; --报警</span><br><span class="line">  <span class="keyword">if</span> turn_timer =<span class="number">4999</span> then </span><br><span class="line">Sreg0 &lt;= TBX1;FMQEN&lt;=<span class="string">'1'</span>;</span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">WHEN TBX1 =&gt;contrologic &lt;= <span class="string">"01100110"</span>; Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --进入返回第一段循迹贴线（火源区<span class="number">4</span>）</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TBX1fix; </span><br><span class="line">elsif turn_timer = <span class="number">1200</span> then</span><br><span class="line">   Sreg0 &lt;= TBX1end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">   WHEN TBX1fix =&gt; contrologic &lt;= <span class="string">"10101010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>))= <span class="string">'1'</span>then Sreg0 &lt;= TBX1; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"> When TBX1end =&gt; contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --空白区域</span><br><span class="line"> <span class="keyword">if</span> turn_timer = <span class="number">500</span> then </span><br><span class="line">   Sreg0 &lt;= TBX2;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">    end <span class="keyword">if</span>;</span><br><span class="line">    WHEN TBX2 =&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>;--进入返回第二段循迹贴线（火源区<span class="number">3</span>）</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TBX2fix; </span><br><span class="line">elsif turn_timer = <span class="number">3500</span> then</span><br><span class="line">   Sreg0 &lt;= TBX2end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> WHEN TBX2fix =&gt; contrologic &lt;= <span class="string">"10101010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'1'</span>then Sreg0 &lt;= TBX2; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">  WHEN TBX2end=&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>;--前端检测黑线</span><br><span class="line">          <span class="keyword">if</span>  XJ(<span class="number">3</span>)=<span class="string">'0'</span> then  </span><br><span class="line">    Sreg0&lt;=HT;</span><br><span class="line"> Else  Sreg0&lt;=TBX2end;</span><br><span class="line">          end <span class="keyword">if</span>; </span><br><span class="line">  WHEN HT =&gt;contrologic &lt;= <span class="string">"10011001"</span>; Z11&lt;=<span class="number">36</span>;Z12&lt;=<span class="number">29</span>;Z21&lt;=<span class="number">36</span>;Z22&lt;=<span class="number">29</span>;--碰到黑线回退</span><br><span class="line">   <span class="keyword">if</span> turn_timer = <span class="number">500</span> then -<span class="number">-1450</span></span><br><span class="line">   Sreg0 &lt;= TB3;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;</span><br><span class="line">        WHEN TB3=&gt;contrologic &lt;= <span class="string">"00100010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;--转向 </span><br><span class="line"><span class="keyword">if</span> turn_timer = <span class="number">900</span> then</span><br><span class="line">   Sreg0 &lt;= TBX3;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line"> end <span class="keyword">if</span>;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">    WHEN TBX3 =&gt;contrologic &lt;= <span class="string">"01100110"</span>;Z11&lt;=<span class="number">38</span>;Z12&lt;=<span class="number">34</span>;Z21&lt;=<span class="number">38</span>;Z22&lt;=<span class="number">34</span>; --贴线循迹，回到起点</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'0'</span> then</span><br><span class="line">Sreg0 &lt;= TBX3fix; </span><br><span class="line">elsif turn_timer = <span class="number">4200</span> then</span><br><span class="line">   Sreg0 &lt;= TBX3end;  </span><br><span class="line">Timer_flag&lt;=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">Timer_flag&lt;=<span class="number">0</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line"> WHEN TBX3fix =&gt; contrologic &lt;= <span class="string">"10101010"</span>;Z11&lt;=<span class="number">40</span>;Z12&lt;=<span class="number">40</span>;Z21&lt;=<span class="number">40</span>;Z22&lt;=<span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span> (XJ(<span class="number">0</span>) and XJ(<span class="number">1</span>) and XJ(<span class="number">2</span>) and XJ(<span class="number">3</span>)) = <span class="string">'1'</span>then Sreg0 &lt;= TBX3; </span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">  WHEN OTHERS =&gt; null; contrologic&lt;= <span class="string">"00000000"</span>;</span><br><span class="line">  END CASE;</span><br><span class="line">END IF;</span><br><span class="line">  END PROCESS;</span><br><span class="line">PROCESS(FMQEN)</span><br><span class="line">BEGIN</span><br><span class="line">IF FMQEN&lt;=<span class="string">'0'</span>then FMQ&lt;=CLKFMQ;</span><br><span class="line">ELSE FMQ&lt;=<span class="string">'1'</span>;</span><br><span class="line">END IF;</span><br><span class="line">END PROCESS;</span><br><span class="line">END abc;</span><br></pre></td></tr></tbody></table></figure><h3 id="四路数据选择器模块"><a class="markdownIt-Anchor" href="#四路数据选择器模块"></a> 四路数据选择器模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY IEEE;</span><br><span class="line">USE IEEE.STD_LOGIC_1164.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_ARITH.ALL;</span><br><span class="line">USE IEEE.STD_LOGIC_UNSIGNED.ALL;</span><br><span class="line">--四路（总线式）数据选择器，通过四位按键控制电机逻辑/电机有效电压（PWM）/蜂鸣器信号/选择小车行驶路线</span><br><span class="line">ENTITY MUX4 IS</span><br><span class="line"><span class="title function_">PORT</span><span class="params">(C1,C2,C3,C4:IN STD_LOGIC_VECTOR(<span class="number">7</span> DOWNTO <span class="number">0</span>);</span></span><br><span class="line"><span class="params">  EN11_1,EN12_1,EN21_1,EN22_1:in std_logic;</span></span><br><span class="line"><span class="params">  EN11_2,EN12_2,EN21_2,EN22_2:in std_logic;</span></span><br><span class="line"><span class="params">  EN11_3,EN12_3,EN21_3,EN22_3:in std_logic;</span></span><br><span class="line"><span class="params">  EN11_4,EN12_4,EN21_4,EN22_4:in std_logic;</span></span><br><span class="line"><span class="params">  FMQ1,FMQ2,FMQ3,FMQ4:in std_logic;</span></span><br><span class="line"><span class="params">  RESET:IN STD_LOGIC_vector(<span class="number">3</span> downto <span class="number">0</span>);--路线选择信号</span></span><br><span class="line"><span class="params">  FMQ:out std_logic;--蜂鸣器</span></span><br><span class="line"><span class="params">  LOGIC:OUT STD_LOGIC_vector(<span class="number">7</span> DOWNTO <span class="number">0</span>);--小车运动控制逻辑</span></span><br><span class="line"><span class="params">  EN11,EN12,EN21,EN22:OUT STD_LOGIC;--小车电机PWM方波输出信号</span></span><br><span class="line"><span class="params">  CLK1MS:in std_logic;--光耦传感器脉冲，复位信号，<span class="number">1</span>MS时钟</span></span><br><span class="line"><span class="params">  LEDSEG: OUT STD_LOGIC_VECTOR(<span class="number">6</span> DOWNTO <span class="number">0</span>);--LED显示</span></span><br><span class="line"><span class="params">  Y:out std_logic_VECTOR(<span class="number">5</span> DOWNTO <span class="number">0</span>)--共阴极</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">END MUX4;--</span><br><span class="line">ARCHITECTURE ABC OF MUX4 IS</span><br><span class="line">signal ledin:std_logic_vector(<span class="number">3</span> downto <span class="number">0</span>);</span><br><span class="line">signal SEL:std_logic_vector(<span class="number">2</span> downto <span class="number">0</span>):=<span class="string">"000"</span>;</span><br><span class="line">BEGIN</span><br><span class="line">--显示译码器--</span><br><span class="line">P11:process (ledin)</span><br><span class="line">BEGIN</span><br><span class="line">CASE ledin IS </span><br><span class="line">WHEN <span class="string">"0000"</span>=&gt;ledseg&lt;=<span class="string">"0111111"</span>;--<span class="string">"1111111110"</span>;</span><br><span class="line">WHEN <span class="string">"0001"</span>=&gt;ledseg&lt;=<span class="string">"0000110"</span>;--<span class="string">"1111111101"</span>;</span><br><span class="line">WHEN <span class="string">"0010"</span>=&gt;ledseg&lt;=<span class="string">"1011011"</span>;--<span class="string">"1111111011"</span>;</span><br><span class="line">WHEN <span class="string">"0011"</span>=&gt;ledseg&lt;=<span class="string">"1001111"</span>;--<span class="string">"1111110111"</span>; </span><br><span class="line">WHEN <span class="string">"0100"</span>=&gt;ledseg&lt;=<span class="string">"1100110"</span>;--<span class="string">"1111101111"</span>;</span><br><span class="line">WHEN <span class="string">"0101"</span>=&gt;ledseg&lt;=<span class="string">"1101101"</span>;--<span class="string">"1111011111"</span>;</span><br><span class="line">WHEN <span class="string">"0110"</span>=&gt;ledseg&lt;=<span class="string">"1111101"</span>;--<span class="string">"1110111111"</span>;</span><br><span class="line">WHEN <span class="string">"0111"</span>=&gt;ledseg&lt;=<span class="string">"0000111"</span>;--<span class="string">"1101111111"</span>;</span><br><span class="line">WHEN <span class="string">"1000"</span>=&gt;ledseg&lt;=<span class="string">"1111111"</span>;--<span class="string">"1011111111"</span>;</span><br><span class="line">WHEN <span class="string">"1001"</span>=&gt;ledseg&lt;=<span class="string">"1101111"</span>;--<span class="string">"0111111111"</span>;</span><br><span class="line">WHEN <span class="string">"1010"</span>=&gt;ledseg&lt;=<span class="string">"0000001"</span>;--<span class="string">"0111111111"</span>;</span><br><span class="line">WHEN OTHERS=&gt;ledseg&lt;=<span class="string">"0000000"</span>;--共阴极，无效</span><br><span class="line">END CASE;</span><br><span class="line">end process P11;</span><br><span class="line">--四位脉冲分配器--</span><br><span class="line">p22:process(clk1ms)</span><br><span class="line">begin</span><br><span class="line">IF clk1ms<span class="number">'</span>event and clk1ms=<span class="string">'1'</span> then</span><br><span class="line"><span class="keyword">if</span> sel=<span class="string">"101"</span> then sel&lt;=<span class="string">"000"</span>;</span><br><span class="line"><span class="keyword">else</span> sel&lt;=sel+<span class="number">1</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end <span class="keyword">if</span>;</span><br><span class="line">end process P22;</span><br><span class="line">PROCESS(RESET)</span><br><span class="line">BEGIN</span><br><span class="line">CASE RESET IS</span><br><span class="line">WHEN <span class="string">"1000"</span> =&gt; </span><br><span class="line">LOGIC &lt;=C1;</span><br><span class="line">EN11&lt;=EN11_1;</span><br><span class="line">EN12&lt;=EN12_1;</span><br><span class="line">EN21&lt;=EN21_1;</span><br><span class="line">EN22&lt;=EN22_1;</span><br><span class="line">FMQ&lt;=FMQ1;</span><br><span class="line">CASE SEL IS</span><br><span class="line">WHEN <span class="string">"001"</span>=&gt;ledin&lt;=<span class="string">"0000"</span>;y&lt;=<span class="string">"111101"</span>;</span><br><span class="line">WHEN <span class="string">"010"</span>=&gt;ledin&lt;=<span class="string">"1001"</span>;y&lt;=<span class="string">"111011"</span>;</span><br><span class="line">WHEN <span class="string">"011"</span>=&gt;ledin&lt;=<span class="string">"0011"</span>;y&lt;=<span class="string">"110111"</span>;</span><br><span class="line">WHEN <span class="string">"100"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"101111"</span>;</span><br><span class="line">WHEN OTHERS =&gt;ledin&lt;=<span class="string">"1111"</span>;y&lt;=<span class="string">"111111"</span>;</span><br><span class="line">END CASE;</span><br><span class="line">WHEN <span class="string">"0100"</span> =&gt; LOGIC &lt;=C2;</span><br><span class="line">EN11&lt;=EN11_2;</span><br><span class="line">EN12&lt;=EN12_2;</span><br><span class="line">EN21&lt;=EN21_2;</span><br><span class="line">EN22&lt;=EN22_2;</span><br><span class="line">FMQ&lt;=FMQ2;</span><br><span class="line">CASE SEL IS</span><br><span class="line">WHEN <span class="string">"000"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"111101"</span>;</span><br><span class="line">WHEN <span class="string">"001"</span>=&gt;ledin&lt;=<span class="string">"1000"</span>;y&lt;=<span class="string">"111011"</span>;</span><br><span class="line">WHEN <span class="string">"010"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"110111"</span>;</span><br><span class="line">WHEN <span class="string">"011"</span>=&gt;ledin&lt;=<span class="string">"1001"</span>;y&lt;=<span class="string">"101111"</span>;</span><br><span class="line">WHEN OTHERS =&gt;ledin&lt;=<span class="string">"1111"</span>;y&lt;=<span class="string">"111111"</span>;</span><br><span class="line">END CASE;</span><br><span class="line">WHEN <span class="string">"0010"</span> =&gt; LOGIC &lt;=C3;</span><br><span class="line">EN11&lt;=EN11_3;</span><br><span class="line">EN12&lt;=EN12_3;</span><br><span class="line">EN21&lt;=EN21_3;</span><br><span class="line">EN22&lt;=EN22_3;</span><br><span class="line">FMQ&lt;=FMQ3;</span><br><span class="line">CASE SEL IS</span><br><span class="line">WHEN <span class="string">"000"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"111101"</span>;</span><br><span class="line">WHEN <span class="string">"001"</span>=&gt;ledin&lt;=<span class="string">"1000"</span>;y&lt;=<span class="string">"111011"</span>;</span><br><span class="line">WHEN <span class="string">"010"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"110111"</span>;</span><br><span class="line">WHEN <span class="string">"011"</span>=&gt;ledin&lt;=<span class="string">"1001"</span>;y&lt;=<span class="string">"101111"</span>;</span><br><span class="line">WHEN OTHERS =&gt;ledin&lt;=<span class="string">"1111"</span>;y&lt;=<span class="string">"111111"</span>;</span><br><span class="line">END CASE;</span><br><span class="line">WHEN <span class="string">"0001"</span> =&gt; LOGIC &lt;=C4;</span><br><span class="line">EN11&lt;=EN11_4;</span><br><span class="line">EN12&lt;=EN12_4;</span><br><span class="line">EN21&lt;=EN21_4;</span><br><span class="line">EN22&lt;=EN22_4;</span><br><span class="line">FMQ&lt;=FMQ4;</span><br><span class="line">CASE SEL IS</span><br><span class="line">WHEN <span class="string">"000"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"111101"</span>;</span><br><span class="line">WHEN <span class="string">"001"</span>=&gt;ledin&lt;=<span class="string">"1000"</span>;y&lt;=<span class="string">"111011"</span>;</span><br><span class="line">WHEN <span class="string">"010"</span>=&gt;ledin&lt;=<span class="string">"0010"</span>;y&lt;=<span class="string">"110111"</span>;</span><br><span class="line">WHEN <span class="string">"011"</span>=&gt;ledin&lt;=<span class="string">"1001"</span>;y&lt;=<span class="string">"101111"</span>;</span><br><span class="line">WHEN OTHERS =&gt;ledin&lt;=<span class="string">"1111"</span>;y&lt;=<span class="string">"111111"</span>;</span><br><span class="line">end <span class="keyword">case</span>;</span><br><span class="line">WHEN OTHERS=&gt;LOGIC&lt;=<span class="string">"00000000"</span>;</span><br><span class="line">END CASE;</span><br><span class="line">END PROCESS;</span><br><span class="line">END ABC;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 项目 </category>
          
          <category> FPGA </category>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> 电赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HEXO】[01]HEXO常用命令</title>
      <link href="/posts/64680/"/>
      <url>/posts/64680/</url>
      
        <content type="html"><![CDATA[<p><strong>hexo远程发布</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></tbody></table></figure><p><strong>新建md文件</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n "name"</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 博客 </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C语言入门学习】[1]初识C语言 01</title>
      <link href="/posts/13150/"/>
      <url>/posts/13150/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言入门学习1初识c语言-01"><a class="markdownIt-Anchor" href="#c语言入门学习1初识c语言-01"></a> 【C语言入门学习】[1]初识C语言 01</h1><h3 id="202419更新"><a class="markdownIt-Anchor" href="#202419更新"></a> 2024.1.9更新</h3><h3 id="2024220更新"><a class="markdownIt-Anchor" href="#2024220更新"></a> 2024.2.20更新</h3><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><h3 id="什么是c语言"><a class="markdownIt-Anchor" href="#什么是c语言"></a> 什么是C语言？</h3><ul><li>C语言是一门通用计算机编程语言，广泛应用于<strong>底层开发</strong>。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。尽管C语言提供了许多低级处理的功能，但仍然保持着良好跨平台的特性，以一个标准规格写出的C语言程序可在许多电脑平台上进行编译，甚至包含一些<strong>嵌入式处理器</strong>（单片机或称MCU）以及<strong>超级电脑</strong>等作业平台。</li><li>ANSI C，作为C语言最初的标准</li><li>C语言是一门<strong>面向过程</strong>的计算机编程语言，与C++，Java等<strong>面向对象</strong>的编程语言有所不同。</li><li>其编译器主要有Clang、GCC、WIN-TC、SUBLIME、MSVC、Turbo C</li><li><strong>C语言介于机器语言和高级语言之间</strong></li></ul><h2 id="一-基本概念"><a class="markdownIt-Anchor" href="#一-基本概念"></a> 一、基本概念</h2><h3 id="一-c语言的基本框架"><a class="markdownIt-Anchor" href="#一-c语言的基本框架"></a> 一、c语言的基本框架</h3><ul><li>main函数是程序的入口</li><li>return 0;函数正常运行结束时返回0</li></ul><h3 id="二-c语言的数据类型"><a class="markdownIt-Anchor" href="#二-c语言的数据类型"></a> 二、c语言的数据类型</h3><ul><li>char //字符数据类型</li><li>short //短整型</li><li>int //整形</li><li>long //长整型</li><li>long long //更长的整形</li><li>float //单精度浮点数</li><li>double //双精度浮点数</li><li>C语言有没有字符串类型？<br><code>add[]="String"</code></li></ul><p><strong>每种字符类型对应的字节大小</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">double</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输出结果：<br>1<br>2<br>4<br>4<br>8<br>4<br>8<br>8 最大为8个字节 2的64次方(64位系统)<br>对于计算机内存的解释,见：</p></blockquote><h3 id="三-变量的作用域和生命周期"><a class="markdownIt-Anchor" href="#三-变量的作用域和生命周期"></a> 三、变量的作用域和生命周期</h3><p>作用域</p><blockquote><p>作用域（scope）是程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用<br>的<br>而限定这个名字的可用性的代码范围就是这个名字的作用域。</p></blockquote><ol><li>局部变量的作用域是变量所在的局部范围。</li><li>全局变量的作用域是整个工程。</li></ol><p>生命周期</p><blockquote><p>变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段</p></blockquote><ol><li>局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束。</li><li>全局变量的生命周期是：整个程序的生命周期。</li></ol><p><strong>代码示例</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用域</span></span><br><span class="line"><span class="comment">//局部变量的作用域：就是变量所在的局部范围</span></span><br><span class="line"><span class="comment">//全局变量的作用域：整个工程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_val = <span class="number">2021</span>;<span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1:%d\n"</span>, g_val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hehe\n"</span>);</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2:%d\n"</span>, g_val);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3:%d\n"</span>, g_val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="extern关键字"><a class="markdownIt-Anchor" href="#extern关键字"></a> #extern(关键字)：</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一下变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_val;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, g_val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生命周期</span></span><br><span class="line"><span class="comment">//变量的生命周期：变量的创建和销毁之间的时间段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量的生命周期：进入局部范围生命开始，出局部范围生命结束</span></span><br><span class="line"><span class="comment">//全局变量的生命周期：程序的生命周期</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//a创建</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//a销毁</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="defineconst和enum"><a class="markdownIt-Anchor" href="#defineconst和enum"></a> #define/const和enum</h3><h4 id="define-和const的区别"><a class="markdownIt-Anchor" href="#define-和const的区别"></a> define 和const的区别</h4><p><strong>1.编译器处理阶段</strong></p><p>define是预处理器预处理阶段完成，const是编译器开始编译程序阶段完成，因此#define先于const处理。<br><strong>2.语法语义方面</strong></p><p>define是宏定义，特点是简单原位做替换，其定义的常量值没有类型限定，也不做类型检查，在出现宏名称的地方直接展开。<br>const是关键字，本质上会定义一个只读变量，不可以更改，编译是检查常量值的类型是否匹配。</p><blockquote><p>例如：</p><p>define PI 3.14159<br>int r = 25;<br>double s = rrPI;<br>r = 30;<br>s = rrPI;<br>预处理完成以后的代码是：<br>int r = 25;<br>double s = rr3.14159;<br>r = 30;<br>s = rr3.14159;<br>define明显是直接替换，PI出现几次，其数值3.14159出现几次。<br>// 必须指定正确的类型<br>const double PI = 3.14159 ;<br>int r = 25;<br>double s = rrPI;<br>r = 30;<br>s = rrPI;<br>const明显是声明和定义一个变量，分配内存空间保存3.14159的数值，以后使用时和普通变量一样取值，但是无法对其进行赋值修改。<br>3.#define宏只做替换，不做表达式计算，如果#define定义的不是单个数值，而是一个常量表达式，建议加上圆括号，避免出错。<br>例如：定义常量表示每个元素的大小是int+double型大小之和。<br>define N sizeof(int) + sizeof(double)<br>int m = 100;<br>// 根据输入的m变量值计算总的空间大小<br>int total = m<em>N;<br>这是错误的，因为替换以后int total= m</em>sizeof(int) + sizeof(double);<br>正确写法是：<br>define N (sizeof(int) + sizeof(double))<br>展开以后：<br>int total = m*(sizeof(int) + sizeof(double));<br>使用const不存在以上问题，const会对表达式先计算。<br>const int N = sizeof(int) + sizeof(double);<br>int m = 100;<br>// 根据输入的m变量值计算总的空间大小<br>int total = m*N;</p></blockquote><p><strong>代码示例</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//1. 字面常量</span></span><br><span class="line"><span class="comment">//3.14;</span></span><br><span class="line"><span class="comment">//10;</span></span><br><span class="line"><span class="comment">//'a';</span></span><br><span class="line"><span class="comment">//"abcdef";</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. const修饰的常变量</span></span><br><span class="line"><span class="comment">//const int num = 10;//num就是常变量 - 具有常属性（不能被改变的属性）</span></span><br><span class="line"><span class="comment">//num = 20;</span></span><br><span class="line"><span class="comment">//printf("num = %d\n", num);//20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int arr[10] = {0};//10个元素</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//const int n = 10;</span></span><br><span class="line"><span class="comment">//int arr2[n] = {0};//n是变量的，这里是不行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. #define 定义的标识符常量</span></span><br><span class="line"><span class="comment">//MAX = 20000;//err</span></span><br><span class="line"><span class="comment">/*int n = MAX;</span></span><br><span class="line"><span class="comment">printf("n = %d\n", n);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">性别</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="comment">//这种枚举类型的变量的未来可能取值</span></span><br><span class="line"><span class="comment">//枚举常量</span></span><br><span class="line">MALE = <span class="number">3</span>,<span class="comment">//赋初值</span></span><br><span class="line">FEMALE,</span><br><span class="line">SECRET</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//4. 枚举常量</span></span><br><span class="line"><span class="comment">//可以一一列举的常量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span> <span class="title">s</span> =</span> MALE;</span><br><span class="line"><span class="comment">//MALE = 3;//err</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, MALE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, FEMALE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SECRET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串和转义字符"><a class="markdownIt-Anchor" href="#字符串和转义字符"></a> #字符串和转义字符</h3><blockquote><p>由双引号（Double Quote）引起来的一串字符称为字符串字面值（String Literal），或者简称字符<br>串。<br>注：字符串的结束标志是一个 \0 的转义字符。在计算字符串长度的时候 \0 是结束标志，不算作字符串内容<br>注：使用<strong>strlen</strong>计算字符串长度时会将\0一并算入</p></blockquote><table><thead><tr><th>转义字符</th><th>x&nbsp;#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#include&lt;math.h&gt;​//写一个代码,打印100~200之间的素数//素数-质数//只能被1和他本身整除​//代码优化1：//m=a<em>b;//a和b中一定至少有一个数字是 &lt;=开平方m的//16 = 2</em>8 = 4*4//所以，大于开平方m的就不需要判断是否为m的因子，减少循环执行次数​//sqrt用于计算开平方的函数 -需要用到库函数 math.h//减少了循环的执行次数​//代码优化2：//偶数不可能是素数//修改for (i = 100; i &lt;= 200; i <ins>)为for (i = 101; i &lt;= 200; i += 2)​int main(){    int i, j = 0;​    //判断i是不是质数    for (i = 101; i &lt;= 200; i += 2)    {        int flag = 1;//定义一个参数，检测i是否能被 除了1和它本身的数 整除​        for (j = 2; j &lt;= sqrt(i); j</ins>)        {            if (i % j == 0)            {                flag = 0;//如果能被2到i-1之间的整除，记录flag=0;                //break;            }        }​        if (flag == 1)//不能被2到i-1之间的数整除        {            printf("%d是质数\n", i);//那么i就是质数        }    }    return 0;}c</th></tr></thead><tbody><tr><td>?</td><td>在书写连续多个问号时使用，防止他们被解析成三字母词</td></tr><tr><td>’</td><td>用于表示字符常量’</td></tr><tr><td>\“</td><td>用于表示一个字符串内部的双引号</td></tr><tr><td>\</td><td>用于表示一个反斜杠，防止它被解释为一个转义序列符。</td></tr><tr><td>\a</td><td>警告字符，蜂鸣</td></tr><tr><td>\b</td><td>退格符</td></tr><tr><td>\f</td><td>进纸符</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\ddd</td><td>ddd表示1~3个八进制的数字。 如： \130 X</td></tr><tr><td>\xdd</td><td>dd表示2个十六进制数字。 如： \x30 0</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串就是一串字符 - 用双引号括起来的一串字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="string">"abcdef"</span>;</span><br><span class="line"><span class="string">"hello bit"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//字符数组 - 数组是一组形同类型的元素</span></span><br><span class="line"><span class="comment">//字符串在结尾的位置隐藏了一个\0的字符</span></span><br><span class="line"><span class="comment">//\0是字符串的结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char arr[] = "hello";</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr1[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="type">char</span> arr2[] = {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">//求一下字符串的长度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(arr1));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(arr2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//int len = strlen("abc");//string length</span></span><br><span class="line"><span class="comment">//printf("%d\n", len);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印字符串</span></span><br><span class="line"><span class="comment">//printf("%s\n", arr1);</span></span><br><span class="line"><span class="comment">//printf("%s\n", arr2);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("c:\test\test.c");</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ab\ncd"</span>);<span class="comment">//\+n</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("(are you ok??)");//??) -- ] - 三字母词</span></span><br><span class="line"><span class="comment">//(are you ok]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//printf("%c\n", '\'');</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"abc"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"\""</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"'"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"c:\\test\\test.c"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf在打印数据的时候，可以指定打印的格式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="string">"abc"</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="四-ascii码"><a class="markdownIt-Anchor" href="#四-ascii码"></a> 四、ASCII码</h3><p><a href="https://c.biancheng.net/c/ascii/">ASCII码一览表</a></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("%c\n", '\130');//8进制的130是十进制的多少呢？</span></span><br><span class="line"><span class="comment">//X   -- ASCII码值是88</span></span><br><span class="line"><span class="comment">//printf("%c\n", '\101');//A - 65 - 8进制是：101</span></span><br><span class="line"><span class="comment">//printf("%c\n", '\x30');//48 - '0'</span></span><br><span class="line"><span class="comment">//printf("%d\n", strlen("abc"));//3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(<span class="string">"c:\test\328\test.c"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="c语言的注释"><a class="markdownIt-Anchor" href="#c语言的注释"></a> #C语言的注释</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">注释: 是用来解释复杂代码的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//int a = 10; //C++注释风格</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int b = 0;</span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line"><span class="comment">//C语言的注释风格 - 不支持嵌套注释</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="c语言的语句"><a class="markdownIt-Anchor" href="#c语言的语句"></a> #C语言的语句</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;<span class="comment">//输入的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"加入比特:&gt;\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"那要好好学习吗(1/0)?&gt;:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (input == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"好offer\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{ </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"卖红薯\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">比特 - <span class="number">30000</span>代码 - 找一个不错的工作</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> line = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">while</span>(line&lt;<span class="number">30000</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"写代码:%d\n"</span>, line);</span><br><span class="line">line++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (line == <span class="number">30000</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"好offer\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="函数概念"><a class="markdownIt-Anchor" href="#函数概念"></a> #函数概念</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line">z = x + y;</span><br><span class="line"><span class="keyword">return</span> z;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;num1, &amp;num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//int sum = num1 + num2;</span></span><br><span class="line"><span class="comment">//函数的方式解决</span></span><br><span class="line"><span class="type">int</span> sum = Add(num1, num2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="数组概念"><a class="markdownIt-Anchor" href="#数组概念"></a> #数组概念</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//int a = 1;</span></span><br><span class="line"><span class="comment">//int b = 2;</span></span><br><span class="line"><span class="comment">//int c = 3;</span></span><br><span class="line"><span class="comment">//int d = 4;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组 - 一组相同类型的元素的集合</span></span><br><span class="line"><span class="comment">//10个整形1-10存起来</span></span><br><span class="line"><span class="comment">//数组是用下标来访问的</span></span><br><span class="line"><span class="comment">//*</span></span><br><span class="line"><span class="comment">// /</span></span><br><span class="line"><span class="comment">//int arr[10] = {1,2,3,4,5,6,7,8,9,10};</span></span><br><span class="line"><span class="comment">//int i = 0;</span></span><br><span class="line"><span class="comment">//while (i &lt; 10)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//printf("%d ", arr[i]);</span></span><br><span class="line"><span class="comment">//i++;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">////char ch[5] = {'a', 'b', 'c'};//不完全初始化，剩余的默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 9 / 2;</span></span><br><span class="line"><span class="comment">//float a = 9 / 2.0;</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span> % <span class="number">2</span>;<span class="comment">//% - 取模（余）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="c语言的操作符和关键字"><a class="markdownIt-Anchor" href="#c语言的操作符和关键字"></a> #c语言的操作符和关键字</h3><p>基本操作符</p><p>常见关键字<br><img src="../img/447d/1cc8c8fe87ff45d5951b158a2fff6ab5-1.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//关于操作符的补充</span></span><br><span class="line"><span class="comment">//+ - * / % </span></span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span> / <span class="number">2</span>;<span class="comment">//整数除法</span></span><br><span class="line"><span class="type">float</span> b = <span class="number">9</span> / <span class="number">2</span>;<span class="comment">//整数除法</span></span><br><span class="line"><span class="type">float</span> c = <span class="number">9</span> / <span class="number">2.0</span>;<span class="comment">//输出为小数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, c);<span class="comment">//正确结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移位操作符</span></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">2</span>;<span class="comment">//0010,此处省略n个0...</span></span><br><span class="line"><span class="type">int</span> b1 = a1 &lt;&lt; <span class="number">1</span>;<span class="comment">//左移操作符，移动的是二进制位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b1);<span class="comment">//0100</span></span><br><span class="line"><span class="comment">//位操作符：&amp; 按位与 | 按位或 ^ 按位异或</span></span><br><span class="line"><span class="comment">//赋值操作符 += -= *= /= ...</span></span><br><span class="line"><span class="comment">//单目操作符：!（逻辑取反） - + &amp;  </span></span><br><span class="line"><span class="comment">// *:间接访问操作符（解引用操作符）</span></span><br><span class="line"><span class="comment">//PS: a+b 有两个操作数，此处+为双目操作符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof是一个操作符，不是函数</span></span><br><span class="line"><span class="keyword">sizeof</span>(a);<span class="comment">//通常使用方法</span></span><br><span class="line"><span class="keyword">sizeof</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, !a);<span class="comment">//非0即真</span></span><br><span class="line">a = -a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//mark:为什么a按位取反后，输出结果为-1;</span></span><br><span class="line"><span class="comment">//~</span></span><br><span class="line">    a = <span class="number">0</span>;<span class="comment">//二进制位32个bit</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ~a);<span class="comment">//结果为-1，按位取反，位即二进制位，按位取反包括符号位（bit31)，补码反码转换符号位不变</span></span><br><span class="line"><span class="comment">//数据在内存中存储的是补码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int b = (++a) + (++a) + (++a);//不建议使用的表达</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"><span class="comment">//int a = (int)3.14;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;&amp;逻辑与 ||逻辑或</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//条件操作符（三目操作符）? :</span></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a2 &gt; b2)</span><br><span class="line">{</span><br><span class="line">max = a2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">max = b2;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max);</span><br><span class="line"></span><br><span class="line">max = a2 &gt; b2 ? a2 : b2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max);</span><br><span class="line"></span><br><span class="line"><span class="comment">//逗号表达式</span></span><br><span class="line"><span class="comment">//逗号表达式从左向右依次计算</span></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b3 = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> c3 = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> d3 = (a3 = b3 + <span class="number">3</span>, b3 = c3 - a3, c3 = a3 + b3);</span><br><span class="line"><span class="comment">//整个表达式是结果是最后一个表达式的结果</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, d3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下标引用，函数调用和结构成员</span></span><br><span class="line"><span class="comment">//[] () , -&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数的时候，函数名后面的()</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hi\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言的关键字</span></span><br><span class="line"><span class="comment">//1.无法自己创建</span></span><br><span class="line"><span class="comment">//2.不能作变量名</span></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a0 = <span class="number">10</span>;<span class="comment">//自动创建，自动销毁 -自动变量</span></span><br><span class="line"><span class="comment">//auto 通常省略</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//extern用来申明外部符号</span></span><br><span class="line"><span class="comment">//register寄存器关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//频繁被使用的数据，可以存储在寄存器中，提升效率</span></span><br><span class="line"><span class="comment">//计算机中效率最快的是寄存器</span></span><br><span class="line"><span class="comment">//现代编译器会自动将数据处理到寄存器中，所以register一般不使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> Number = <span class="number">849797</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//signed 有符号的 10 -10</span></span><br><span class="line"><span class="comment">//unsigned 无符号的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static 静态的</span></span><br><span class="line"><span class="comment">//union 联合体(共用体）</span></span><br><span class="line"><span class="comment">//void 无 空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//volatile</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//类型重命名</span></span><br><span class="line"><span class="comment">//define,include不是关键字，为预处理命令</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num11 = <span class="number">100</span>;</span><br><span class="line">u_int num2 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="内存本质"><a class="markdownIt-Anchor" href="#内存本质"></a> #内存本质</h3><p><img src="https://img-blog.csdnimg.cn/direct/b0be605535994a9aaaa292c9d1f0eaba.png" alt=""></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结：</strong></h1><h3 id="计算机原理补充"><a class="markdownIt-Anchor" href="#计算机原理补充"></a> 计算机原理补充：</h3><p><mark>变量的二进制本质上是32位bit的,最高位为符号位，用&amp;按位取反时会改变所有位</mark></p><p><mark>整数在内存中存储的是补码</mark></p><p><mark>补码 -&gt;原码转换不会变符号位</mark></p><p><mark>一个内存单元大小为一个字节，然后再分配地址</mark></p><p><mark>1byte = 8bit</mark></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS2】OriginBot ROS2用指令</title>
      <link href="/posts/54789/"/>
      <url>/posts/54789/</url>
      
        <content type="html"><![CDATA[<h3 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3><p>每次对originbot的功能包参数进行修改后都要进行编译操作，命令如下<br><code>cd /userdata/dev_ws/</code><br><code>colcon build</code></p><h3 id="小车ssh远程连接"><a class="markdownIt-Anchor" href="#小车ssh远程连接"></a> 小车ssh远程连接</h3><p><code>ssh root@192.168.238.81</code><br>在多类终端均可使用该命令</p><h3 id="建立dss连接"><a class="markdownIt-Anchor" href="#建立dss连接"></a> 建立DSS连接</h3><p><code>export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp</code><br><code>CYCLONEDDS_URI='&lt;CycloneDDS&gt;&lt;Domain&gt;&lt;General&gt;&lt;NetworkInterfaceAddress&gt;ens33&lt;/NetworkInterfaceAddress&gt;&lt;/General&gt;&lt;/Domain&gt;&lt;/CycloneDDS&gt;'</code></p><h3 id="查看网络配置"><a class="markdownIt-Anchor" href="#查看网络配置"></a> 查看网络配置</h3><p><code>ifconfig</code><br><code>sudo apt install net-tools</code><br>才能使用ifcongfig命令</p><h3 id="关机"><a class="markdownIt-Anchor" href="#关机"></a> 关机</h3><p><code>halt</code></p><p>xxxxxxxxxx&nbsp;git remote add [alias] [url]//参数[alias]为别名， [url]为远程仓库的地址bash</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> ROS </category>
          
          <category> Linux </category>
          
          <category> RDK X3 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> RDK X3 </tag>
            
            <tag> Originbot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first blog</title>
      <link href="/posts/63785/"/>
      <url>/posts/63785/</url>
      
        <content type="html"><![CDATA[<h2 id="声明本站主要作为个人开发学习也欢迎各位分享知识和交流技术经验"><a class="markdownIt-Anchor" href="#声明本站主要作为个人开发学习也欢迎各位分享知识和交流技术经验"></a> 声明：本站主要作为个人开发学习，也欢迎各位分享知识和交流技术经验。</h2><h3 id="将在后续保持优化网站架构及内容更新"><a class="markdownIt-Anchor" href="#将在后续保持优化网站架构及内容更新"></a> 将在后续保持优化网站架构及内容更新</h3><h4 id="记录markdown错误写法-后面要加空格同理"><a class="markdownIt-Anchor" href="#记录markdown错误写法-后面要加空格同理"></a> 记录，markdown错误写法 ，-后面要加空格（#同理）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tags: </span><br><span class="line">-数字电路与VHDL设计<span class="string">"</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
