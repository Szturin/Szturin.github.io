<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Turin&#39;s Blog</title>
  
  <subtitle>数理照亮世界</subtitle>
  <link href="https://szturin.github.io/atom.xml" rel="self"/>
  
  <link href="https://szturin.github.io/"/>
  <updated>2024-05-03T06:03:42.583Z</updated>
  <id>https://szturin.github.io/</id>
  
  <author>
    <name>Szturin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【HEXO】[2] 多线程部署常见问题</title>
    <link href="https://szturin.github.io/posts/45608/"/>
    <id>https://szturin.github.io/posts/45608/</id>
    <published>2024-05-03T05:10:37.000Z</published>
    <updated>2024-05-03T06:03:42.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo部署到云服务器ubuntu系统"><a class="markdownIt-Anchor" href="#hexo部署到云服务器ubuntu系统"></a> HEXO部署到云服务器(Ubuntu系统)</h2><p><strong><a href="https://cloud.tencent.com/developer/article/1945550">Hexo部署至服务器（Ubuntu 20.04）-腾讯云开发者社区-腾讯云 (tencent.com)</a></strong></p><p><strong><a href="https://blog.cpen.top/posts/38874.html">04_Hexo-多平台部署-云服务器-GitHub-Gitee | Mycpen</a></strong></p><h1 id="ubuntu允许root连接服务器"><a class="markdownIt-Anchor" href="#ubuntu允许root连接服务器"></a> Ubuntu允许root连接服务器</h1><p><a href="https://blog.csdn.net/crayon0/article/details/122272001">Linux开启ssh并允许root登录（ubuntu、centos、kalilinux）_ssh允许root远程登录-CSDN博客</a></p><blockquote><p>报错信息 “E45: ‘readonly’ option is set (add ! to override)” 是在使用 Vim 或 Neovim 文本编辑器时可能遇到的一个错误信息。当您尝试将更改写入以只读模式打开的文件时，就会出现这条信息。这种情况可能由几个原因引起，例如，您正在编辑的文件在文件系统级别启用了写保护，或者 Vim 打开了一个它认为不应该修改的文件（例如，系统配置文件或标记为“只读”的文件）。</p><p>要解决这个问题并强制 Vim 或 Neovim 尽管文件处于只读状态也要写入更改，您可以使用 <code>:w!</code> 命令，其中 <code>w</code> 代表“写入”，<code>!</code> 实际上意味着“强制”或“覆盖”。</p><p>下面是如何处理这种情况：</p><h3 id="如果您打算修改文件"><a class="markdownIt-Anchor" href="#如果您打算修改文件"></a> 如果您打算修改文件</h3><ol><li><p><strong>强制保存更改</strong>：如果您知道文件是安全可编辑的，且打算保存更改，可以使用 <code>:w!</code> 命令强制保存更改。这告诉 Vim 覆盖只读限制。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w!</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>更改文件权限</strong>：如果文件是只读的是因为文件系统权限，您可能需要在 Vim 外部更改其权限。例如，在类 Unix 系统（Linux、macOS）上，您可以使用 <code>chmod</code> 命令使文件可写。假设文件名为 <code>example.txt</code>；您可以使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +w example.txt</span><br></pre></td></tr></tbody></table></figure><p>然后，在 Vim 内尝试再次保存文件。</p></li></ol><h3 id="如果文件应保持不变"><a class="markdownIt-Anchor" href="#如果文件应保持不变"></a> 如果文件应保持不变</h3><p>如果文件应该是只读的，且您不小心做了更改或重新考虑了您的编辑，有几个操作您可以执行：</p><ol><li><p><strong>撤销更改</strong>：通过使用 Vim 中的撤销命令 <code>u</code> 手动撤销更改，直到您恢复到文件的原始状态。</p></li><li><p><strong>不保存并退出</strong>：如果您想退出 Vim 而不保存任何更改，可以使用 <code>:q!</code> 命令，它退出 Vim 且不保存。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="理解只读文件"><a class="markdownIt-Anchor" href="#理解只读文件"></a> 理解只读文件</h3><p>在决定覆盖其只读状态之前，了解文件为什么可能处于只读模式是很重要的。文件可以因各种原因而被设置为只读：</p><ul><li>文件可能在文件系统级别被标记为只读，以防止意外更改。</li><li>文件可能属于另一个用户或需要管理员权限才能修改。</li><li>Vim 可能会在检测到文件正在被另一个进程使用时，以只读模式打开文件。</li><li>某些配置或命令（如使用 <code>vim -R &lt;filename&gt;</code> 打开文件）可以指示 Vim 以只读模式打开文件。</li></ul><p>在尝试覆盖文件的只读状态之前，始终确保修改文件是恰当的。</p></blockquote><p><strong>root终端连接效果</strong></p><img src="/posts/45608/image-20240503134748284.png" class="" title="image-20240503134748284"><h2 id="公网ip访问blog网站"><a class="markdownIt-Anchor" href="#公网ip访问blog网站"></a> 公网ip访问Blog网站</h2><img src="/posts/45608/image-20240503135033425.png" class="" title="image-20240503135033425"><p><strong>总结：使用腾讯云服务器（Unbuntu系统）部署Hexo博客，踩雷无数。此次部署博主理解了Linux服务器的详细配置流程，blog网站的访问速度得到了大幅度的提升，免受”科学上网“之苦</strong></p><h1 id="hexo更新日志"><a class="markdownIt-Anchor" href="#hexo更新日志"></a> HEXO更新日志</h1><p><strong>2024.5.3</strong></p><ul><li>重要更新：将HEXO博客部署到腾讯云轻量化服务器，极大提升国内访问速度，访问ip地址：<a href="http://122.51.23.7/">Turin’s Blog - 数理照亮世界</a></li><li>优化主页文章卡片界面，参考文章：<a href="https://butterfly.zhheo.com/home.html">首页 | Butterfly主题美化教程 (zhheo.com)</a></li><li>优化网站页面显示效果：透明度。<a href="https://qianchenggit.github.io/2021/10/06/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E4%BD%BF%E7%94%A8%E4%B8%80%E5%9B%BE%E6%B5%81/">博客背景使用一图流 | QianChengGit の小森林</a></li></ul><h1 id="问题待解决"><a class="markdownIt-Anchor" href="#问题待解决"></a> 问题（待解决）</h1><h2 id="一-每次deploy需要输入服务器root密码"><a class="markdownIt-Anchor" href="#一-每次deploy需要输入服务器root密码"></a> 一、每次deploy需要输入服务器root密码</h2><h2 id="二-blog域名"><a class="markdownIt-Anchor" href="#二-blog域名"></a> 二、Blog域名</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hexo部署到云服务器ubuntu系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hexo部署到云服务器ubuntu系统&quot;&gt;&lt;/a&gt; HEXO部署到云服务器(Ubuntu系统)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="博客搭建" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/categories/Linux/Ubuntu/"/>
    
    
    <category term="HEXO" scheme="https://szturin.github.io/tags/HEXO/"/>
    
    <category term="博客" scheme="https://szturin.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="github" scheme="https://szturin.github.io/tags/github/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/tags/Ubuntu/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[软件操作]仿真调试</title>
    <link href="https://szturin.github.io/posts/45531/"/>
    <id>https://szturin.github.io/posts/45531/</id>
    <published>2024-04-27T07:26:45.000Z</published>
    <updated>2024-05-02T11:57:05.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软键盘"><a class="markdownIt-Anchor" href="#软键盘"></a> 软键盘</h1><img src="/posts/45531/image-20240427152809497.png" class="" title="image-20240427152809497"><h1 id="选择使用按键的属性"><a class="markdownIt-Anchor" href="#选择使用按键的属性"></a> 选择使用按键的属性</h1><img src="/posts/45531/image-20240427152840915.png" class="" title="image-20240427152840915">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软键盘&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软键盘&quot;&gt;&lt;/a&gt; 软键盘&lt;/h1&gt;
&lt;img src=&quot;/posts/45531/image-20240427152809497.png&quot; class=&quot;&quot; title=&quot;imag</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MPLAB" scheme="https://szturin.github.io/tags/MPLAB/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[8]AD/DA转换</title>
    <link href="https://szturin.github.io/posts/56223/"/>
    <id>https://szturin.github.io/posts/56223/</id>
    <published>2024-04-23T13:49:05.000Z</published>
    <updated>2024-05-02T12:06:14.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p><strong>配置ADC时钟的前分配比，配置APB2的分配，输入到ADCCLK</strong></p><p>void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);</p><p><strong>恢复缺省配置</strong></p><p>void ADC_DeInit(ADC_TypeDef* ADCx);</p><p><strong>ADC初始化</strong></p><p>void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>ADC上电</strong></p><p>void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>开启DMA输出信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>中断输出控制</strong></p><p>void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);</p><ul><li>用于控制某个中断能否通往NVIC</li></ul><p><strong>复位校准</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取复位校准状态</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>开始校准</strong></p><p>void ADC_StartCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取开始校准状态</strong></p><p>FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);</p><p><strong>ADC软件触发的函数</strong></p><p>void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>ADC获取软件转换状态</strong></p><p>FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);</p><ul><li><p>实际上是获取CR2的SWSTART这一位,但是SWSTART在开始ADC转换后直接清除，所以并不能通过这个函数获得是否开始转换的信息</p><img src="/posts/56223/image-20240423220300035.png" class="" title="image-20240423220300035"></li></ul><p><strong><mark>如何获取ADC是否开启的状态？</mark></strong></p><p><strong>获取标志位状态</strong></p><p>FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);</p><ul><li>可以调用这个函数,ADC_FLAG选择EOC,判断EOC标志位是否置1</li></ul><p><strong>每隔几个通道间断一次</strong></p><p>void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);</p><p><strong>是否启动间断模式</strong></p><p>void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC规则组通道配置</strong></mark></p><p>void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);</p><ul><li>ADCx</li><li>ADC_Channel：指定的通道</li><li>Rank：序列的位置</li><li>ADC_SampleTime：指定通道的采样时间</li></ul><p><strong>ADC外部触发转换控制（是否允许外部触发转换）</strong></p><p>void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC获取转换值</strong></mark></p><p>uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);</p><ul><li>获取AD转换的数据寄存器，读取转换结果</li></ul><p><strong>ADC获取双模式转换值</strong></p><p>uint32_t ADC_GetDualModeConversionValue(void);</p><p><strong>是否启动模拟看门狗</strong></p><p>void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);</p><p><strong>配置高低阈值</strong></p><p>void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);</p><p><strong>配置看门的通道</strong></p><p>void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);</p><p><strong>ADC温度传感器、内部参考电压控制</strong></p><p>void ADC_TempSensorVrefintCmd(FunctionalState NewState);</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;库函数解释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#库函数解释&quot;&gt;&lt;/a&gt; 库函数解释&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;配置ADC时钟的前分配比，配置APB2的分配，输入到ADCCLK&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="AD/DA转换" scheme="https://szturin.github.io/tags/AD-DA%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[7]编码器接口测速</title>
    <link href="https://szturin.github.io/posts/37664/"/>
    <id>https://szturin.github.io/posts/37664/</id>
    <published>2024-04-20T14:16:11.000Z</published>
    <updated>2024-05-02T12:05:41.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h2><blockquote><p><strong>定时器编码器配置</strong></p><p>void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,<br>uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);</p><ul><li>TIMx:选择定时器</li><li>TIM_EncoderMode: 选择编码器模式，T1单独计数，T2单独计数，T1/T2同时计数</li></ul><img src="/posts/37664/image-20240420235549817.png" class="" title="image-20240420235549817"><ul><li>TIM_IC1Polarity：电平极性</li><li>TIM_IC2Polarity：电平极性  可以通过配置这两个参数，设置正相和反相</li></ul><img src="/posts/37664/image-20240420235814820.png" class="" title="image-20240420235814820"></blockquote><h2 id="编码器测计数"><a class="markdownIt-Anchor" href="#编码器测计数"></a> 编码器测计数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM3);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">1</span><span class="number">-1</span>;<span class="comment">//PSC 不分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">65536</span> - <span class="number">1</span>;<span class="comment">//ARR </span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line">TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获单元配置*/</span></span><br><span class="line"><span class="comment">/**通道1配置**/</span></span><br><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">    TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="comment">//给结构体赋初始值，防止出现不确定的状态</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发  TIM_EncoderInterfaceConfig重复配置了相同的寄存器</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line">    <span class="comment">/**通道2配置**/</span> <span class="comment">//注意：这里不需要再定义新的结构体。因为上一次的值已经写入硬件寄存器</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_2;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置编码器接口*/</span></span><br><span class="line">    TIM_EncoderInterfaceConfig(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//定时器3 ，T1T2同时使用，极性相同(上升沿/下降沿两个都是有效的)，即为正相</span></span><br><span class="line">    <span class="comment">//若要反相，那么一个配置位上升沿，一个配置为下降沿有效</span></span><br><span class="line">TIM_Cmd(TIM3,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//int16_t 表示有符号数，能把unint16_相比最高位变为了符号位,这里利用到了补码的特性</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> TIM_GetCounter(TIM3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="编码器测速"><a class="markdownIt-Anchor" href="#编码器测速"></a> 编码器测速</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关库函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#相关库函数&quot;&gt;&lt;/a&gt; 相关库函数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定时器编码器配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void TIM_EncoderI</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="输入捕获" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/"/>
    
    <category term="输出比较" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】方波发生器-电子琴</title>
    <link href="https://szturin.github.io/posts/46544/"/>
    <id>https://szturin.github.io/posts/46544/</id>
    <published>2024-04-16T10:23:27.000Z</published>
    <updated>2024-05-02T11:57:58.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何得到精准的250us定时"><a class="markdownIt-Anchor" href="#如何得到精准的250us定时"></a> 如何得到精准的250us定时？</h1><p><strong>先确认大概的定时器计数器值，再利用跑马表调整误差</strong></p><img src="/posts/46544/image-20240416182439723.png" class="" title="image-20240416182439723">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何得到精准的250us定时&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何得到精准的250us定时&quot;&gt;&lt;/a&gt; 如何得到精准的250us定时？&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;先确认大概的定时器计数器值，再利用跑马表调整误差&lt;/s</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="项目设计学习" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MPLAB" scheme="https://szturin.github.io/tags/MPLAB/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[软件操作]-跑马表</title>
    <link href="https://szturin.github.io/posts/15341/"/>
    <id>https://szturin.github.io/posts/15341/</id>
    <published>2024-04-05T07:21:38.000Z</published>
    <updated>2024-05-02T11:57:14.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何打开stop-watch窗口"><a class="markdownIt-Anchor" href="#如何打开stop-watch窗口"></a> 如何打开Stop Watch窗口？</h1><blockquote><p><strong>在DEBUG下选mplab sim后，再点DEBUGSETTING来设好频率，设好后点stopwatch</strong></p></blockquote><h1 id="跑马表仿真测试"><a class="markdownIt-Anchor" href="#跑马表仿真测试"></a> 跑马表仿真测试</h1><p><mark>在中断<strong>对应</strong>的位置打上断点，点击仿真运行，即可通过跑马表查看每次进中断的运行时间</mark></p><img src="/posts/15341/image-20240405155601030.png" class="" title="image-20240405155601030"><h1 id="车辆里程表"><a class="markdownIt-Anchor" href="#车辆里程表"></a> 车辆里程表</h1><h2 id="proteus仿真"><a class="markdownIt-Anchor" href="#proteus仿真"></a> proteus仿真</h2><p><mark>可以通过工具栏<strong>调试</strong>选项</mark>，查看各个所需的调试窗口，运行调试工具。</p><p>ps:<strong>step into</strong>可以跳过断点</p><img src="/posts/15341/image-20240405170845407.png" class="" title="image-20240405170845407"><p>第二次进中断，LED灯点亮</p><img src="/posts/15341/image-20240405171351683.png" class="" title="image-20240405171351683"><p>ps:<strong>cof为仿真文件,hex为下载文件</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何打开stop-watch窗口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何打开stop-watch窗口&quot;&gt;&lt;/a&gt; 如何打开Stop Watch窗口？&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在DEBUG下选</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MPLAB" scheme="https://szturin.github.io/tags/MPLAB/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[2]中断系统</title>
    <link href="https://szturin.github.io/posts/18816/"/>
    <id>https://szturin.github.io/posts/18816/</id>
    <published>2024-03-27T13:27:47.000Z</published>
    <updated>2024-05-02T11:56:39.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="保护现场"><a class="markdownIt-Anchor" href="#保护现场"></a> 保护现场</h2><img src="/posts/18816/image-20240327212904491.png" class="" title="image-20240327212904491">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;保护现场&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#保护现场&quot;&gt;&lt;/a&gt; 保护现场&lt;/h2&gt;
&lt;img src=&quot;/posts/18816/image-20240327212904491.png&quot; class=&quot;&quot; title=&quot;i</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【单片机】串口通信</title>
    <link href="https://szturin.github.io/posts/25165/"/>
    <id>https://szturin.github.io/posts/25165/</id>
    <published>2024-03-23T11:29:59.000Z</published>
    <updated>2024-05-02T08:02:59.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯部分"><a class="markdownIt-Anchor" href="#蓝桥杯部分"></a> 蓝桥杯部分</h1><h2 id="1串口底层"><a class="markdownIt-Anchor" href="#1串口底层"></a> 1.串口底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字节发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line">SBUF=dat;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Send_String</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(*dat != <span class="string">'\0'</span>)<span class="comment">//当字符不为空时，继续发送</span></span><br><span class="line">SendByte(*dat++);<span class="comment">//发送后指针dat加1，指向下一个字节</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2单片机发送字符串给上位机"><a class="markdownIt-Anchor" href="#2单片机发送字符串给上位机"></a> 2.单片机发送字符串给上位机</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0x7F</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0xF0</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL0 = <span class="number">0x18</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF0 = <span class="number">0</span>;<span class="comment">//清除TF0标志</span></span><br><span class="line">TR0 = <span class="number">1</span>;<span class="comment">//定时器0开始计时</span></span><br><span class="line">ET0 = <span class="number">1</span>;    <span class="comment">//定时器中断0打开</span></span><br><span class="line">EA = <span class="number">1</span>;     <span class="comment">//总中断打开</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay500ms</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">23</span>;</span><br><span class="line">j = <span class="number">205</span>;</span><br><span class="line">k = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (--k);</span><br><span class="line">} <span class="keyword">while</span> (--j);</span><br><span class="line">} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"></span><br><span class="line">Uart1_Init();</span><br><span class="line"></span><br><span class="line">Delay500ms();<span class="comment">//mark:初始化后若立即发送数据，第一个字节会重复发送，所以先延时500ms,等待UART稳定工作，再发送字符串</span></span><br><span class="line"></span><br><span class="line">Uart1_SendString(<span class="string">"Hello UART"</span>);<span class="comment">//字符串发送数据在开启定时器中断时容易被打断,第一个字节刚好卡在没发完的时刻,造成死循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行任务</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//Key_Proc();</span></span><br><span class="line"><span class="comment">//Nixie_Proc();</span></span><br><span class="line"><span class="comment">//LED_Proc();</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3上位机发送字符串给单片机"><a class="markdownIt-Anchor" href="#3上位机发送字符串给单片机"></a> 3.上位机发送字符串给单片机</h2><p><strong><mark>PS:按键4可发送单片机接收到的字符串给上位机</mark></strong></p><h3 id="串口处理模块"><a class="markdownIt-Anchor" href="#串口处理模块"></a> 串口处理模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData[Uart_RecData_Index]=SBUF;</span><br><span class="line">Uart_RecData_Index++;</span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="按键程序"><a class="markdownIt-Anchor" href="#按键程序"></a> 按键程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Key_Down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">Uart_SendDataFlag=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中断程序"><a class="markdownIt-Anchor" href="#中断程序"></a> 中断程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData[Uart_RecData_Index]=SBUF;</span><br><span class="line">Uart_RecData_Index++;</span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Uart_Timer==<span class="number">100</span>){Uart_Timer=<span class="number">0</span>;}</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">10</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Uart_SendDataFlag==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_SendDataFlag=<span class="number">0</span>;</span><br><span class="line">Uart1_SendString(Uart_RecData);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4上位机发送数据控制单片机led"><a class="markdownIt-Anchor" href="#4上位机发送数据控制单片机led"></a> 4.上位机发送数据控制单片机LED</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Uart_Timer)<span class="keyword">return</span>;</span><br><span class="line">Uart_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if(Uart_RecData[Uart_RecData_Index-1]==0x0a &amp;&amp; Uart_RecData[Uart_RecData_Index-2]==0x0d) //0x0a--&gt;'\n' 0x0d--&gt;'\r'</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//if(Uart_RecData_Index==9 &amp;&amp; Uart_RecData[0]=='L' &amp;&amp; Uart_RecData[1]=='E' &amp;&amp; Uart_RecData[2]=='D' &amp;&amp; Uart_RecData[3]=='1' &amp;&amp; Uart_RecData[4]=='='&amp;&amp;Uart_RecData[5]=='1')</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//ucLED[0]=1;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="keyword">if</span>(Uart_RecData[Uart_RecData_Index<span class="number">-1</span>]==<span class="number">0x0a</span> &amp;&amp; Uart_RecData[Uart_RecData_Index<span class="number">-2</span>]==<span class="number">0x0d</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Uart_RecData_Index==<span class="number">8</span> &amp;&amp; Uart_RecData[<span class="number">0</span>]==<span class="string">'L'</span> &amp;&amp; Uart_RecData[<span class="number">1</span>]==<span class="string">'E'</span> &amp;&amp; Uart_RecData[<span class="number">2</span>]==<span class="string">'D'</span> &amp;&amp; Uart_RecData[<span class="number">3</span>]==<span class="string">'1'</span> &amp;&amp; Uart_RecData[<span class="number">4</span>]==<span class="string">'='</span>&amp;&amp;Uart_RecData[<span class="number">5</span>]==<span class="string">'1'</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2串口优化"><a class="markdownIt-Anchor" href="#2串口优化"></a> 2.串口优化</h2><h3 id="putchar重定向"><a class="markdownIt-Anchor" href="#putchar重定向"></a> putchar重定向</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> <span class="title function_">putchar</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">    SBUF=ch; <span class="comment">///将dat数据</span></span><br><span class="line">    <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">    TI=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>(ch);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;蓝桥杯部分&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#蓝桥杯部分&quot;&gt;&lt;/a&gt; 蓝桥杯部分&lt;/h1&gt;
&lt;h2 id=&quot;1串口底层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1串口底层&quot;&gt;&lt;/a&gt; 1.串</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯单片机】考点复盘1</title>
    <link href="https://szturin.github.io/posts/5903/"/>
    <id>https://szturin.github.io/posts/5903/</id>
    <published>2024-03-23T08:33:10.000Z</published>
    <updated>2024-05-02T08:08:15.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-led模块"><a class="markdownIt-Anchor" href="#一-led模块"></a> 一、LED模块</h1><h2 id="1led底层代码"><a class="markdownIt-Anchor" href="#1led底层代码"></a> 1.LED底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Led_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr, enable)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp = <span class="number">0x00</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span> (enable)</span><br><span class="line">        temp |= <span class="number">0x01</span> &lt;&lt; addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp &amp;= ~(<span class="number">0x01</span> &lt;&lt; addr);</span><br><span class="line">   <span class="keyword">if</span> (temp != temp_old)</span><br><span class="line">    {</span><br><span class="line">        P0 = ~temp;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0x80</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式"><a class="markdownIt-Anchor" href="#2基本调用方式"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ucLED[n]=x;</span><br><span class="line"></span><br><span class="line">中断程序</span><br><span class="line">{</span><br><span class="line">    Led_Disp(Nixie_Pos,ucLED[Nixie_Pos]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二-按键模块"><a class="markdownIt-Anchor" href="#二-按键模块"></a> 二、按键模块</h1><h2 id="1按键底层代码"><a class="markdownIt-Anchor" href="#1按键底层代码"></a> 1.按键底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Read</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp = <span class="number">0</span>;</span><br><span class="line">    ET0 = <span class="number">0</span>;</span><br><span class="line">    P44 = <span class="number">0</span>;P42 = <span class="number">1</span>;P35 = <span class="number">1</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">7</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">0</span>;P35 = <span class="number">1</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">11</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">1</span>;P35 = <span class="number">0</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">15</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">1</span>;P35 = <span class="number">1</span>;P34 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">19</span>;</span><br><span class="line">    P3 = <span class="number">0xff</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式-2"><a class="markdownIt-Anchor" href="#2基本调用方式-2"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(Key_Down)<span class="comment">//下降沿</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">case</span> X:</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="23-模式切换"><a class="markdownIt-Anchor" href="#23-模式切换"></a> <strong>2.3</strong> <strong>模式切换</strong></h4><img src="/posts/5903/clip_image002.jpg" class="" title="img"><p>第十届省赛真题</p><img src="/posts/5903/clip_image004.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="24-参数设置"><a class="markdownIt-Anchor" href="#24-参数设置"></a> <strong>2.4</strong> <strong>参数设置</strong></h4><img src="/posts/5903/clip_image006.jpg" class="" title="img"><p>第九届省赛真题</p><img src="/posts/5903/clip_image008.jpg" class="" title="img"><p>第八届省赛真题</p><h4 id="25-参数保存"><a class="markdownIt-Anchor" href="#25-参数保存"></a> <strong>2.5</strong> <strong>参数保存</strong></h4><img src="/posts/5903/clip_image010.jpg" class="" title="img"><p>第五届省赛真题</p><img src="/posts/5903/clip_image012.jpg" class="" title="img"><p>第十一届省赛真题</p><h4 id="26-特定使能"><a class="markdownIt-Anchor" href="#26-特定使能"></a> <strong>2.6</strong> <strong>特定使能</strong></h4><img src="/posts/5903/clip_image014.jpg" class="" title="img"><p>第十一届省赛真题</p><h4 id="27-长按跳转-松手返回"><a class="markdownIt-Anchor" href="#27-长按跳转-松手返回"></a> <strong>2.7</strong> <strong>长按跳转 松手返回</strong></h4><img src="/posts/5903/clip_image016.jpg" class="" title="img"><p>第八届省赛真题</p><h4 id="28-键盘输入"><a class="markdownIt-Anchor" href="#28-键盘输入"></a> <strong>2.8</strong> <strong>键盘输入</strong></h4><img src="/posts/5903/clip_image017.png" class="" title="img"><p>模拟训练二</p><h4 id="29-长按短按-效果不同"><a class="markdownIt-Anchor" href="#29-长按短按-效果不同"></a> <strong>2.9</strong> <strong>长按短按 效果不同</strong></h4><img src="/posts/5903/clip_image019.jpg" class="" title="img"><h1 id="三-数码管模块"><a class="markdownIt-Anchor" href="#三-数码管模块"></a> 三、数码管模块</h1><h2 id="1数码管底层代码"><a class="markdownIt-Anchor" href="#1数码管底层代码"></a> 1.数码管底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg_dula[] = {<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0xff</span>};</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg_wela[] = {<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Seg_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> wela,dula,point)</span></span><br><span class="line">{</span><br><span class="line">    P0 = <span class="number">0xff</span>;</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xe0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line"></span><br><span class="line">    P0 = seg_wela[wela];</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xc0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">    </span><br><span class="line">    P0 = seg_dula[dula];</span><br><span class="line">    <span class="keyword">if</span>(point)</span><br><span class="line">        P0 &amp;= <span class="number">0x7f</span>;</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xe0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>; </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式-3"><a class="markdownIt-Anchor" href="#2基本调用方式-3"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Seg_Buf[X] = Y;</span><br><span class="line">Seg_Point[X] = Y;</span><br></pre></td></tr></tbody></table></figure><h4 id="33-显示整数变量"><a class="markdownIt-Anchor" href="#33-显示整数变量"></a> <strong>3.3</strong> <strong>显示整数变量</strong></h4><img src="/posts/5903/clip_image002-1711183567913-109.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="34-显示小数点变量"><a class="markdownIt-Anchor" href="#34-显示小数点变量"></a> <strong>3.4</strong> <strong>显示小数点变量</strong></h4><img src="/posts/5903/clip_image004-1711183567913-110.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="35-不同状态显示不同内容"><a class="markdownIt-Anchor" href="#35-不同状态显示不同内容"></a> <strong>3.5</strong> <strong>不同状态显示不同内容</strong></h4><img src="/posts/5903/clip_image006-1711183567914-112.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="36-高位熄灭"><a class="markdownIt-Anchor" href="#36-高位熄灭"></a> <strong>3.6</strong> <strong>高位熄灭</strong></h4><img src="/posts/5903/clip_image008-1711183567913-111.jpg" class="" title="img"><p>第十届省赛真题</p><h4 id="37-选中单元闪烁"><a class="markdownIt-Anchor" href="#37-选中单元闪烁"></a> <strong>3.7</strong> <strong>选中单元闪烁</strong></h4><img src="/posts/5903/clip_image010-1711183567914-113.jpg" class="" title="img"><p>第八届省赛真题</p><h1 id="四-继电器蜂鸣器"><a class="markdownIt-Anchor" href="#四-继电器蜂鸣器"></a> 四、继电器蜂鸣器</h1><h2 id="1底层代码"><a class="markdownIt-Anchor" href="#1底层代码"></a> 1.底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_1 = <span class="number">0x00</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old_1 = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Beep</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        temp_1 |= <span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp_1 &amp;= ~<span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">    {</span><br><span class="line">        P0 = temp_1;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old_1 = temp_1;        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Relay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        temp_1 |= <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp_1 &amp;= ~<span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">    {</span><br><span class="line">        P0 = temp_1;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old_1 = temp_1;        </span><br><span class="line">    }   </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>…</p><h1 id="ne555"><a class="markdownIt-Anchor" href="#ne555"></a> NE555</h1><p>绑定定时器0，应采用计数器模式</p><h1 id="超声波"><a class="markdownIt-Anchor" href="#超声波"></a> #超声波</h1><h2 id="1超声波底层代码"><a class="markdownIt-Anchor" href="#1超声波底层代码"></a> 1.超声波底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">()</span>        <span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">()</span> <span class="comment">//超声波初始化函数 产生8个40Mhz的方波信号</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        Tx = <span class="number">1</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">        Tx = <span class="number">0</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0f</span>;<span class="comment">//配置定时器1计时模式</span></span><br><span class="line">    TH1 = TL1 = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    TR1 = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (TF1 == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    TR1 = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(TF1 == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = TH1 &lt;&lt; <span class="number">8</span> | TL1;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        TF1 = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2pca写法"><a class="markdownIt-Anchor" href="#2pca写法"></a> 2.PCA写法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    CMOD =  <span class="number">0x00</span>;<span class="comment">//配置PCA工作模式</span></span><br><span class="line">    CH = CL = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    CR = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (CF == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    CR = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(CF == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = CH &lt;&lt; <span class="number">8</span> | CL;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        CF = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="串口"><a class="markdownIt-Anchor" href="#串口"></a> #串口</h1><h2 id="1串口底层"><a class="markdownIt-Anchor" href="#1串口底层"></a> 1.串口底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span>     <span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">    SCON = <span class="number">0x50</span>;        <span class="comment">//8位数据,可变波特率</span></span><br><span class="line">    AUXR |= <span class="number">0x01</span>;       <span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">    AUXR |= <span class="number">0x04</span>;       <span class="comment">//定时器时钟1T模式</span></span><br><span class="line">    T2L = <span class="number">0xC7</span>;     <span class="comment">//设置定时初始值</span></span><br><span class="line">    T2H = <span class="number">0xFE</span>;     <span class="comment">//设置定时初始值</span></span><br><span class="line">    AUXR |= <span class="number">0x10</span>;       <span class="comment">//定时器2开始计时</span></span><br><span class="line">    ES = <span class="number">1</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字节发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line">    SBUF=dat;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">    TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Send_String</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(*dat != <span class="string">'\0'</span>)<span class="comment">//当字符不为空时，继续发送</span></span><br><span class="line">        SendByte(*dat++);<span class="comment">//发送后指针dat加1，指向下一个字节</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口1中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1Server</span><span class="params">()</span> interrupt 4</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(RI == <span class="number">1</span>) <span class="comment">//串口接收数据</span></span><br><span class="line">    {</span><br><span class="line">        Uart_Recv[Uart_Recv_Index] = SBUF;</span><br><span class="line">        Uart_Recv_Index++;</span><br><span class="line">        RI = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-串口接收数据"><a class="markdownIt-Anchor" href="#2-串口接收数据"></a> **2. **串口接收数据</h2><p><strong>模拟题</strong></p><hr><img src="/posts/5903/clip_image002-1711190784499-119.jpg" class="" title="img"><hr><img src="/posts/5903/clip_image004-1711190784499-120.jpg" class="" title="img"><h2 id="3-串口发送数据"><a class="markdownIt-Anchor" href="#3-串口发送数据"></a> **3. **串口发送数据</h2><p><strong>模拟题</strong></p><hr><img src="/posts/5903/clip_image005.jpg" class="" title="img"><hr><img src="/posts/5903/clip_image006-1711190784499-121.jpg" class="" title="img"><ul><li><strong>内存溢出：idata/xdata/data/code</strong></li></ul><h2 id="第三部分-大模板"><a class="markdownIt-Anchor" href="#第三部分-大模板"></a> <mark>第三部分 大模板</mark></h2><h3 id="一-头文件声明区域"><a class="markdownIt-Anchor" href="#一-头文件声明区域"></a> 一、头文件声明区域</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件声明区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC15F2K60S2.H&gt;</span><span class="comment">//单片机寄存器专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span><span class="comment">//初始化底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Led.h&gt;</span><span class="comment">//Led底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span><span class="comment">//按键底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Seg.h&gt;</span><span class="comment">//数码管底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span><span class="comment">//串口底层驱动专用头文件</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="二-变量声明区域"><a class="markdownIt-Anchor" href="#二-变量声明区域"></a> 二、变量声明区域</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 变量声明区 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Val,Key_Down,Key_Old,Key_Up;<span class="comment">//按键专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Slow_Down;<span class="comment">//按键减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Buf[<span class="number">8</span>] = {<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Point[<span class="number">8</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管小数点数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Pos;<span class="comment">//数码管扫描专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Seg_Slow_Down;<span class="comment">//数码管减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLed[<span class="number">8</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//Led显示数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Slow_Down;<span class="comment">//串口减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Recv[<span class="number">10</span>];<span class="comment">//串口接收数据储存数组 默认10个字节 若接收数据较长 可更改最大字节数</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Recv_Index;<span class="comment">//串口接收数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Send[<span class="number">10</span>];<span class="comment">//串口接收数据储存数组 默认10个字节 若发送数据较长 可更改最大字节数</span></span><br></pre></td></tr></tbody></table></figure><h3 id="三-按键处理函数"><a class="markdownIt-Anchor" href="#三-按键处理函数"></a> 三、按键处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 键盘处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Key_Slow_Down) <span class="keyword">return</span>;<span class="comment">//作用：使得程序在每次定时扫描过程只执行一次，即Key_Slow_Down=0时立即置1，向下执行。</span></span><br><span class="line"></span><br><span class="line">  Key_Slow_Down = <span class="number">1</span>;<span class="comment">//键盘减速程序</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  Key_Val = Key_Read();<span class="comment">//实时读取键码值</span></span><br><span class="line"></span><br><span class="line">  Key_Down = Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//捕捉按键下降沿</span></span><br><span class="line"></span><br><span class="line">  Key_Up = ~Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//捕捉按键上降沿</span></span><br><span class="line"></span><br><span class="line">  Key_Old = Key_Val;<span class="comment">//辅助扫描变量</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="四-信息处理函数"><a class="markdownIt-Anchor" href="#四-信息处理函数"></a> 四、信息处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信息处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Seg_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Seg_Slow_Down) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Seg_Slow_Down = <span class="number">1</span>;<span class="comment">//数码管减速程序</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="五-其他显示函数"><a class="markdownIt-Anchor" href="#五-其他显示函数"></a> 五、其他显示函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 其他显示函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Led_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="六-串口处理函数"><a class="markdownIt-Anchor" href="#六-串口处理函数"></a> 六、串口处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Uart_Slow_Down) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Uart_Slow_Down = <span class="number">1</span>;<span class="comment">//串口减速程序 </span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="七-定时器初始化函数"><a class="markdownIt-Anchor" href="#七-定时器初始化函数"></a> 七、定时器初始化函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器0中断初始化函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0Init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  AUXR &amp;= <span class="number">0x7F</span>;    <span class="comment">//定时器时钟12T模式</span></span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;    <span class="comment">//设置定时器模式</span></span><br><span class="line"></span><br><span class="line">  TL0 = <span class="number">0x18</span>;   <span class="comment">//设置定时初始值</span></span><br><span class="line"></span><br><span class="line">  TH0 = <span class="number">0xFC</span>;   <span class="comment">//设置定时初始值</span></span><br><span class="line"></span><br><span class="line">  TF0 = <span class="number">0</span>;     <span class="comment">//清除TF0标志</span></span><br><span class="line"></span><br><span class="line">  TR0 = <span class="number">1</span>;     <span class="comment">//定时器0开始计时</span></span><br><span class="line"></span><br><span class="line">  ET0 = <span class="number">1</span>;   <span class="comment">//定时器中断0打开</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;   <span class="comment">//总中断打开</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="八-中断服务函数"><a class="markdownIt-Anchor" href="#八-中断服务函数"></a> 八、中断服务函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器0中断服务函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0Server</span><span class="params">()</span> interrupt 1</span><br><span class="line"></span><br><span class="line">{  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Key_Slow_Down == <span class="number">10</span>) Key_Slow_Down = <span class="number">0</span>;<span class="comment">//键盘减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Seg_Slow_Down == <span class="number">500</span>) Seg_Slow_Down = <span class="number">0</span>;<span class="comment">//数码管减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Uart_Slow_Down == <span class="number">200</span>) Uart_Slow_Down = <span class="number">0</span>;<span class="comment">//串口减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Seg_Pos == <span class="number">8</span>) Seg_Pos = <span class="number">0</span>;<span class="comment">//数码管显示专用</span></span><br><span class="line"></span><br><span class="line">  Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">  Led_Disp(Seg_Pos,ucLed[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="九-串口服务函数"><a class="markdownIt-Anchor" href="#九-串口服务函数"></a> 九、串口服务函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口1中断服务函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1Server</span><span class="params">()</span> interrupt 4</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(RI == <span class="number">1</span>) <span class="comment">//串口接收数据</span></span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line">      Uart_Recv[Uart_Recv_Index] = SBUF;</span><br><span class="line">  Uart_Recv_Index++;</span><br><span class="line">      RI = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="十-主函数"><a class="markdownIt-Anchor" href="#十-主函数"></a> 十、主函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  System_Init();</span><br><span class="line"></span><br><span class="line">  Timer0Init();</span><br><span class="line"></span><br><span class="line">  UartInit();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    Key_Proc();</span><br><span class="line"></span><br><span class="line">    Seg_Proc();</span><br><span class="line"></span><br><span class="line">    Led_Proc();</span><br><span class="line"></span><br><span class="line">    Uart_Proc();</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-led模块&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-led模块&quot;&gt;&lt;/a&gt; 一、LED模块&lt;/h1&gt;
&lt;h2 id=&quot;1led底层代码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1led底层</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="蓝桥杯" scheme="https://szturin.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="C语言" scheme="https://szturin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="STC15" scheme="https://szturin.github.io/tags/STC15/"/>
    
    <category term="蓝桥杯" scheme="https://szturin.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="数字电路" scheme="https://szturin.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[6]输入捕获和输出比较</title>
    <link href="https://szturin.github.io/posts/64385/"/>
    <id>https://szturin.github.io/posts/64385/</id>
    <published>2024-03-17T04:39:49.000Z</published>
    <updated>2024-05-02T12:05:23.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><p>4个输入捕获和输出比较通道，公用4个CCR寄存器</p><p>另外它们的CH1到CH4，4个通道的引脚，也是公用的</p><p>所以对于同一个定时器，输入捕获和输出比较只能用其中一个。</p><h2 id="一-输出比较"><a class="markdownIt-Anchor" href="#一-输出比较"></a> 一、输出比较</h2><img src="/posts/64385/image-20240317124437632.png" class="" title="image-20240317124437632"><img src="/posts/64385/image-20240317124510956.png" class="" title="image-20240317124510956"><p><strong>根据CNT和CCR的大小关系，从通道引脚输出高低电平</strong></p><h2 id="二-输入捕获"><a class="markdownIt-Anchor" href="#二-输入捕获"></a> 二、输入捕获</h2><img src="/posts/64385/image-20240317124716864.png" class="" title="image-20240317124716864"><img src="/posts/64385/image-20240317124815682.png" class="" title="image-20240317124815682"><p>输入滤波器：可以对毛刺信号进行滤波</p><p>交叉输入的作用？</p><p>TRC?</p><p>CNT计数器是由内部的标准时钟进行驱动的，可以用于测量外部检测两个上升沿的时间间隔，</p><p>所以需要在检测到一个上升沿过后，清零CNT，这样在第二次上升沿后，CNT值就是测周法的N，可以通过主从触发模式，自动完成。</p><p><strong>总结：</strong></p><p>输入捕获类似于外部中断。都是检测边沿，然后执行相应的动嘴，而在输入捕获中。检测到指定电平跳变后，CNT的值所存到CCR中。</p><ul><li><p>输出比较。引脚是输出端口，根据CNT和CCR的大小关系执行输出的动作。</p></li><li><p>输入捕获。引脚是输入端口，接收到输入信号，执行锁存的动作。</p></li></ul><p><strong>#主从触发模式：</strong></p><p>将主从触发模式和PWMI模式相结合，可以让硬件自动测量频率和占空比，软件无需进行干预。</p><h2 id="三-频率测量"><a class="markdownIt-Anchor" href="#三-频率测量"></a> 三、频率测量</h2><img src="/posts/64385/image-20240317125647320.png" class="" title="image-20240317125647320"><p><strong>PS：STM32测频率只能测量数字信号，若测量正选波，可以用运放电路搭建一个比较器。若测量的信号电压较高，需要考虑隔离的问题，比如隔离放大器，电压互感器等元件。总而言之，要用STM32测量频率，只能用数字信号，高电平3.3V，低电平0V</strong></p><p><strong>#区别</strong></p><ul><li><p>测频法：规定时间，记录上升沿次数，<mark>适合测量高频信号</mark>。在计次N过少时，误差会比较大。</p><p>​测频法自带均值滤波，得到的其实是平均频率。</p></li><li><p>测周法：从待测频率的第一个上升沿开始，以一个标准的频率计次，记录计数器的次数，直到检测到待测频率信号的第二个上升沿。<mark>适合测量低频信号</mark>，低频信号，周期长，计次多，有利于减小误差。</p><p>一般情况下，待测信号几百几千HZ以上，测周法更新更快，又因为测周法只测量一个周期，所以结果容易收到噪声的影响，波动较大。</p></li><li><p>两种方法都会出现正负1误差</p></li></ul><p>#<strong>中界频率</strong></p><ul><li>用于界定选用测频法还是测周法的频率</li></ul><h2 id="四-输入捕获通道"><a class="markdownIt-Anchor" href="#四-输入捕获通道"></a> 四、输入捕获通道</h2><img src="/posts/64385/image-20240317133236546.png" class="" title="image-20240317133236546"><p><mark>fDTS是滤波器的采样时钟来源。TI1是输入信号，TI1F是滤波后的信号，CCMR1寄存器中的ICF位可以控制滤波器的参数</mark></p><p>​ICF相关定义</p><img src="/posts/64385/image-20240317133728716.png" class="" title="image-20240317133728716"><p>滤波之后的信号通过后续的边沿检测器，并且可以通过CCIP选择极性。最终得到TI1FP1的触发信号，进入通道1后续的捕获电路。同样的，通道2也是一样的流程，不过图中省略了。</p><p>CC1E位，控制输出使能或失能。</p><p><strong>如何自动清零CNT？</strong></p><h3 id="主从触发模式"><a class="markdownIt-Anchor" href="#主从触发模式"></a> 主从触发模式</h3><img src="/posts/64385/image-20240317134635166.png" class="" title="image-20240317134635166"><ul><li><p>主模式可以将定时器内部的信号，映射到TRGO引脚，用于触发别的外设</p></li><li><p>从模式接收其他外设或者自身外设的一些信号，用于控制自身定时器的运行。</p></li></ul><p><strong>这里将TI1FP1作为触发源，从模式执行Reset操作，这样就可以实现CNT自动清零。</strong></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><h3 id="输入捕获基本结构"><a class="markdownIt-Anchor" href="#输入捕获基本结构"></a> 输入捕获基本结构</h3><img src="/posts/64385/image-20240317135641144.png" class="" title="image-20240317135641144"><p>这个结构只使用了一个通道，只能用于测量频率。</p><p>先转运CNT，再对CNT进行清零。</p><p>使用从模式自动清零CNT，只能用通道1和通道2。</p><h3 id="pwmi基本结构"><a class="markdownIt-Anchor" href="#pwmi基本结构"></a> PWMI基本结构</h3><img src="/posts/64385/image-20240317140209540.png" class="" title="image-20240317140209540"><p>开始，第一个上升沿，CCR1捕获并且清零CNT，CNT++。第一个下降沿，CCR2捕获CNT，但不会执行CNT清零。第二个上升沿，CCR1捕获CNT，同时CNT清零。</p><p>这样CCR1值就是整个周期的计数值，CCR2就是高电平期间的计数值。这样可以同时得到PWM的频率和占空比。</p><p>这里也可以配置两个通道同时捕获第二个引脚的输入，使用TI2FP1和TI2FP2两个引脚。</p><h1 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> 代码部分</h1><blockquote><hr><p><strong>单独修改PSR值</strong></p><p>void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)</p><ul><li>TIMx：定时器</li><li>Prescaler：PSR值</li><li>TIM_PSCReloadMode：指定定时器预分频器的重装模式<ul><li>@arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event. 在更新事件中 重装<ul><li><pre><code>@arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately. 立即重装</code></pre></li></ul></li></ul></li></ul><hr><p><strong>输入捕获</strong></p><p>void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);</p><p>输入捕获函数，4个通道共用一个函数</p><hr><p><strong>给输入捕获结构体赋初值</strong></p><p>void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);</p><hr><p><strong>选择输入触发源TIGI</strong></p><p>void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><p>配置从模式的输入触发源</p><hr><p><strong>选择输出触发源TRGO</strong></p><p>void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><p>配置主模式的输出触发源</p><hr><p><strong>配置从模式</strong></p><p>void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);</p><img src="/posts/64385/image-20240317150206255.png" class="" title="image-20240317150206255"><p><mark>ps:这三个从模式是给编码器接口用的，会有另外的函数进行配置</mark></p><hr><p><strong>配置通道1234的定时器</strong></p><p>void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);</p><hr><p><strong>读取4个通道的CCR</strong></p><p>uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);</p><p><strong>对于写4个通道CCR的函数</strong></p><p>void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);<br>void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);<br>void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);<br>void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);</p><p><mark>输入捕获模式下，CCR是只读的，要用GetCapture读出</mark></p><hr><p><strong><mark>TIM_PWMIConfig(TIM3,&amp;TIM_ICInitStructure);//标准库中已将上述注释部分封装好,即会将以及配置号的部分，再配置另外的通道将参数进行相反的设置</mark></strong></p><hr></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本概念&quot;&gt;&lt;/a&gt; 基本概念&lt;/h1&gt;
&lt;p&gt;4个输入捕获和输出比较通道，公用4个CCR寄存器&lt;/p&gt;
&lt;p&gt;另外它们的CH1到CH4，4个通道的引脚，也是公用的&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="输入捕获" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/"/>
    
    <category term="输出比较" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯单片机】第九届省赛题</title>
    <link href="https://szturin.github.io/posts/25039/"/>
    <id>https://szturin.github.io/posts/25039/</id>
    <published>2024-03-08T15:51:48.000Z</published>
    <updated>2024-03-08T16:22:45.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1><img src="/posts/25039/image-20240308235630315.png" class="" title="image-20240308235630315"><h2 id="题目分析思路"><a class="markdownIt-Anchor" href="#题目分析思路"></a> 题目分析（思路）</h2><ol><li><p>首先，定义按键所控制的相关变量</p></li><li><p>编写数码管显示的逻辑，以”设置状态为准“，测试按键是否能正常控制相关参数(工作模式、流转间隔)</p><ul><li>因为一共有四个工作模式，流转间隔定义为一个数组，存放各个元素的流转时长</li></ul></li><li><p>将工作模式1的相关逻辑（LED流转方式）编写出来</p><ul><li>这里使用一个指针用于LED的点亮(LED_OFF)，另一个用于LED的熄灭(LED_ON)</li></ul></li><li><p>将工作模式，流转间隔的逻辑与LED工作模式1关联，测试按键功能是否正常，LED是否能被流转间隔控制</p></li><li><p>如果以上程序测试正确，编写其他三个工作模式的LED模块</p><ul><li>此时进行程序测试，功能正常，但是切换其他流转模式会有上一个模式的LED”残留“ (如双LED模式切换到单LED模式时)，因此需要进行LED的复位（在按键控制模块中编写）</li></ul></li><li><p>修改完毕后，编写亮度控制，此时注意到，一个定时器0无法满足对LED扫描的同时进行亮度控制，因此再调用定时器1，用于LED的<strong>扫描指针偏移</strong>，以及LED的<strong>PWM控制亮度</strong>。</p><ul><li>这里修改完程序后，发现数码管闪烁，这是因为定时器1的频率较高，会打断主函数中数码管显示模块，因此将Nixie_Proc()函数放入定时器1中进行运行</li></ul></li><li><p>当以上各个功能全部测试完毕后，调用EEPROM模块，保存流转间隔</p></li></ol><h1 id="程序部分"><a class="markdownIt-Anchor" href="#程序部分"></a> 程序部分</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Work_Mode;<span class="comment">//工作模式参数 0-模式1 1-模式2 2-模式3 3-模式4</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Set_Mode;<span class="comment">// 0-数码管熄灭 1-模式编号 2-流转间隔</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_FlashFlag;<span class="comment">//闪烁标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Timer_800ms;<span class="comment">//0.8s定时（闪烁用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> LED_Flow_Timer_Set[]={<span class="number">400</span>,<span class="number">400</span>,<span class="number">400</span>,<span class="number">400</span>};<span class="comment">//流转间隔参数,控制流转速度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> LED_Flow_Timer;<span class="comment">//流转定时</span></span><br><span class="line">bit LED_Enable=<span class="number">0</span>;<span class="comment">//LED流转使能位，1时LED流转使能，默认LED流转启动</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Level_ShowFlag;<span class="comment">//按下按键4显示LED亮度等级</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_OFF=<span class="number">7</span>;<span class="comment">//LED熄灭指针</span></span><br><span class="line"><span class="comment">/*LED亮度控制相关参数*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Count;<span class="comment">//LED显示周期</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Level;<span class="comment">//LED等级</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Pos;<span class="comment">//LED扫描位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键扫描模块*/</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键4按下*/</span></span><br><span class="line"><span class="keyword">if</span>(Key_Old==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">LED_Level_ShowFlag=<span class="number">1</span>;<span class="comment">//显示LED亮度等级</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_Level_ShowFlag=<span class="number">0</span>;<span class="comment">//松开，LED亮度等级标志位失效</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键控制模块*/</span></span><br><span class="line"><span class="keyword">switch</span>(Key_Down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:<span class="comment">//按键7，用于控制LED的启动和暂停</span></span><br><span class="line">LED_Enable^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:<span class="comment">//按键6，控制设置界面</span></span><br><span class="line"><span class="keyword">if</span>(++Set_Mode==<span class="number">3</span>)</span><br><span class="line">Set_Mode=<span class="number">0</span>;</span><br><span class="line">EEPROM_Write(LED_Flow_Timer_Set,<span class="number">0x00</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//按键5</span></span><br><span class="line"><span class="keyword">if</span>(Set_Mode==<span class="number">2</span>)<span class="comment">//设置界面位于“流转间隔“对应”运行模式“的流转间隔+100ms</span></span><br><span class="line">{</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]+=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer_Set[Work_Mode]&gt;=<span class="number">1300</span>)</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]=<span class="number">400</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Set_Mode==<span class="number">1</span>)<span class="comment">//设置界面位于“运行模式”运行模式切换</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Work_Mode==<span class="number">4</span>)</span><br><span class="line">Work_Mode=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每次模式切换，对LED指针进行复位*/</span></span><br><span class="line"><span class="keyword">if</span>(Work_Mode==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为4</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为1</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">7</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为2</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为3</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">3</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span>(Set_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]-=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer_Set[Work_Mode]&lt;=<span class="number">300</span>)</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]=<span class="number">1200</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Set_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--Work_Mode==<span class="number">255</span>)</span><br><span class="line">Work_Mode=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每次模式切换，对LED指针进行复位*/</span></span><br><span class="line"><span class="keyword">if</span>(Work_Mode==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">7</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line">LED_Level=<span class="number">4</span>-((AD_Read(<span class="number">0x01</span>))/<span class="number">64</span>);</span><br><span class="line"><span class="keyword">switch</span>(Set_Mode)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Level_ShowFlag)</span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Level;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">17</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=Nixie_FlashFlag?Work_Mode:<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=(LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>)?LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>:<span class="number">10</span>;<span class="comment">//高位熄灭</span></span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Flow_Timer_Set[Work_Mode]%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=Work_Mode;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(Nixie_FlashFlag)</span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=(LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>)?LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>:<span class="number">10</span>;<span class="comment">//高位熄灭</span></span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Flow_Timer_Set[Work_Mode]%<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer)<span class="keyword">return</span>;</span><br><span class="line">LED_Flow_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*LED工作模式控制模块*/</span></span><br><span class="line"><span class="keyword">switch</span>(Work_Mode)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)<span class="comment">//LED流转使能位有效</span></span><br><span class="line">{</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(++LED_ON==<span class="number">8</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">0</span>;LED_OFF=<span class="number">7</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--LED_ON==<span class="number">255</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">7</span>;LED_OFF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++LED_ON==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">0</span>;LED_OFF=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--LED_ON==<span class="number">255</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">3</span>;LED_OFF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer1_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//125微秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0xBF</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL1 = <span class="number">0x83</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH1 = <span class="number">0xFF</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF1 = <span class="number">0</span>;<span class="comment">//清除TF1标志</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">ET1 = <span class="number">1</span>; <span class="comment">//定时器i打开</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">EEPROM_Read(LED_Flow_Timer_Set,<span class="number">0x00</span>,<span class="number">4</span>);<span class="comment">//读取AT24C02中的数据</span></span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">Timer1_Init();</span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行任务</span></span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line"><span class="comment">//Nixie_Proc();</span></span><br><span class="line">LED_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">300</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line"><span class="keyword">if</span>(++LED_Flow_Timer&gt;=LED_Flow_Timer_Set[Work_Mode]){LED_Flow_Timer=<span class="number">0</span>;}<span class="comment">//控制LED流转速度</span></span><br><span class="line"><span class="keyword">if</span>(++LED_Count==<span class="number">13</span>){LED_Count=<span class="number">0</span>;}<span class="comment">//LED亮起的周期（PWM周期），12MS</span></span><br><span class="line"><span class="keyword">if</span>(++Timer_800ms==<span class="number">800</span>){Timer_800ms=<span class="number">0</span>;Nixie_FlashFlag^=<span class="number">1</span>;}</span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer1_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 3</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++LED_Pos==<span class="number">8</span>){LED_Pos=<span class="number">0</span>;}<span class="comment">//LED每1ms完成一次扫描</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(LED_Count&lt;((LED_Level<span class="number">-1</span>)*<span class="number">3</span>))<span class="comment">//LED占空比</span></span><br><span class="line">{</span><br><span class="line">LED_Disp(LED_Pos,ucLED[LED_Pos]);<span class="comment">//LED点亮，1ms</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_Disp(LED_Pos,<span class="number">0</span>);<span class="comment">//LED熄灭,1ms</span></span><br><span class="line">}</span><br><span class="line">Nixie_Proc();<span class="comment">//如果数码管放置在主程序中，由于定时器1频率高，优先级高，主函数会被频繁打断出现闪烁现象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目要求&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目要求&quot;&gt;&lt;/a&gt; 题目要求&lt;/h1&gt;
&lt;img src=&quot;/posts/25039/image-20240308235630315.png&quot; class=&quot;&quot; title=&quot;i</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="蓝桥杯" scheme="https://szturin.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="C语言" scheme="https://szturin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="STC15" scheme="https://szturin.github.io/tags/STC15/"/>
    
    <category term="蓝桥杯" scheme="https://szturin.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="数字电路" scheme="https://szturin.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>【单片机】SPI协议</title>
    <link href="https://szturin.github.io/posts/23815/"/>
    <id>https://szturin.github.io/posts/23815/</id>
    <published>2024-03-08T15:27:37.000Z</published>
    <updated>2024-05-02T08:08:14.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h1><h3 id="什么是spi"><a class="markdownIt-Anchor" href="#什么是spi"></a> 什么是SPI？</h3><p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一 种同步串行接口技术，是一种高速的，全双工，同步的通信总线。</p><p><strong>SPI优点</strong>:支持全双工通信 通信简单 数据传输速率块</p><p><strong>缺点</strong> :没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据 可靠性上有一定的缺陷。</p><p><strong>特点</strong>:</p><ol><li>高速、同步、全双工、非差分、总线式</li><li>主从机通信模式</li></ol><h1 id="蓝桥杯相关暂未使用spi"><a class="markdownIt-Anchor" href="#蓝桥杯相关暂未使用spi"></a> 蓝桥杯相关（暂未使用SPI）</h1><h2 id="ds1302时钟芯片底层"><a class="markdownIt-Anchor" href="#ds1302时钟芯片底层"></a> DS1302（时钟芯片）底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ds1302.h"</span></span></span><br><span class="line">sbit SCK=P1^<span class="number">7</span>;</span><br><span class="line">sbit SDA=P2^<span class="number">3</span>;</span><br><span class="line">sbit RST = P1^<span class="number">3</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302</span><span class="params">(<span class="type">unsigned</span>  <span class="type">char</span> temp)</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)     </span><br><span class="line">{ </span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">SDA=temp&amp;<span class="number">0x01</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">SCK=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302_Byte</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address,<span class="type">unsigned</span> <span class="type">char</span> dat )</span>     </span><br><span class="line">{</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>; _nop_();  </span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> Write_Ds1302(dat);</span><br><span class="line"> RST=<span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_Ds1302_Byte</span> <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address )</span></span><br><span class="line">{</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> i,temp=<span class="number">0x00</span>;</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>;_nop_();</span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) </span><br><span class="line"> {</span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(SDA)</span><br><span class="line"> temp|=<span class="number">0x80</span>;</span><br><span class="line"> SCK=<span class="number">1</span>;</span><br><span class="line">} </span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line">SCK=<span class="number">1</span>;_nop_();</span><br><span class="line">SDA=<span class="number">0</span>;_nop_();</span><br><span class="line">SDA=<span class="number">1</span>;_nop_();</span><br><span class="line"><span class="keyword">return</span> (temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写"><a class="markdownIt-Anchor" href="#基于底层的时序编写"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Set_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0</span>);<span class="comment">//关闭写保护</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x84</span>-i*<span class="number">2</span>,ucRtc[i]);<span class="comment">//给ds1302写入数据,0x84时 0x82分 0x80秒</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">1</span>);<span class="comment">//打开写保护</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">ucRtc[i] = Read_Ds1302_Byte(<span class="number">0x85</span>-i*<span class="number">2</span>);<span class="comment">//读取ds1302的数据</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0</span>);<span class="comment">//关闭写保护</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8c</span>,ucDate[<span class="number">0</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x88</span>,ucDate[<span class="number">1</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x86</span>,ucDate[<span class="number">2</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">ucDate[<span class="number">0</span>] = Read_Ds1302_Byte(<span class="number">0x8d</span>);</span><br><span class="line">ucDate[<span class="number">1</span>] = Read_Ds1302_Byte(<span class="number">0x89</span>);</span><br><span class="line">ucDate[<span class="number">2</span>] = Read_Ds1302_Byte(<span class="number">0x87</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="超声波底层"><a class="markdownIt-Anchor" href="#超声波底层"></a> 超声波底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ultrasonic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit TX = P1^<span class="number">0</span>;</span><br><span class="line">sbit RX = P1^<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//超声波初始化函数 产生8个40Mhz的方波信号</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        TX=<span class="number">1</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">        TX=<span class="number">0</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写-2"><a class="markdownIt-Anchor" href="#基于底层的时序编写-2"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Ut_Wave_Data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;</span><br><span class="line">    TL1=TH1=<span class="number">0</span>;</span><br><span class="line">    Ut_Wave_Init();</span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((RX==<span class="number">1</span>) &amp;&amp; (TF1==<span class="number">0</span>));<span class="comment">//等待超声波返回或定时器溢出</span></span><br><span class="line"></span><br><span class="line">    TR1=<span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(TF1==<span class="number">0</span>)<span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = TH1&lt;&lt;<span class="number">8</span> | TL1;</span><br><span class="line">        <span class="keyword">return</span> (time *<span class="number">0.017</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        TF1=<span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础概念&quot;&gt;&lt;/a&gt; 基础概念&lt;/h1&gt;
&lt;h3 id=&quot;什么是spi&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是spi&quot;&gt;&lt;/a&gt; 什么是S</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【单片机】OneWire通信协议</title>
    <link href="https://szturin.github.io/posts/46163/"/>
    <id>https://szturin.github.io/posts/46163/</id>
    <published>2024-03-08T15:13:29.000Z</published>
    <updated>2024-05-02T08:08:13.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-onewire单总线协议"><a class="markdownIt-Anchor" href="#一-onewire单总线协议"></a> 一、OneWire（单总线）协议</h3><p>•单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线</p><p>•一根通信线：DQ</p><p>•异步、半双工</p><p>•单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线</p><h3 id="二-单总线电路规范"><a class="markdownIt-Anchor" href="#二-单总线电路规范"></a> 二、单总线电路规范</h3><p>•设备的DQ均要配置成开漏输出模式</p><p>•DQ添加一个上拉电阻，阻值一般为4.7KΩ左右</p><p>•若此总线的从机采取寄生供电，则主机还应配一个强上拉输出电路</p><img src="/posts/46163/image-20240302232447437.png" class="" title="image-20240302232447437"><h3 id="三-单总线的时序结构"><a class="markdownIt-Anchor" href="#三-单总线的时序结构"></a> 三、单总线的时序结构</h3><img src="/posts/46163/image-20240302232633388.png" class="" title="image-20240302232633388"><img src="/posts/46163/image-20240302232648244.png" class="" title="image-20240302232648244"><img src="/posts/46163/image-20240302232700200.png" class="" title="image-20240302232700200"><img src="/posts/46163/image-20240302232708528.png" class="" title="image-20240302232708528"><hr><h1 id="蓝桥杯相关"><a class="markdownIt-Anchor" href="#蓝桥杯相关"></a> 蓝桥杯相关</h1><h2 id="onewire底层"><a class="markdownIt-Anchor" href="#onewire底层"></a> OneWire底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"onewire.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"reg52.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit DQ = P1^<span class="number">4</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线内部延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_OneWire</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>  </span><br><span class="line">{</span><br><span class="line">t *= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线写操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_DS18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">DQ = dat&amp;<span class="number">0x01</span>;</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线读操作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_DS18B20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(DQ)</span><br><span class="line">{</span><br><span class="line">dat |= <span class="number">0x80</span>;</span><br><span class="line">}    </span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//DS18B20初始化</span></span><br><span class="line">bit <span class="title function_">init_ds18b20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  bit initflag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">12</span>);</span><br><span class="line">  DQ = <span class="number">0</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">80</span>);</span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">10</span>); </span><br><span class="line">    initflag = DQ;     </span><br><span class="line">  Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> initflag;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ds18b20温度读取时序"><a class="markdownIt-Anchor" href="#ds18b20温度读取时序"></a> DS18B20温度读取时序</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基于底层编写*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">ds18b20_read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> low,high;<span class="comment">//高八位，低八位，DS18B20温度数据是十六位二进制</span></span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0x44</span>);<span class="comment">//ds18b20开始温度转换</span></span><br><span class="line">    </span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0xbe</span>);<span class="comment">//ds18b20开始温度读取</span></span><br><span class="line">low=Read_DS18B20();</span><br><span class="line">high=Read_DS18B20();</span><br><span class="line"><span class="keyword">return</span>((high &lt;&lt; <span class="number">8</span> )| low) /<span class="number">16.0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一-onewire单总线协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-onewire单总线协议&quot;&gt;&lt;/a&gt; 一、OneWire（单总线）协议&lt;/h3&gt;
&lt;p&gt;•单总线（1-Wire BUS）是由Dallas公司开发的一种通用数</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【单片机】IIC通信协议</title>
    <link href="https://szturin.github.io/posts/19787/"/>
    <id>https://szturin.github.io/posts/19787/</id>
    <published>2024-03-08T14:58:21.000Z</published>
    <updated>2024-05-02T08:08:12.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-单片机通信基础概念"><a class="markdownIt-Anchor" href="#一-单片机通信基础概念"></a> 一、单片机通信基础概念</h3><p><strong>全双工和半双工的区别：</strong></p><p>一、全双工（Full Duplex）通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。</p><p>二、半双工（Half Duplex）数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。</p><p><strong>MCU中常见的通信协议：</strong></p><img src="/posts/19787/5490adeb2e9d43dcae940a3b83a35b73.png" class="" title="在这里插入图片描述"><h3 id="二-推挽输出和开漏输出"><a class="markdownIt-Anchor" href="#二-推挽输出和开漏输出"></a> 二、推挽输出和开漏输出</h3><p><strong>推挽输出：</strong></p><blockquote><p>推挽输出结构是由两个MOS或者<a href="https://so.csdn.net/so/search?q=%E4%B8%89%E6%9E%81%E7%AE%A1&amp;spm=1001.2101.3001.7020">三极管</a>收到互补控制的信号控制，两个管子时钟一个在导通，一个在截止，如图1所示：</p></blockquote><img src="/posts/19787/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdHRsZV9veA==,size_16,color_FFFFFF,t_70.png" class="" title="图1 推挽输出结构"><p>特点:</p><ul><li>推挽输出可以输出高电平和低电平，在两种电平下都具有驱动能力。</li><li>相比于后面介绍的开漏输出，输出高电平时的驱动能力强很多</li><li>缺点：推挽输出不能实现" 线与"。</li></ul><p><strong>开漏输出：</strong></p><blockquote><p>常说的与推挽输出相对的就是开漏输出，抽象地说就是COMS反相器去掉了NMOS部分，PMOS管漏极输出，即开漏输出。PMOS管由高电平导通输出低电平，高电平没有驱动能力，需要借助“上拉电阻” (一般上拉电阻值较大，即弱上拉模式)<a href="https://blog.csdn.net/monkey_d_xue/article/details/129802153">什么是弱上拉?</a></p></blockquote><img src="/posts/19787/20201208174916607.png" class="" title="图4 OD"><h5 id="开漏输出的另一个优点在于可以实现线与功能所谓的线与指的是多个信号线直接连接在一起只有当所有信号全部为高电平时合在一起的总线为高电平只要有任意一个或者多个信号为低电平则总线为低电平这就是为什么后面用到iic通信当一个信号线为低电平要释放总线"><a class="markdownIt-Anchor" href="#开漏输出的另一个优点在于可以实现线与功能所谓的线与指的是多个信号线直接连接在一起只有当所有信号全部为高电平时合在一起的总线为高电平只要有任意一个或者多个信号为低电平则总线为低电平这就是为什么后面用到iic通信当一个信号线为低电平要释放总线"></a> <strong>开漏输出的另一个优点在于可以实现"线与"功能，所谓的"线与"指的是多个信号线直接连接在一起，只有当所有信号全部为高电平时，合在一起的总线为高电平；只要有任意一个或者多个信号为低电平，则总线为低电平(这就是为什么后面用到IIC通信,当一个信号线为低电平,要"释放总线")。</strong></h5><h5 id="而推挽输出就不行如果高电平和低电平连在一起会出现电流倒灌损坏器件"><a class="markdownIt-Anchor" href="#而推挽输出就不行如果高电平和低电平连在一起会出现电流倒灌损坏器件"></a> <strong>而推挽输出就不行，如果高电平和低电平连在一起，会出现电流倒灌，损坏器件</strong></h5><p><mark><strong>IIC为什么要开漏输出模式？</strong></mark></p><ul><li>输出端浮空，电平易受外界干扰，不稳定</li></ul><h3 id="三-i2c总线介绍"><a class="markdownIt-Anchor" href="#三-i2c总线介绍"></a> 三、I2C总线介绍：</h3><ul><li>I2C总线（Inter IC BUS）是由Philips公司开发的一种通用数据总线</li><li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</li><li>同步、半双工，带数据应答</li><li>通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度</li></ul><h3 id="四-i2c电路规范"><a class="markdownIt-Anchor" href="#四-i2c电路规范"></a> 四、I2C电路规范</h3><ul><li><p>所有I2C设备的SCL连在一起，SDA连在一起</p></li><li><p>设备的SCL和SDA均要配置成开漏输出模式</p></li><li><p>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</p></li><li><p>开漏输出和上拉电阻的共同作用实现了“线与”的功能，此设计主要是为了解决多机通信互相干扰的问题</p></li></ul><h3 id="五-i2c时序结构"><a class="markdownIt-Anchor" href="#五-i2c时序结构"></a> 五、I2C时序结构</h3><hr><img src="/posts/19787/1baf27e6e69a429394f21dd1a30900f1.png" class="" title="在这里插入图片描述"><img src="/posts/19787/115006bca35b4b2a8193651f437b65fc.png" class="" title="在这里插入图片描述"><img src="/posts/19787/a1ec063743594e96bb853e3fe69a3800.png" class="" title="在这里插入图片描述"><img src="/posts/19787/image-20240302223549490.png" class="" title="image-20240302223549490"><img src="/posts/19787/72b48d4af46f41ec9fe40720751e4a39.png" class="" title="在这里插入图片描述"><img src="/posts/19787/image-20240302225440107.png" class="" title="image-20240302225440107"><hr><p><strong>总结：IIC的 时序模块</strong></p><ul><li>起始条件</li><li>中止条件</li><li>发送一个字节</li><li>接收一个字节</li><li>接收应答</li><li>发送应答</li></ul><h1 id="蓝桥杯相关"><a class="markdownIt-Anchor" href="#蓝桥杯相关"></a> 蓝桥杯相关</h1><h2 id="iic模块"><a class="markdownIt-Anchor" href="#iic模块"></a> IIC模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iic.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME 5</span></span><br><span class="line"><span class="comment">// I2C总线内部延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        _nop_();</span><br><span class="line">    } <span class="keyword">while</span> (i--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线启动信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应答或非应答信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendAck</span><span class="params">(bit ackbit)</span></span><br><span class="line">{</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = ackbit;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答</span></span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    <span class="keyword">return</span> ackbit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线发送一个字节数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        <span class="keyword">if</span> (byt &amp; <span class="number">0x80</span>)</span><br><span class="line">            SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SDA = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        byt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线接收一个字节数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i, da;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        da &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SDA)</span><br><span class="line">            da |= <span class="number">1</span>;</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> da;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="adda转换模块"><a class="markdownIt-Anchor" href="#adda转换模块"></a> AD/DA转换模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">AD_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line">    </span><br><span class="line">    IIC_Start();       <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr); <span class="comment">//主机发送一个字节(要操作数据的地址),对应AD转换的通道</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    </span><br><span class="line">    IIC_Start(); <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x91</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    temp = IIC_RecByte(); <span class="comment">//从机送出数据,主机读入的数据用变量存储</span></span><br><span class="line">    IIC_SendAck(<span class="number">1</span>);<span class="comment">//主机发送应答,1表示完成数据的接收,从机停止发送数据</span></span><br><span class="line">    IIC_Stop();<span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DA_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>);<span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x41</span>); <span class="comment">//主机发送一个字节(要操作数据的地址),对应DA转换的通道</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(Data); <span class="comment">//主机送出DA输出的数据字节</span></span><br><span class="line">    IIC_WaitAck(); <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_Stop(); <span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="at24c02epprom模块"><a class="markdownIt-Anchor" href="#at24c02epprom模块"></a> AT24C02（EPPROM）模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环发送数据字节,存入AT24C02</span></span><br><span class="line">    {</span><br><span class="line">        IIC_SendByte(*EEPROM_String++);<span class="comment">//发送数据字节,要存入AT24C02的数据,字节个数为num</span></span><br><span class="line">        IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">        IIC_Delay(<span class="number">200</span>);<span class="comment">//延时200ms,保证从机(AT24C02能够完整收到数据)</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答  </span></span><br><span class="line"></span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA1</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环接收数据字节,存入EEPROM_String指向的地址</span></span><br><span class="line">    {</span><br><span class="line">        *EEPROM_String++=IIC_RecByte();<span class="comment">//指针移位读取数据到对应的地址中</span></span><br><span class="line">        <span class="keyword">if</span>(num)<span class="comment">//判断是否读取完数据</span></span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">0</span>);<span class="comment">//发送应答0,表示继续接收数据</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">1</span>);<span class="comment">//发送应答1,表示停止接收数据</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一-单片机通信基础概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-单片机通信基础概念&quot;&gt;&lt;/a&gt; 一、单片机通信基础概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;全双工和半双工的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、全双工（Ful</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【51单片机】AT24C02(EEPROM储存)</title>
    <link href="https://szturin.github.io/posts/4799/"/>
    <id>https://szturin.github.io/posts/4799/</id>
    <published>2024-03-05T11:59:51.000Z</published>
    <updated>2024-03-08T14:52:36.562Z</updated>
    
    <content type="html"><![CDATA[<p>2.26更新</p><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><h2 id="前置概念"><a class="markdownIt-Anchor" href="#前置概念"></a> #前置概念</h2><blockquote><p>所用外设：</p><p><mark>AT24C02(EEPROM储存) 使用IIC协议</mark></p></blockquote><h3 id="一-单片机通信协议本文以iic为重点"><a class="markdownIt-Anchor" href="#一-单片机通信协议本文以iic为重点"></a> 一、单片机通信协议（本文以IIC为重点）</h3><p><strong>全双工和半双工的区别：</strong></p><p>一、全双工（Full Duplex）通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。</p><p>二、半双工（Half Duplex）数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。</p><p><strong>MCU中常见的通信协议：</strong></p><img src="/posts/4799/5490adeb2e9d43dcae940a3b83a35b73.png" class="" title="在这里插入图片描述"><h3 id="二-推挽输出和开漏输出"><a class="markdownIt-Anchor" href="#二-推挽输出和开漏输出"></a> 二、推挽输出和开漏输出</h3><p><strong>推挽输出：</strong></p><ul><li>推挽输出可以输出高电平和低电平，在两种电平下都具有驱动能力。</li><li>相比于后面介绍的开漏输出，输出高电平时的驱动能力强很多</li><li>缺点：推挽输出不能实现" 线与"。</li></ul><p><strong>开漏输出：</strong></p><ul><li>常说的与推挽输出相对的就是开漏输出，抽象地说就是COMS反相器去掉了NMOS部分，PMOS管漏极输出，即开漏输出。PMOS管由高电平导通输出低电平，高电平没有驱动能力，需要借助“上拉电阻” (一般上拉电阻值较大，即弱上拉模式)<a href="https://blog.csdn.net/monkey_d_xue/article/details/129802153">什么是弱上拉?</a></li></ul><p><mark><strong>IIC为什么要开漏输出模式？</strong></mark></p><ul><li>输出端浮空，电平易受外界干扰，不稳定</li></ul><h3 id="三-i2c总线介绍"><a class="markdownIt-Anchor" href="#三-i2c总线介绍"></a> 三、I2C总线介绍：</h3><ul><li>I2C总线（Inter IC BUS）是由Philips公司开发的一种通用数据总线</li><li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</li><li>同步、半双工，带数据应答</li><li>通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度</li></ul><h3 id="四-i2c电路规范"><a class="markdownIt-Anchor" href="#四-i2c电路规范"></a> 四、I2C电路规范</h3><ul><li><p>所有I2C设备的SCL连在一起，SDA连在一起</p></li><li><p>设备的SCL和SDA均要配置成开漏输出模式</p></li><li><p>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</p></li><li><p>开漏输出和上拉电阻的共同作用实现了“线与”的功能，此设计主要是为了解决多机通信互相干扰的问题</p></li></ul><h3 id="五-i2c时序结构"><a class="markdownIt-Anchor" href="#五-i2c时序结构"></a> 五、I2C时序结构</h3><hr><img src="/posts/4799/1baf27e6e69a429394f21dd1a30900f1.png" class="" title="在这里插入图片描述"><img src="/posts/4799/115006bca35b4b2a8193651f437b65fc.png" class="" title="在这里插入图片描述"><img src="/posts/4799/a1ec063743594e96bb853e3fe69a3800.png" class="" title="在这里插入图片描述"><img src="/posts/4799/image-20240302223549490.png" class="" title="image-20240302223549490"><img src="/posts/4799/72b48d4af46f41ec9fe40720751e4a39.png" class="" title="在这里插入图片描述"><img src="/posts/4799/image-20240302225440107.png" class="" title="image-20240302225440107"><hr><p><strong>总结：IIC的工作模块</strong></p><ul><li>起始条件</li><li>中止条件</li><li>发送一个字节</li><li>接收一个字节</li><li>接收应答</li><li>发送应答</li></ul><hr><h2 id="存储器at24c02"><a class="markdownIt-Anchor" href="#存储器at24c02"></a> #存储器/AT24C02</h2><h3 id="一-ram和rom"><a class="markdownIt-Anchor" href="#一-ram和rom"></a> 一、RAM和ROM</h3><blockquote><p>**RAM : 易失性存储器 (高速存储） **</p><p><mark>单片机内RAM为中间数据存储器</mark></p></blockquote><ul><li>SRAM：静态RAM，电脑中的CPU，高速缓存，容量少，成本高</li><li>DRAM：动态RAM，使用电容存储，电容容值小，需要补电能，成本相较于SRAM更低，容量更大</li><li>掉电丢失</li></ul><blockquote><p><strong>ROM:非易失性存储器</strong></p><p><mark>单片机内ROM为指令存储器</mark></p></blockquote><ul><li>Mask ROM(掩膜ROM），只能读，不能写</li><li>PROM：可编程ROM，可以写，但是只能写入一次</li><li>EPROM：可擦除可编程ROM，可以编程，也可以清除（30分钟紫外线）</li><li>E2PROM： 电可擦除可编程ROM，5V电可擦除，掉电不丢失</li><li>Flash（闪存）：</li><li>硬盘、软盘、光盘等：磁介质、光信号</li></ul><hr><img src="/posts/4799/image-20240302224153992.png" class="" title="image-20240302224153992"><blockquote><p>单片机烧录的由来：早期通过编程储存数据，实际上是将特殊的二极管击穿，相当于“烧毁”（PROM）</p></blockquote><hr><h3 id="二-at24c02"><a class="markdownIt-Anchor" href="#二-at24c02"></a> 二、AT24C02</h3><img src="/posts/4799/image-20240302224329935.png" class="" title="image-20240302224329935"><img src="/posts/4799/7b07f23e9e7640f1b8db85bc873a9e36.png" class="" title="在这里插入图片描述"><h1 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> 代码部分</h1><h2 id="一-给at24c02写入数据"><a class="markdownIt-Anchor" href="#一-给at24c02写入数据"></a> 一、给AT24C02写入数据</h2><blockquote><p><strong>实现：AT24C02掉电不丢失</strong></p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LCD1602.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AT24C02.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Hello World"</span>);</span><br><span class="line"><span class="comment">//AT24C02_WriteByte(1,123);</span></span><br><span class="line">Delay(<span class="number">5</span>);<span class="comment">//AT21C02写一个序列的有效停止条件开始至内部写周期结束的时间</span></span><br><span class="line">Data=AT24C02_ReadByte(<span class="number">1</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,Data,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完善代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LCD1602.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AT24C02.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum;</span><br><span class="line"><span class="comment">//unsigned char Num; 这里要用到整型</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key();</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">Num--;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">AT24C02_WriteByte(<span class="number">0</span>,Num%<span class="number">256</span>);<span class="comment">//低八位</span></span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">1</span>,Num/<span class="number">256</span>);<span class="comment">//高八位</span></span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"Write OK"</span>);<span class="comment">//完成写入数据，提示</span></span><br><span class="line">Delay(<span class="number">1000</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"        "</span>);<span class="comment">//延时清除</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">4</span>)<span class="comment">//读的时候不需要Delay</span></span><br><span class="line">{</span><br><span class="line">Num=AT24C02_ReadByte(<span class="number">0</span>);</span><br><span class="line">Num|=AT24C02_ReadByte(<span class="number">1</span>)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Num,<span class="number">5</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"Read OK"</span>);<span class="comment">//完成读取数据，提示</span></span><br><span class="line">Delay(<span class="number">1000</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"        "</span>);<span class="comment">//延时清除</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为什么要写:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AT24C02_WriteByte(<span class="number">0</span>,Num%<span class="number">256</span>);<span class="comment">//低八位</span></span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">1</span>,Num/<span class="number">256</span>);<span class="comment">//高八位</span></span><br></pre></td></tr></tbody></table></figure><p>因为：int类型最高65535,对应的二进制为16位</p><h2 id="二-定时器扫描按键"><a class="markdownIt-Anchor" href="#二-定时器扫描按键"></a> 二、定时器扫描按键</h2><blockquote><p><strong>实验：定时器按键扫描，<mark>实现键值的数码管显示</mark></strong></p><p><strong>实验结果：如果直接让Nixie在判断键码后显示Keynum值，只能显示一瞬间，数码管的显示方式不同于LCD1602，所以需要一个缓存量Temp</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*错误写法*/</span><br><span class="line">Temp=Key();</span><br><span class="line">if(KeyNum)//显示结果只在一瞬间显示</span><br><span class="line">{</span><br><span class="line">Nixie(1,KeyNum);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*正确写法*/</span><br><span class="line">if(Temp)</span><br><span class="line">{</span><br><span class="line">KeyNum=Temp;</span><br><span class="line">}</span><br><span class="line">Nixie(1,KeyNum);</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>实验：定时器按键扫描实列2</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;REGX52.H&gt;</span><br><span class="line">#include "Key.h"</span><br><span class="line">#include "AT24C02.h"</span><br><span class="line">#include "Timer0.h"</span><br><span class="line">#include "Nixie.h"</span><br><span class="line">#include "Delay.h"</span><br><span class="line">unsigned char KeyNum;</span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line">Timer0_Init();</span><br><span class="line">while(1)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key();</span><br><span class="line">if(KeyNum)</span><br><span class="line">{</span><br><span class="line">Nixie_SetBuf(1,KeyNum);</span><br><span class="line">Nixie_SetBuf(2,KeyNum);</span><br><span class="line">Nixie_SetBuf(3,KeyNum);</span><br><span class="line">Delay(1000);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void Timer0_Routine() interrupt 1 //中断子程序</span><br><span class="line">{</span><br><span class="line">static unsigned int T0Count1,T0Count2;//静态局部变量，保证退出函数之后不销毁</span><br><span class="line">TL0 = 0x66;//设置定时初始值</span><br><span class="line">TH0 = 0xFC;//设置定时初始值</span><br><span class="line">T0Count1++;//每次进入中断子程序，秒控制器自加一</span><br><span class="line">if(T0Count1&gt;=20)//每隔20ms，按键函数会被调用一次</span><br><span class="line">{</span><br><span class="line">T0Count1=0;</span><br><span class="line">Key_Loop(); </span><br><span class="line">}</span><br><span class="line">T0Count2++;</span><br><span class="line">if(T0Count2&gt;=2)</span><br><span class="line">{</span><br><span class="line"> T0Count2=0;</span><br><span class="line"> Nixie_Loop();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>实验结果：</strong></p><img src="/posts/4799/cd3ca4af62f4478d9e79c4a31087a160.jpeg" class="" title="请添加图片描述"><img src="/posts/4799/858d834686d84ec7b7dab21610cca5db.jpeg" class="" title="请添加图片描述"><p><strong><mark>这时，按下按键，数码管显示会延时一秒改变，可见，使用定时器扫描按键，不会被延时函数影响，相较于延时函数使单片机的工作更具有可靠性</mark></strong></p></blockquote><hr><blockquote><p><strong>秒表源代码：</strong><br>操作方式：</p><ul><li>按键1暂停</li><li>按键2清零</li><li>按键3通过AT24C02写入数据</li><li>按键4通过AT24C02读取数据</li></ul></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AT24C02.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Timer0.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Nixie.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Min,Sec,MiniSec;<span class="comment">//单位：分，秒，1/100s=10ms</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> RunFlag;<span class="comment">//启动暂定标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">P2_5=<span class="number">0</span>;<span class="comment">//蜂鸣器关闭</span></span><br><span class="line">Timer0_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">KeyNum=Key();</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RunFlag=!RunFlag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">Min=<span class="number">0</span>;Sec=<span class="number">0</span>;MiniSec=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">AT24C02_WriteByte(<span class="number">0</span>,Min);</span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">1</span>,Sec);</span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">AT24C02_WriteByte(<span class="number">2</span>,MiniSec);</span><br><span class="line">Delay(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">Min=AT24C02_ReadByte(<span class="number">0</span>);</span><br><span class="line">Sec=AT24C02_ReadByte(<span class="number">1</span>);</span><br><span class="line">MiniSec=AT24C02_ReadByte(<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Nixie_SetBuf(<span class="number">1</span>,Min/<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">2</span>,Min%<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">3</span>,<span class="number">11</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">4</span>,Sec/<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">5</span>,Sec%<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">6</span>,<span class="number">11</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">7</span>,MiniSec/<span class="number">10</span>);</span><br><span class="line">Nixie_SetBuf(<span class="number">8</span>,MiniSec%<span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sec_Loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RunFlag)</span><br><span class="line">{</span><br><span class="line">MiniSec++;</span><br><span class="line"><span class="keyword">if</span>(MiniSec&gt;=<span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">MiniSec=<span class="number">0</span>;</span><br><span class="line">Sec++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Sec&gt;=<span class="number">60</span>)</span><br><span class="line">{</span><br><span class="line">Sec=<span class="number">0</span>;</span><br><span class="line">Min++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Min&gt;=<span class="number">60</span>)</span><br><span class="line">{</span><br><span class="line">Min=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 <span class="comment">//中断子程序</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count1,T0Count2,T0Count3;<span class="comment">//静态局部变量，保证退出函数之后不销毁</span></span><br><span class="line">TL0 = <span class="number">0x66</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T0Count1++;<span class="comment">//每次进入中断子程序，秒控制器自加一</span></span><br><span class="line"><span class="keyword">if</span>(T0Count1&gt;=<span class="number">20</span>)<span class="comment">//每隔20ms，按键函数会被调用一次</span></span><br><span class="line">{</span><br><span class="line">T0Count1=<span class="number">0</span>;</span><br><span class="line">Key_Loop(); </span><br><span class="line">}</span><br><span class="line">T0Count2++;</span><br><span class="line"><span class="keyword">if</span>(T0Count2&gt;=<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"> T0Count2=<span class="number">0</span>;</span><br><span class="line"> Nixie_Loop();</span><br><span class="line">}</span><br><span class="line">T0Count3++;</span><br><span class="line"><span class="keyword">if</span>(T0Count3&gt;=<span class="number">10</span>)<span class="comment">//10ms</span></span><br><span class="line">{</span><br><span class="line"> T0Count3=<span class="number">0</span>;</span><br><span class="line"> Sec_Loop();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>题外话: 6-1矩阵键盘密码锁：为什么密码不能设置为0开头?<br>因为0开头代表八进制,比如0123实际上对应的十进制数是83</p></blockquote><hr><h1 id="蓝桥杯stc15拓展"><a class="markdownIt-Anchor" href="#蓝桥杯stc15拓展"></a> #蓝桥杯(STC15)拓展</h1><p><strong>IIC通信底层</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iic.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME 5</span></span><br><span class="line"><span class="comment">// I2C总线内部延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        _nop_();</span><br><span class="line">    } <span class="keyword">while</span> (i--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线启动信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应答或非应答信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendAck</span><span class="params">(bit ackbit)</span></span><br><span class="line">{</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = ackbit;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答</span></span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    <span class="keyword">return</span> ackbit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线发送一个字节数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        <span class="keyword">if</span> (byt &amp; <span class="number">0x80</span>)</span><br><span class="line">            SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SDA = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        byt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C总线接收一个字节数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i, da;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        da &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SDA)</span><br><span class="line">            da |= <span class="number">1</span>;</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> da;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基于IIC底层，编写AT24C02函数模块*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 写入EEPROM</span></span><br><span class="line"><span class="comment">  * @param  需要写的字符串，写入的地址，写入数量</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">IIC_Start();<span class="comment">//发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line">    </span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//写入要储存的数据地址,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        IIC_SendByte(*EEPROM_String++);<span class="comment">//要存入AT24C02的数据,按位存</span></span><br><span class="line">        IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line">        IIC_Delay(<span class="number">200</span>);</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//停止IIC命令</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 读取EEPROM数据,替换需要读取字符串的数据</span></span><br><span class="line"><span class="comment">  * @param  需要读取的字符串，写入的地址，写入数量</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//写入要读取的数据地址,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答  </span></span><br><span class="line"></span><br><span class="line">    IIC_Start();<span class="comment">//发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA1</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        *EEPROM_String++=IIC_RecByte();<span class="comment">//按位取数据</span></span><br><span class="line">        <span class="keyword">if</span>(num)<span class="comment">//未取完数据</span></span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">1</span>);<span class="comment">//主机接收完数据，发送应答</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//停止IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2.26更新&lt;/p&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本概念&quot;&gt;&lt;/a&gt; 基本概念&lt;/h1&gt;
&lt;h2 id=&quot;前置概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前置概念&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[5]定时器控制PWM</title>
    <link href="https://szturin.github.io/posts/32351/"/>
    <id>https://szturin.github.io/posts/32351/</id>
    <published>2024-03-05T11:57:05.000Z</published>
    <updated>2024-05-02T12:05:03.337Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>配置结构体初始化输出比较单元</strong></p><p>void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);<br>void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);<br>void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);<br>void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);</p><p><strong>设置结构体初始值</strong></p><p>void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);</p><hr><p><strong>*配置强制输出</strong></p><p>void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);</p><p><strong>*配置影子寄存器</strong></p><p>void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);<br>void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);</p><p><strong>*配置快速使能</strong></p><p>void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);<br>void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);<br>void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);<br>void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);</p><p><strong>*清除REF信号</strong></p><p>void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);<br>void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);<br>void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);<br>void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);</p><p><strong>配置输出极性</strong></p><blockquote><p>带N即高级定时器里互补通道的配置</p><p>OC4无互补通道</p><p>结构体初始化中也可以设置极性</p></blockquote><p>void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);<br>void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);<br>void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);<br>void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);<br>void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);<br>void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);<br>void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);</p><p>void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);<br>void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);</p><p><strong>单独修改输出使能参数</strong></p><p>void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);<br>void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);</p><p><strong>单独更改输出比较模式</strong></p><p>void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);</p><p><strong>单独更改CCR寄存器的函数</strong></p><p>void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);<br>void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);<br>void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);<br>void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);</p><p><strong>高级定时器，使能PWM，否则无法正常输出</strong></p><p>void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;配置结构体初始化输出比较单元&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);&lt;br&gt;
void TI</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="定时器" scheme="https://szturin.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
    <category term="PWM" scheme="https://szturin.github.io/tags/PWM/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯单片机】程序模板设计</title>
    <link href="https://szturin.github.io/posts/18220/"/>
    <id>https://szturin.github.io/posts/18220/</id>
    <published>2024-03-01T15:12:54.000Z</published>
    <updated>2024-05-02T12:08:28.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p><strong>为了确保程序的准确性，总结了以下要点</strong></p><ol><li><mark>保证程序<strong>逻辑正确</strong>，其次再是“基于现象上”的正确，保证程序不会出现<strong>隐性问题</strong></mark></li><li><mark>在逻辑正确的前提下，保证数据读取的<strong>实时性</strong>，尽量优化代码执行效率</mark></li><li><mark>对数据的处理，在确保程序完全正常运行的前提下，最大限度地提高内存空间的<strong>利用率</strong></mark></li><li><mark>编写程序时，先写主框架，验证逻辑后，再依次验证其他模块</mark></li></ol><h1 id="数码管led模块工作原理"><a class="markdownIt-Anchor" href="#数码管led模块工作原理"></a> 数码管/LED模块工作原理</h1><p><mark>例如：数码管的段选/位选输出由两个74HC573锁存器控制</mark></p><img src="/posts/18220/image-20240301234539921.png" class="" title="image-20240301234539921"><blockquote><p><strong>锁存器送出数据的过程</strong></p><ol><li><p>P0输出8位数据</p></li><li><p>锁存器不使能，Q0~Q7为之前的数据，D0 ~ D7等待被送出</p></li><li><p>锁存器使能，数据送出，Q0~Q7即为P00 ~ P07的信号</p><p>注意：OE此处默认接GND</p></li></ol></blockquote><blockquote><p>**如何控制锁存器送出数据的顺序/使锁存器单个送出数据? **</p><ul><li>由一个或非门(U25)的四个输出控制四个锁存器的输入使能信号(Y7C~Y4C)</li></ul><img src="/posts/18220/image-20240301235153721.png" class="" title="image-20240301235153721"><ul><li>或非门的输入Y7 ~ Y4由一个译码器的输出控制，或非门的一端WR默认为低电平，那么这里的或非门就相当于一个输入为Y（n）的非门</li><li>其中74HC138(U24)的输入为P2口的P27~P25</li><li>通过推导可知，P27 ~ P25对应的三位二进制数即为后面会使能的锁存器，即111使得Y7=0，继而使得与非门输出Y7C=1，使得控制数码管段选的锁存器使能，送出数据。</li></ul><img src="/posts/18220/image-20240301235438487.png" class="" title="image-20240301235438487"><p>总结：P27~P25对应组成的二进制值即为使能的锁存器, LED/数码管/外设控制都是由锁存器控制，锁存器的输入共用<mark>P0口</mark>，这样通过多个锁存器，以及逻辑电路，节省了单片机的IO口</p></blockquote><h1 id="程序设计与分析"><a class="markdownIt-Anchor" href="#程序设计与分析"></a> 程序设计与分析</h1><h2 id="ct107d初始化"><a class="markdownIt-Anchor" href="#ct107d初始化"></a> CT107D初始化</h2><p><strong><mark>上电时，默认所有IO口为高电平，未被使能过的锁存器默认输出低电平，这会导致全部LED被点亮，有源蜂鸣器响(也是低电平有效),这就需要我们写一个程序初始化函数，关闭这些影响后续功能的现象</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief系统初始化函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">System_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*关闭LED*/</span></span><br><span class="line">P0 = <span class="number">0xFF</span>;</span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0x80</span>;    <span class="comment">//100X XXXX 锁存器Y4C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*关闭蜂鸣器*/</span></span><br><span class="line">P0=<span class="number">0x00</span>;<span class="comment">//锁存器输出会经过ULN2003，相当于反相器，预载值应为全低电平，这样最终输出的是高电平</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xA0</span>;    <span class="comment">//101X XXXX 锁存器Y5C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注意：锁存器输出会经过ULN2003，相当于(增强驱动能力)反相器，预载值(P2)应为全低电平，这样最终输出的是高电平。</strong></p><p>ULN2003：<a href="https://blog.csdn.net/qq_38410730/article/details/79787766">【常用芯片】ULN2003工作原理及中文资料（实例：STM32驱动28BYJ48步进电机）_uln2003驱动板说明书-CSDN博客</a></p><p><strong>由于单片机的引脚输出电流太低了，无法驱动大部分的设备。而ULN2003只相当于是一个开关，设备（负载）的供电是在外围电路上，而它能够通过微弱的单片机输出电流来控制外围电路的开闭。这某种程度上也可以说是，放大电流，增加驱动能力</strong></p><img src="/posts/18220/image-20240302002932910.png" class="" title="image-20240302002932910"><img src="/posts/18220/image-20240302003020482.png" class="" title="image-20240302003020482"><h2 id="led模块"><a class="markdownIt-Anchor" href="#led模块"></a> LED模块</h2><p>原理图</p><img src="/posts/18220/image-20240302002203560.png" class="" title="image-20240302002203560"><img src="/posts/18220/image-20240302002230011.png" class="" title="image-20240302002230011"><h2 id="led蜂鸣器继电器"><a class="markdownIt-Anchor" href="#led蜂鸣器继电器"></a> LED/蜂鸣器/继电器</h2><p>ps:~(0x01&lt;&lt;addr); 一定要加括号，否则会出现逻辑错误，如 0000 0001–&gt; 1110 1111 变成 1111 1110 – &gt; 1110 0000 ，最终经过一系列运行导致<mark>LED亮度降低</mark>(待考究)。</p><p>ps:<mark>一定要仔细注意逻辑，不能记忆性写程序！</mark></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  LED控制函数</span></span><br><span class="line"><span class="comment">  * @param  LED位，使能标志位</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_1;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old_1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Disp</span><span class="params">(<span class="type">unsigned</span> addr,enable)</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp=<span class="number">0x00</span>;   <span class="comment">// led暂存值</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old=<span class="number">0xFF</span>; <span class="comment">//上下两个变量应当赋不想等的初值</span></span><br><span class="line"><span class="keyword">if</span>(enable)<span class="comment">//LED使能时</span></span><br><span class="line">{</span><br><span class="line">temp|=<span class="number">0x01</span>&lt;&lt;addr; <span class="comment">//点亮第一位, 即 0x01&lt;&lt;0 temp=xxxx xxx1</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">temp&amp;=~(<span class="number">0x01</span>&lt;&lt;addr); <span class="comment">//熄灭第一位，即~ (0x01&lt;&lt;0) temp=xxxx xxx0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(temp!=temp_old) <span class="comment">// temp的值发生变化时（即外部调用此函数，想要改变LED的状态），才会对P0进行赋值操作，因为P0口负责多个锁存器的预载值，LED一般是静态的，不应该对P0进行反复赋值</span></span><br><span class="line">{</span><br><span class="line">P0=~temp; <span class="comment">//低电平有效，故按位取反</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0x80</span>;    <span class="comment">//100X XXXX 锁存器（Y4C使能）</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//000 x xxxx</span></span><br><span class="line">temp_old=temp;<span class="comment">//记录当前的led暂存值</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Beep</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">temp_1 |= <span class="number">0x40</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp_1 &amp;= ~<span class="number">0x40</span>;</span><br><span class="line"><span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">{</span><br><span class="line">P0 = temp_1;</span><br><span class="line">P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>; <span class="comment">//锁存器（Y5C使能）</span></span><br><span class="line">P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">temp_old_1 = temp_1;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Relay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">temp_1 |= <span class="number">0x10</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp_1 &amp;= ~<span class="number">0x10</span>;</span><br><span class="line"><span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">{</span><br><span class="line">P0 = temp_1;</span><br><span class="line">P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;<span class="comment">//锁存器（Y5C使能）</span></span><br><span class="line">P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">temp_old_1 = temp_1;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>PS:按位取或/按位取与，通常用于对单个BIT位进行操作</strong></p><h2 id="数码管模块"><a class="markdownIt-Anchor" href="#数码管模块"></a> 数码管模块</h2><p>ps:<strong><mark>蓝桥杯单片机开发板使用的是共阳极数码管，注意段码和位码，以及Disp函数的逻辑</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//共阳极数码管</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_seg[] = <span class="comment">//段码</span></span><br><span class="line">{</span><br><span class="line"><span class="number">0xc0</span>, <span class="comment">//0</span></span><br><span class="line"><span class="number">0xf9</span>, <span class="comment">//1</span></span><br><span class="line"><span class="number">0xa4</span>, <span class="comment">//2</span></span><br><span class="line"><span class="number">0xb0</span>, <span class="comment">//3</span></span><br><span class="line"><span class="number">0x99</span>, <span class="comment">//4</span></span><br><span class="line"><span class="number">0x92</span>, <span class="comment">//5</span></span><br><span class="line"><span class="number">0x82</span>, <span class="comment">//6</span></span><br><span class="line"><span class="number">0xf8</span>, <span class="comment">//7</span></span><br><span class="line"><span class="number">0x80</span>, <span class="comment">//8</span></span><br><span class="line"><span class="number">0x90</span>, <span class="comment">//9</span></span><br><span class="line"><span class="number">0xFF</span>, <span class="comment">//熄灭&lt;10&gt;</span></span><br><span class="line"><span class="number">0x88</span>, <span class="comment">//A &lt;11&gt;</span></span><br><span class="line"><span class="number">0x83</span>, <span class="comment">//b&lt;12&gt;</span></span><br><span class="line"><span class="number">0xc6</span>, <span class="comment">//C&lt;13&gt;</span></span><br><span class="line"><span class="number">0xa1</span>, <span class="comment">//d&lt;14&gt;</span></span><br><span class="line"><span class="number">0x86</span>, <span class="comment">//E&lt;15&gt;</span></span><br><span class="line"><span class="number">0x8e</span>  <span class="comment">//F&lt;16&gt;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Location[] =  <span class="comment">//位码</span></span><br><span class="line">{</span><br><span class="line"><span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x02</span>,</span><br><span class="line"><span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x08</span>,</span><br><span class="line"><span class="number">0x10</span>,</span><br><span class="line"><span class="number">0x20</span>,</span><br><span class="line"><span class="number">0x40</span>,</span><br><span class="line"><span class="number">0x80</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief数码管点亮函数</span></span><br><span class="line"><span class="comment">  * @param  位选，段选，小数点</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,Seg,Point)</span></span><br><span class="line">{</span><br><span class="line">P0=<span class="number">0xFF</span>; <span class="comment">//段码，数码管熄灭，消影</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xE0</span>;    <span class="comment">//111X XXXX 锁存器 Y7C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//关闭锁存器</span></span><br><span class="line"></span><br><span class="line">P0=Nixie_Location[Location];<span class="comment">//位选预载值</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xC0</span>;    <span class="comment">//101X XXXX 锁存器 Y5C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//关闭锁存器</span></span><br><span class="line"></span><br><span class="line">P0=Nixie_seg[Seg];<span class="comment">//段选预载值</span></span><br><span class="line">    <span class="comment">//这里的Point即为数码管‘点’的使能位，实质上‘点’对应的是数码管段码的BIT7，最高位</span></span><br><span class="line"><span class="keyword">if</span>(Point){P0 &amp;= <span class="number">0x7F</span>;}    <span class="comment">//错误写法：P0|=0x80; 共阳极数码管！，逻辑0点亮！</span></span><br><span class="line">P2 = P2 &amp; <span class="number">0x1F</span> | <span class="number">0xE0</span>;   <span class="comment">//111X XXXX 锁存器 Y7C使能</span></span><br><span class="line">P2 &amp;= <span class="number">0x1F</span>;<span class="comment">//关闭锁存器</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定时器模块"><a class="markdownIt-Anchor" href="#定时器模块"></a> 定时器模块</h2><p><strong><mark>注意，STC15单片机的定时器是支持自动重装载的，这里不需要在中断子程序中赋初值，否则会出现定时器定时值的混乱</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief定时器初始化</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0x7F</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0xF0</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL0 = <span class="number">0x18</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF0 = <span class="number">0</span>;<span class="comment">//清除TF0标志</span></span><br><span class="line">TR0 = <span class="number">1</span>;<span class="comment">//定时器0开始计时</span></span><br><span class="line">ET0 = <span class="number">1</span>;<span class="comment">//定时器中断0打开</span></span><br><span class="line">EA  = <span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">PT0 = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void Timer0_Server(void)  interrupt 1</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="按键模块"><a class="markdownIt-Anchor" href="#按键模块"></a> 按键模块</h2><p>ps:<strong><mark>键值读取函数中定义局部变量temp一定要赋初值！！！否则会出现在没有按键按下时键值读取异常值的情况。</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief矩阵按键读取函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/*矩阵按键模式*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp=<span class="number">0</span>;<span class="comment">//局部变量初始化为0</span></span><br><span class="line">    ET0=<span class="number">0</span>;<span class="comment">//串口使用屏蔽</span></span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">4</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">5</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">6</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">7</span>;}</span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">8</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">9</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">10</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">11</span>;}</span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">12</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">13</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">14</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">15</span>;}</span><br><span class="line">P44=<span class="number">0</span>;P42=<span class="number">1</span>;P35=<span class="number">1</span>;P34=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(P33==<span class="number">0</span>){temp=<span class="number">16</span>;}</span><br><span class="line"><span class="keyword">if</span>(P32==<span class="number">0</span>){temp=<span class="number">17</span>;}</span><br><span class="line"><span class="keyword">if</span>(P31==<span class="number">0</span>){temp=<span class="number">18</span>;}</span><br><span class="line"><span class="keyword">if</span>(P30==<span class="number">0</span>){temp=<span class="number">19</span>;}</span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//串口使用打开</span></span><br><span class="line">    P3=<span class="number">0xff</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief独立按键读取函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/*独立按键模式*/</span></span><br><span class="line"><span class="comment">/*unsigned char Key_Read(void)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(P33==0){temp=4;}</span></span><br><span class="line"><span class="comment">if(P32==0){temp=5;}</span></span><br><span class="line"><span class="comment">if(P31==0){temp=6;}</span></span><br><span class="line"><span class="comment">if(P30==0){temp=7;}</span></span><br><span class="line"><span class="comment">return temp;</span></span><br><span class="line"><span class="comment">}*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="主函数模块"><a class="markdownIt-Anchor" href="#主函数模块"></a> 主函数模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信息（数码管）显示处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*其他信息处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行程序模块</span></span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line">Nixie_Proc();</span><br><span class="line">LED_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="超声波模块使用pca"><a class="markdownIt-Anchor" href="#超声波模块使用pca"></a> 超声波模块（使用PCA）</h2><p><strong>ps:<mark>返回值的单位是cm,可以根据题目要求更改底层</mark></strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ultrasound.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"intrins.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit Tx = P1^<span class="number">0</span>;</span><br><span class="line">sbit Rx = P1^<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">()</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">38</span>;</span><br><span class="line"><span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">()</span> <span class="comment">//超声波模块初始化</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">Tx = <span class="number">1</span>;</span><br><span class="line">Delay12us();</span><br><span class="line">Tx = <span class="number">0</span>;</span><br><span class="line">Delay12us();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    CCON =  <span class="number">0x00</span>;<span class="comment">// 初始化PCA控制寄存器，PCA定时器停止，清除CF</span></span><br><span class="line">    CH = CL = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    EA=<span class="number">0</span>;<span class="comment">//总中断关闭</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">    CR = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (CF == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    CR = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(CF == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = CH &lt;&lt; <span class="number">8</span> | CL;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        CF = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="串口模块putchar重定向"><a class="markdownIt-Anchor" href="#串口模块putchar重定向"></a> 串口模块（putchar重定向）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* putchar重定向 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">putchar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">SBUF= ch;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line"><span class="keyword">return</span> (ch);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="串口中断服务程序"><a class="markdownIt-Anchor" href="#串口中断服务程序"></a> 串口中断服务程序</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart_Server</span><span class="params">()</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI == <span class="number">1</span> &amp;&amp; Uart_RecData_Index &lt;<span class="number">8</span>)</span><br><span class="line">    {</span><br><span class="line">        Uart_RecData[Uart_RecData_Index++]=SBUF;</span><br><span class="line">        RI=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Uart_RecData_Index == <span class="number">6</span>)</span><br><span class="line">    {</span><br><span class="line">        Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定时器使用注意事项"><a class="markdownIt-Anchor" href="#定时器使用注意事项"></a> 定时器使用注意事项：</h2><ul><li>定时器0：主要工作定时器.NE555方波发生器</li><li>定时器1：一般用于PWM,使用NE555时,主要定时器选为定时器1</li><li>定时器2：串口中断1绑定</li><li>PCA：用于超声波模块</li></ul><h1 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> #补充</h1><h2 id="一-iic模块"><a class="markdownIt-Anchor" href="#一-iic模块"></a> 一、IIC模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  程序说明: IIC总线驱动程序</span></span><br><span class="line"><span class="comment">  软件环境: Keil uVision 4.10 </span></span><br><span class="line"><span class="comment">  硬件环境: CT107单片机综合实训平台 8051，12MHz</span></span><br><span class="line"><span class="comment">  日    期: 2011-8-9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iic.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"intrins.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Photo_Res_Channel 0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Adj_Res_Channel 0x43</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//总线引脚定义</span></span><br><span class="line">sbit SDA = P2^<span class="number">1</span>;  <span class="comment">/* 数据线 */</span></span><br><span class="line">sbit SCL = P2^<span class="number">0</span>;  <span class="comment">/* 时钟线 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">do</span>{_nop_();}</span><br><span class="line">    <span class="keyword">while</span>(i--);        </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay200us</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span>;</span><br><span class="line">j = <span class="number">82</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//总线启动条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//总线停止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应答</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendAck</span><span class="params">(bit ackbit)</span></span><br><span class="line">{</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA = ackbit;  <span class="comment">// 0：应答，1：非应答</span></span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = <span class="number">0</span>; </span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答</span></span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL  = <span class="number">1</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    <span class="keyword">return</span> ackbit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过I2C总线发送数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SCL  = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        <span class="keyword">if</span>(byt &amp; <span class="number">0x80</span>) SDA  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> SDA  = <span class="number">0</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        byt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    SCL  = <span class="number">0</span>;  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//从I2C总线上接收数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i, da;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    {   </span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">IIC_Delay(DELAY_TIME);</span><br><span class="line">da &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(SDA) da |= <span class="number">1</span>;</span><br><span class="line">SCL = <span class="number">0</span>;</span><br><span class="line">IIC_Delay(DELAY_TIME);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> da;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于iic的adda转换"><a class="markdownIt-Anchor" href="#基于iic的adda转换"></a> 基于IIC的AD/DA转换</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">AD_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line">    </span><br><span class="line">    IIC_Start();       <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr); <span class="comment">//主机发送一个字节(要操作数据的地址),对应AD转换的通道</span></span><br><span class="line">    IIC_WaitAck();      <span class="comment">//主机等待应答</span></span><br><span class="line">    </span><br><span class="line">    IIC_Start(); <span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x91</span>); <span class="comment">//主机发送寻址信号, 确认PCF8591，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    temp = IIC_RecByte(); <span class="comment">//从机送出数据,主机读入的数据用变量存储</span></span><br><span class="line">    IIC_SendAck(<span class="number">1</span>);<span class="comment">//主机发送应答,1表示完成数据的接收,从机停止发送数据</span></span><br><span class="line">    IIC_Stop();<span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DA_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x90</span>);<span class="comment">//主机发送寻址信号, 确认PCF8591，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(<span class="number">0x41</span>); <span class="comment">//主机发送一个字节(要操作数据的地址),对应DA转换的通道</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(Data); <span class="comment">//主机送出DA输出的数据字节</span></span><br><span class="line">    IIC_WaitAck(); <span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_Stop(); <span class="comment">//中止信号,结束IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于iic的at24c02epprom储存器"><a class="markdownIt-Anchor" href="#基于iic的at24c02epprom储存器"></a> 基于IIC的AT24C02(EPPROM)储存器</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节,最好是八的倍数，如果不是8的倍数，将无法写入整页的字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环发送数据字节,存入AT24C02</span></span><br><span class="line">    {</span><br><span class="line">        IIC_SendByte(*EEPROM_String++);<span class="comment">//发送数据字节,要存入AT24C02的数据,字节个数为num</span></span><br><span class="line">        IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">        IIC_Delay(<span class="number">200</span>);<span class="comment">//延时200ms,保证从机(AT24C02能够完整收到数据)</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *EEPROM_String,<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> num)</span></span><br><span class="line">{</span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA0</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，写模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line">    IIC_SendByte(addr);<span class="comment">//发送一个要操作数据的地址字节</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答  </span></span><br><span class="line"></span><br><span class="line">    IIC_Start();<span class="comment">//主机发送开始信号</span></span><br><span class="line">    IIC_SendByte(<span class="number">0xA1</span>);<span class="comment">//主机发送寻址信号，确认EEPROM芯片，读模式</span></span><br><span class="line">    IIC_WaitAck();<span class="comment">//主机等待应答</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num--)<span class="comment">//循环接收数据字节,存入EEPROM_String指向的地址</span></span><br><span class="line">    {</span><br><span class="line">        *EEPROM_String++=IIC_RecByte();<span class="comment">//指针移位读取数据到对应的地址中</span></span><br><span class="line">        <span class="keyword">if</span>(num)<span class="comment">//判断是否读取完数据</span></span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">0</span>);<span class="comment">//发送应答0,表示继续接收数据</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            IIC_SendAck(<span class="number">1</span>);<span class="comment">//发送应答1,表示停止接收数据</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    IIC_Stop();<span class="comment">//终止IIC通信</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二-onewire模块"><a class="markdownIt-Anchor" href="#二-onewire模块"></a> 二、onewire模块</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"onewire.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"reg52.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit DQ = P1^<span class="number">4</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线内部延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_OneWire</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>  </span><br><span class="line">{</span><br><span class="line">t *= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线写操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_DS18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">DQ = dat&amp;<span class="number">0x01</span>;</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线读操作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_DS18B20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(DQ)</span><br><span class="line">{</span><br><span class="line">dat |= <span class="number">0x80</span>;</span><br><span class="line">}    </span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//DS18B20初始化</span></span><br><span class="line">bit <span class="title function_">init_ds18b20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  bit initflag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">12</span>);</span><br><span class="line">  DQ = <span class="number">0</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">80</span>);</span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">10</span>); </span><br><span class="line">    initflag = DQ;     </span><br><span class="line">  Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> initflag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">rd_temperature</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> low,high;</span><br><span class="line">init_ds18b20();<span class="comment">//初始化ds18b20;</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//跳过ROM指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0x44</span>);<span class="comment">//开始温度转换</span></span><br><span class="line"></span><br><span class="line">init_ds18b20();<span class="comment">//初始化ds18b20;</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//跳过ROM指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0xBe</span>);<span class="comment">//开始温度读取</span></span><br><span class="line"></span><br><span class="line">low = Read_DS18B20();</span><br><span class="line">high = Read_DS18B20();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (high &lt;&lt; <span class="number">8</span> | low)/<span class="number">16.0</span>;<span class="comment">//二进制转十进制</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ds1302模块"><a class="markdownIt-Anchor" href="#ds1302模块"></a> #DS1302模块</h2><h3 id="ds1302时钟芯片底层"><a class="markdownIt-Anchor" href="#ds1302时钟芯片底层"></a> DS1302（时钟芯片）底层</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ds1302.h"</span></span></span><br><span class="line">sbit SCK=P1^<span class="number">7</span>;</span><br><span class="line">sbit SDA=P2^<span class="number">3</span>;</span><br><span class="line">sbit RST = P1^<span class="number">3</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302</span><span class="params">(<span class="type">unsigned</span>  <span class="type">char</span> temp)</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)     </span><br><span class="line">{ </span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">SDA=temp&amp;<span class="number">0x01</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">SCK=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302_Byte</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address,<span class="type">unsigned</span> <span class="type">char</span> dat )</span>     </span><br><span class="line">{</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>; _nop_();  </span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> Write_Ds1302(dat);</span><br><span class="line"> RST=<span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_Ds1302_Byte</span> <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address )</span></span><br><span class="line">{</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> i,temp=<span class="number">0x00</span>;</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>;_nop_();</span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) </span><br><span class="line"> {</span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(SDA)</span><br><span class="line"> temp|=<span class="number">0x80</span>;</span><br><span class="line"> SCK=<span class="number">1</span>;</span><br><span class="line">} </span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line">SCK=<span class="number">1</span>;_nop_();</span><br><span class="line">SDA=<span class="number">0</span>;_nop_();</span><br><span class="line">SDA=<span class="number">1</span>;_nop_();</span><br><span class="line"><span class="keyword">return</span> (temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写"><a class="markdownIt-Anchor" href="#基于底层的时序编写"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Set_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x00</span>);<span class="comment">//关闭写保护</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x84</span>-i*<span class="number">2</span>,ucRtc[i]);<span class="comment">//给ds1302写入数据,0x84时 0x82分 0x80秒</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x80</span>);<span class="comment">//打开写保护</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">ucRtc[i] = Read_Ds1302_Byte(<span class="number">0x85</span>-i*<span class="number">2</span>);<span class="comment">//读取ds1302的数据</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x00</span>);<span class="comment">//关闭写保护</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8c</span>,ucDate[<span class="number">0</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x88</span>,ucDate[<span class="number">1</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x86</span>,ucDate[<span class="number">2</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0x80</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">ucDate[<span class="number">0</span>] = Read_Ds1302_Byte(<span class="number">0x8d</span>);</span><br><span class="line">ucDate[<span class="number">1</span>] = Read_Ds1302_Byte(<span class="number">0x89</span>);</span><br><span class="line">ucDate[<span class="number">2</span>] = Read_Ds1302_Byte(<span class="number">0x87</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li><p><strong>程序模板使用到的模块：</strong></p><ul><li>系统初始化、按键、数码管、LED（继电器、蜂鸣器）</li><li>串口(定时器2)、超声波(PCA)，NE555(定时器0（计数器模式))，定时器1</li><li>IIC（AD/DA转换、AT24C02存储器）、OneWire（ds18b20温度读取）</li><li>DS1302时钟芯片</li></ul></li><li><p><strong>单片机程序设计，模块化，可读性强，执行效率高，占用储存空间小，以及契合硬件电路底层原理是最重要的思路</strong></p></li><li><p><strong>后续设计功能更复杂，更强的单片机/嵌入式系统时，就要拓展相关的知识面，进一步提升对单片机/各种芯片/电路的认识。</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;为了确保程序的准确性，总结了以下要点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;mark&gt;保证程序&lt;strong&gt;逻辑正确&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="蓝桥杯" scheme="https://szturin.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="C语言" scheme="https://szturin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="STC15" scheme="https://szturin.github.io/tags/STC15/"/>
    
    <category term="蓝桥杯" scheme="https://szturin.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="数字电路" scheme="https://szturin.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[1] 文件寄存器RAM</title>
    <link href="https://szturin.github.io/posts/52613/"/>
    <id>https://szturin.github.io/posts/52613/</id>
    <published>2024-02-29T02:30:18.000Z</published>
    <updated>2024-05-02T11:56:21.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课堂记录"><a class="markdownIt-Anchor" href="#课堂记录"></a> 课堂记录</h2><img src="/posts/52613/image-20240229103029035.png" class="" title="image-20240229103029035"><h2 id="配置位"><a class="markdownIt-Anchor" href="#配置位"></a> 配置位</h2><img src="/posts/52613/image-20240229205150184.png" class="" title="image-20240229205150184">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;课堂记录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#课堂记录&quot;&gt;&lt;/a&gt; 课堂记录&lt;/h2&gt;
&lt;img src=&quot;/posts/52613/image-20240229103029035.png&quot; class=&quot;&quot; title=&quot;i</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[4]定时器中断</title>
    <link href="https://szturin.github.io/posts/57601/"/>
    <id>https://szturin.github.io/posts/57601/</id>
    <published>2024-02-28T12:43:14.000Z</published>
    <updated>2024-05-02T12:04:47.394Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>打开RCC内部时钟</p></li><li><p>选择时基单元时钟源</p></li><li><p>配置时基单元</p></li><li><p>配置输出中断控制，允许更新中断输出到NVIC</p></li><li><p>配置NVIC，打开定时器通道，并分配一个优先级</p></li><li><p>运行控制</p></li></ul><h1 id="相关函数"><a class="markdownIt-Anchor" href="#相关函数"></a> 相关函数</h1><blockquote><ul><li>恢复缺省配置</li></ul><p>TIM_DeInit(TIM_TypeDef* TIMx);</p><ul><li>时基单元初始化</li></ul><p>TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</p><blockquote><p>TIMx：选择定时器</p><p>TIM_TimeBaseInitStruct：结构体，定时器有关的配置</p></blockquote><ul><li>结构体初始化</li></ul><p>TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</p><ul><li>使能计数器，对应<mark>运行控制</mark></li></ul><p>TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);</p><ul><li>中断输出使能控制</li></ul><p>TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState); 使能中断输出</p><blockquote><p>uint16_t TIM 选择中断输出</p><p>NewState：使能状态</p></blockquote><p><strong>时基单元的时钟选择部分函数：</strong></p><ul><li>选择内部时钟</li></ul><p>void TIM_InternalClockConfig(TIM_TypeDef* TIMx);</p><ul><li>选择ITRX其他定时器的时钟</li></ul><p>void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><blockquote><p>TIMx 选择要配置的寄存器</p><p>TIM_InputTriggerSource 选择接入的寄存器</p></blockquote><ul><li>选择TIX捕获通道的时钟</li></ul><p>void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,uint16_t TIM_ICPolarity, uint16_t ICFilter);</p><blockquote><p>TIM_TIxExternalCLKSource,uint16_t  选择TIX具体的引脚</p><p>TIM_ICPolarity 输入的极性</p><p>ICFilter 滤波器</p></blockquote><ul><li>选择ETR通过外部时钟模式1输入的时钟</li></ul><p>void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,  uint16_t ExtTRGFilter);</p><blockquote><p>TIM_ExtTRGPrescaler 可以对ETR外部时钟再次分频</p><p>ExtTRGPolarity/ExtTRGFilter 极性/滤波器</p></blockquote><ul><li>选择ETR通过外部时钟模式1输入的时钟</li></ul><p>void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);</p><blockquote><p>同TIM_ETRClockMode1Config(</p></blockquote><ul><li>单独配置ETR引脚的预分频器、极性、滤波器这些参数</li></ul><p>void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,<br>uint16_t ExtTRGFilter);</p></blockquote><p><strong>初始化后，像自动重装值和预分频值等等，可能需要修改，有一些函数可以单独修改这些参数</strong></p><blockquote><ul><li>单独修改预分频值</li></ul><p>void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);</p><blockquote><p>uint16_t Prescaler 要写入的预分频值</p><p>PSCReloadMode 写入的模式</p></blockquote><ul><li>改变计数器的计数模式</li></ul><p>void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);</p><blockquote><p>TIM_CounterMode 计数器的计数模式</p></blockquote><ul><li>自动重装器<mark>预装功能</mark>配置</li></ul><p>void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);</p><blockquote><p>NewState 使能状态</p></blockquote><ul><li>给计数器写入一个值</li></ul><p>void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter);</p><ul><li>给自动重装器写入一个值</li></ul><p>void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);</p><ul><li>获取当前计数器的值</li></ul><p>uint16_t TIM_GetCounter(TIM_TypeDef* TIMx);</p><ul><li>获取当前预分频器的值</li></ul><p>uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);</p><ul><li>获取/清除标志位相关函数</li></ul><p>FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);<br>void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);<br>ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);<br>void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);</p></blockquote><h2 id="编写定时器初始化框架"><a class="markdownIt-Anchor" href="#编写定时器初始化框架"></a> 编写定时器初始化框架</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="滤波原理"><a class="markdownIt-Anchor" href="#滤波原理"></a> 滤波原理</h2><img src="/posts/57601/image-20240229000125982.png" class="" title="image-20240229000125982"><ul><li><p>在一个固定的时钟频率f下进行采样，如果连续N个采样点都是相同的电平，说明信号稳定，如果N个采样点抖动，就让输出保持不变，这样就能保证输出信号在一定程度上被滤波保护。</p></li><li><p>采样点数越多，滤波效果越好，但是同时信号延迟越大</p></li><li><p>采样频率的来源？</p><ul><li>由内部时钟直接而来</li><li>也可是内部时钟+一个时钟分频而来</li></ul></li></ul><p><strong>TIM_Clock_Division_CKD的取值</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define TIM_CKD_DIV1                       ((uint16_t)0x0000)//1分频</span><br><span class="line">#define TIM_CKD_DIV2                       ((uint16_t)0x0100)</span><br><span class="line">#define TIM_CKD_DIV4                       ((uint16_t)0x0200)</span><br></pre></td></tr></tbody></table></figure><h2 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> 代码部分</h2><h3 id="一-定时器中断内部时钟"><a class="markdownIt-Anchor" href="#一-定时器中断内部时钟"></a> 一、定时器中断（内部时钟）</h3><p><strong>定时器底层程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line"><span class="comment">/*时基单元关键寄存器*/</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">7200</span> - <span class="number">1</span>;<span class="comment">//ARR ， 对72MHZ进行7200分频 也就是10MHZ</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">10000</span> - <span class="number">1</span>;<span class="comment">//PSC，计数器重装载值，10000次清零,控制ARR和PSC可以控制计数频率</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"><span class="comment">//1--&gt;注意：更新中断和更新事件同时发生，初始化会立刻进入中断</span></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//2--&gt;手动清理中断标志位</span></span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//中断配置，选择更新中断,使能</span></span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel= TIM2_IRQn;<span class="comment">//定时器通道设置，选择TIM2_IRQn</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd= ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//定时器初始化</span></span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断服务程序模板</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);//清除标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Encoder.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Num;<span class="comment">//定义一个16位的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Num:"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"CNT:"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);<span class="comment">//计时的值</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);<span class="comment">//CNT计数器的值</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)<span class="comment">//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);<span class="comment">//清除标志位</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二-外部时钟"><a class="markdownIt-Anchor" href="#二-外部时钟"></a> 二、外部时钟</h3><p><strong>定时器底层程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA时钟</span></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIM_InternalClockConfig(TIM2);//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line">TIM_ETRClockMode2Config(TIM2,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted,<span class="number">0x00</span>);<span class="comment">//通过ETR引脚的外部时钟模式2配置</span></span><br><span class="line"><span class="comment">//定时器选择    不需要分频    外部触发的极性：不反相     外部触发滤波器,决定F和N，这里不需要滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line"><span class="comment">/**时基单元关键寄存器**/</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">1</span> - <span class="number">1</span>;<span class="comment">//ARR ， 对72MHZ进行7200分频 也就是10MHZ</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">10</span> - <span class="number">1</span>;<span class="comment">//PSC，计数器重装载值，10000次清零,控制ARR和PSC可以控制计数频率</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"><span class="comment">//1--&gt;注意：更新中断和更新事件同时发生，初始化会立刻进入中断</span></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//2--&gt;手动清理中断标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//中断配置，选择更新中断,使能</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel= TIM2_IRQn;<span class="comment">//定时器通道设置，选择TIM2_IRQn</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd= ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//NVIC初始化</span></span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//CNT值封装函数</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">Timer_GetCounter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> TIM_GetCounter(TIM2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);//清除标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Encoder.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Num=<span class="number">0</span>;<span class="comment">//定义一个16位的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Num:"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"CNT:"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);<span class="comment">//计时的值</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Timer_GetCounter(),<span class="number">5</span>);<span class="comment">//CNT计数器的值</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)<span class="comment">//获取中断标志位，参数：定时器2，检测更新标志位</span></span><br><span class="line">{</span><br><span class="line">Num++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);<span class="comment">//清除标志位</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><mark><strong>什么时候可以使用浮空输入？</strong></mark></p><p>如果外部输入的信号功率很小时，内部的上拉电阻可能影响到外部输入信号，这时候就使用浮空输入模式，防止影响外部输入电平。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;打开RCC内部时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择时基单元时钟源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置时基单元&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置输出中断控制，允许更新中断输出到NVIC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置NVI</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="定时器" scheme="https://szturin.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[3]EXTI外部中断</title>
    <link href="https://szturin.github.io/posts/44123/"/>
    <id>https://szturin.github.io/posts/44123/</id>
    <published>2024-02-27T16:19:42.000Z</published>
    <updated>2024-05-02T12:04:13.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stm32的中断结构"><a class="markdownIt-Anchor" href="#stm32的中断结构"></a> stm32的中断结构</h1><img src="/posts/44123/image-20240228002139630.png" class="" title="image-20240228002139630"><h2 id="nvic"><a class="markdownIt-Anchor" href="#nvic"></a> NVIC</h2><p><a href="https://blog.csdn.net/liuqi3256797/article/details/89891621">STM32中的NVIC详解_stm32 nvic-CSDN博客</a></p><h2 id="exti"><a class="markdownIt-Anchor" href="#exti"></a> EXTI</h2><img src="/posts/44123/image-20240228002339511.png" class="" title="image-20240228002339511"><img src="/posts/44123/image-20240228002507136.png" class="" title="image-20240228002507136"><h2 id="一-对射式红外传感器计次"><a class="markdownIt-Anchor" href="#一-对射式红外传感器计次"></a> 一、对射式红外传感器计次</h2><h3 id="红外传感器底层程序"><a class="markdownIt-Anchor" href="#红外传感器底层程序"></a> 红外传感器底层程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count;<span class="comment">//全局变量，用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：计数传感器初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*外部中断的定义*/</span></span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);<span class="comment">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO初始化*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//将PB14引脚初始化为上拉输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*AFIO选择中断引脚*/</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);<span class="comment">//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*EXTI初始化*/</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">EXTI_InitStructure.EXTI_Line = EXTI_Line14;<span class="comment">//选择配置外部中断的14号线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;<span class="comment">//指定外部中断线使能</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;<span class="comment">//指定外部中断线为中断模式</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//指定外部中断线为下降沿触发</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);<span class="comment">//将结构体变量交给EXTI_Init，配置EXTI外设</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//配置NVIC为分组2</span></span><br><span class="line"><span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line"><span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line"><span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line"><span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;<span class="comment">//选择配置NVIC的EXTI15_10线</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：获取计数传感器的计数值</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：计数值，范围：0~65535</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：EXTI15_10外部中断函数</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span></span><br><span class="line"><span class="comment">  *           函数名为预留的指定名称，可以从启动文件复制</span></span><br><span class="line"><span class="comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//每次进入中断服务程序，中断标志位都会置1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line14) == SET)<span class="comment">//判断是否是外部中断14号线触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">CountSensor_Count ++;<span class="comment">//计数值自增一次</span></span><br><span class="line">}</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line14);<span class="comment">//清除外部中断14号线的中断标志位</span></span><br><span class="line"><span class="comment">//中断标志位必须清除</span></span><br><span class="line"><span class="comment">//否则中断将连续不断地触发，导致主程序卡死</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="主程序"><a class="markdownIt-Anchor" href="#主程序"></a> 主程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Count:"</span>);</span><br><span class="line">CountSensor_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">7</span>,CountSensor_Get(),<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="二-旋转编码器"><a class="markdownIt-Anchor" href="#二-旋转编码器"></a> 二、旋转编码器</h2><h3 id="底层程序"><a class="markdownIt-Anchor" href="#底层程序"></a> 底层程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count;<span class="comment">//全局变量，用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：计数传感器初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*外部中断的定义*/</span></span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);<span class="comment">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO初始化*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//将PB14引脚初始化为上拉输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*AFIO选择中断引脚*/</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);<span class="comment">//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*EXTI初始化*/</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">EXTI_InitStructure.EXTI_Line = EXTI_Line14;<span class="comment">//选择配置外部中断的14号线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;<span class="comment">//指定外部中断线使能</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;<span class="comment">//指定外部中断线为中断模式</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//指定外部中断线为下降沿触发</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);<span class="comment">//将结构体变量交给EXTI_Init，配置EXTI外设</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC中断分组*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//配置NVIC为分组2</span></span><br><span class="line"><span class="comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span></span><br><span class="line"><span class="comment">//此分组配置在整个工程中仅需调用一次</span></span><br><span class="line"><span class="comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span></span><br><span class="line"><span class="comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;<span class="comment">//选择配置NVIC的EXTI15_10线</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//指定NVIC线路使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的抢占优先级为1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;<span class="comment">//指定NVIC线路的响应优先级为1</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：获取计数传感器的计数值</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：计数值，范围：0~65535</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：EXTI15_10外部中断函数</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span></span><br><span class="line"><span class="comment">  *           函数名为预留的指定名称，可以从启动文件复制</span></span><br><span class="line"><span class="comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//每次进入中断服务程序，中断标志位都会置1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line14) == SET)<span class="comment">//判断是否是外部中断14号线触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">CountSensor_Count ++;<span class="comment">//计数值自增一次</span></span><br><span class="line">}</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line14);<span class="comment">//清除外部中断14号线的中断标志位</span></span><br><span class="line"><span class="comment">//中断标志位必须清除</span></span><br><span class="line"><span class="comment">//否则中断将连续不断地触发，导致主程序卡死</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="主程序-2"><a class="markdownIt-Anchor" href="#主程序-2"></a> 主程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CountSensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Encoder.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">Encoder_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"Encoder_Count:"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">n += Encoder_Get_Change_value();</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">1</span>, n, <span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;stm32的中断结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stm32的中断结构&quot;&gt;&lt;/a&gt; stm32的中断结构&lt;/h1&gt;
&lt;img src=&quot;/posts/44123/image-20240228002139630.png&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="外部中断" scheme="https://szturin.github.io/tags/%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
</feed>
