<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Turin&#39;s Blog</title>
  
  <subtitle>数理照亮世界</subtitle>
  <link href="https://szturin.github.io/atom.xml" rel="self"/>
  
  <link href="https://szturin.github.io/"/>
  <updated>2024-07-09T12:16:32.962Z</updated>
  <id>https://szturin.github.io/</id>
  
  <author>
    <name>Szturin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Opencv】[1]图像处理基本概念</title>
    <link href="https://szturin.github.io/posts/51713/"/>
    <id>https://szturin.github.io/posts/51713/</id>
    <published>2024-07-07T16:42:28.000Z</published>
    <updated>2024-07-09T12:16:32.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统视觉循迹"><a class="markdownIt-Anchor" href="#传统视觉循迹"></a> 传统视觉循迹</h1><h1 id="基于opencv的传统视觉循迹-demo1"><a class="markdownIt-Anchor" href="#基于opencv的传统视觉循迹-demo1"></a> 基于OpenCV的传统视觉循迹-demo1</h1><p>地平线RDK X3具有相当完善的资料以及社区支持，由于本人对Linux平台，深度学习与机器视觉尚不熟悉，故基于纯Python的方法，利用OpenCV计算机视觉库，制作一个简易的摄像头循迹</p><p><strong>硬件平台：RDK X3派</strong></p><p><strong>摄像头：USB免驱1080P摄像头</strong></p><img src="/posts/51713/image-20220828203147852-0b003de50acfa021faa9568d96f523d5.png" class="" title="image-20220828203147852"><h2 id="开发过程"><a class="markdownIt-Anchor" href="#开发过程"></a> 开发过程：</h2><img src="/posts/51713/29ace386f0b101a5463a90635c37e8b7_720.jpg" class="" title="29ace386f0b101a5463a90635c37e8b7_720"><p>图像处理方案1：</p><ul><li>用USB摄像头连接Linux嵌入式设备，驱动摄像头获取图像，将图像bgr格式转灰度后，使用大津法进行二值化，对白区域进行腐蚀处理</li><li>取一行像素点，本例识别黑色像素，获取黑色像素的数目，黑色像素行中心坐标值，相当于640路的灰度循迹，使用方法类似CCD摄像头</li><li>使用差速的方法进行循迹，左轮+(坐标值-拟合线坐标)*系数，右轮-(坐标值-拟合线坐标)*系数，原理同PID(只含P环)</li></ul><p>PS: RDK X3自带两路PWM GPIO口，按照手册做好相关配置后，即可简单驱动小车了</p><p>待改进点：</p><ul><li>使用PID得到更好的巡线拟合（前级），这部分由RDK X3进行运算，即图像测得坐标与目标拟合线的偏差，使用PID算法（输出符合当前运动状态的目标速度），调节P值，比例作用大,可以加快调节,能迅速反应误差，从而减小稳态误差。调节I值，使系统消除稳态误差，提高无差度。调节D值，减小超调量，克服振荡(大幅低频振荡-&gt;小幅高频振荡)，使系统的稳定性提高，同时加快系统的动态响应速度，减小调整时间，从而改善系统的动态性能。</li><li>使用单片机微控制器获得更精准强大的驱动控制能力，同时进行PID控制（这里用于减少目标速度与当前速度的误差），与上位机前级PID形成串级关系，前级PID输出作为下位机PID控制的输入。</li><li>代码方面：改进代码结构与算法，优化代码执行效率，使用面向对象编程方法，封装代码便于调用与移植</li><li>图传方面： 使用RDK X3引脚编解码代替imshow，进行推流</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"><span class="keyword">import</span> serial.tools.list_ports</span><br><span class="line"><span class="keyword">import</span> Hobot.GPIO <span class="keyword">as</span> GPIO</span><br><span class="line"></span><br><span class="line">img = cv2.VideoCapture(<span class="number">8</span>, cv2.CAP_V4L2) <span class="comment">#使能摄像头8的驱动</span></span><br><span class="line">codec = cv2.VideoWriter_fourcc( <span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span> )</span><br><span class="line"></span><br><span class="line">direction = <span class="number">302</span> <span class="comment">#设置目标拟合线坐标（列数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#图像初始化配置</span></span><br><span class="line">img.<span class="built_in">set</span>(cv2.CAP_PROP_FOURCC, codec)</span><br><span class="line">img.<span class="built_in">set</span>(cv2.CAP_PROP_FPS, <span class="number">30</span>) <span class="comment">#帧数</span></span><br><span class="line">img.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">640</span>) <span class="comment">#列 宽度</span></span><br><span class="line">img.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>) <span class="comment"># 行 高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#串口选择</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"List of enabled UART:"</span>)</span><br><span class="line">os.system(<span class="string">'ls /dev/tty[a-zA-Z]*'</span>)</span><br><span class="line">uart_dev= <span class="built_in">input</span>(<span class="string">"请输出需要测试的串口设备名:"</span>)</span><br><span class="line"><span class="keyword">match</span> uart_dev:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">        uart_dev = <span class="string">"/dev/ttyS0"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">        uart_dev = <span class="string">"/dev/ttyS1"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">        uart_dev = <span class="string">"/dev/ttyS2"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">        uart_dev = <span class="string">"/dev/ttyS3"</span></span><br><span class="line">baudrate = <span class="built_in">input</span>(<span class="string">"请输入波特率(9600,19200,38400,57600,115200,921600):"</span>)</span><br><span class="line">ser = serial.Serial(uart_dev, <span class="built_in">int</span>(baudrate), timeout=<span class="number">1</span>) <span class="comment"># 1s timeout</span></span><br><span class="line"><span class="built_in">print</span>(ser)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Starting demo now! Press CTRL+C to exit"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#PWM引脚号定义</span></span><br><span class="line">pwm_pin1 = <span class="number">32</span></span><br><span class="line">pwm_pin2 = <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#GPIO初始化</span></span><br><span class="line">GPIO.setmode(GPIO.BOARD)</span><br><span class="line">GPIO.setup(<span class="number">16</span>, GPIO.OUT,initial=GPIO.HIGH) <span class="comment">#bn1</span></span><br><span class="line">GPIO.setup(<span class="number">15</span>, GPIO.OUT,initial=GPIO.LOW)  <span class="comment">#bn2</span></span><br><span class="line">GPIO.setup(<span class="number">11</span>, GPIO.OUT,initial=GPIO.HIGH)  <span class="comment">#an1</span></span><br><span class="line">GPIO.setup(<span class="number">13</span>, GPIO.OUT,initial=GPIO.LOW)  <span class="comment">#an2</span></span><br><span class="line">PWM_1 = GPIO.PWM(pwm_pin1, <span class="number">48000</span>)</span><br><span class="line">PWM_2 = GPIO.PWM(pwm_pin2, <span class="number">48000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#占空比初值定义</span></span><br><span class="line">val1 = <span class="number">25</span></span><br><span class="line">val2 = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#控制</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Control</span>():</span><br><span class="line">    PWM_1.ChangeDutyCycle(val1)</span><br><span class="line">    PWM_2 .ChangeDutyCycle(val2)</span><br><span class="line">    PWM_1.start(<span class="built_in">abs</span>(val1))</span><br><span class="line">    PWM_2.start(<span class="built_in">abs</span>(val2))</span><br><span class="line"></span><br><span class="line"><span class="comment">#PID</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PID</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,KP,KI,KD</span>):</span><br><span class="line">        self.KP = KP</span><br><span class="line">        self.KI = KI</span><br><span class="line">        self.KD = KD</span><br><span class="line">        self.p1 , self.p2 = <span class="number">0</span> , <span class="number">0</span><span class="comment">#保留一个帧的误差</span></span><br><span class="line">        self.i = <span class="number">0</span><span class="comment">#积累误差初值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = img.read() <span class="comment">#从相机获取图像</span></span><br><span class="line">    </span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) <span class="comment">#BGR格式转化为灰度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">### cv2.line(frame, (0, 360), (640, 360), color=(0, 0, 255), thickness=3) # 红色的线</span></span><br><span class="line">    <span class="comment">### cv2.line(frame, (0, 240), (640, 240), color=(0, 0, 255), thickness=3) # 红色的线</span></span><br><span class="line"></span><br><span class="line">    retval, dst = cv2.threshold(gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_OTSU)   <span class="comment">##大津法二值化</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    dst = cv2.dilate(dst, <span class="literal">None</span>, iterations=<span class="number">2</span>) <span class="comment"># 膨胀，白区域变大</span></span><br><span class="line">    </span><br><span class="line">    cv2.imshow(<span class="string">"Trace_Mode"</span>, dst) <span class="comment">#显示二值化图像</span></span><br><span class="line"></span><br><span class="line">    color = dst[<span class="number">400</span>] <span class="comment">#获取第400行像素值，视为最底层</span></span><br><span class="line">    <span class="comment">##color1 = dst[360] #获取第360行像素值</span></span><br><span class="line">    <span class="comment">##color2 = dst[240] #获取第240行像素</span></span><br><span class="line">    black_count = np.<span class="built_in">sum</span>(color == <span class="number">0</span>) <span class="comment">#统计第400行像素个数</span></span><br><span class="line">    <span class="comment"># print(black_count) #串口打印底层黑色像素个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> black_count == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"黑色像素点为0"</span>)</span><br><span class="line">            <span class="comment">#time.sleep(0.2)</span></span><br><span class="line">            ser.write(<span class="string">"r:0000l:0000\r\n"</span>.encode())<span class="comment">#在这里加上了串口</span></span><br><span class="line">            <span class="comment"># pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">##black_count_1 = np.sum(color1 == 0) # 黑色像素点数目统计</span></span><br><span class="line">        <span class="comment">##black_count_2 = np.sum(color2 == 0) # 黑色像素点数目统计</span></span><br><span class="line">        black_index = np.where(color == <span class="number">0</span>) <span class="comment">#创建list索引第360行像素值</span></span><br><span class="line">        <span class="comment">##black_index_1 = np.where(color1 == 0) #创建list索引第360行像素值</span></span><br><span class="line">        <span class="comment">##black_index_2 = np.where(color2 == 0)#创建list索引第360行像素值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> black_count_1 &gt; <span class="number">0</span> <span class="keyword">and</span> black_count_2 &gt; <span class="number">0</span>:</span><br><span class="line">            center = (black_index[<span class="number">0</span>][black_count - <span class="number">1</span>] + black_index[<span class="number">0</span>][<span class="number">0</span>] )/<span class="number">2</span></span><br><span class="line">            <span class="comment">##center1 = (black_index_1[0][black_count_1 - 1] + black_index_1[0][0] )/2 #计算第一行像素点中心坐标</span></span><br><span class="line">            <span class="comment">##center2 = (black_index_2[0][black_count_2 - 1] + black_index_2[0][0] )/2 #计算第二行像素点中心坐标</span></span><br><span class="line">            <span class="comment">##cv2.line(frame, (int(center1), 360), (int(center2), 240), color=(0, 255, 0), thickness=2) # 绘出倾角线</span></span><br><span class="line">            err = direction - center <span class="comment">#计算插值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#差速循迹</span></span><br><span class="line">            val1 = <span class="number">15</span> - err*<span class="number">0.04</span></span><br><span class="line">            val2 = <span class="number">15</span> + err*<span class="number">0.04</span></span><br><span class="line">            Control()</span><br><span class="line">            <span class="built_in">print</span>(err)</span><br><span class="line">            <span class="comment">##cv2.imshow("frame", frame)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#检测'Esc'按下，销毁程序    </span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#清空PWM,GPIO引脚</span></span><br><span class="line">PWM_1.stop()</span><br><span class="line">PWM_2.stop()</span><br><span class="line">GPIO.cleanup()</span><br><span class="line"><span class="comment">#释放图像</span></span><br><span class="line">img.release()</span><br><span class="line"><span class="comment">#销毁CV窗口</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h1 id="rdk-x3-开发体验"><a class="markdownIt-Anchor" href="#rdk-x3-开发体验"></a> RDK X3 开发体验</h1><p>题主目前初学Python,OpenCV,Ros2, 且对深度学习，图像处理等知识存在相当大的欠缺，基本参考RDK X3的官方手册学习，不得不说，RDK X3的官方镜像，社区生态支持做的都相当便捷，嵌入式边缘计算设备方面领域能做到对初学者如此友好的仅此一家。</p><blockquote><p>sudo bash -c ‘echo 1 &gt; /sys/devices/system/cpu/cpufreq/boost’</p></blockquote><blockquote><p>可通过<code>sudo hrut_somstatus</code>命令查看当前芯片工作频率、温度等状态：</p></blockquote><blockquote><p>供电不稳定导致X3无法正常启动，或者程序执行过程中摄像头无法正常驱动</p></blockquote><blockquote><p>驱动USB摄像头时应该确定设备号，使用<code>ls /dev/video*</code>命令查看当前的video设备</p></blockquote><blockquote><p>使用 rc.local 可以便捷配置开机自启动脚本</p></blockquote><blockquote><p>使用ros2或者tros命令应配置好环境变量</p></blockquote><blockquote><p>烧录镜像应选择稳定版本，比如 2.10 ，3.0.0beta存在一些小毛病（VNC无法正常使用）</p></blockquote><blockquote><p>vscode remote无法获得opencv imshow的图像，使用MobaXterm则正常显示X3的摄像头图像</p></blockquote><h1 id="rdk-x3多媒体"><a class="markdownIt-Anchor" href="#rdk-x3多媒体"></a> RDK X3多媒体</h1><h2 id="术语约定httpsdeveloperhorizonccdocuments_rdkmultimedia_developmentoverviewterminology"><a class="markdownIt-Anchor" href="#术语约定httpsdeveloperhorizonccdocuments_rdkmultimedia_developmentoverviewterminology"></a> 术语约定(<a href="https://developer.horizon.cc/documents_rdk/multimedia_development/overview#terminology">https://developer.horizon.cc/documents_rdk/multimedia_development/overview#terminology</a>)</h2><table><thead><tr><th>缩写</th><th>全称</th><th>解释</th></tr></thead><tbody><tr><td>VIN</td><td>Video IN</td><td>包含视频处理接入、图像信号处理器、畸变矫正和防抖处理，接收来自sensor的数据并处理，也可以直接接收内存中的图像数据</td></tr><tr><td>VPS</td><td>Video Process System</td><td>包含图像旋转、图像裁剪、缩放功能，可对同一种输入源输出不同分辨率的图像。输入源可以是VIN模块，也可以是内存中的图像数据</td></tr><tr><td>VENC</td><td>Video Encode</td><td>VENC编码模块支持H.264/H.265/JPEG/MJPEG编码，VPS模块处理后的数据可通过编码模块按不同协议编码做码流输出</td></tr><tr><td>VDEC</td><td>Video Decode</td><td>VDEC解码模块支持H.264/H.265/JPEG/MJPEG解码，可对已编码的码流进行解码，交给VPS模块做进一步处理，输出到VOT模块进行显示</td></tr><tr><td>VPU</td><td>Video Processing Unit</td><td>视频处理单元，完成视频的编解码功能</td></tr><tr><td>JPU</td><td>JPEG Processing Unit</td><td>JPEG 图片处理单元，完成JPEG、MJPEG的编解码功能</td></tr><tr><td>VOT</td><td>Video Output</td><td>视频输出模块接收VPS、VDEC的图像数据，可输出到显示设备</td></tr><tr><td>VIO</td><td>Video IN/OUT</td><td>视频输入、输出，包括VIN和VOT模块</td></tr><tr><td>MIPI</td><td>Mobile Industry Processor Interface</td><td>移动产业处理器接口</td></tr><tr><td>CSI</td><td>Camera Serial Interface</td><td>相机串行接口。CSI接口与DSI接口同属一门，都是MIPI（移动产业处理器接口联盟）制定的一种接口规范</td></tr><tr><td>DVP</td><td>Digital Video Port</td><td>数字视频端口</td></tr><tr><td>SIF</td><td>Sensor Interface</td><td>sensor接口，用来接收mipi、dvp或者内存的图像数据</td></tr><tr><td>ISP</td><td>Image Signal Processor</td><td>图像信号处理器，完成图像的效果调校</td></tr><tr><td>LDC</td><td>Lens Distortion Correction</td><td>镜头畸变校正</td></tr><tr><td>DIS</td><td>Digital Image Stabilizer</td><td>数字图像稳定</td></tr><tr><td>DWE</td><td>Dewarp Engine</td><td>畸变矫正引擎，主要是将LDC和DIS集成在一起，包括LDC的畸变矫正和DIS的统计结果</td></tr><tr><td>IPU</td><td>Image Process Unit</td><td>图像信号处理单元，支持图像的旋转、图像裁剪、缩放功能</td></tr><tr><td>GDC</td><td>Geometrical Distortion Correction</td><td>几何畸变矫正</td></tr><tr><td>PYM</td><td>Pyramid</td><td>图像金字塔</td></tr><tr><td>OSD</td><td>On Screen Display</td><td>视频图像叠层显示</td></tr><tr><td>BPU</td><td>Brain Process Unit</td><td>地平线机器人自主研发的可编程AI加速引擎</td></tr><tr><td>HAL</td><td>Hardware Abstraction Layer</td><td>硬件抽象层</td></tr><tr><td>FW</td><td>Firmware</td><td>固件</td></tr><tr><td>Sensor</td><td>Sensor</td><td>如不做特别说明，特指CMOS图像传感器</td></tr></tbody></table><h1 id="usb推理函数解释"><a class="markdownIt-Anchor" href="#usb推理函数解释"></a> USB推理函数解释</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> hobot_dnn <span class="keyword">import</span> pyeasy_dnn <span class="keyword">as</span> dnn</span><br><span class="line"><span class="keyword">from</span> hobot_vio <span class="keyword">import</span> libsrcampy <span class="keyword">as</span> srcampy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> json </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_handler</span>(<span class="params">signal, frame</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nExiting program"</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">output_tensors = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">fcos_postprocess_info = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbSysMem_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"phyAddr"</span>,ctypes.c_double),</span><br><span class="line">        (<span class="string">"virAddr"</span>,ctypes.c_void_p),</span><br><span class="line">        (<span class="string">"memSize"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNQuantiShift_yt</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"shiftLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"shiftData"</span>,ctypes.c_char_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNQuantiScale_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"scaleLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"scaleData"</span>,ctypes.POINTER(ctypes.c_float)),</span><br><span class="line">        (<span class="string">"zeroPointLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"zeroPointData"</span>,ctypes.c_char_p)</span><br><span class="line">    ]    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensorShape_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"dimensionSize"</span>,ctypes.c_int * <span class="number">8</span>),</span><br><span class="line">        (<span class="string">"numDimensions"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensorProperties_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"validShape"</span>,hbDNNTensorShape_t),</span><br><span class="line">        (<span class="string">"alignedShape"</span>,hbDNNTensorShape_t),</span><br><span class="line">        (<span class="string">"tensorLayout"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"tensorType"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"shift"</span>,hbDNNQuantiShift_yt),</span><br><span class="line">        (<span class="string">"scale"</span>,hbDNNQuantiScale_t),</span><br><span class="line">        (<span class="string">"quantiType"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"quantizeAxis"</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">"alignedByteSize"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"stride"</span>,ctypes.c_int * <span class="number">8</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensor_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"sysMem"</span>,hbSysMem_t * <span class="number">4</span>),</span><br><span class="line">        (<span class="string">"properties"</span>,hbDNNTensorProperties_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FcosPostProcessInfo_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"height"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"width"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"ori_height"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"ori_width"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"score_threshold"</span>,ctypes.c_float),</span><br><span class="line">        (<span class="string">"nms_threshold"</span>,ctypes.c_float),</span><br><span class="line">        (<span class="string">"nms_top_k"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"is_pad_resize"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libpostprocess = ctypes.CDLL(<span class="string">'/usr/lib/libpostprocess.so'</span>) </span><br><span class="line"></span><br><span class="line">get_Postprocess_result = libpostprocess.FcosPostProcess</span><br><span class="line">get_Postprocess_result.argtypes = [ctypes.POINTER(FcosPostProcessInfo_t)]  </span><br><span class="line">get_Postprocess_result.restype = ctypes.c_char_p  </span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_bboxs</span>(<span class="params">image, bboxes, classes=get_classes(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="string">"""draw the bboxes in the original image"""</span></span><br><span class="line">    <span class="comment"># 获取类别数量</span></span><br><span class="line">    num_classes = <span class="built_in">len</span>(classes)</span><br><span class="line">    <span class="comment"># 获取图像的高度、宽度和通道数</span></span><br><span class="line">    image_h, image_w, channel = image.shape</span><br><span class="line">    <span class="comment"># 生成颜色列表，每个类别一个颜色</span></span><br><span class="line">    hsv_tuples = [(<span class="number">1.0</span> * x / num_classes, <span class="number">1.</span>, <span class="number">1.</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(num_classes)]</span><br><span class="line">    colors = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: colorsys.hsv_to_rgb(*x), hsv_tuples))</span><br><span class="line">    <span class="comment"># 将颜色值转换为0-255范围内的RGB值</span></span><br><span class="line">    colors = <span class="built_in">list</span>(</span><br><span class="line">        <span class="built_in">map</span>(<span class="keyword">lambda</span> x: (<span class="built_in">int</span>(x[<span class="number">0</span>] * <span class="number">255</span>), <span class="built_in">int</span>(x[<span class="number">1</span>] * <span class="number">255</span>), <span class="built_in">int</span>(x[<span class="number">2</span>] * <span class="number">255</span>)),</span><br><span class="line">            colors))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置字体缩放比例</span></span><br><span class="line">    fontScale = <span class="number">0.5</span></span><br><span class="line">    <span class="comment"># 设置矩形框的厚度</span></span><br><span class="line">    bbox_thick = <span class="built_in">int</span>(<span class="number">0.6</span> * (image_h + image_w) / <span class="number">600</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每个检测结果</span></span><br><span class="line">    <span class="keyword">for</span> i, result <span class="keyword">in</span> <span class="built_in">enumerate</span>(bboxes):</span><br><span class="line">        <span class="comment"># 获取矩形框的位置信息</span></span><br><span class="line">        bbox = result[<span class="string">'bbox'</span>]</span><br><span class="line">        <span class="comment"># 获取检测分数</span></span><br><span class="line">        score = result[<span class="string">'score'</span>]</span><br><span class="line">        <span class="comment"># 获取类别ID</span></span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">int</span>(result[<span class="string">'id'</span>])</span><br><span class="line">        <span class="comment"># 获取类别名称</span></span><br><span class="line">        name = result[<span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将位置信息四舍五入为整数</span></span><br><span class="line">        coor = [<span class="built_in">round</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> bbox]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据类别ID获取对应的颜色</span></span><br><span class="line">        bbox_color = colors[<span class="built_in">id</span>]</span><br><span class="line">        <span class="comment"># 矩形框的两个顶点坐标</span></span><br><span class="line">        c1, c2 = (coor[<span class="number">0</span>], coor[<span class="number">1</span>]), (coor[<span class="number">2</span>], coor[<span class="number">3</span>])</span><br><span class="line">        <span class="comment"># 画矩形框</span></span><br><span class="line">        cv2.rectangle(image, c1, c2, bbox_color, bbox_thick)</span><br><span class="line">        <span class="comment"># 类别名称</span></span><br><span class="line">        classes_name = name</span><br><span class="line">        <span class="comment"># 矩形框内显示的文字</span></span><br><span class="line">        bbox_mess = <span class="string">'%s: %.2f'</span> % (classes_name, score)</span><br><span class="line">        <span class="comment"># 获取文字尺寸</span></span><br><span class="line">        t_size = cv2.getTextSize(bbox_mess,</span><br><span class="line">                                 <span class="number">0</span>,</span><br><span class="line">                                 fontScale,</span><br><span class="line">                                 thickness=bbox_thick // <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 画矩形框的填充部分，用于显示文字背景</span></span><br><span class="line">        cv2.rectangle(image, c1, (c1[<span class="number">0</span>] + t_size[<span class="number">0</span>], c1[<span class="number">1</span>] - t_size[<span class="number">1</span>] - <span class="number">3</span>),</span><br><span class="line">                      bbox_color, -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 在图像上显示文字</span></span><br><span class="line">        cv2.putText(image,</span><br><span class="line">                    bbox_mess, (c1[<span class="number">0</span>], c1[<span class="number">1</span>] - <span class="number">2</span>),</span><br><span class="line">                    cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">                    fontScale, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                    bbox_thick // <span class="number">2</span>,</span><br><span class="line">                    lineType=cv2.LINE_AA)</span><br><span class="line">        <span class="comment"># 打印检测结果</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"{} is in the picture with confidence:{:.4f}"</span>.<span class="built_in">format</span>(</span><br><span class="line">            classes_name, score))</span><br><span class="line">    <span class="comment"># 返回绘制了矩形框和文字的图像</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_display_res</span>():</span><br><span class="line">    <span class="comment"># 检查指定路径下的可执行文件是否存在，如果不存在则返回默认分辨率 1920x1080</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">"/usr/bin/get_hdmi_res"</span>) == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1920</span>, <span class="number">1080</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> subprocess</span><br><span class="line">    <span class="comment"># 使用子进程运行 get_hdmi_res 命令，获取输出</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"/usr/bin/get_hdmi_res"</span>], stdout=subprocess.PIPE)</span><br><span class="line">    result = p.communicate()</span><br><span class="line">    <span class="comment"># 将结果按逗号分割</span></span><br><span class="line">    res = result[<span class="number">0</span>].split(<span class="string">b','</span>)</span><br><span class="line">    <span class="comment"># 确保宽度和高度在合理范围内</span></span><br><span class="line">    res[<span class="number">1</span>] = <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(res[<span class="number">1</span>]), <span class="number">1920</span>), <span class="number">0</span>)</span><br><span class="line">    res[<span class="number">0</span>] = <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(res[<span class="number">0</span>]), <span class="number">1080</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(res[<span class="number">1</span>]), <span class="built_in">int</span>(res[<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get HDMI display object</span></span><br><span class="line">disp = srcampy.Display()</span><br><span class="line"><span class="comment"># For the meaning of parameters, please refer to the relevant documents of HDMI display</span></span><br><span class="line">disp_w, disp_h = get_display_res()</span><br><span class="line">disp.display(<span class="number">0</span>, disp_w, disp_h) <span class="comment"># 显示模块初始化，并配置显示参数</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 FcosPostProcessInfo_t 对象</span></span><br><span class="line">fcos_postprocess_info = FcosPostProcessInfo_t()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标图像的高度和宽度</span></span><br><span class="line">fcos_postprocess_info.height = <span class="number">512</span></span><br><span class="line">fcos_postprocess_info.width = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置原始图像的高度和宽度</span></span><br><span class="line">fcos_postprocess_info.ori_height = disp_h</span><br><span class="line">fcos_postprocess_info.ori_width = disp_w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置分数阈值，用于过滤低置信度的检测框</span></span><br><span class="line">fcos_postprocess_info.score_threshold = <span class="number">0.5</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置非极大值抑制（NMS）的阈值，用于合并重叠的检测框</span></span><br><span class="line">fcos_postprocess_info.nms_threshold = <span class="number">0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 NMS 阶段保留的检测框数量上限</span></span><br><span class="line">fcos_postprocess_info.nms_top_k = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定是否在图像调整大小时使用填充</span></span><br><span class="line">fcos_postprocess_info.is_pad_resize = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(models[<span class="number">0</span>].outputs)):</span><br><span class="line">    <span class="comment"># 设置每个输出张量的布局属性</span></span><br><span class="line">    output_tensors[i].properties.tensorLayout = get_TensorLayout(models[<span class="number">0</span>].outputs[i].properties.layout)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查输出张量的 scale_data 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(models[<span class="number">0</span>].outputs[i].properties.scale_data) == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 如果 scale_data 为空，设置量化类型为 0</span></span><br><span class="line">        output_tensors[i].properties.quantiType = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果 scale_data 不为空，设置量化类型为 2</span></span><br><span class="line">        output_tensors[i].properties.quantiType = <span class="number">2</span>  </span><br><span class="line">        <span class="comment"># 将 scale_data 重新调整形状</span></span><br><span class="line">        scale_data_tmp = models[<span class="number">0</span>].outputs[i].properties.scale_data.reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, models[<span class="number">0</span>].outputs[i].properties.shape[<span class="number">3</span>])  </span><br><span class="line">        <span class="comment"># 将 scale_data 转换为指向浮点数的指针</span></span><br><span class="line">        output_tensors[i].properties.scale.scaleData = scale_data_tmp.ctypes.data_as(ctypes.POINTER(ctypes.c_float))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置每个输出张量的有效形状和对齐形状</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(models[<span class="number">0</span>].outputs[i].properties.shape)):</span><br><span class="line">        output_tensors[i].properties.validShape.dimensionSize[j] = models[<span class="number">0</span>].outputs[i].properties.shape[j]</span><br><span class="line">        output_tensors[i].properties.alignedShape.dimensionSize[j] = models[<span class="number">0</span>].outputs[i].properties.shape[j]</span><br></pre></td></tr></tbody></table></figure><h2 id="主循环"><a class="markdownIt-Anchor" href="#主循环"></a> 主循环</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        _ ,frame = cap.read()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(frame.shape)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Failed to get image from usb camera"</span>)</span><br><span class="line">        <span class="comment"># 把图片缩放到模型的输入尺寸</span></span><br><span class="line">        <span class="comment"># 获取算法模型的输入tensor 的尺寸</span></span><br><span class="line">        h, w = models[<span class="number">0</span>].inputs[<span class="number">0</span>].properties.shape[<span class="number">2</span>], models[<span class="number">0</span>].inputs[<span class="number">0</span>].properties.shape[<span class="number">3</span>]</span><br><span class="line">        des_dim = (w, h)</span><br><span class="line">        resized_data = cv2.resize(frame, des_dim, interpolation=cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line">        nv12_data = bgr2nv12_opencv(resized_data)</span><br><span class="line"></span><br><span class="line">        t0 = time()</span><br><span class="line">        <span class="comment"># Forward</span></span><br><span class="line">        outputs = models[<span class="number">0</span>].forward(nv12_data)</span><br><span class="line">        t1 = time()</span><br><span class="line">        <span class="comment"># print("forward time is :", (t1 - t0))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Do post process</span></span><br><span class="line">        strides = [<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strides)):</span><br><span class="line">            <span class="keyword">if</span> (output_tensors[i].properties.quantiType == <span class="number">0</span>):</span><br><span class="line">                output_tensors[i].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">5</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">5</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">10</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">10</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">            <span class="keyword">else</span>:      </span><br><span class="line">                output_tensors[i].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">5</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">5</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">10</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">10</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line"></span><br><span class="line">            libpostprocess.FcosdoProcess(output_tensors[i], output_tensors[i + <span class="number">5</span>], output_tensors[i + <span class="number">10</span>], ctypes.pointer(fcos_postprocess_info), i)</span><br><span class="line"></span><br><span class="line">        result_str = get_Postprocess_result(ctypes.pointer(fcos_postprocess_info))  </span><br><span class="line">        result_str = result_str.decode(<span class="string">'utf-8'</span>)  </span><br><span class="line">        t2 = time()</span><br><span class="line">        <span class="comment"># print("FcosdoProcess time is :", (t2 - t1))</span></span><br><span class="line">        <span class="comment"># print(result_str)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># draw result</span></span><br><span class="line">        <span class="comment"># 解析JSON字符串  </span></span><br><span class="line">        data = json.loads(result_str[<span class="number">14</span>:])  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frame.shape[<span class="number">0</span>]!=disp_h <span class="keyword">or</span> frame.shape[<span class="number">1</span>]!=disp_w:</span><br><span class="line">            frame = cv2.resize(frame, (disp_w,disp_h), interpolation=cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Draw bboxs</span></span><br><span class="line">        box_bgr = draw_bboxs(frame, data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># cv2.imwrite("imf.jpg", box_bgr)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Convert to nv12 for HDMI display</span></span><br><span class="line">        box_nv12 = bgr2nv12_opencv(box_bgr)</span><br><span class="line">        disp.set_img(box_nv12.tobytes())</span><br><span class="line"></span><br><span class="line">        finish_time = time()</span><br><span class="line">        image_counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> finish_time - start_time &gt;  <span class="number">10</span>:</span><br><span class="line">            <span class="built_in">print</span>(start_time, finish_time, image_counter)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"FPS: {:.2f}"</span>.<span class="built_in">format</span>(image_counter / (finish_time - start_time)))</span><br><span class="line">            start_time = finish_time</span><br><span class="line">            image_counter = <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传统视觉循迹&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#传统视觉循迹&quot;&gt;&lt;/a&gt; 传统视觉循迹&lt;/h1&gt;
&lt;h1 id=&quot;基于opencv的传统视觉循迹-demo1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【ROS2】ROS2基本概念</title>
    <link href="https://szturin.github.io/posts/45607/"/>
    <id>https://szturin.github.io/posts/45607/</id>
    <published>2024-07-05T16:06:13.000Z</published>
    <updated>2024-07-09T12:14:48.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros2上手体验"><a class="markdownIt-Anchor" href="#ros2上手体验"></a> ROS2上手体验</h1><p>ros2环境的配置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/humble/setup.bash #添加环境变量，需要每次启动终端使用此命令，比较繁琐</span><br><span class="line">echo " source /opt/ros/humble/setup.bash" &gt;&gt; ~/.bashrc #将添加环境变量的命令添加到脚本，开启终端自启动，无需反复source</span><br></pre></td></tr></tbody></table></figure><p>发布者节点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run demo_nodes_cpp talker </span><br></pre></td></tr></tbody></table></figure><p>订阅者节点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run demo_nodes_py listener</span><br></pre></td></tr></tbody></table></figure><p>node</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node</span><br></pre></td></tr></tbody></table></figure><h1 id="linuxros2命令行操作"><a class="markdownIt-Anchor" href="#linuxros2命令行操作"></a> Linux/Ros2命令行操作</h1><p>Linux的命令庞大，但基本掌握常用的一些基础命令即可</p><p>获取当前终端操作的目录位置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></tbody></table></figure><p>列举当前目录显示的文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></tbody></table></figure><p>列举当前目录（包括被隐藏的）文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -A</span><br></pre></td></tr></tbody></table></figure><p>新建文件夹</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br></pre></td></tr></tbody></table></figure><p>修改当前终端路径</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd test/</span><br></pre></td></tr></tbody></table></figure><p>效果：</p><img src="/posts/45607/image-20240706002347136.png" class="" title="image-20240706002347136"><p>在当前路径新建文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch read.txt</span><br></pre></td></tr></tbody></table></figure><p>在当前路径删除文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm read.txt</span><br></pre></td></tr></tbody></table></figure><p>删除文件夹</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -R test/ #-R表示递归删除</span><br></pre></td></tr></tbody></table></figure><p>安装软件包</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libopencv(自动补全)# sudo表示提升当前使用者权限为管理员,apt表示应用,install表示安装,安装opencv</span><br></pre></td></tr></tbody></table></figure><h2 id="ros2相关"><a class="markdownIt-Anchor" href="#ros2相关"></a> ros2相关</h2><p>将正在运行的节点进行打印</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node list </span><br></pre></td></tr></tbody></table></figure><p>查看节点正在运行的信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node info /节点名</span><br></pre></td></tr></tbody></table></figure><p>查看节点的基本数据/参数</p><p>以查看话题为例，查看哪些话题正在发布和订阅</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></tbody></table></figure><p>对话题进行订阅并打印</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic echo /turtlel/pose</span><br></pre></td></tr></tbody></table></figure><p>使用topic 进行pub，发布一个消息，和run一样可以控制“海龟”进行运动</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}" </span><br><span class="line"># --rate 1:频率1HZ</span><br><span class="line"># /turtle1/cmd_vel geometry_msgs/msg/Twist</span><br><span class="line"># linear:线速度</span><br><span class="line"># angular:角速度</span><br></pre></td></tr></tbody></table></figure><p>使用“服务”，产生新的机器人</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: 'abb'}"</span><br><span class="line"></span><br><span class="line">#使用ros2 topic list查看是否产生新的接口：</span><br><span class="line">turin@turin-virtual-machine:~/Desktop$ ros2 topic list</span><br><span class="line">/abb/cmd_vel</span><br><span class="line">/abb/color_sensor</span><br><span class="line">/abb/pose</span><br><span class="line">/parameter_events</span><br><span class="line">/rosout</span><br><span class="line">/turtle1/cmd_vel</span><br><span class="line">/turtle1/color_sensor</span><br><span class="line">/turtle1/pose</span><br></pre></td></tr></tbody></table></figure><p>总结：话题是机器人控制的<mark>接口</mark>,接口的名称不同，控制的对象不同</p><p>录制机器人的运动过程(录制)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 bag record /turtle/cmd_vel</span><br></pre></td></tr></tbody></table></figure><h1 id="节点"><a class="markdownIt-Anchor" href="#节点"></a> 节点</h1><p><a href="http://setup.py">setup.py</a></p><p>配置ros2程序执行的入口</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">package_name = <span class="string">'learning_node'</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=package_name,</span><br><span class="line">    version=<span class="string">'0.0.0'</span>,</span><br><span class="line">    packages=[package_name],</span><br><span class="line">    data_files=[</span><br><span class="line">        (<span class="string">'share/ament_index/resource_index/packages'</span>,</span><br><span class="line">            [<span class="string">'resource/'</span> + package_name]),</span><br><span class="line">        (<span class="string">'share/'</span> + package_name, [<span class="string">'package.xml'</span>]),</span><br><span class="line">    ],</span><br><span class="line">    install_requires=[<span class="string">'setuptools'</span>],</span><br><span class="line">    zip_safe=<span class="literal">True</span>,</span><br><span class="line">    maintainer=<span class="string">'Hu Chunxu'</span>,</span><br><span class="line">    maintainer_email=<span class="string">'huchunxu@guyuehome.com'</span>,</span><br><span class="line">    description=<span class="string">'TODO: Package description'</span>,</span><br><span class="line">    license=<span class="string">'TODO: License declaration'</span>,</span><br><span class="line">    tests_require=[<span class="string">'pytest'</span>],</span><br><span class="line">    entry_points={</span><br><span class="line">        <span class="string">'console_scripts'</span>: [</span><br><span class="line">         <span class="string">'node_helloworld       = learning_node.node_helloworld:main'</span>, <span class="comment">#节点的配置信息,配置完成后就可以用ros2 run运行</span></span><br><span class="line">         <span class="string">'node_helloworld_class = learning_node.node_helloworld_class:main'</span>,</span><br><span class="line">         <span class="string">'node_object            = learning_node.node_object:main'</span>,</span><br><span class="line">         <span class="string">'node_object_webcam     = learning_node.node_object_webcam:main'</span>,</span><br><span class="line">        ],</span><br><span class="line">    },</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p><strong>面向过程编程</strong></p><img src="/posts/45607/image-20240706230802271.png" class="" title="image-20240706230802271"><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@作者: 古月居(www.guyuehome.com)</span></span><br><span class="line"><span class="string">@说明: ROS2节点示例-发布“Hello World”日志信息, 使用面向对象的实现方式</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy                                     <span class="comment"># ROS2 Python接口库</span></span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node                      <span class="comment"># ROS2 节点类</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">创建一个HelloWorld节点, 初始化时输出“hello world”日志</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorldNode</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)                       <span class="comment"># ROS2节点父类初始化</span></span><br><span class="line">        <span class="keyword">while</span> rclpy.ok():                            <span class="comment"># ROS2系统是否正常运行</span></span><br><span class="line">            self.get_logger().info(<span class="string">"Hello World"</span>)    <span class="comment"># ROS2日志输出</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)                          <span class="comment"># 休眠控制循环时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):                                 <span class="comment"># ROS2节点主入口main函数</span></span><br><span class="line">    rclpy.init(args=args)                            <span class="comment"># ROS2 Python接口初始化</span></span><br><span class="line">    node = HelloWorldNode(<span class="string">"node_helloworld_class"</span>)   <span class="comment"># 创建ROS2节点对象并进行初始化</span></span><br><span class="line">    node.destroy_node()                              <span class="comment"># 销毁节点对象</span></span><br><span class="line">    rclpy.shutdown()                                 <span class="comment"># 关闭ROS2 Python接口</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意：编写完成程序后，需要重新编译，纯py文件无法用ros2命令直接运行, ros2 run 运行的是install</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ros2上手体验&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ros2上手体验&quot;&gt;&lt;/a&gt; ROS2上手体验&lt;/h1&gt;
&lt;p&gt;ros2环境的配置&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tab</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2024微机原理课程设计-小车跟随系统</title>
    <link href="https://szturin.github.io/posts/50511/"/>
    <id>https://szturin.github.io/posts/50511/</id>
    <published>2024-06-20T20:44:16.000Z</published>
    <updated>2024-07-09T12:14:48.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小车基本控制设计"><a class="markdownIt-Anchor" href="#小车基本控制设计"></a> 小车基本控制设计</h1><h2 id="一-前期系统分析与设计"><a class="markdownIt-Anchor" href="#一-前期系统分析与设计"></a> 一、前期系统分析与设计</h2><p>​      在本次设计的前期准备工作中，通过对题目的分析，小车运动的精确低延迟控制+蓝牙通信都是相当重要的关键点。本次课程设计，使用电机型号为带霍尔传感器地无刷电机，能够通过内置编码器的A,B相固定输出390次/圈的脉冲，可以用于精准测量电机转速以及作为<mark>车辆里程表</mark>。因此，我基于所用电机的特性，利用PIC单片机CCP极其优秀的PWM输出功能，设计了一个易用的电机驱动程序，能够使得单片机输出频率10KHZ，占空比可调范围在0~100的PWM信号。对比于常规的使用定时器作为计时基准的方法，直接利用单片机设计好的电路外设模块，减轻了单片机<mark>程序</mark>上消耗的资源，也大幅提高了后续小车的运动性能以及稳定性。重要的一点是，基于对自动控制原理的粗略学习，我们可以利用本次电机所带的编码器模块，实现<strong>单片机测速——程序PID控制器——输出PWM波</strong>的一个PID自动控速系统以及能够精准记录脉冲数的<strong>车辆里程表（这在后面进行内外圈转向时发挥了关键的作用）</strong>，同时，蓝牙模块也是一个极其便捷的工具，使用两片蓝牙模块，分别连接单片机和计算机，在一些串口助手软件上，能够迅速实现基于上位机的参数检测以及调试系统。</p><p>注：本次设计的串口助手为VOFA，可以兼容所有串口调试的基本功能，能够根据数值的大小显示波形。</p><h3 id="设计框图蓝牙控速小车"><a class="markdownIt-Anchor" href="#设计框图蓝牙控速小车"></a> 设计框图：蓝牙控速小车</h3><p><strong>基于上述程序的编写以及小车板块的搭建，首先设计一个可以通过计算机或者手机终端等设备进行蓝牙遥控的小车运动系统。本次课程设计我们基于实验以及课程的理论经验，从搭建<mark>底层框架</mark>再到完成其余功能要求的设计思想，分阶段、板块完成设计，更有利于后面的高效分工与调试。</strong></p><img src="/posts/50511/image-20240625013830066.png" class="" title="image-20240625013830066"><h2 id="1电机驱动程序设计"><a class="markdownIt-Anchor" href="#1电机驱动程序设计"></a> 1.电机驱动程序设计</h2><p><strong>问题1：PWM输出</strong></p><p>​常见的8位单片机（stc89c52），产生PWM，通常是利用到定时器模块，以定时器计时为基准（时间基准t1，假设为1ms），程序上定义计时变量time(每次进定时器中断time自加1)、周期时间变量T（假设T=100）、占空比时间变量N（假设N=50），然后通过IF语句判断，翻转设定的引脚（假设为RC1）输出PWM方波信号。但是考虑到如果使用定时器，如果定时器的计数寄存器（计时溢出周期）设置过小，程序会频繁进入中断，不利于其他部分程序的执行，占用了软件上的资源；如果定时器计时周期设置的太大，比如10ms，又想输出一个可调范围0~100的PWM，那么PWM方波信号的周期就高达1s，PWM频率仅仅只有1HZ，这样就会使得电机无法正常驱动或者运动过程有明显的卡顿（PWM分辨率过低）。而本次使用的PIC16F877A单片机，具备CCP1+CCP2模块，能够通过配置寄存器，硬件自动生成两路的PWM信号，节省了软件资源，并且PIC单片机的CCP模块生成的PWM方波相当的精准可靠，在完成CCP模块PWM模式的初始化后，只需要修改CCP1L/CCP2L的值即可修改PWM（RC6、RC7）的占空比。</p><hr><p>电机驱动模块子程序设计</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_A RC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_B RC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_1 RB4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_2 RB5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_1 RB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_2 RB7</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函    数</span></span><br><span class="line"><span class="comment">参    数要写入的命令</span></span><br><span class="line"><span class="comment">返 回 值无</span></span><br><span class="line"><span class="comment">特殊说明无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_GPIO_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISB4=<span class="number">0</span>;</span><br><span class="line">TRISB5=<span class="number">0</span>;</span><br><span class="line">TRISB6=<span class="number">0</span>;</span><br><span class="line">TRISB7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;</span><br><span class="line">TRISC2=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_CCP_PWM_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*定义CCP1工作在PWM模式*/</span></span><br><span class="line">CCP1CON=<span class="number">0X0C</span>;<span class="comment">//定义CCP1模块工作在PWM模式</span></span><br><span class="line">CCPR1L=<span class="number">50</span>;<span class="comment">//定义脉宽为50us</span></span><br><span class="line">PR2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义CCP2工作在PWM模式*/</span></span><br><span class="line">    CCP2CON = <span class="number">0x0c</span>; <span class="comment">// 配置CCP2为PWM模式</span></span><br><span class="line">    CCPR2L = <span class="number">50</span>;          <span class="comment">// 设置CCP2 PWM占空比（高位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*与CCP模块PWM模式配合的TMR2*/</span></span><br><span class="line">T2CON=<span class="number">0</span>;<span class="comment">//定义TM2模块工作在预、后分频比都是1:1的定时器模式</span></span><br><span class="line">TMR2=<span class="number">0</span>;</span><br><span class="line">TMR2ON=<span class="number">1</span>;<span class="comment">//启动TMR2，此刻从RC2引脚输出所设的波形</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Speed_Set</span><span class="params">(<span class="type">int</span> Speed1,<span class="type">int</span> Speed2)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Speed1 &gt; <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">0</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">1</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Speed2 &gt;<span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">0</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">1</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>问题2：测速</strong></p><p><mark><strong>通过外部中断配合定时器1测速</strong></mark></p><p>​我们可以按照实验课中的方法，使用定时器1和外部中断配合设计测速系统，通过检测信号跳变，配合定时器1的TMR1ON控制启停，计算电平的持续时间，这样就能测量PWM的占空比。但是，通过对本次课程设计电机模块的分析以及学习（本次设计为无刷电机==(注意固定螺丝不能太长会磨损电机减速箱)==，并且自带霍尔编码器）</p><p>​霍尔编码器：通过霍尔传感器感应电机转过的次数，相应的，在本次设计中使用的电机模块，转动一圈产生390个脉冲。直接使用实验五的方法，通过串口调试助手打印测得速度，发现速度是不连续的（此图出现如290km/h 71km/h 15 km/h等速度）。因为如果要使用霍尔传感器，它的脉冲实际上不是代表的PWM，只有通过记录编码器输出的脉冲次数才能实现单位时间内小车的速度/里程计算。</p><img src="/posts/50511/image-20240621050939454.png" class="" title="image-20240621050939454"><hr><p><mark><strong>采用外部中断计数的方法测速，如下图</strong></mark></p><p><strong>我们改用定时器0（50ms为计数周期)，外部中断（测量电机驱动输出的编码器脉冲计数），这样就能轻而易举地计算出50ms内地脉冲数目，进而进行速度的精准测量+里程的累计。</strong></p><p>可见，直接通过计算脉冲次数的方法，速度的测量基本无波动（横坐标表示50ms时间内的脉冲计数,此图位48-49范围内波动，基本无误差）。</p><img src="/posts/50511/d34fd09e3d5cd10c526f393554abff6.png" class="" title="d34fd09e3d5cd10c526f393554abff6"><hr><p><strong>子函数设计</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_A RC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_B RC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_1 RB4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_2 RB5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_1 RB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_2 RB7</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函    数</span></span><br><span class="line"><span class="comment">参    数要写入的命令</span></span><br><span class="line"><span class="comment">返 回 值无</span></span><br><span class="line"><span class="comment">特殊说明无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_GPIO_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISB4=<span class="number">0</span>;</span><br><span class="line">TRISB5=<span class="number">0</span>;</span><br><span class="line">TRISB6=<span class="number">0</span>;</span><br><span class="line">TRISB7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;</span><br><span class="line">TRISC2=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_CCP_PWM_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*定义CCP1工作在PWM模式*/</span></span><br><span class="line">CCP1CON=<span class="number">0X0C</span>;<span class="comment">//定义CCP1模块工作在PWM模式</span></span><br><span class="line">CCPR1L=<span class="number">50</span>;<span class="comment">//定义脉宽为50us</span></span><br><span class="line">PR2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义CCP2工作在PWM模式*/</span></span><br><span class="line">    CCP2CON = <span class="number">0x0c</span>; <span class="comment">// 配置CCP2为PWM模式</span></span><br><span class="line">    CCPR2L = <span class="number">50</span>;          <span class="comment">// 设置CCP2 PWM占空比（高位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*与CCP模块PWM模式配合的TMR2*/</span></span><br><span class="line">T2CON=<span class="number">0</span>;<span class="comment">//定义TM2模块工作在预、后分频比都是1:1的定时器模式</span></span><br><span class="line">TMR2=<span class="number">0</span>;</span><br><span class="line">TMR2ON=<span class="number">1</span>;<span class="comment">//启动TMR2，此刻从RC2引脚输出所设的波形</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Speed_Set</span><span class="params">(<span class="type">int</span> Speed1,<span class="type">int</span> Speed2)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Speed1 &gt; <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">0</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">1</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Speed2 &gt;<span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">0</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">1</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>电机的速度计算准确后，通过我们对自动控制原理的学习了解，或许可以应用一些简单的算法，进行小车的速度闭环负反馈控制？</li></ul><h3 id="3串口通信初始化"><a class="markdownIt-Anchor" href="#3串口通信初始化"></a> 3.串口通信初始化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//putch 重定向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putch</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">    TXREG=ch;</span><br><span class="line">    <span class="keyword">while</span>(TRMT==<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*??????????*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_PrintString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *String)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(*String != <span class="string">'\0'</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,*String++);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口引脚初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">TRISC6=<span class="number">1</span>;</span><br><span class="line">TRISC7=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    SPBRG=<span class="number">12</span>;<span class="comment">//波特率设置为19200</span></span><br><span class="line">    TXSTA=<span class="number">0B</span>00100100;<span class="comment">//异步模式。发送8位数据，允许发送</span></span><br><span class="line">    RCSTA=<span class="number">0B</span>10010000;<span class="comment">//允许串口工作，连续接收使能，接收8位数据</span></span><br><span class="line">    GIE=<span class="number">1</span>;PEIE=<span class="number">1</span>;RCIE=<span class="number">1</span>;<span class="comment">//开放USART接收中断</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将连接单片机的蓝牙模块配置为主机模式，连接计算机的蓝牙模块配置为从机模式，并且两片蓝牙的密码设置为一致，波特率与单片机、电脑串口助手都设置为19200。这样，单片机就能够发送数据到串口助手，串口中断打印出数据/波形，实现远程调参效果。</p><h3 id="pid控速的尝试与应用"><a class="markdownIt-Anchor" href="#pid控速的尝试与应用"></a> PID控速的尝试与应用</h3><p>1.给定占空比</p><p>​通过修改CCP1L和CCP2L的值，可以实现指定PWM占空比的电机变速效果，通过串口助手显示编码器测速的波形，发现给定PWM的速度也是比较稳定的。</p><img src="/posts/50511/image-20240625022659866.png" class="" title="image-20240625022659866"><p>2.PID控速</p><p>​编写PID速度环控制子程序，将速度测量值以及速度目标值作为输入，返回值为PID的输出值，作为PWM的输出，形成闭环反馈系统。经上位机显示速度波形，测量速度（红线）能够逐渐趋近于目标速度（绿线），说明PID速度闭环的程序是正确的，后面对各个参数（Kp、Ki、Kd）进行优化，减少过充现象，增大反应速度，提高PID速度闭环系统的抗干扰能力。</p><img src="/posts/50511/image-20240625023158792.png" class="" title="image-20240625023158792"><p>​经过我们后面对PIC16F877A的引脚分配，发现它能够进行速度测量的引脚基本上只能使用外部中断，CCP模块以及被用作PWM输出，那么PID控速的想法就暂时被搁置了。但是，我们后面将编码器的脉冲输入作为车辆里程表，也可以实现灵活度更高的功能（内外圈转向区分）。</p><h1 id="灰度巡线pid-数学模型解决工程问题"><a class="markdownIt-Anchor" href="#灰度巡线pid-数学模型解决工程问题"></a> 灰度巡线PID - 数学模型解决工程问题</h1><img src="/posts/50511/image-20240621050902381.png" class="" title="image-20240621050902381"><p><strong>头文件定义/变量定义</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span><span class="comment">//PIC库</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);<span class="comment">//配置起始位</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//C语言库</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*PIC单片机驱动相关子函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\LCD1602.H"</span><span class="comment">//LCD1602子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\KeyBoard.H"</span><span class="comment">//按键子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\iic.H"</span><span class="comment">//iic通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Motor.H"</span><span class="comment">//电机驱动</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Usart.H"</span><span class="comment">//串口（蓝牙）通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Led.H"</span><span class="comment">//Led</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Encoder.H"</span><span class="comment">//霍尔编码器测速</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\PID.H"</span><span class="comment">//PID控制程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\csb.H"</span><span class="comment">//超声波控制程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*PIC单片机系统相关子函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\System\Timer.H"</span><span class="comment">//定时器初始化程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\System\Delay.H"</span><span class="comment">//延时子程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bluetooth;<span class="comment">//蓝牙接收字节存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*外部中断测速*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Counter_temp;<span class="comment">//车辆旋转圈数计数变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Timer0_Counter;<span class="comment">//定时器0溢出计数变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Encoder_Counter;<span class="comment">//脉冲计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*循迹控制主要变量*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Motor_Flag;<span class="comment">//电机允许模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Turn_PWM;<span class="comment">//转向PWM，由循迹PID控制函数输出赋值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Byte;<span class="comment">//八路循迹对应一个字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_left,Speed_right;<span class="comment">//寻线速度77y89-</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_Velcolity=<span class="number">33</span>;<span class="comment">//直行速度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> IO_flag=<span class="number">0</span>;<span class="comment">//（90度转向）启停标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Circle_Mode=<span class="number">0</span>;<span class="comment">//车辆运行模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Start_Find_flag=<span class="number">0</span>;<span class="comment">//脉冲计数标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Bifurcate_Flag=<span class="number">0</span>;<span class="comment">//分叉路口标志位，0表示第一个，1表示第二个</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Stop_Flag=<span class="number">0</span>;<span class="comment">//停车标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Mode=<span class="number">0</span>;<span class="comment">//八路循迹状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> distance;<span class="comment">//超声波距离</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> BT_State=<span class="number">0</span>;<span class="comment">//蓝牙通信状态机，无线调参</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> csb_Flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> NQ_fast_Flag=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*//循迹工作验证函数</span></span><br><span class="line"><span class="comment">unsigned char yz[8]={0};</span></span><br><span class="line"><span class="comment">unsigned char mod;</span></span><br><span class="line"><span class="comment">void yanzheng()</span></span><br><span class="line"><span class="comment">{ </span></span><br><span class="line"><span class="comment">unsigned char temp = mod;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">yz[i] = temp %2;</span></span><br><span class="line"><span class="comment">temp/=2;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>模块验证函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*//循迹工作验证函数</span></span><br><span class="line"><span class="comment">unsigned char yz[8]={0};</span></span><br><span class="line"><span class="comment">unsigned char mod;</span></span><br><span class="line"><span class="comment">void yanzheng()</span></span><br><span class="line"><span class="comment">{ </span></span><br><span class="line"><span class="comment">unsigned char temp = mod;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">yz[i] = temp %2;</span></span><br><span class="line"><span class="comment">temp/=2;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>循迹控制函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Byte;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Kp=<span class="number">3.2</span>;</span><br><span class="line"><span class="type">int</span> Kd=<span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> turn_err;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> last_err;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> err_difference;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Trace_PID</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Trace_Byte = (RC0&lt;&lt;<span class="number">7</span>|RC3&lt;&lt;<span class="number">6</span>|RE0&lt;&lt;<span class="number">5</span>|RE1&lt;&lt;<span class="number">4</span>|RE2&lt;&lt;<span class="number">3</span>|RA4&lt;&lt;<span class="number">2</span>|RC4&lt;&lt;<span class="number">1</span>|RC5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Trace_Byte)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//直行</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11100111: </span><br><span class="line">turn_err=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11110111:</span><br><span class="line">turn_err=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11101111:</span><br><span class="line">turn_err=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//左转</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11001111:</span><br><span class="line">turn_err=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11011111:</span><br><span class="line">turn_err=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>10011111:</span><br><span class="line">turn_err=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>10111111:</span><br><span class="line">turn_err=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>00111111:</span><br><span class="line">turn_err=<span class="number">6</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>01111111:</span><br><span class="line">turn_err=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右转</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11110011:</span><br><span class="line">turn_err=<span class="number">-2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111011:</span><br><span class="line">turn_err=<span class="number">-3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111001:</span><br><span class="line">turn_err=<span class="number">-4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111101:</span><br><span class="line">turn_err=<span class="number">-5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111100:</span><br><span class="line">turn_err=<span class="number">-6</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111110:</span><br><span class="line">turn_err=<span class="number">-7</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err_difference= turn_err - last_err;</span><br><span class="line"></span><br><span class="line">last_err= turn_err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)(turn_err*Kp + err_difference*Kd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>路线控制函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Trace_Control</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Circle_Mode == <span class="number">0</span>)<span class="comment">//起始点</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">1</span>;<span class="comment">//脉冲计数标志位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt;<span class="number">550</span>)<span class="comment">//固定距离，越过黑线</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">1</span>)<span class="comment">//第一圈，外圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag =<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Find_flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">200</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">IO_flag = <span class="number">1</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">2</span>;<span class="comment">//内圈</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">2</span>)<span class="comment">//第二圈，内圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IO_flag == <span class="number">0</span>)<span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//putch(3);//进入第三圈</span></span><br><span class="line">Start_Find_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Find_flag == <span class="number">1</span>  &amp;&amp; NQ_fast_Flag == <span class="number">0</span>)<span class="comment">//开启计脉冲且，内圈没有加速</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">300</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">IO_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">3</span>;</span><br><span class="line">csb_Flag= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(NQ_fast_Flag)<span class="comment">//开启内圈加速</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">800</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">NQ_fast_Flag = <span class="number">0</span>;</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;<span class="comment">//回归</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//内圈固定转向</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(<span class="number">20</span>,<span class="number">60</span>);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">320</span>)</span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">NQ_fast_Flag = <span class="number">1</span>;</span><br><span class="line">IO_flag = <span class="number">0</span>;</span><br><span class="line">Speed_Velcolity+=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">3</span>)<span class="comment">//第三圈，外圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">1</span>;</span><br><span class="line">Stop_Flag=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Stop_Flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">putch(<span class="number">0x08</span>);</span><br><span class="line">Motor_Speed_Set(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//停车</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;小车基本控制设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#小车基本控制设计&quot;&gt;&lt;/a&gt; 小车基本控制设计&lt;/h1&gt;
&lt;h2 id=&quot;一-前期系统分析与设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】PID平衡小车项目实战</title>
    <link href="https://szturin.github.io/posts/25248/"/>
    <id>https://szturin.github.io/posts/25248/</id>
    <published>2024-06-09T08:22:17.000Z</published>
    <updated>2024-07-09T12:14:48.012Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[CubeMX][1]Hal库初始化配置</title>
    <link href="https://szturin.github.io/posts/253/"/>
    <id>https://szturin.github.io/posts/253/</id>
    <published>2024-06-09T07:31:45.000Z</published>
    <updated>2024-06-09T08:22:13.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><ul><li>在准备安装CubeMX开发环境之前，需要注册ST官网账号，注册的信息不要出现中文，密码也不要与注册信息的个人姓名相关，否则可能导致页面卡住。</li><li>需要安装java环境，才能正常允许CubeMX</li><li>确保以及安装了Keil MDK，Keil完成了stm32的芯片包配置，至少下载串口通信（FLY MCU） , STLink Unit中其中一款下载/串口通信软件。</li></ul><h1 id="cubemx初始配置"><a class="markdownIt-Anchor" href="#cubemx初始配置"></a> CubeMX初始配置</h1><h2 id="1cubemx安装芯片固件包"><a class="markdownIt-Anchor" href="#1cubemx安装芯片固件包"></a> 1.CubeMX安装芯片固件包</h2><img src="/posts/253/image-20240609153709278.png" class="" title="image-20240609153709278"><p>xxxxxxxxxx&nbsp;typedef struct//typedef为成员列表提供了一个GPIO_InitTypeDef的名字{}GPIO_InitTypeDef;c</p><p><strong>像常用的stm32f103c8t6，我们就选择STM32F1，勾选最新固件包，点击Install Now进行在线安装</strong></p><hr><img src="/posts/253/image-20240609155414174.png" class="" title="image-20240609155414174"><hr><h2 id="2工程创建"><a class="markdownIt-Anchor" href="#2工程创建"></a> 2.工程创建</h2><p>1.打开stm32cubeMX，File &gt; New project &gt;MCU/MPU Selector &gt;Part Number<br>2.输入stm32f103c8,Start Project<br>3.Project Manager &gt; Project</p><h2 id="3引脚配置"><a class="markdownIt-Anchor" href="#3引脚配置"></a> 3.引脚配置</h2><img src="/posts/253/image-20240609154359188.png" class="" title="image-20240609154359188"><h2 id="3外设配置"><a class="markdownIt-Anchor" href="#3外设配置"></a> 3.外设配置</h2><p><mark>GPIO属性配置</mark></p><img src="/posts/253/image-20240609155305797.png" class="" title="image-20240609155305797"><blockquote><p>GPIO output level &gt; High 输出等级 高</p><p>GPIO mode Output &gt; Push Pull 输出模式 推挽输出</p><p>GPIO Pull-up/Pull-down &gt; Pull-down 初始输出 设为低</p><p>User Label &gt;  用户标签，方便代码中使用，如图：</p><p>​<img src="/posts/253/image-20240609154825836.png" class="" title="image-20240609154825836"></p></blockquote><img src="/posts/253/image-20240609154611816.png" class="" title="image-20240609154611816"><p><mark>配置时钟模式</mark></p><p>Pinout &amp; Configuration &gt; A-Z &gt; RCC &gt; High Speed Clock<br>Crystal/Ceramic Resonator 使用外部时钟源</p><img src="/posts/253/image-20240609155203231.png" class="" title="image-20240609155203231"><p><mark>时钟可视化配置</mark></p><p>Clock Configuration<br>选中HSE,倍频x9，不分频</p><img src="/posts/253/image-20240609154912764.png" class="" title="image-20240609154912764"><h2 id="4工程设置"><a class="markdownIt-Anchor" href="#4工程设置"></a> 4.工程设置</h2><blockquote><p>Project Name 项目名称，填写led</p><p>Project Location 项目位置，选择一个你喜欢的文件夹，不要出现中文 Toolchain/IDE</p><p>交叉编译链，选择MDK，V5</p><p>勾选 Use latest available version</p></blockquote><img src="/posts/253/image-20240609155924976.png" class="" title="image-20240609155924976"><blockquote><p>Project Manager &gt; Code Generator</p><p>勾选Generate peripheral…</p></blockquote><img src="/posts/253/image-20240609160038284.png" class="" title="image-20240609160038284"><blockquote><p>其余默认配置即可</p></blockquote><img src="/posts/253/image-20240609160159606.png" class="" title="image-20240609160159606"><blockquote><p>GENERATE CODE生成代码，Open Project</p></blockquote><h1 id="mdk代码编写"><a class="markdownIt-Anchor" href="#mdk代码编写"></a> MDK代码编写</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">  HAL_Init();<span class="comment">//HAL库初始化</span></span><br><span class="line">  SystemClock_Config();<span class="comment">//时钟初始化</span></span><br><span class="line">  MX_GPIO_Init();<span class="comment">//GPIO初始化</span></span><br><span class="line"><span class="comment">/* USER CODE END 1 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_5);<span class="comment">//翻转引脚电平</span></span><br><span class="line">  HAL_Delay(<span class="number">500</span>);<span class="comment">//延时500ms</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em><em>==注意：    /</em> USER CODE BEGIN 3 <em>/之内的代码不会杯CubeMX重新生成代码时覆盖掉！ /</em> USER CODE END 3 <em>/==</em></em></p><img src="/posts/253/image-20240609160459831.png" class="" title="image-20240609160459831"><img src="/posts/253/image-20240609160610985.png" class="" title="image-20240609160610985"><p>下载后编译，观察PA5引脚电平变化（利用LED），是否以0.5s周期变化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在准备安装CubeMX开发环境之前，需要注册ST官网账号，注册的信息不要出现中文，密码也不要与注册信息的个人姓名相关，否则可能导致页</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【蓝桥杯单片机】客观题</title>
    <link href="https://szturin.github.io/posts/24737/"/>
    <id>https://szturin.github.io/posts/24737/</id>
    <published>2024-05-26T04:04:07.000Z</published>
    <updated>2024-06-09T08:08:29.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rc低通滤波器"><a class="markdownIt-Anchor" href="#rc低通滤波器"></a> RC低通滤波器</h1><h2 id="截止频率"><a class="markdownIt-Anchor" href="#截止频率"></a> 截止频率</h2><img src="/posts/24737/image-20240526121741003.png" class="" title="image-20240526121741003">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rc低通滤波器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rc低通滤波器&quot;&gt;&lt;/a&gt; RC低通滤波器&lt;/h1&gt;
&lt;h2 id=&quot;截止频率&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#截止频率&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[11]IIC通信(mpu6050)</title>
    <link href="https://szturin.github.io/posts/5621/"/>
    <id>https://szturin.github.io/posts/5621/</id>
    <published>2024-05-24T12:55:20.000Z</published>
    <updated>2024-05-26T17:40:25.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iic通信协议"><a class="markdownIt-Anchor" href="#iic通信协议"></a> IIC通信协议</h1><h2 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h2><ul><li><p>同步时序的稳定性比异步时序更高</p></li><li><p>半双工</p></li><li><p>SCL、SDA两根通信线</p></li><li><p>支持总线挂载（一主多从，多主多从）</p></li></ul><h2 id="硬件电路"><a class="markdownIt-Anchor" href="#硬件电路"></a> 硬件电路</h2><ul><li>所有I2C设备的SCL连接在一起，SDA连接在一起</li><li>设备的SCL和SDA均要配置成开漏输出模式(防止形成短路电流，SDA要么<mark>被上拉</mark>，要么<mark>输出低电平</mark>)，会有“线与”的现象。在多主机的模式下，可以利用线与的特性，实现总线仲裁和时钟同步。</li><li>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</li></ul><img src="/posts/5621/image-20240524211453559.png" class="" title="image-20240524211453559"><hr><img src="/posts/5621/image-20240524212810776.png" class="" title="image-20240524212810776"><p><strong>PS：IIC时序是高位先行，串口是低位先行</strong></p><hr><img src="/posts/5621/image-20240524212934134.png" class="" title="image-20240524212934134"><p><strong>PS：主机接收时，需要释放SDA，即输入模式</strong></p><hr><img src="/posts/5621/image-20240524213709342.png" class="" title="image-20240524213709342"><p><strong>PS:从机的地址可以通过电路改变</strong></p><hr><img src="/posts/5621/image-20240524214219090.png" class="" title="image-20240524214219090"><p><strong><mark>红线处，此时需要从机应答，这里如果但看主机的SDA，应该会释放SDA，即高电平，由于从机要发送应答，根据线与的特性，这里拉低了SDA，所以最后SDA呈现图中所示。</mark></strong></p><hr><img src="/posts/5621/image-20240524214908190.png" class="" title="image-20240524214908190"><p><strong>IIC通信的设备中会有单独一个字节空间存储地址指针，当给IIC设备指定地址写时，地址指针会加一，这时如果使用当前地址读，就是读取指针地址指向的内存。此时序较为少用、</strong></p><hr><img src="/posts/5621/image-20240524215204768.png" class="" title="image-20240524215204768"><p><strong><mark>指定地址读的实现原理：先调用指定地址写，但是不写数据。再次调用当前地址读，这样复合的时序就能完成指定地址读的功能了</mark></strong></p><h1 id="mpu6050"><a class="markdownIt-Anchor" href="#mpu6050"></a> MPU6050</h1><img src="/posts/5621/image-20240524220155605.png" class="" title="image-20240524220155605"><h2 id="姿态角欧拉角"><a class="markdownIt-Anchor" href="#姿态角欧拉角"></a> 姿态角（欧拉角）</h2><img src="/posts/5621/image-20240524220352017.png" class="" title="image-20240524220352017"><p><strong>飞机相对于初始三个轴的夹角：</strong></p><ul><li>俯仰角：Pitch</li><li>滚转：Roll</li><li>偏航：Yaw</li></ul><p>要想获得稳定的欧拉角，就需要进行数据融合，进一步得到姿态角。</p><p><strong>常见的数据融合算法：</strong></p><ul><li>互补滤波</li><li>卡尔曼滤波</li></ul><p>ps:惯性导航领域里，姿态解算</p><h2 id="加速度计结构"><a class="markdownIt-Anchor" href="#加速度计结构"></a> 加速度计结构</h2><img src="/posts/5621/image-20240524220855509.png" class="" title="image-20240524220855509"><p><strong>F=ma(测力计)</strong></p><img src="/posts/5621/image-20240524221000525.png" class="" title="image-20240524221000525"><p><strong><mark>加速度计测得的是静态加速度，只能在物体静止的时候使用</mark></strong></p><h2 id="陀螺仪传感器"><a class="markdownIt-Anchor" href="#陀螺仪传感器"></a> 陀螺仪传感器</h2><img src="/posts/5621/image-20240524221506605.png" class="" title="image-20240524221506605"><p><strong>测得的是角速度，要想得到角度，可以进行求积分</strong></p><p><strong><mark>陀螺仪具有动态稳定性，不具有静态稳定性</mark></strong></p><p><strong><mark>对两种传感器进行互补滤波，就可以得到稳定的姿态角了</mark></strong></p><h2 id="mpu6050的参数"><a class="markdownIt-Anchor" href="#mpu6050的参数"></a> MPU6050的参数</h2><img src="/posts/5621/image-20240524221944683.png" class="" title="image-20240524221944683"><p>eg: mpu6050的从机地址：0x68 ，IIC时序中发送的第一个字节，高七位为从机地址，第八位为读写位。有时候把0XD0当作MPU6050的地址</p><h2 id="硬件结构"><a class="markdownIt-Anchor" href="#硬件结构"></a> 硬件结构</h2><img src="/posts/5621/image-20240525205511856.png" class="" title="image-20240525205511856"><blockquote><p><strong>六轴传感器的缺点：没有稳定的参考方向</strong></p><p>XCL，XDA：挂载磁力计，气压计</p><p>INT引脚：可以配置MPU6050内部一些事件，产生电平跳变</p><p>PS：MPU6050内部包含DMP单元：进行姿态融合和数据结算</p><p>包含稳压电路</p></blockquote><p><mark><strong>传感器内部含有自测单元</strong></mark></p><img src="/posts/5621/image-20240525210718105.png" class="" title="image-20240525210718105"><p>使能自测-&gt;读取数据1-&gt;失能自测-&gt;读取数据2，两个数据相减，得到的数据称作自测响应，自测响应如果在<mark>规定的范围内</mark>，说明芯片性能没问题。</p><hr><p><strong>电荷泵</strong></p><img src="/posts/5621/image-20240525210953979.png" class="" title="image-20240525210953979"><p>是一种<mark>升压电路</mark></p><p>原理：电源和电容串并联的切换（充电-&gt;串联-&gt;相当于电压升高（放电）-&gt;快速切换到并联-&gt;充电-&gt;循环）+ 电容滤波 = 平稳升压</p><img src="/posts/5621/image-20240525211051107.png" class="" title="image-20240525211051107"><hr><p><strong>DMP</strong>（数字运动处理器）</p><img src="/posts/5621/image-20240525211323304.png" class="" title="image-20240525211323304"><p>配合MPU6050官方的DMP库，进行姿态解算。</p><p><mark>引脚说明</mark></p><blockquote><p>FSYNC：帧同步</p></blockquote><blockquote><p>通信接口：用于和STM32通信</p><img src="/posts/5621/image-20240525211535797.png" class="" title="image-20240525211535797"></blockquote><blockquote><p>通信接口：用于和MPU6050拓展设备进行通信</p><p>​可以拓展连接磁力计</p><img src="/posts/5621/image-20240525211622949.png" class="" title="image-20240525211622949"></blockquote><hr><h2 id="软件iic读写mpu6050"><a class="markdownIt-Anchor" href="#软件iic读写mpu6050"></a> 软件IIC读写MPU6050</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MyIIC.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主机寻址MPU6050*/</span></span><br><span class="line">MyIIC_Init();</span><br><span class="line">MyIIC_Start();</span><br><span class="line">MyIIC_SendByte(<span class="number">0xD0</span>);<span class="comment">//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="type">uint8_t</span> Ack = MyIIC_ReceiveAck();</span><br><span class="line">MyIIC_Stop();</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Ack,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> <img src="/posts/5621/image-20240525224436566.png" class="" title="image-20240525224436566"><hr><p><strong>修改MPU6050地址</strong></p><p>可见，寻址无应答</p><img src="/posts/5621/image-20240526152458852.png" class="" title="image-20240526152458852"><hr><p><strong>读取MPU6050 ID号</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="comment">/*//主机寻址MPU6050</span></span><br><span class="line"><span class="comment">MyIIC_Init();</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(0xD2);//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="comment">uint8_t Ack = MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">OLED_ShowNum(1,1,Ack,3);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//读取MPU6050ID号</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154358599.png" class="" title="image-20240526154358599"><hr><p><strong>写MPU6050</strong>，需要关闭MPU6050的睡眠模式</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//在电源管理器1，写入0x00，接触睡眠模式</span></span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//更改采样频率</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x19</span>);<span class="comment">//读取MPU6050采样频率</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154723015.png" class="" title="image-20240526154723015"><p><strong>PS:某种程度上来说，对寄存器的读写操作可以看作读写一个存储器，但是寄存器能反应硬件电路的状态，对硬件电路进行操作</strong></p><hr><h2 id="mpu6050读取六轴姿态值"><a class="markdownIt-Anchor" href="#mpu6050读取六轴姿态值"></a> MPU6050读取六轴姿态值</h2><p><strong>函数定义</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用指针，实现函数多返回值的操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params"><span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> DataH ,DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">*AccX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">*AccY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">*AccZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">*GyroX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">*GyroY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">*GyroZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int16_t</span> Ax,Ay,Az,Gx,Gy,Gz;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">MPU6050_GetData(&amp;Ax,&amp;Ay,&amp;Az,&amp;Gx,&amp;Gy,&amp;Gz);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">1</span>,Ax,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">1</span>,Ay,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">1</span>,Az,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">8</span>,Gx,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">8</span>,Gy,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">8</span>,Gz,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>加速度计最大量程为16g</strong></p><img src="/posts/5621/image-20240526162104183.png" class="" title="image-20240526162104183"><p>左侧为加速度计，右侧为角速度测量值</p><hr><h2 id="硬件iic读写mpu6050"><a class="markdownIt-Anchor" href="#硬件iic读写mpu6050"></a> 硬件IIC读写MPU6050</h2><p>CR：控制寄存器</p><p>DR：数据寄存器</p><p>SR：状态寄存器</p><p><strong>STM32IIC外设</strong></p><img src="/posts/5621/image-20240526162959527.png" class="" title="image-20240526162959527"><h3 id="多主机模型"><a class="markdownIt-Anchor" href="#多主机模型"></a> 多主机模型</h3><p><strong>一主多从</strong></p><img src="/posts/5621/image-20240526163123491.png" class="" title="image-20240526163123491"><p><strong>多主多从</strong></p><p>固定多主机：</p><img src="/posts/5621/image-20240526163142347.png" class="" title="image-20240526163142347"><p>可变多主机：</p><img src="/posts/5621/image-20240526163226138.png" class="" title="image-20240526163226138"><p><strong>GPIO复用输入和复用输出</strong></p><img src="/posts/5621/image-20240526164412282.png" class="" title="image-20240526164412282"><p><strong>IIC主机发送流程图</strong></p><img src="/posts/5621/image-20240526165109626.png" class="" title="image-20240526165109626"><p><strong>IIC主机接收流程图</strong></p><img src="/posts/5621/image-20240526165718823.png" class="" title="image-20240526165718823"><h3 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h3><blockquote><p><strong>产生起始条件</strong></p><p>void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>生成终止条件</strong></p><p>void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>配置在收到一个字节后，是否给从机应答</strong></p><p>void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>写数据到数据寄存器DR</strong></p><p>void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);</p><p><strong>读取DR的数据，作为返回值</strong></p><p>uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);</p><p><strong>发送7位地址</strong></p><p>void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);</p></blockquote><p><strong>状态监控函数的官方说明</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> ****************************************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                         I2C State Monitoring Functions</span></span><br><span class="line"><span class="comment"> *                       </span></span><br><span class="line"><span class="comment"> ****************************************************************************************   </span></span><br><span class="line"><span class="comment"> * This I2C driver provides three different ways for I2C state monitoring</span></span><br><span class="line"><span class="comment"> *  depending on the application requirements and constraints:</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 1) Basic state monitoring:</span></span><br><span class="line"><span class="comment"> *    Using I2C_CheckEvent() function:</span></span><br><span class="line"><span class="comment"> *    It compares the status registers (SR1 and SR2) content to a given event</span></span><br><span class="line"><span class="comment"> *    (can be the combination of one or more flags).</span></span><br><span class="line"><span class="comment"> *    It returns SUCCESS if the current status includes the given flags </span></span><br><span class="line"><span class="comment"> *    and returns ERROR if one or more flags are missing in the current status.</span></span><br><span class="line"><span class="comment"> *    - When to use:</span></span><br><span class="line"><span class="comment"> *      - This function is suitable for most applications as well as for startup </span></span><br><span class="line"><span class="comment"> *      activity since the events are fully described in the product reference manual </span></span><br><span class="line"><span class="comment"> *      (RM0008).</span></span><br><span class="line"><span class="comment"> *      - It is also suitable for users who need to define their own events.</span></span><br><span class="line"><span class="comment"> *    - Limitations:</span></span><br><span class="line"><span class="comment"> *      - If an error occurs (ie. error flags are set besides to the monitored flags),</span></span><br><span class="line"><span class="comment"> *        the I2C_CheckEvent() function may return SUCCESS despite the communication</span></span><br><span class="line"><span class="comment"> *        hold or corrupted real state. </span></span><br><span class="line"><span class="comment"> *        In this case, it is advised to use error interrupts to monitor the error</span></span><br><span class="line"><span class="comment"> *        events and handle them in the interrupt IRQ handler.</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *        @note </span></span><br><span class="line"><span class="comment"> *        For error management, it is advised to use the following functions:</span></span><br><span class="line"><span class="comment"> *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).</span></span><br><span class="line"><span class="comment"> *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.</span></span><br><span class="line"><span class="comment"> *            Where x is the peripheral instance (I2C1, I2C2 ...)</span></span><br><span class="line"><span class="comment"> *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()</span></span><br><span class="line"><span class="comment"> *            in order to determine which error occurred.</span></span><br><span class="line"><span class="comment"> *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()</span></span><br><span class="line"><span class="comment"> *            and/or I2C_GenerateStop() in order to clear the error flag and source,</span></span><br><span class="line"><span class="comment"> *            and return to correct communication status.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  2) Advanced state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetLastEvent() which returns the image of both status </span></span><br><span class="line"><span class="comment"> *     registers in a single word (uint32_t) (Status Register 2 value is shifted left </span></span><br><span class="line"><span class="comment"> *     by 16 bits and concatenated to Status Register 1).</span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *       - This function is suitable for the same applications above but it allows to</span></span><br><span class="line"><span class="comment"> *         overcome the limitations of I2C_GetFlagStatus() function (see below).</span></span><br><span class="line"><span class="comment"> *         The returned value could be compared to events already defined in the </span></span><br><span class="line"><span class="comment"> *         library (stm32f10x_i2c.h) or to custom values defined by user.</span></span><br><span class="line"><span class="comment"> *       - This function is suitable when multiple flags are monitored at the same time.</span></span><br><span class="line"><span class="comment"> *       - At the opposite of I2C_CheckEvent() function, this function allows user to</span></span><br><span class="line"><span class="comment"> *         choose when an event is accepted (when all events flags are set and no </span></span><br><span class="line"><span class="comment"> *         other flags are set or just when the needed flags are set like </span></span><br><span class="line"><span class="comment"> *         I2C_CheckEvent() function).</span></span><br><span class="line"><span class="comment"> *     - Limitations:</span></span><br><span class="line"><span class="comment"> *       - User may need to define his own events.</span></span><br><span class="line"><span class="comment"> *       - Same remark concerning the error management is applicable for this </span></span><br><span class="line"><span class="comment"> *         function if user decides to check only regular communication flags (and </span></span><br><span class="line"><span class="comment"> *         ignores error flags).</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3) Flag-based state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetFlagStatus() which simply returns the status of </span></span><br><span class="line"><span class="comment"> *     one single flag (ie. I2C_FLAG_RXNE ...). </span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *        - This function could be used for specific applications or in debug phase.</span></span><br><span class="line"><span class="comment"> *        - It is suitable when only one flag checking is needed (most I2C events </span></span><br><span class="line"><span class="comment"> *          are monitored through multiple flags).</span></span><br><span class="line"><span class="comment"> *     - Limitations: </span></span><br><span class="line"><span class="comment"> *        - When calling this function, the Status register is accessed. Some flags are</span></span><br><span class="line"><span class="comment"> *          cleared when the status register is accessed. So checking the status</span></span><br><span class="line"><span class="comment"> *          of one Flag, may clear other ones.</span></span><br><span class="line"><span class="comment"> *        - Function may need to be called twice or more in order to monitor one </span></span><br><span class="line"><span class="comment"> *          single event.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="iic配置占空比的缘由"><a class="markdownIt-Anchor" href="#iic配置占空比的缘由"></a> #IIC配置占空比的缘由</h3><p><strong>上升沿变化较慢，下降沿比较迅速，标准速度下，时钟占空比接近1：1，快速状态，占空比接近2：1</strong></p><img src="/posts/5621/image-20240526174725131.png" class="" title="image-20240526174725131"><p>100KHZ</p><img src="/posts/5621/image-20240526174831972.png" class="" title="image-20240526174831972"><p>400KHZ</p><img src="/posts/5621/image-20240526174841651.png" class="" title="image-20240526174841651"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> *  <span class="number">1</span>) Basic state monitoring</span><br><span class="line"> *******************************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Checks whether the last I2Cx Event is equal to the one passed</span></span><br><span class="line"><span class="comment">  *   as parameter.</span></span><br><span class="line"><span class="comment">  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.</span></span><br><span class="line"><span class="comment">  * @param  I2C_EVENT: specifies the event to be checked. </span></span><br><span class="line"><span class="comment">  *   This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     </span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9</span></span><br><span class="line"><span class="comment">  *     </span></span><br><span class="line"><span class="comment">  * @note: For detailed description of Events, please refer to section </span></span><br><span class="line"><span class="comment">  *    I2C_Events in stm32f10x_i2c.h file.</span></span><br><span class="line"><span class="comment">  *    </span></span><br><span class="line"><span class="comment">  * @retval An ErrorStatus enumeration value:</span></span><br><span class="line"><span class="comment">  * - SUCCESS: Last event is equal to the I2C_EVENT</span></span><br><span class="line"><span class="comment">  * - ERROR: Last event is different from the I2C_EVENT</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解决while死循环等待的问题"><a class="markdownIt-Anchor" href="#解决while死循环等待的问题"></a> 解决WHILE死循环等待的问题</h3><p><strong>多个while,比较危险，一旦通信出现问题，程序直接卡死</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*软件I2C，阻塞式程序</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();//可以加判断，确保时序的正确</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(RegAddress);//指定要写入的寄存器</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(Data);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//硬件IIC，非阻塞式程序</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT ) !=SUCCESS);<span class="comment">//事件监测</span></span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//选择I2C外设，从机地址，从机地址最低位。此函数自带接收应答的功能</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,RegAddress);<span class="comment">//写入DR，需要等待EV8事件</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,Data);</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) !=SUCCESS);<span class="comment">//发送完最后一个字节，需要监测EB8_1事件</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTOP(I2C2,ENABLE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>保护程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Timeout;</span><br><span class="line">Timeout= <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2Cx,I2C_EVENT) != SUCCESS)</span><br><span class="line">{</span><br><span class="line">Timeout--;</span><br><span class="line"><span class="keyword">if</span>(Timeout==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="dmp库"><a class="markdownIt-Anchor" href="#dmp库"></a> DMP库</h1><p>digital motion processor数字运动处理器，mpu6050自带的一个硬件，可以直接输出用于姿态结算的四元数</p><h1 id="卡尔曼滤波"><a class="markdownIt-Anchor" href="#卡尔曼滤波"></a> 卡尔曼滤波</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iic通信协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#iic通信协议&quot;&gt;&lt;/a&gt; IIC通信协议&lt;/h1&gt;
&lt;h2 id=&quot;基本功能&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本功能&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="IIC" scheme="https://szturin.github.io/tags/IIC/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[9]DMA数据转运</title>
    <link href="https://szturin.github.io/posts/10712/"/>
    <id>https://szturin.github.io/posts/10712/</id>
    <published>2024-05-22T03:44:18.000Z</published>
    <updated>2024-05-25T11:44:00.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h1><blockquote><p><strong>恢复缺省配置</strong></p><p>void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>初始化DMA</strong></p><p>void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>DMA使能</strong></p><p>void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);</p><p><strong>中断输出使能</strong></p><p>void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);</p><p><strong>DMA设置当前数据寄存器</strong></p><p>void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);</p><p><strong>DMA获取当前数据寄存器</strong></p><p>uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>获取DMA标志位状态</strong></p><p>FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);</p><p><strong>清除DMA标志位</strong></p><p>void DMA_ClearFlag(uint32_t DMAy_FLAG);</p><p><strong>获取DMA中断标志位状态</strong></p><p>ITStatus DMA_GetITStatus(uint32_t DMAy_IT);</p><p><strong>清除DMA中断标志位</strong></p><p>void DMA_ClearITPendingBit(uint32_t DMAy_IT);</p><p><strong>开启ADC DMA触发信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p></blockquote><ul><li><p><strong><mark>DMA是AHB总线的设备</mark></strong></p></li><li><p><strong><mark>DMA软件触发和硬件触发不能同时使用，如果同时使用DMA就会连续触发</mark></strong></p></li><li><p>DMA转运有三个条件：1.传输计数器大于0 2.触发源有触发信号 3.DMA使能</p></li></ul><h1 id="一-dma数据转运"><a class="markdownIt-Anchor" href="#一-dma数据转运"></a> 一、DMA数据转运</h1><h2 id="1stm32单片机ram和rom"><a class="markdownIt-Anchor" href="#1stm32单片机ram和rom"></a> 1.stm32单片机RAM和ROM</h2><h3 id="不加const修饰"><a class="markdownIt-Anchor" href="#不加const修饰"></a> 不加const修饰</h3><img src="/posts/10712/image-20240522115326572.png" class="" title="image-20240522115326572"><h3 id="加上const修饰"><a class="markdownIt-Anchor" href="#加上const修饰"></a> 加上const修饰</h3><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> aa =<span class="number">0x66</span>;<span class="comment">//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,aa,<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;aa,<span class="number">8</span>);<span class="comment">//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>现象</strong></p><p>flash里面编译的代码部分，地址位于flah最前面，所以这里变量的显示在靠后的地址</p><img src="/posts/10712/image-20240522115450140.png" class="" title="image-20240522115450140"><h2 id="const关键字节省sram空间"><a class="markdownIt-Anchor" href="#const关键字节省sram空间"></a> const关键字节省SRAM空间</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED字模库，宽8像素，高16像素*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> OLED_F8x16[][<span class="number">16</span>]=</span><br><span class="line">{</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//  0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="结构体访问寄存器ram地址"><a class="markdownIt-Anchor" href="#结构体访问寄存器ram地址"></a> 结构体访问寄存器RAM地址</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR,<span class="number">8</span>);</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522115913765.png" class="" title="image-20240522115913765"><p><strong><mark>外设的起始地址+寄存器的偏移地址=指定寄存器的地址</mark></strong></p><p><strong><mark>使用结构体访问，指定地址对应寄存器，这样，结构体访问就是寄存器的地址</mark></strong></p><h2 id="2dma转运数组"><a class="markdownIt-Anchor" href="#2dma转运数组"></a> 2.DMA转运数组</h2><p><strong>软件触发代码部分</strong></p> <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522143322783.png" class="" title="image-20240522143322783"><h2 id="3dma软件触发"><a class="markdownIt-Anchor" href="#3dma软件触发"></a> 3.DMA软件触发</h2><img src="/posts/10712/image-20240522144732279.png" class="" title="image-20240522144732279"><p><strong>DMA传输计数器软件重装</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyDMA_Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数DMA初始化配置</span></span><br><span class="line"><span class="comment">  * @参数要转运数据的首地址，存储器站点的起始地址，传输次数</span></span><br><span class="line"><span class="comment">  * @返回值</span></span><br><span class="line"><span class="comment">  * @特殊说明</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line">MyDMA_Size=Size;</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=Size;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Enable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=AddrB;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;<span class="comment">//以字节传输</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;</span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=AddrA;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte;<span class="comment">//转运数据宽度为一个字节</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，所以通道可以任意选择</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,MyDMA_Size);</span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"DataA"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">"DataB"</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataA,<span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataB,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">DataA[<span class="number">0</span>]++;</span><br><span class="line">DataA[<span class="number">1</span>]++;</span><br><span class="line">DataA[<span class="number">2</span>]++;</span><br><span class="line">DataA[<span class="number">3</span>]++;</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">MyDMA_Transfer();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522145131191.png" class="" title="image-20240522145131191"><p><strong>将DataA用const修饰</strong></p><p>DataA此时为flash里面的变量，所以地址为08开头</p><img src="/posts/10712/image-20240522145359406.png" class="" title="image-20240522145359406"><h1 id="adc-dma转运"><a class="markdownIt-Anchor" href="#adc-dma转运"></a> ADC+ DMA转运</h1><p><strong>ADC单次扫描，DMA单次转运+软件触发</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD_Value[<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=DISABLE;<span class="comment">//单次模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,<span class="number">4</span>);<span class="comment">//传输次数给4</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里选择了ADC触发DMA，标志位自动清零，所以不需要软件清零</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);//等待转换完成标志位置1</span></span><br><span class="line"><span class="comment">return ADC_GetConversionValue(ADC1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA转运完成总是在ADC完成之后的，所以这里等待DMA状态标志位即可*/</span></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>ADC连续扫描+DMA循环转运模式</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=ENABLE;<span class="comment">//连续模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Circular;<span class="comment">//传输模式，是否使用自动重装,DMA循环模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line"></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思考：</strong></p><ul><li>定时器触发ADC单词转换后通过DMA转运？</li><li>串口发送的数据使用DMA进行存储器到外设的转运</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;相关库函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#相关库函数&quot;&gt;&lt;/a&gt; 相关库函数&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;恢复缺省配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void DMA_DeInit(DMA</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="DMA数据转运" scheme="https://szturin.github.io/tags/DMA%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[10]串口通信</title>
    <link href="https://szturin.github.io/posts/19202/"/>
    <id>https://szturin.github.io/posts/19202/</id>
    <published>2024-05-20T03:50:54.000Z</published>
    <updated>2024-05-25T17:34:23.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p><strong>结构体初始化配置</strong></p><p>void USART_DeInit(USART_TypeDef* USARTx);<br>void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);<br>void USART_StructInit(USART_InitTypeDef* USART_InitStruct);</p><p><strong>同步时钟配置</strong></p><p>void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);<br>void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);</p><p><strong>发送数据</strong></p><p>void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);</p><ul><li>写DR寄存器</li></ul><p><strong>接收数据</strong></p><p>uint16_t USART_ReceiveData(USART_TypeDef* USARTx);</p><ul><li>读DR寄存器</li></ul></blockquote><h1 id="microlib"><a class="markdownIt-Anchor" href="#microlib"></a> MicroLIB</h1><p><strong>MicroLIB是Keil为嵌入式平台优化的一个精简库</strong></p><img src="/posts/19202/image-20240520133336274.png" class="" title="image-20240520133336274"><h1 id="多个串口同时使用printf"><a class="markdownIt-Anchor" href="#多个串口同时使用printf"></a> 多个串口同时使用printf</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(String,<span class="string">"Num=%d\r\n"</span>,<span class="number">666</span>);<span class="comment">//sprintf.可以将指定的数据复制到数组中</span></span><br><span class="line">Serial_SendString(String);<span class="comment">//打印字符串</span></span><br></pre></td></tr></tbody></table></figure><h1 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_Prinf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="汉字编码发送"><a class="markdownIt-Anchor" href="#汉字编码发送"></a> 汉字编码发送</h1><img src="/posts/19202/image-20240520135012811.png" class="" title="image-20240520135012811"><p><strong>统一选定为UTF-8编码</strong></p><h1 id="串口接收"><a class="markdownIt-Anchor" href="#串口接收"></a> 串口接收</h1><h2 id="1查询方法"><a class="markdownIt-Anchor" href="#1查询方法"></a> 1.查询方法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">RXData=USART_ReceiveData(USART1);<span class="comment">//读DR可以自动清除标志位</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2中断方法"><a class="markdownIt-Anchor" href="#2中断方法"></a> 2.中断方法</h2><h3 id="子程序"><a class="markdownIt-Anchor" href="#子程序"></a> 子程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxData;</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GerRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> Serial_RxData;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2主程序"><a class="markdownIt-Anchor" href="#2主程序"></a> 2.主程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"RxData:"</span>);</span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_GerRxFlag()==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RXData = Serial_GetRxData();</span><br><span class="line">Serial_SendByte(RXData);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">RXData=USART_ReceiveData(USART1);//读DR可以自动清除标志位</span></span><br><span class="line"><span class="comment">OLED_ShowHexNum(1,1,RXData,2);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="串口数据包"><a class="markdownIt-Anchor" href="#串口数据包"></a> 串口数据包</h1><p><strong>打包多字节为一个数据包，方便发送多字节的数据。将同一批的数据进行打包和分割</strong></p><p><strong>包头、包尾：简易通信协议</strong></p><ul><li>文本数据包</li><li>Hex数据包</li></ul><h2 id="状态机的方法来接收数据包"><a class="markdownIt-Anchor" href="#状态机的方法来接收数据包"></a> 状态机的方法来接收数据包</h2><img src="/posts/19202/image-20240520150733732.png" class="" title="image-20240520150733732"><h2 id="1发送数据包"><a class="markdownIt-Anchor" href="#1发送数据包"></a> 1.发送数据包</h2><img src="/posts/19202/image-20240520152533465.png" class="" title="image-20240520152533465"><h2 id="2接收数据包"><a class="markdownIt-Anchor" href="#2接收数据包"></a> 2.接收数据包</h2><p><strong>串口中断子程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_TxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送数据包*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(<span class="number">0xFF</span>);</span><br><span class="line">Serial_SendArray(Serial_TxPacket,<span class="number">4</span>);</span><br><span class="line">Serial_SendByte(<span class="number">0xFE</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line"><span class="keyword">if</span>(++pRxState&gt;=<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">pRxState=<span class="number">0</span>;</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="number">0xFE</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Serial.h</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_TxPacket[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_RxPacket[];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="小操作"><a class="markdownIt-Anchor" href="#小操作"></a> 小操作</h2><p><strong>按住alt选择一列进行修改</strong></p><img src="/posts/19202/image-20240520154534025.png" class="" title="image-20240520154534025"><h2 id="3文本收发数据包"><a class="markdownIt-Anchor" href="#3文本收发数据包"></a> 3.文本收发数据包</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">100</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'@'</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'\r'</span>)<span class="comment">//第一个包尾</span></span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line">pRxState++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)<span class="comment">//第二个包尾</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="string">'\n'</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">Serial_RxPacket[pRxState]=<span class="string">'\0'</span>;<span class="comment">//字符串结束时加上\0,表示字符串的结束</span></span><br><span class="line">pRxState=<span class="number">0</span>;<span class="comment">//MARK:忘记清零</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="串口下载"><a class="markdownIt-Anchor" href="#串口下载"></a> #串口下载</h1><h2 id="boot引脚"><a class="markdownIt-Anchor" href="#boot引脚"></a> Boot引脚</h2><p>BootLoder的作用相当于刷机</p><h2 id="调试使用"><a class="markdownIt-Anchor" href="#调试使用"></a> 调试使用</h2><img src="/posts/19202/image-20240520163851412.png" class="" title="image-20240520163851412"><p>可以保持跳线帽置1，但是复位后程序丢失，所以仅用来调试</p><h2 id="读flash生成bin文件"><a class="markdownIt-Anchor" href="#读flash生成bin文件"></a> 读FLASH生成bin文件</h2><img src="/posts/19202/image-20240520164112095.png" class="" title="image-20240520164112095"><h2 id="读保护写保护"><a class="markdownIt-Anchor" href="#读保护写保护"></a> 读保护/写保护</h2><img src="/posts/19202/image-20240520164217951.png" class="" title="image-20240520164217951"><h1 id="蓝牙串口通信"><a class="markdownIt-Anchor" href="#蓝牙串口通信"></a> 蓝牙串口通信</h1><p><a href="https://blog.csdn.net/struggle_success/article/details/130440579">电赛|项目|课设：蓝牙模块HC05主从配置与连接_蓝牙 master和 slave 服务-CSDN博客</a></p><p><strong>AT指令集</strong></p><p>AT+NAME = xlg 设置蓝牙名称为xlg</p><p>AT+ROLE=0 蓝牙模式为从模式 AT+ROLE=1 蓝牙模式为主模式<br>AT+CMODE=0 蓝牙连接模式为任意地址连接模式<br>AT+PSWD=1234 蓝牙配对密码为1234<br>AT+UART=9600，0，0 蓝牙通信串口波特率为9600，停止位1位，无校验位<br>AT+RMAAD 清空配对列表</p><p>一、更改波特率<br>AT+UART=a,b,c<br>蓝牙通信串口波特率为a，<br>b:停止位1位，无校验位<br>返回响应为OK</p><p>二、修改蓝牙模块密码</p><p>修改密码的AT指令格式如下：（以修改后的密码为1314为例）</p><pre><code>        AT+PSWD=1314（这里加回车）</code></pre><p>1<br>三、修改蓝牙模块名字</p><p>修改模块名字的AT指令如下：</p><pre><code>            AT+NAME =</code></pre><p>1<br>1， AT+ROLE设置主从模式：<br>AT+ROLE=1是设成主，AT+ROLE=0是设成从，AT+ROLE=2设成回环模式Slave-Loop：被动连接，接收远程蓝 牙主设备数据并将数据原样返回给远程蓝牙<br>AT+ROLE?：查询主从状态<br>2， AT+RESET:HC-05复位</p><p>3， AT+VERSION?：获取HC-05的软件版本号，只能获取，不能修改。</p><p>4， AT+ORGL:恢复出厂默认设置，当把模块设置乱了，使用此命令进行恢复默认值。</p><p>5， AT+ADDR?：获取HC-05的蓝牙地址码，只能获取，不能修改。</p><p>6， AT+NAME？:获取HC-05的名字,AT+NAME=xlg，修改模块的名字为xlg，具体名字自行修改。</p><p>7， AT+CLASS?：设置查询设备的类型，尽量不要去修改此参数。默认是1F00。</p><p>8， AT+IAC?：查询设置查询访问码，默认是9E8B33，尽量不要去修改此参数。</p><p>9， AT+PSWD？:查询设置配对密码,AT+PSWD=”0000”,密码要有双引号,密码是四位数字.</p><p>10， AT+UART：AT+UART？是查询当前模块的波特率，AT+UART=波特率,0,0。</p><p>11， AT+CMODE：AT+CMODE？是查询当前连接模式。AT+CMODE=0，1，2(0——指定蓝牙地址连接模式（指定蓝牙地址由绑定指令设置）1——任意蓝牙地址连接模式（不受绑定指令设置地址的约束）2——回环角色（Slave-Loop）默认连接模式：0)。</p><p>12， AT+BIND:AT+BIND?查询当前绑定地址,AT+BIND=NAP，UAP，LAP(用逗号隔开)。</p><p>13， AT+RMADD:从蓝牙配对列表中删除所有认证设备.</p><p>14， AT+STATE？:获取蓝牙模块工作状态.</p><p>15， AT+LINK=NAP,UAP,LAP：与远程设备建立连接。</p><p>16， AT+DISC:断开连接.</p><p>17， AT+RNAME？NAP，UAP，LAP:获取远程蓝牙设备名称.</p><p>18， AT+ADCN?：获取蓝牙配对列表中认证设备数。</p><p>19， AT+MRAD？获取最近使用过的蓝牙认证设备地址。</p><p>20， AT+INQM:设置查询模式,AT+INQM=1，9，48(1-带RSSI信号强度指示,9-超过9个蓝牙设备响应则终止查询,48-设定超时为48*1.28=61.44秒)</p><p><strong>ps: HC05模块的AT指令，蓝牙命名AT+NAME= 以及密码设置AT+PSWD= 需要加双引号！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;库函数解释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#库函数解释&quot;&gt;&lt;/a&gt; 库函数解释&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;结构体初始化配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void USART_DeInit</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="串口" scheme="https://szturin.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="蓝牙" scheme="https://szturin.github.io/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>【Python学习】[1] 初识Python</title>
    <link href="https://szturin.github.io/posts/23330/"/>
    <id>https://szturin.github.io/posts/23330/</id>
    <published>2024-05-19T05:00:29.000Z</published>
    <updated>2024-05-25T11:45:00.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个python程序"><a class="markdownIt-Anchor" href="#第一个python程序"></a> 第一个Python程序</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\Users\123&gt;python</span><br><span class="line">Python 3.11.7 | packaged by Anaconda, Inc. | (main, Dec 15 2023, 18:05:47) [MSC v.1916 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">&gt;&gt;&gt; print('Hello world')</span><br><span class="line">Hello world</span><br><span class="line">&gt;&gt;&gt; print("Hello world")</span><br><span class="line">Hello world</span><br><span class="line">&gt;&gt;&gt; name = input('请输入你的名字')</span><br><span class="line">请输入你的名字'Turin'</span><br><span class="line">&gt;&gt;&gt; print(name)</span><br><span class="line">'Turin'</span><br><span class="line">&gt;&gt;&gt; print('Hello',name)</span><br><span class="line">Hello 'Turin'</span><br><span class="line">&gt;&gt;&gt; 2**10</span><br><span class="line">1024</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017063826246112">数据类型和变量 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h2 id="prompt运行py"><a class="markdownIt-Anchor" href="#prompt运行py"></a> <a href="http://xn--prompt-8w2r549b.py">prompt运行.py</a></h2><p><strong>prompt窗口1</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">please enter your name: Turin</span><br><span class="line">hello, Turin</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>.py文件</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>); <span class="comment">#Python中的分号可以省略，主要通过换行来识别语句的结束</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span><span class="string">"hello world"</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>,<span class="string">"hello world"</span>); <span class="comment">#print()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是拼起来的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> + <span class="number">200</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'1024*1024 ='</span>,<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">'please enter your name: '</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'hello,'</span>, name)</span><br></pre></td></tr></tbody></table></figure><p><strong>prompt窗口2</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">版权所有 (C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">尝试新的跨平台 PowerShell https://aka.ms/pscore6</span><br><span class="line"></span><br><span class="line">PS D:\7_python_project&gt; cd '.\1-1 python base\'</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">Turin</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">w</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">w</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt;</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt;</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python</span><br><span class="line">Python 3.10.2 (tags/v3.10.2:a58ebcc, Jan 17 2022, 14:12:15) [MSC v.1929 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">&gt;&gt;&gt; name = input()</span><br><span class="line">Turin</span><br><span class="line">&gt;&gt;&gt; print(name)</span><br><span class="line">Turin</span><br><span class="line">&gt;&gt;&gt; name = input('please enter your name: ')</span><br><span class="line">please enter your name: print('hello,', name)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">KeyboardInterrupt</span><br><span class="line"></span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">please enter your name: Turin</span><br><span class="line">hello, Turin</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; print('1024 * 768 ='1024 * 768 )</span><br><span class="line">所在位置 行:1 字符: 21</span><br><span class="line">+ print('1024 * 768 ='1024 * 768 )</span><br><span class="line">+                     ~~~~</span><br><span class="line">表达式或语句中包含意外的标记“1024”。</span><br><span class="line">所在位置 行:1 字符: 21</span><br><span class="line">+ print('1024 * 768 ='1024 * 768 )</span><br><span class="line">+                     ~</span><br><span class="line">表达式中缺少右“)”。</span><br><span class="line">所在位置 行:1 字符: 32</span><br><span class="line">+ print('1024 * 768 ='1024 * 768 )</span><br><span class="line">+                                ~</span><br><span class="line">表达式或语句中包含意外的标记“)”。</span><br><span class="line">    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException</span><br><span class="line">    + FullyQualifiedErrorId : UnexpectedToken</span><br><span class="line"></span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; print('1024 * 768 ='1024 * 768 ^C</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; print('1024 * 768 ='1024 * 768 ^C</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; ^C</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python</span><br><span class="line">Python 3.10.2 (tags/v3.10.2:a58ebcc, Jan 17 2022, 14:12:15) [MSC v.1929 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">&gt;&gt;&gt; print('1024 * 768 ='1024 * 768 )</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    print('1024 * 768 ='1024 * 768 )</span><br><span class="line">          ^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">SyntaxError: invalid syntax. Perhaps you forgot a comma?</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt; print('\\\t\\')</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r'\\\t\\')</span><br><span class="line">\\\t\\</span><br><span class="line">&gt;&gt;&gt; print(''' line1</span><br><span class="line">... ...line2</span><br><span class="line">... ...line3''')</span><br><span class="line"> line1</span><br><span class="line">...line2</span><br><span class="line">...line3</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; print('''line1</span><br><span class="line">... line2</span><br><span class="line">... line3</span><br><span class="line">... '''</span><br><span class="line">... ^Z</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt; print('''line1</span><br><span class="line">... line2</span><br><span class="line">... line3''')</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 0</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; False or False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; not 1 = 1</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    not 1 = 1</span><br><span class="line">    ^^^^^</span><br><span class="line">SyntaxError: cannot assign to expression</span><br><span class="line">&gt;&gt;&gt; not 1==1</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; n = 123</span><br><span class="line">&gt;&gt;&gt; f = 456.789</span><br><span class="line">&gt;&gt;&gt; s1 = 'Hello, world'</span><br><span class="line">&gt;&gt;&gt; s2 = 'Hello, \'Adam\''</span><br><span class="line">&gt;&gt;&gt; s3 = r'Hello, "Bart"'</span><br><span class="line">&gt;&gt;&gt; s4 = r'''Hello,</span><br><span class="line">... Lisa!'''</span><br><span class="line">&gt;&gt;&gt; print(n\n,f,s1,s2,s3,s4)</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    print(n\n,f,s1,s2,s3,s4)</span><br><span class="line">            ^</span><br><span class="line">SyntaxError: unexpected character after line continuation character</span><br><span class="line">&gt;&gt;&gt; n = 123</span><br><span class="line">&gt;&gt;&gt; f = 456.789</span><br><span class="line">&gt;&gt;&gt; s1 = 'Hello, world'</span><br><span class="line">&gt;&gt;&gt; s2 = 'Hello, \'Adam\''</span><br><span class="line">&gt;&gt;&gt; s3 = r'Hello, "Bart"'</span><br><span class="line">&gt;&gt;&gt; s4 = r'''Hello,</span><br><span class="line">... Lisa!'''</span><br><span class="line">&gt;&gt;&gt; print(n\t,f,s1,s2,s3,s4)</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    print(n\t,f,s1,s2,s3,s4)</span><br><span class="line">            ^</span><br><span class="line">SyntaxError: unexpected character after line continuation character</span><br><span class="line">&gt;&gt;&gt; n = 123</span><br><span class="line">&gt;&gt;&gt; f = 456.789</span><br><span class="line">&gt;&gt;&gt; s1 = 'Hello, world'</span><br><span class="line">&gt;&gt;&gt; s2 = 'Hello, \'Adam\''</span><br><span class="line">&gt;&gt;&gt; s3 = r'Hello, "Bart"'</span><br><span class="line">&gt;&gt;&gt; s4 = r'''Hello,</span><br><span class="line">... Lisa!'''</span><br><span class="line">&gt;&gt;&gt; print('n\n,f,s1,s2,s3,s4')</span><br><span class="line">n</span><br><span class="line">,f,s1,s2,s3,s4</span><br><span class="line">&gt;&gt;&gt; ord('A')</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord('中')</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">'B'</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">'B'</span><br><span class="line">&gt;&gt;&gt; '\u4e2d\u6587'</span><br><span class="line">'中文'</span><br><span class="line">&gt;&gt;&gt; x = b'ABC'</span><br><span class="line">&gt;&gt;&gt; 'ABC'.encode('ascii')</span><br><span class="line">b'ABC'</span><br><span class="line">&gt;&gt;&gt; '中文'.encode('UTF-8')</span><br><span class="line">b'\xe4\xb8\xad\xe6\x96\x87'</span><br><span class="line">&gt;&gt;&gt; '中文'.encode('ascii')</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)</span><br><span class="line">&gt;&gt;&gt; b'ABC'.decode('UTF-8')</span><br><span class="line">'ABC'</span><br><span class="line">&gt;&gt;&gt; len('中文')</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; len('中文'.encode('utf-8'))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; 'Hello, %s' % 'world'</span><br><span class="line">'Hello, world'</span><br><span class="line">&gt;&gt;&gt; 'Hello,%s' &amp; 'world'</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) for &amp;: 'str' and 'str'</span><br><span class="line">&gt;&gt;&gt; 'Hello,%s' %'world'</span><br><span class="line">'Hello,world'</span><br><span class="line">&gt;&gt;&gt; 'Hi,&amp;s,You have %d$' %('Meter',100000)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">TypeError: %d format: a real number is required, not str</span><br><span class="line">&gt;&gt;&gt; 'Hi,%s,You have %d$' %('Meter',100000)</span><br><span class="line">'Hi,Meter,You have 100000$'</span><br><span class="line">&gt;&gt;&gt; 'Hi,&amp;s,You have %d$' %('Meter',100000)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">TypeError: %d format: a real number is required, not str</span><br><span class="line">&gt;&gt;&gt; print('%2d-%02d' % (3, 1))</span><br><span class="line"> 3-01</span><br><span class="line">&gt;&gt;&gt; print('%.2f' % 3.1415926)</span><br><span class="line">3.14</span><br><span class="line">&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)</span><br><span class="line">'Age: 25. Gender: True'</span><br><span class="line">&gt;&gt;&gt; 'growth rate: %d %%' % 7</span><br><span class="line">'growth rate: 7 %'</span><br><span class="line">&gt;&gt;&gt; '中文'.encode('gb2312')</span><br><span class="line">b'\xd6\xd0\xce\xc4'</span><br><span class="line">&gt;&gt;&gt; 'Hello,{0}的成绩提高了{1:.1f}'.format('小明',17.125)</span><br><span class="line">'Hello,小明的成绩提高了17.1'</span><br><span class="line">&gt;&gt;&gt; print(f'^Z')</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt; s = '小明'</span><br><span class="line">&gt;&gt;&gt; a = '85'</span><br><span class="line">&gt;&gt;&gt; print(f'Hello,{s}的成绩为{a}')</span><br><span class="line">Hello,小明的成绩为85</span><br><span class="line">&gt;&gt;&gt; s1=72</span><br><span class="line">&gt;&gt;&gt; s2=85</span><br><span class="line">&gt;&gt;&gt; rate = s1/85</span><br><span class="line">&gt;&gt;&gt; print(f'小明的成绩从去年的{s1}分提升到了今年的{s2}分，提升了{rate}%')</span><br><span class="line">小明的成绩从去年的72分提升到了今年的85分，提升了0.8470588235294118%</span><br><span class="line">&gt;&gt;&gt; s1=72</span><br><span class="line">&gt;&gt;&gt; s2=85</span><br><span class="line">&gt;&gt;&gt; rate = s1/85</span><br><span class="line">&gt;&gt;&gt; s2=85^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>PS:当<code>str</code>和<code>bytes</code>互相转换时,没有特殊要求，指定使用UTF-8编码</strong></p><h1 id="问题及解决方案"><a class="markdownIt-Anchor" href="#问题及解决方案"></a> 问题及解决方案</h1><ul><li><a href="https://blog.csdn.net/m0_52592128/article/details/120798138">Vscode提示“无法在只读编辑器中编辑”解决方法_vscode编辑器关闭只读模式-CSDN博客</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一个python程序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一个python程序&quot;&gt;&lt;/a&gt; 第一个Python程序&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbod</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python/"/>
    
    <category term="人工智能" scheme="https://szturin.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="编程" scheme="https://szturin.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Python" scheme="https://szturin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【pid算法】[入门篇] 1-深入浅出pid控制算法原理</title>
    <link href="https://szturin.github.io/posts/34110/"/>
    <id>https://szturin.github.io/posts/34110/</id>
    <published>2024-05-12T06:55:23.000Z</published>
    <updated>2024-05-22T07:53:39.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pid模拟调参无人机"><a class="markdownIt-Anchor" href="#pid模拟调参无人机"></a> pid模拟调参（无人机）</h2><p><a href="https://rossning92.github.io/pid-simulation/">Webpack App (rossning92.github.io)</a></p><img src="/posts/34110/image-20240512152800666.png" class="" title="image-20240512152800666"><h2 id="多环平衡小车"><a class="markdownIt-Anchor" href="#多环平衡小车"></a> 多环(平衡小车)</h2><img src="/posts/34110/image-20240512154358581.png" class="" title="image-20240512154358581"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Kp,Ki,Kd;</span><br><span class="line"><span class="type">int</span> Error;</span><br><span class="line"><span class="type">int</span> Error_old;</span><br><span class="line"><span class="type">int</span> Error_difference;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> Error_sum;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I_amplitude_limiting</span><span class="params">(<span class="type">int</span> number)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Error_sum&gt;number)</span><br><span class="line">{</span><br><span class="line">Error_sum=number;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//PID控制系统:P、I、D共同作用</span></span><br><span class="line"><span class="comment">//measure,calcu:系统的输入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PID_control</span><span class="params">(<span class="type">float</span> measure,<span class="type">float</span> calcu)</span></span><br><span class="line">{</span><br><span class="line">Error = measure - calcu;<span class="comment">//误差值</span></span><br><span class="line"></span><br><span class="line">Error_sum += Error;<span class="comment">//误差累加</span></span><br><span class="line">I_amplitude_limiting(<span class="number">2000</span>);<span class="comment">//限幅函数</span></span><br><span class="line"></span><br><span class="line">Error_difference = Error- Error_old;<span class="comment">//误差变化率(近似于对时间的微分)</span></span><br><span class="line">Error_old = Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(Kp*Error+Kd*Error_difference+Ki*Error_sum);<span class="comment">//PID控制器响应结果</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;pid模拟调参无人机&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pid模拟调参无人机&quot;&gt;&lt;/a&gt; pid模拟调参（无人机）&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://rossning92.github.io/pid-simu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【微机原理】红外通信系统</title>
    <link href="https://szturin.github.io/posts/29338/"/>
    <id>https://szturin.github.io/posts/29338/</id>
    <published>2024-05-11T06:32:46.000Z</published>
    <updated>2024-05-22T07:53:39.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> # 前言</h1><h2 id="一-红外通信系统"><a class="markdownIt-Anchor" href="#一-红外通信系统"></a> 一、红外通信系统</h2><h3 id="二-红外调制解调的原理"><a class="markdownIt-Anchor" href="#二-红外调制解调的原理"></a> 二、红外调制解调的原理</h3><ul><li>空闲状态：红外LED不亮，接收头输出高电平</li><li>发送低电平：红外LED以38KHz频率闪烁发光，接收头输出低电平</li><li>发送高电平：红外LED不亮，接收头输出高电平<br>总而言之，只有红外LED发送38KHZ的闪烁信号时，红外接收头OUT引脚才会对外输出低电平信号<br>红外发送–红外接收的本质是<mark>调制</mark>和<mark>解调</mark>，在这种条件下，可以过滤掉自然界中的“噪声信号”，只有38KHZ附近的红外信号才能被红外接收头识别转换为对应的低电平。</li></ul><p><strong>转换示意图：</strong><br>1.红外LED发出的信号</p><img src="/posts/29338/c97d453d8866482a8bc0a2191a565288.png" class="" title="在这里插入图片描述"><p>2.红外接收头发出的信号</p><img src="/posts/29338/3d972def937345fdb73a96eb875114b8.png" class="" title="在这里插入图片描述"><p>其中，红外接收头发出的低电平信号的宽度等价于红外LED发送的38KHz信号的时间。</p><h1 id="一-基于ccp1输入捕获模式的解调电路"><a class="markdownIt-Anchor" href="#一-基于ccp1输入捕获模式的解调电路"></a> 一、基于CCP1输入捕获模式的解调电路</h1><h2 id="1-proteus生成基带信号"><a class="markdownIt-Anchor" href="#1-proteus生成基带信号"></a> 1. Proteus生成基带信号</h2><img src="/posts/29338/image-20240511143825355.png" class="" title="image-20240511143825355"><h3 id="11脉冲最小单位"><a class="markdownIt-Anchor" href="#11脉冲最小单位"></a> 1.1脉冲最小单位</h3><img src="/posts/29338/image-20240511143912266.png" class="" title="image-20240511143912266"><h3 id="12特定脉冲序列"><a class="markdownIt-Anchor" href="#12特定脉冲序列"></a> 1.2特定脉冲序列</h3><img src="/posts/29338/image-20240511143937021.png" class="" title="image-20240511143937021"><img src="/posts/29338/image-20240519153450824.png" class="" title="image-20240519153450824"><p><strong>从左往右表示数据从高位到低位，如图所示为01001101</strong></p><h3 id="13仿真结果"><a class="markdownIt-Anchor" href="#13仿真结果"></a> 1.3仿真结果</h3><img src="/posts/29338/image-20240519153542254.png" class="" title="image-20240519153542254"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;<span class="comment">//接收数据储存变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获模式接收信号跳变*/</span></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次接收信号为下跳变</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;</span><br><span class="line">CCP1CON=<span class="number">0X05</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//本次接收信号为上跳变</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0</span> &amp;&amp; CCPR1H == <span class="number">0X00</span>){B=B&lt;&lt;<span class="number">1</span>;}<span class="comment">//'0'</span></span><br><span class="line"><span class="keyword">if</span>(CCPR1L &lt; <span class="number">0X50</span> &amp;&amp; CCPR1H == <span class="number">0X01</span>){B=B&lt;&lt;<span class="number">1</span>;B=B+<span class="number">1</span>;}  <span class="comment">//'1'</span></span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0XA0</span> &amp;&amp; CCPR1H == <span class="number">0X01</span>){PORTB = B;}  <span class="comment">//结束信号，电平宽度匹配时表示完整接收到1Byte数据</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;<span class="comment">//清空寄存器</span></span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;<span class="comment">//中断相关寄存器配置</span></span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line">B=<span class="number">0</span>;TRISB=<span class="number">0</span>; PORTB=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//开启定时器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二-基于ccp1输出比较模式的基带信号生成电路"><a class="markdownIt-Anchor" href="#二-基于ccp1输出比较模式的基带信号生成电路"></a> 二、基于CCP1输出比较模式的基带信号生成电路</h1><h2 id="1mpalb波形显示窗口显示rc2产生的基带信号"><a class="markdownIt-Anchor" href="#1mpalb波形显示窗口显示rc2产生的基带信号"></a> 1.MPALB波形显示窗口，显示RC2产生的基带信号</h2><img src="/posts/29338/image-20240519155221573.png" class="" title="image-20240519155221573"><h2 id="2代码解释"><a class="markdownIt-Anchor" href="#2代码解释"></a> 2.代码解释</h2><p><strong>CCP1模块每次发送1位二进制的负脉冲宽度，每次循环从data左移一位。PIC单片机C语言循环移位语句用汇编语句asm(“rlf _data,f”)，每次将最高位移入CARRY寄存器中，以最高的程序执行效率进行数据移位并生成基带信号的操作，并且每次发送1位二进制负脉冲宽度之后，会发送1位同步头的正脉冲宽度。发送完所有二进制数据之后，发送1位结束头低电平宽度</strong></p><img src="/posts/29338/image-20240519155522173.png" class="" title="image-20240519155522173"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data,data_cnt;<span class="comment">//发送的二进制代码，代码长度</span></span><br><span class="line"><span class="type">char</span> IR_SendSelect;</span><br><span class="line">bit a;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a=!a;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RC7=<span class="number">0</span>;</span><br><span class="line">data_cnt--;<span class="comment">//低电平。二进制代码位数减1</span></span><br><span class="line"><span class="keyword">if</span>(data_cnt == <span class="number">0</span>) <span class="keyword">goto</span> period_delty;<span class="comment">//位数为0，全部发送完，转624us延时</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"rlf _data,f"</span>);<span class="comment">//未发送完，取下一位待发送数据（数据移入CARRY中）</span></span><br><span class="line"><span class="keyword">if</span>(CARRY == <span class="number">1</span>) <span class="keyword">goto</span> data_5eh;<span class="comment">//待发送数据=1</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//待发送数据=0,叠加低电平时长68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;</span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">data_5eh:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X38</span>;<span class="comment">//待发送数据=1,叠加低电平时长138H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">1</span>;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">period_delty:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X70</span>;<span class="comment">//叠加624us的延时参数270H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">2</span>;<span class="comment">//高位字节加2及低位叠加时的进位和</span></span><br><span class="line">data=<span class="number">0B</span>01001101;<span class="comment">//=PORTB //从PORTB取数据</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;</span><br><span class="line">ret_fie:</span><br><span class="line">CCP1M0=<span class="number">0</span>;<span class="comment">//下次匹配时输出高电平</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//叠加同步头的延时参数68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line">CCP1M0=<span class="number">1</span>;<span class="comment">//下次匹配时输出低电平</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">nRBPU=<span class="number">0</span>;<span class="comment">//启用RB弱上拉</span></span><br><span class="line">TRISB=<span class="number">0xFF</span>;<span class="comment">//作输入口</span></span><br><span class="line">TRISC2=<span class="number">0</span>;<span class="comment">//C口定义为输入口，只定义RC2作为输出</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;<span class="comment">//设置预分频比为 = 1:1,开中断</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;<span class="comment">//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line">CCP1CON = <span class="number">0X08</span>;<span class="comment">//CCP1设为匹配时令CCP1/RC2引脚输出高电平</span></span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//启动TMR1</span></span><br><span class="line">data = <span class="number">0B</span>01001101;<span class="comment">//=PORTB;从PORTB取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三-将基带电路与调制电路配合组成简易的红外通信系统"><a class="markdownIt-Anchor" href="#三-将基带电路与调制电路配合组成简易的红外通信系统"></a> 三、将基带电路与调制电路配合，组成简易的红外通信系统</h1><p><strong>如图所示，因为RC2输出的红外基带信号带有毛刺，所以这里改为RC7引脚输出基带信号，这样，就能组成一个完整的红外发送-接收系统，运行仿真，此时红外接收端的LED同与发送端PORTB的逻辑</strong></p><img src="/posts/29338/image-20240519161843951.png" class="" title="image-20240519161843951"><h1 id="四-配合ccp1输出比较和ccp2-pwm输出模式构成载波-调制信号"><a class="markdownIt-Anchor" href="#四-配合ccp1输出比较和ccp2-pwm输出模式构成载波-调制信号"></a> 四、配合CCP1输出比较和CCP2 PWM输出模式，构成载波-调制信号</h1><p><strong>MPLAB仿真观测调制信号，与原基带信号进行对比，验证代码现象</strong></p><p><strong>调制信号在图像上有些地方在同步头结束后为高电平，但在经过红外发送管之后，发送的信号依然对应者基带信号的波形，所以实际上并没有影响</strong></p><img src="/posts/29338/image-20240514130203460.png" class="" title="image-20240514130203460"><h1 id="五-实物测试部分"><a class="markdownIt-Anchor" href="#五-实物测试部分"></a> 五、实物测试部分</h1><h2 id="1红外二极管收发"><a class="markdownIt-Anchor" href="#1红外二极管收发"></a> 1.红外二极管收发</h2><h3 id="使用电压表测试红外接收管压降"><a class="markdownIt-Anchor" href="#使用电压表测试红外接收管压降"></a> <mark>使用电压表测试红外接收管压降</mark></h3><img src="/posts/29338/b8287e8289bf096bd5da1196ff211612.jpg" class="" title="b8287e8289bf096bd5da1196ff211612"><h2 id="2测试红外接收模块是否能被触发"><a class="markdownIt-Anchor" href="#2测试红外接收模块是否能被触发"></a> 2.测试红外接收模块是否能被触发</h2><ul><li><mark><strong>首先测试能否顺利进入中断，用PIC板载LED进行观测，每次进入中断，代表接收到一次38KHZ的红外信号，同时PIC板的八位LED进行取反闪烁</strong></mark></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;</span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line">PORTD^=<span class="number">0xFF</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">if(CCPR1L &gt; 0 &amp;&amp; CCPR1H == 0X00){B=B&lt;&lt;1;}//'0'==0x685</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X01){B=B&lt;&lt;1;B=B+1;}  //'1'==0x12C</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X02){PORTD = B;}  //结束信号==0x270</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;</span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;</span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line">B=<span class="number">0</span>;TRISD=<span class="number">0</span>; PORTD=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3仿真软件测量接收信号时选定捕捉每个bit数据的范围"><a class="markdownIt-Anchor" href="#3仿真软件测量接收信号时选定捕捉每个bit数据的范围"></a> 3.仿真软件测量接收信号时，选定捕捉每个bit数据的范围</h2><h3 id="31-程序调试使得红外传输系统更加精确稳定"><a class="markdownIt-Anchor" href="#31-程序调试使得红外传输系统更加精确稳定"></a> 3.1 程序调试，使得红外传输系统更加精确稳定</h3><p><mark><strong>虽然在红外调制电路代码中，我们指定了每个二进制数据，停止位，起始位的电平长度，但是，因为程序设计以及单片机响应速度的原因，我们并不知道它最终生成信号各个部分的电平宽度具体值，如果将编写好的程序直接拿来用，可能得不到任何想要的现象。因此，要通过测量红外解调电路实际获取到的各个二进制电平的长度（通过LCD1602显示），然后再修改程序，使得红外接收单片机能够稳定接收红外发送单片机发送的信号。</strong></mark></p><p><strong>下面为用于测试接收端接收到各个bit数据电平宽度的代码，如：控制发送端发送的数据为0x00，然后接收端这边进行对’0’的电平宽度测量，显示在LCD1602上，其他任意宽度的bit位也是同理</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;</span><br><span class="line"><span class="type">int</span> Time_Data;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//PORTD^=0xFF;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次捕捉下降沿</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;</span><br><span class="line">CCP1CON=<span class="number">0X05</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>; Time_Data = CCPR1H &lt;&lt; <span class="number">8</span> | CCPR1L;</span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0</span> &amp;&amp; CCPR1H == <span class="number">0X00</span>){LCD1602_WriteNum(<span class="number">1</span>,<span class="number">0</span>,Time_Data,<span class="number">5</span>);CCP1IE=<span class="number">0</span>;}<span class="comment">//55</span></span><br><span class="line"><span class="comment">//if(CCPR1H == 0X01){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//263</span></span><br><span class="line"><span class="comment">//if(CCPR1H == 0X02){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)//本次捕捉下降沿</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;//清零TMR1寄存器值</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//下一次捕捉上升沿</span></span><br><span class="line"><span class="comment">CCP1IF=0;//清除输入捕捉标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;//下一次捕捉下降沿</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">if(CCPR1L &gt; 0 &amp;&amp; CCPR1H == 0X00){B=B&lt;&lt;1;}//0'068</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X01){B=B&lt;&lt;1;B=B+1;}  //'1'==0x12C</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X02){PORTD = B;}  //结束信号==0x270</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISD=<span class="number">0X00</span>;<span class="comment">//数据口</span></span><br><span class="line">    TRISA=<span class="number">0x00</span>;<span class="comment">//RA0配置为输出模式</span></span><br><span class="line">ADCON1=<span class="number">0X07</span>;<span class="comment">//RA端口与AD转换有关！！！，不然无法正常显示LCD1602</span></span><br><span class="line">LCD1602_Init();</span><br><span class="line">LCD1602_WriteString(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"OK"</span>);</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;</span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;</span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line"></span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line"></span><br><span class="line">B=<span class="number">0</span>;TRISD=<span class="number">0</span>; PORTD=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/29338/image-20240514001540423.png" class="" title="image-20240514001540423"><h2 id="发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据"><a class="markdownIt-Anchor" href="#发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据"></a> 发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据</h2><p><strong>如图所示，发送连续三个Byte的一帧数据</strong></p><img src="/posts/29338/image-20240514015916078.png" class="" title="image-20240514015916078"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data,data_cnt;<span class="comment">//发送的二进制代码，代码长度</span></span><br><span class="line"><span class="type">char</span> IR_SendSelect;</span><br><span class="line"><span class="type">char</span> measure_Flag;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1_HighByte;<span class="comment">//CCP1高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1_LowByte;<span class="comment">//CCP1低字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Over_Counter=<span class="number">0</span>;<span class="comment">//溢出计数值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Over_Counter_temp;<span class="comment">//溢出计数暂存值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1IF_TriggerFlag;<span class="comment">//CCP1中断触发标志位</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> TABLE[<span class="number">16</span>]={<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>,<span class="number">0x46</span>};</span><br><span class="line"><span class="type">char</span> Send_Counter;<span class="comment">//发送字节次数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Cycle;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data_new;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Cycle;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data_M;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稳定数据滤波器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">data_filter</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">T_data_new.Data[<span class="number">0</span>]=Over_Counter;</span><br><span class="line">T_data_new.Data[<span class="number">1</span>]=CCP1_HighByte;</span><br><span class="line">T_data_new.Data[<span class="number">2</span>]=CCP1_LowByte;</span><br><span class="line"></span><br><span class="line">T_data_M.Data[i++]= T_data_new.Cycle;</span><br><span class="line">i%=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T_data_M.Data[<span class="number">0</span>]==T_data_M.Data[<span class="number">1</span>] &amp;&amp; T_data_M.Data[<span class="number">1</span>] == T_data_M.Data[<span class="number">2</span>])<span class="comment">//当三次取值相等时，才为有效值</span></span><br><span class="line">{</span><br><span class="line">T_data.Cycle=T_data_new.Cycle;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(measure_Flag == 0)//为周期测量模式</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(TMR1IF==1)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">Over_Counter_temp++;//累加TMR1的溢出次数</span></span><br><span class="line"><span class="comment">TMR1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else if(CCP1IF==1)//判断是不是由CCP1引起的中断</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1IF_TriggerFlag^=1;//标志位取反</span></span><br><span class="line"><span class="comment">if(CCP1IF_TriggerFlag==1)//第一次捕捉到跳变</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;//清除定时器0计数寄存器值</span></span><br><span class="line"><span class="comment">TMR1L=0;</span></span><br><span class="line"><span class="comment">TMR1ON=1;//定时器1开始计时</span></span><br><span class="line"><span class="comment">CCP1IF=0;//清除中断标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else//第二次捕捉到跳变</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CCP1_LowByte=CCPR1L+31;//校准值</span></span><br><span class="line"><span class="comment">CCP1_HighByte=CCPR1H+CARRY;//加上进位标志位</span></span><br><span class="line"><span class="comment">Over_Counter=Over_Counter_temp;//将计数溢出暂存值赋值给显示值</span></span><br><span class="line"><span class="comment">data_filter();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Over_Counter_temp=0;//清除计数溢出暂存值</span></span><br><span class="line"><span class="comment">TMR1H=0;//清除定时器0计数寄存器值</span></span><br><span class="line"><span class="comment">TMR1L=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">LCD1602_WriteCommand(0x80);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[0]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[0]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[1]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[1]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[2]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[2]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData('H');</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TMR1ON=0;//定时器1停止计时</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*PWM,输出比较配置</span></span><br><span class="line"><span class="comment">T2CON=0;PR2=25;TMR2=0;//TMR2初始化，周期26us</span></span><br><span class="line"><span class="comment">CCP2CON=0X0C;</span></span><br><span class="line"><span class="comment">CCPR2L=13;//CCP2初始化，脉宽13us</span></span><br><span class="line"><span class="comment">T1CON=0;//设置预分频比为 = 1:1,开中断</span></span><br><span class="line"><span class="comment">data_cnt = 0x09;//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line"><span class="comment">CCP1CON = 0X08;//CCP1设为匹配时令CCP1/RC2引脚输出电平不变</span></span><br><span class="line"><span class="comment">TMR1ON=1;//启动TMR1</span></span><br><span class="line"><span class="comment">measure_Flag=1;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(measure_Flag == <span class="number">0</span>)<span class="comment">//将测量值发送(PWM(CCP2),输出比较(CCP1))</span></span><br><span class="line">{</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCP1M0==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RC7=<span class="number">0</span>;</span><br><span class="line">CCP2CON=<span class="number">0x00</span>;</span><br><span class="line">data_cnt--;<span class="comment">//低电平。二进制代码位数减1</span></span><br><span class="line"><span class="keyword">if</span>(data_cnt == <span class="number">0</span>){<span class="keyword">goto</span> period_delty;} <span class="comment">//位数为0，全部发送完，转624us延时</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"rlf _data,f"</span>);<span class="comment">//未发送完，取下一位待发送数据（数据移入CARRY中）</span></span><br><span class="line"><span class="keyword">if</span>(CARRY == <span class="number">1</span>) <span class="keyword">goto</span> data_5eh;<span class="comment">//待发送数据=1</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X04</span>;<span class="comment">//待发送数据=0,叠加低电平时长68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">data_5eh:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X18</span>;<span class="comment">//待发送数据=1,叠加低电平时长138H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">4</span>;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">period_delty:</span><br><span class="line">Send_Counter++;</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0XC0</span>;<span class="comment">//叠加624us的延时参数270H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">9</span>;<span class="comment">//高位字节加2及低位叠加时的进位和</span></span><br><span class="line">data=<span class="number">0B</span>10101001;<span class="comment">//=PORTB //从PORTB取数据</span></span><br><span class="line">data_cnt = <span class="number">9</span>;</span><br><span class="line">ret_fie:</span><br><span class="line">CCP1M0=<span class="number">0</span>;<span class="comment">//下次匹配时输出高电平</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCP2CON=<span class="number">0X0C</span>;</span><br><span class="line">RC7=<span class="number">1</span>;TMR2ON=<span class="number">1</span>;<span class="comment">//同步头时间，启动PWM信号输出</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//叠加同步头的延时参数68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line">CCP1M0=<span class="number">1</span>;<span class="comment">//下次匹配时输出低电平</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Send_Counter &gt;= <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">Send_Counter=<span class="number">0</span>;</span><br><span class="line">measure_Flag = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CCP1IF=0;//CCP标志位清零</span></span><br><span class="line"><span class="comment">TMR1IE=1;//定时器1中断使能</span></span><br><span class="line"><span class="comment">TMR1IF=0;//定时器1中断标志位清零</span></span><br><span class="line"><span class="comment">T1CON=0B00000000;//TMR1为定时器，预分频比1:1,不启动定时器1</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//使能CCP1捕捉每一个输入信号的上升沿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">TMR1ON=<span class="number">0</span>;<span class="comment">//关闭定时器1</span></span><br><span class="line">CCP2CON=<span class="number">0X00</span>;<span class="comment">//关闭PWM</span></span><br><span class="line">CCP1CON=<span class="number">0X00</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Send_Counter=<span class="number">0</span>;</span><br><span class="line">nRBPU=<span class="number">0</span>;<span class="comment">//启用RB弱上拉</span></span><br><span class="line">TRISB=<span class="number">0xFF</span>;<span class="comment">//作输入口</span></span><br><span class="line">TRISC7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;<span class="comment">//PWM信号（载波）输出引脚</span></span><br><span class="line">TRISC2=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">TRISD=<span class="number">0X00</span>;<span class="comment">//数据口</span></span><br><span class="line">    TRISA=<span class="number">0x00</span>;<span class="comment">//RA0配置为输出模式</span></span><br><span class="line">ADCON1=<span class="number">0X07</span>;<span class="comment">//RA端口与AD转换有关！！！，不然无法正常显示LCD1602 </span></span><br><span class="line">LCD1602_Init();</span><br><span class="line">LCD1602_WriteString(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CCP中断配置*/</span></span><br><span class="line">GIE=<span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">PEIE=<span class="number">1</span>;<span class="comment">//第二梯队中断打开</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;<span class="comment">//CCP中断打开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*周期测量</span></span><br><span class="line"><span class="comment">CCP1IF=0;//CCP标志位清零</span></span><br><span class="line"><span class="comment">TMR1IE=1;//定时器1中断使能</span></span><br><span class="line"><span class="comment">TMR1IF=0;//定时器1中断标志位清零</span></span><br><span class="line"><span class="comment">T1CON=0B00000000;//TMR1为定时器，预分频比1:1,不启动定时器1</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//使能CCP1捕捉每一个输入信号的上升沿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">T2CON=<span class="number">0</span>;PR2=<span class="number">25</span>;TMR2=<span class="number">0</span>;<span class="comment">//TMR2初始化，周期26us</span></span><br><span class="line">CCP2CON=<span class="number">0X0C</span>;</span><br><span class="line">CCPR2L=<span class="number">13</span>;<span class="comment">//CCP2初始化，脉宽13us</span></span><br><span class="line">T1CON=<span class="number">0</span>;<span class="comment">//设置预分频比为 = 1:1,开中断</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;<span class="comment">//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line">CCP1CON = <span class="number">0X08</span>;<span class="comment">//CCP1设为匹配时令CCP1/RC2引脚输出电平不变</span></span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//启动TMR1</span></span><br><span class="line"></span><br><span class="line">data = PORTB;<span class="comment">//=PORTB;从PORTB取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="猜测同步头的宽窄导致信号处理出现错误数据"><a class="markdownIt-Anchor" href="#猜测同步头的宽窄导致信号处理出现错误数据"></a> 猜测：同步头的宽窄，导致信号处理出现错误数据</h2><img src="/posts/29338/image-20240514130203460.png" class="" title="image-20240514130203460"><p><strong>解决方案：<mark>调整同步头宽度。每Byte数据需要等待一定的时间</mark></strong></p><h2 id="仿真测试结果没有完整移入数据实际上只接收到了7位"><a class="markdownIt-Anchor" href="#仿真测试结果没有完整移入数据实际上只接收到了7位"></a> 仿真测试结果：没有完整移入数据，实际上只接收到了7位</h2><img src="/posts/29338/image-20240514160814051.png" class="" title="image-20240514160814051"><p><strong>更改输入捕获中断内对各个二进制捕获的电平时间范围，使得红外解调的容允值更大，修改后，代码如下</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data_RecByte;</span><br><span class="line"><span class="type">int</span> Time_Data;</span><br><span class="line">bit Data_RecFlag;</span><br><span class="line"><span class="type">char</span> i;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> TABLE[<span class="number">16</span>]={<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>,<span class="number">0x46</span>};</span><br><span class="line">bit Start_Flag;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">5</span>];</span><br><span class="line">}T_Data_Rec;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//PORTD^=0xFF;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)//本次捕捉下降沿</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;</span></span><br><span class="line"><span class="comment">CCP1IF=0; Time_Data = CCPR1H &lt;&lt; 8 | CCPR1L;</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 400  &amp;&amp; Time_Data&lt; 500){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//55</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 800  &amp;&amp; Time_Data&lt; 1000){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//263</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 2300  &amp;&amp; Time_Data&lt; 2600){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line"><span class="comment">if(Time_Data &gt; 2900 ){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次捕捉下降沿</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;<span class="comment">//清零TMR1寄存器值</span></span><br><span class="line">CCP1CON=<span class="number">0X05</span>;<span class="comment">//下一次捕捉上升沿</span></span><br><span class="line">CCP1IF=<span class="number">0</span>;<span class="comment">//清除输入捕捉标志位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//本次捕捉上升沿</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//下一次捕捉下降沿</span></span><br><span class="line">CCP1IF=<span class="number">0</span>;Time_Data = CCPR1H &lt;&lt; <span class="number">8</span> | CCPR1L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;<span class="number">3200</span>){Start_Flag=<span class="number">1</span>;}  <span class="comment">//开始信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Flag)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">400</span>  &amp;&amp; Time_Data &lt;= <span class="number">500</span>){Data_RecByte=Data_RecByte&lt;&lt;<span class="number">1</span>;}<span class="comment">//0'068</span></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">800</span>  &amp;&amp; Time_Data&lt;= <span class="number">1200</span>){Data_RecByte=Data_RecByte&lt;&lt;<span class="number">1</span>;Data_RecByte=Data_RecByte+<span class="number">1</span>;} <span class="comment">//'1'</span></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">2200</span>  &amp;&amp; Time_Data&lt;= <span class="number">2500</span>){T_Data_Rec.Data[i++] = Data_RecByte;Start_Flag=<span class="number">0</span>;}  <span class="comment">//结束信号</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">{</span><br><span class="line">LCD1602_WriteNum(<span class="number">2</span>,<span class="number">0</span>,Time_Data,<span class="number">5</span>);</span><br><span class="line">LCD1602_WriteCommand(<span class="number">0x80</span>);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">0</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">0</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">1</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">1</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">2</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">2</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">3</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">3</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">4</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">4</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(<span class="string">'H'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>最终结果：实现了连续5Byte数据的接收</strong></p><img src="/posts/29338/image-20240514160944486.png" class="" title="image-20240514160944486"><h1 id="自定义通信协议"><a class="markdownIt-Anchor" href="#自定义通信协议"></a> 自定义通信协议</h1><p><strong><mark>在完整的红外传输系统工作在稳定可靠的状态后，我们可以拓展一些功能，如自己定义一个红外传输协议，使得单片机之间的红外通信能够实现更加复杂的功能，一次性能够传输更多的数据。</mark></strong></p><ul><li><p>添加一个起始位，长度位结束位的两倍</p></li><li><p>修改全部所有数据位对应的电平宽度，增加各自的比例。</p><ul><li>起始位：0xC30</li><li>‘0’: 0x204</li><li>‘1’:0x418</li><li>结束位:0x9C0</li></ul></li><li><p>修改同步头宽度，因为在实际使用红外通信时，单片机产生的红外信号可能没有那么理想，红外发射头发送出去的信号会衰减，因此我们可以适当增加同步头宽度，提高红外调制信号的“功率”，使得红外接收头能够正常接收到红外信号</p></li></ul><h1 id="周期信号测量红外收发系统"><a class="markdownIt-Anchor" href="#周期信号测量红外收发系统"></a> 周期信号测量+红外收发系统</h1><img src="/posts/29338/image-20240519165157774.png" class="" title="image-20240519165157774"><h1 id="红外双发双收双工系统"><a class="markdownIt-Anchor" href="#红外双发双收双工系统"></a> 红外双发双收（双工系统）</h1><img src="/posts/29338/image-20240519170223726.png" class="" title="image-20240519170223726"><h1 id="红外双工中继基站系统"><a class="markdownIt-Anchor" href="#红外双工中继基站系统"></a> 红外双工+中继基站系统</h1><p><strong><mark>如图所示，红外收发装置通过中继系统进行数据通信</mark></strong></p><img src="/posts/29338/image-20240519173118590.png" class="" title="image-20240519173118590"><h1 id="心得体会"><a class="markdownIt-Anchor" href="#心得体会"></a> 心得体会</h1><p>我在本次小组任务中，首先学习了红外通信系统的基本组成结构，了解了通信系统中调制/解调的原理以及实现方法。基于对第九章各个例子以及习题的学习以及编写相关代码，我熟悉了CCP模块的输入捕获、输出比较、PWM模式的工作原理。通过将这些模块组合，协同工作，在代码中利用定义的各个“标志位"，配置好了这些CCP各个功能模块协同工作的代码结构。</p><p>在准备进行本次小组任务的工作前，我们首先大概预览了一下本次小组任务需要用到的知识点，因为整个红外通信系统的构成需要多个单片机协同工作，所以必须要循循渐进地进行代码的编写、调试、验证。为了设计出最终包含红外双工通信+中继器的复杂系统，我们首先编写完成了一个简易的红外通信系统，不过这个系统的信号发送端发送的是基带信号，没有经过红外管，直接送给接收端单片机进行信号的解调。虽然我们在发送端设置好了各个不同数据位的电平宽度，比如’0‘，’1‘，’停止位‘的电平宽度有按照一定的比例用于区分，但课本上一开始给的例子，各个数据位电平宽度仅仅在微妙级，不管是仿真还是实物验证接收端都有可能无法解调出正确的信号，因为这些数据位的电平宽度太短，没有明显的区分度，一旦程序运行效率不行或者单片机电路上的微小延迟都有可能造成数据读取的错误。因此，我们等比例放大了每个数据位的电平宽度，以及同步头的宽度（保证调制信号的功率）。这样的话，不同bit的区分度就大大提高了。然后，我们自己再编写一段调试代码，即接收到任意的上边沿+下边沿的输入捕获，输出端改为固定指定的数据位发送，然后在接收端那边通过LCD1602显示实际上捕获到的电平宽度，这样就能知道红外接收端实际容允的电平宽度范围，确保整个红外通信系统的稳定性。</p><p>本次小组任务，更像一个小课程设计，我们设计出了一个功能完备的红外通信系统，在每个阶段的调试过程中，我们遇到了很多的问题，这些问题大多数是由于寄存器的配置引起的（因为单片机中CCP各个模块要协同工作，这就涉及到大量寄存器的状态切换），一旦寄存器配置冲突，而我们又不熟悉寄存器，就无法认识到代码的问题所在。我们通过MPLAB强大轻量化的Debug窗口，以及Proteus的调试功能，反复验证，循序渐进，最终设计出来了一个具备双工通信+中继器（基站）的完备通信系统，并且我们的通信系统可以通过修改代码中的参数实现连续任意位Byte的收发。</p><p>本次小组任务是有挑战性的，但是这也为我们后续学习更多复杂的通信系统打下基础。我们学会了化繁为简，分模块和层次，熟练配置单片机上所有相关功能寄存器的技巧，这不仅是我们单片机编程、电路系统设计技术上的显著提升，也是对理论基础是否扎实的考验。我想，通过本次小组任务，我们可以设计出各种功能强大，效率高的通信系统，利用自身专业编写出完备的通信协议等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; # 前言&lt;/h1&gt;
&lt;h2 id=&quot;一-红外通信系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-红外通信系统&quot;&gt;&lt;/a&gt; 一、红外</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【HEXO】[2] 多线程部署常见问题</title>
    <link href="https://szturin.github.io/posts/45608/"/>
    <id>https://szturin.github.io/posts/45608/</id>
    <published>2024-05-03T05:10:37.000Z</published>
    <updated>2024-05-21T12:12:43.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo更新日志"><a class="markdownIt-Anchor" href="#hexo更新日志"></a> HEXO更新日志</h1><p><strong>2024.5.3</strong></p><ul><li>重要更新：将HEXO博客部署到腾讯云轻量化服务器，极大提升国内访问速度，访问ip地址：<a href="http://122.51.23.7/">Turin’s Blog - 数理照亮世界</a></li><li>优化主页文章卡片界面，参考文章：<a href="https://butterfly.zhheo.com/home.html">首页 | Butterfly主题美化教程 (zhheo.com)</a></li><li>优化网站页面显示效果：透明度。<a href="https://qianchenggit.github.io/2021/10/06/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E4%BD%BF%E7%94%A8%E4%B8%80%E5%9B%BE%E6%B5%81/">博客背景使用一图流 | QianChengGit の小森林</a></li></ul><hr><p>xxxxxxxxxx&nbsp;git remote add [alias] [url]//参数[alias]为别名， [url]为远程仓库的地址bash</p><h1 id="一-hexo部署到云服务器ubuntu系统"><a class="markdownIt-Anchor" href="#一-hexo部署到云服务器ubuntu系统"></a> 一、HEXO部署到云服务器(Ubuntu系统)</h1><p><strong><a href="https://cloud.tencent.com/developer/article/1945550">Hexo部署至服务器（Ubuntu 20.04）-腾讯云开发者社区-腾讯云 (tencent.com)</a></strong></p><p><strong><a href="https://blog.cpen.top/posts/38874.html">04_Hexo-多平台部署-云服务器-GitHub-Gitee | Mycpen</a></strong></p><h1 id="二-ubuntu允许root连接服务器"><a class="markdownIt-Anchor" href="#二-ubuntu允许root连接服务器"></a> 二、Ubuntu允许root连接服务器</h1><p><a href="https://blog.csdn.net/crayon0/article/details/122272001">Linux开启ssh并允许root登录（ubuntu、centos、kalilinux）_ssh允许root远程登录-CSDN博客</a></p><blockquote><p>报错信息 “E45: ‘readonly’ option is set (add ! to override)” 是在使用 Vim 或 Neovim 文本编辑器时可能遇到的一个错误信息。当您尝试将更改写入以只读模式打开的文件时，就会出现这条信息。这种情况可能由几个原因引起，例如，您正在编辑的文件在文件系统级别启用了写保护，或者 Vim 打开了一个它认为不应该修改的文件（例如，系统配置文件或标记为“只读”的文件）。</p><p>要解决这个问题并强制 Vim 或 Neovim 尽管文件处于只读状态也要写入更改，您可以使用 <code>:w!</code> 命令，其中 <code>w</code> 代表“写入”，<code>!</code> 实际上意味着“强制”或“覆盖”。</p><p>下面是如何处理这种情况：</p><h3 id="如果您打算修改文件"><a class="markdownIt-Anchor" href="#如果您打算修改文件"></a> 如果您打算修改文件</h3><ol><li><p><strong>强制保存更改</strong>：如果您知道文件是安全可编辑的，且打算保存更改，可以使用 <code>:w!</code> 命令强制保存更改。这告诉 Vim 覆盖只读限制。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w!</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>更改文件权限</strong>：如果文件是只读的是因为文件系统权限，您可能需要在 Vim 外部更改其权限。例如，在类 Unix 系统（Linux、macOS）上，您可以使用 <code>chmod</code> 命令使文件可写。假设文件名为 <code>example.txt</code>；您可以使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +w example.txt</span><br></pre></td></tr></tbody></table></figure><p>然后，在 Vim 内尝试再次保存文件。</p></li></ol><h3 id="如果文件应保持不变"><a class="markdownIt-Anchor" href="#如果文件应保持不变"></a> 如果文件应保持不变</h3><p>如果文件应该是只读的，且您不小心做了更改或重新考虑了您的编辑，有几个操作您可以执行：</p><ol><li><p><strong>撤销更改</strong>：通过使用 Vim 中的撤销命令 <code>u</code> 手动撤销更改，直到您恢复到文件的原始状态。</p></li><li><p><strong>不保存并退出</strong>：如果您想退出 Vim 而不保存任何更改，可以使用 <code>:q!</code> 命令，它退出 Vim 且不保存。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="理解只读文件"><a class="markdownIt-Anchor" href="#理解只读文件"></a> 理解只读文件</h3><p>在决定覆盖其只读状态之前，了解文件为什么可能处于只读模式是很重要的。文件可以因各种原因而被设置为只读：</p><ul><li>文件可能在文件系统级别被标记为只读，以防止意外更改。</li><li>文件可能属于另一个用户或需要管理员权限才能修改。</li><li>Vim 可能会在检测到文件正在被另一个进程使用时，以只读模式打开文件。</li><li>某些配置或命令（如使用 <code>vim -R &lt;filename&gt;</code> 打开文件）可以指示 Vim 以只读模式打开文件。</li></ul><p>在尝试覆盖文件的只读状态之前，始终确保修改文件是恰当的。</p></blockquote><p><strong>root终端连接效果</strong></p><img src="/posts/45608/image-20240503134748284.png" class="" title="image-20240503134748284"><h2 id="公网ip访问blog网站"><a class="markdownIt-Anchor" href="#公网ip访问blog网站"></a> 公网ip访问Blog网站</h2><img src="/posts/45608/image-20240503135033425.png" class="" title="image-20240503135033425"><p><strong>总结：使用腾讯云服务器（Unbuntu系统）部署Hexo博客，踩雷无数。此次部署博主理解了Linux服务器的详细配置流程，blog网站的访问速度得到了大幅度的提升，免受”科学上网“之苦</strong></p><h1 id="三-问题待解决"><a class="markdownIt-Anchor" href="#三-问题待解决"></a> 三、问题（待解决）</h1><h2 id="一-每次deploy需要输入服务器root密码"><a class="markdownIt-Anchor" href="#一-每次deploy需要输入服务器root密码"></a> 一、每次deploy需要输入服务器root密码</h2><ul><li><p><strong>解决方案：配置SSH公钥</strong></p></li><li><p><strong>参考文章：</strong><a href="https://zhuanlan.zhihu.com/p/549151974">Hexo历险记之八SSH远程链接服务器 - 知乎 (zhihu.com)</a></p></li></ul><p><strong>将git环境下的ssh公钥配置到服务器中的authorized_keys，并且修改sshd_config文件，配置好ssh各项权限</strong></p><img src="/posts/45608/image-20240503153851704.png" class="" title="image-20240503153851704"><p>**最终效果：**免密连接</p><img src="/posts/45608/image-20240503154119191.png" class="" title="image-20240503154119191"><p><strong>PS: 允许不同环境的终端配对的公钥可能不一样，这里使用git bash，要连接的服务器那边就需要使用git bash生成的公钥，才能实现免密登录，这样每次deploy时无需输入密码</strong></p><h2 id="二-blog域名"><a class="markdownIt-Anchor" href="#二-blog域名"></a> 二、Blog域名</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo更新日志&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hexo更新日志&quot;&gt;&lt;/a&gt; HEXO更新日志&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;2024.5.3&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重要更新：将HEXO博客部署到</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="博客搭建" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/categories/Linux/Ubuntu/"/>
    
    
    <category term="HEXO" scheme="https://szturin.github.io/tags/HEXO/"/>
    
    <category term="博客" scheme="https://szturin.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="github" scheme="https://szturin.github.io/tags/github/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/tags/Ubuntu/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【ROS2】“人在回路”---与生成式人工智能交互的视觉医疗机器人</title>
    <link href="https://szturin.github.io/posts/17498/"/>
    <id>https://szturin.github.io/posts/17498/</id>
    <published>2024-04-27T16:39:25.000Z</published>
    <updated>2024-05-18T03:36:16.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人在回路与生成式人工智能交互的视觉服务机器人"><a class="markdownIt-Anchor" href="#人在回路与生成式人工智能交互的视觉服务机器人"></a> “人在回路”—与生成式人工智能交互的视觉服务机器人</h1><p><strong>第一次更新：2024.4.28</strong></p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><ul><li>人在回路（Human-in-the-loop）是一种模式，类似于人机闭环系统或人机互助系统。这种模式被认为是机器学习、人工智能和机器智能的一种可行发展模式，需要人与机器之间的相互作用。在这种模式下，人类始终是模型的一部分，影响着模型的结果，并且需要人类的智能来帮助机器更加智能化。</li><li>ChatGPT是一款强大的基于深度学习的自然语言处理模型，能够生成高质量的自然语言文本。使用ChatGPT+TogetheROS，即ChatRobot将文字描述转化为小车控制指令，根据描述生成特定功能的代码，使机器人按照描述执行相应的任务。–转自NodeHube社区。–转自NobeHube</li></ul><h2 id="项目信息"><a class="markdownIt-Anchor" href="#项目信息"></a> 项目信息：</h2><p><strong>我们的机器人定位为医疗看护机器人（无人车），使用RDK X3 嵌入式AI开发板作为主控，通过Opencv等进行视觉识别，基于类似激光雷达测距的方法实现自主导航运动，满足不同场景下的控制需求。通过ROS2系统使小车与计算机进行通信。</strong></p><p><strong>我们计划使用OpenAI提供的API接口写入小车系统，实现初步的语音交互到控制的过程。基于搭载ROS2系统的RDK X3开发板，使用"人在回路"的模型训练方法，完善机器人行为模型的逻辑，提升机器学习的算法和模型的zhi在后续对GPT接口的开发中，我们设想可以与Chatgpt进行“人在回路”的系统训练，基本实现我们的设想目标。</strong></p><p>基于"人在回路"的模型训练：</p><p><strong>传统的机器人设计，往往是按照设定好的行为逻辑，这种设计过于机械化。而在医疗领域，传统的机器人显然不足以应对以人为核心的服务化需要。所以我们设想，利用“人在回路“的人机闭环互助系统对机器人进行训练，是否可以使得机器人简单地接近于人类的思维模式。应用在医疗服务等领域</strong></p><p><strong>人类能够根据实际情况灵活调整策略和方法，这种能力是当前机器人或人工智能难以完全实现的。通过人在回路，机器人在执行任务时可以依据人类的指示灵活调整其行为和策略，更好地适应复杂多变的环境，这就是我们设计的初步思想，虽然从技术的角度出发还有非常遥远的距离，但是我们可以通过这种方法和思想，逐步完善机器人的基本功能。</strong></p><p><mark><strong>我们将搭载地平线公司的RDK X3作为主控， 配合32位单片机与各类传感器模块进行数据交互，制作一个能够应用于医疗、后勤等领域的复杂多场景的无人车型机器人，能够先实现以下的基本功能：</strong></mark></p><ul><li><p>送药：前期阶段实现小车的所有控制部分，通过Opencv，Openmv组成双摄系统。Opencv负责深度学习相关的视觉识别，Openmv通过SPI协议与单片机进行通信，搭建基础的路径检测控制功能。==实现房号识别，自动药物配送。==中期阶段部署利用Simulink或者Gazebo进行小车的运动仿真。</p></li><li><p>自主导航：通过激光雷达进行SLAM建图，使得机器人具备在不同地环境下进行路径规划避障的功能。</p></li><li><p>语言交互：通过API接口与ChatGPT初步实现计算机的文字交互-&gt;控制小车基本运动-&gt;搭载语音模块控制ChatGPT-&gt;完成更复杂的人机交互系统（图像识别+传感器+语音模块）。</p></li><li><p>环境检测：实现小车上述的基本功能后，进行深度学习相关的视觉开发，使用时下热门的YOLO目标检测算法。能够实现对病人如：跌倒检测（识别人体关节点）等视觉应用。</p></li></ul><h2 id="队伍信息"><a class="markdownIt-Anchor" href="#队伍信息"></a> 队伍信息</h2><p><strong>我们队伍命名为FFT队，FFT即为快速傅立叶变换（Fast Fourier Transform），它是一种算法，在信号处理、图像处理、音频处理等领域广泛使用的技术，在如今5G大规模普及的时代，5G具有mMTC(超大规模机器连接)，eMBB(超低延时)的特点，”物联网“，“边缘计算”，“自动驾驶”等技术得到显著的发展。队伍成员基本为为通信系学生。FFT意为我们队伍追求高效、灵活、准确的开发学习，秉持创新思维、以赛促学的思想，能够将创意与专业知识运用在前沿领域。我们希望基于RDK X3 实现一些基于AI与物联网的idea，利用自身的专业知识，能够在本次项目中通信部分进行着重地设计，提高云平台与机器人的通信效率与可靠性。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人在回路与生成式人工智能交互的视觉服务机器人&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#人在回路与生成式人工智能交互的视觉服务机器人&quot;&gt;&lt;/a&gt; “人在回路”—与生成式人工智能交互的视觉服务机器人&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;第</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="ROS2" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ROS2/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/categories/Linux/"/>
    
    <category term="RDK X3" scheme="https://szturin.github.io/categories/RDK-X3/"/>
    
    <category term="人工智能" scheme="https://szturin.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/categories/Linux/Ubuntu/"/>
    
    <category term="ROS2" scheme="https://szturin.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/ROS2/"/>
    
    
    <category term="ROS2" scheme="https://szturin.github.io/tags/ROS2/"/>
    
    <category term="linux" scheme="https://szturin.github.io/tags/linux/"/>
    
    <category term="操作系统" scheme="https://szturin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="RDK X3" scheme="https://szturin.github.io/tags/RDK-X3/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[软件操作]仿真调试</title>
    <link href="https://szturin.github.io/posts/45531/"/>
    <id>https://szturin.github.io/posts/45531/</id>
    <published>2024-04-27T07:26:45.000Z</published>
    <updated>2024-05-19T07:28:04.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软键盘"><a class="markdownIt-Anchor" href="#软键盘"></a> 软键盘</h1><img src="/posts/45531/image-20240427152809497.png" class="" title="image-20240427152809497"><h1 id="选择使用按键的属性"><a class="markdownIt-Anchor" href="#选择使用按键的属性"></a> 选择使用按键的属性</h1><img src="/posts/45531/image-20240427152840915.png" class="" title="image-20240427152840915">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软键盘&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软键盘&quot;&gt;&lt;/a&gt; 软键盘&lt;/h1&gt;
&lt;img src=&quot;/posts/45531/image-20240427152809497.png&quot; class=&quot;&quot; title=&quot;imag</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MPLAB" scheme="https://szturin.github.io/tags/MPLAB/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[8]AD/DA转换</title>
    <link href="https://szturin.github.io/posts/56223/"/>
    <id>https://szturin.github.io/posts/56223/</id>
    <published>2024-04-23T13:49:05.000Z</published>
    <updated>2024-05-09T11:10:24.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p>xxxxxxxxxx&nbsp;$ tags: -数字电路与VHDL设计"bash</p><p>void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);</p><p><strong>恢复缺省配置</strong></p><p>void ADC_DeInit(ADC_TypeDef* ADCx);</p><p><strong>ADC初始化</strong></p><p>void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>ADC上电</strong></p><p>void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>开启DMA输出信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>中断输出控制</strong></p><p>void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);</p><ul><li>用于控制某个中断能否通往NVIC</li></ul><p><strong>复位校准</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取复位校准状态</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>开始校准</strong></p><p>void ADC_StartCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取开始校准状态</strong></p><p>FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);</p><p><strong>ADC软件触发的函数</strong></p><p>void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>ADC获取软件转换状态</strong></p><p>FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);</p><ul><li><p>实际上是获取CR2的SWSTART这一位,但是SWSTART在开始ADC转换后直接清除，所以并不能通过这个函数获得是否开始转换的信息</p><img src="/posts/56223/image-20240423220300035.png" class="" title="image-20240423220300035"></li></ul><p><strong><mark>如何获取ADC是否开启的状态？</mark></strong></p><p><strong>获取标志位状态</strong></p><p>FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);</p><ul><li>可以调用这个函数,ADC_FLAG选择EOC,判断EOC标志位是否置1</li></ul><p><strong>每隔几个通道间断一次</strong></p><p>void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);</p><p><strong>是否启动间断模式</strong></p><p>void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC规则组通道配置</strong></mark></p><p>void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);</p><ul><li>ADCx</li><li>ADC_Channel：指定的通道</li><li>Rank：序列的位置</li><li>ADC_SampleTime：指定通道的采样时间</li></ul><p><strong>ADC外部触发转换控制（是否允许外部触发转换）</strong></p><p>void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC获取转换值</strong></mark></p><p>uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);</p><ul><li>获取AD转换的数据寄存器，读取转换结果</li></ul><p><strong>ADC获取双模式转换值</strong></p><p>uint32_t ADC_GetDualModeConversionValue(void);</p><p><strong>是否启动模拟看门狗</strong></p><p>void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);</p><p><strong>配置高低阈值</strong></p><p>void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);</p><p><strong>配置看门的通道</strong></p><p>void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);</p><p><strong>ADC温度传感器、内部参考电压控制</strong></p><p>void ADC_TempSensorVrefintCmd(FunctionalState NewState);</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;库函数解释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#库函数解释&quot;&gt;&lt;/a&gt; 库函数解释&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;xxxxxxxxxx&amp;nbsp;$ tags: -数字电路与VHDL设计&quot;bash&lt;/p&gt;
&lt;p&gt;v</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="AD/DA转换" scheme="https://szturin.github.io/tags/AD-DA%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[7]编码器接口测速</title>
    <link href="https://szturin.github.io/posts/37664/"/>
    <id>https://szturin.github.io/posts/37664/</id>
    <published>2024-04-20T14:16:11.000Z</published>
    <updated>2024-05-02T12:05:41.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h2><blockquote><p><strong>定时器编码器配置</strong></p><p>void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,<br>uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);</p><ul><li>TIMx:选择定时器</li><li>TIM_EncoderMode: 选择编码器模式，T1单独计数，T2单独计数，T1/T2同时计数</li></ul><img src="/posts/37664/image-20240420235549817.png" class="" title="image-20240420235549817"><ul><li>TIM_IC1Polarity：电平极性</li><li>TIM_IC2Polarity：电平极性  可以通过配置这两个参数，设置正相和反相</li></ul><img src="/posts/37664/image-20240420235814820.png" class="" title="image-20240420235814820"></blockquote><h2 id="编码器测计数"><a class="markdownIt-Anchor" href="#编码器测计数"></a> 编码器测计数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM3);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">1</span><span class="number">-1</span>;<span class="comment">//PSC 不分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">65536</span> - <span class="number">1</span>;<span class="comment">//ARR </span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line">TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获单元配置*/</span></span><br><span class="line"><span class="comment">/**通道1配置**/</span></span><br><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">    TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="comment">//给结构体赋初始值，防止出现不确定的状态</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发  TIM_EncoderInterfaceConfig重复配置了相同的寄存器</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line">    <span class="comment">/**通道2配置**/</span> <span class="comment">//注意：这里不需要再定义新的结构体。因为上一次的值已经写入硬件寄存器</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_2;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置编码器接口*/</span></span><br><span class="line">    TIM_EncoderInterfaceConfig(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//定时器3 ，T1T2同时使用，极性相同(上升沿/下降沿两个都是有效的)，即为正相</span></span><br><span class="line">    <span class="comment">//若要反相，那么一个配置位上升沿，一个配置为下降沿有效</span></span><br><span class="line">TIM_Cmd(TIM3,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//int16_t 表示有符号数，能把unint16_相比最高位变为了符号位,这里利用到了补码的特性</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> TIM_GetCounter(TIM3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="编码器测速"><a class="markdownIt-Anchor" href="#编码器测速"></a> 编码器测速</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关库函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#相关库函数&quot;&gt;&lt;/a&gt; 相关库函数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定时器编码器配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void TIM_EncoderI</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="输入捕获" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/"/>
    
    <category term="输出比较" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】方波发生器-电子琴</title>
    <link href="https://szturin.github.io/posts/46544/"/>
    <id>https://szturin.github.io/posts/46544/</id>
    <published>2024-04-16T10:23:27.000Z</published>
    <updated>2024-05-22T07:52:59.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何得到精准的250us定时"><a class="markdownIt-Anchor" href="#如何得到精准的250us定时"></a> 如何得到精准的250us定时？</h1><p><strong>先确认大概的定时器计数器值，再利用跑马表调整误差</strong></p><img src="/posts/46544/image-20240416182439723.png" class="" title="image-20240416182439723">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何得到精准的250us定时&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何得到精准的250us定时&quot;&gt;&lt;/a&gt; 如何得到精准的250us定时？&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;先确认大概的定时器计数器值，再利用跑马表调整误差&lt;/s</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="项目设计学习" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MPLAB" scheme="https://szturin.github.io/tags/MPLAB/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[软件操作]-跑马表</title>
    <link href="https://szturin.github.io/posts/15341/"/>
    <id>https://szturin.github.io/posts/15341/</id>
    <published>2024-04-05T07:21:38.000Z</published>
    <updated>2024-05-02T11:57:14.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何打开stop-watch窗口"><a class="markdownIt-Anchor" href="#如何打开stop-watch窗口"></a> 如何打开Stop Watch窗口？</h1><blockquote><p><strong>在DEBUG下选mplab sim后，再点DEBUGSETTING来设好频率，设好后点stopwatch</strong></p></blockquote><h1 id="跑马表仿真测试"><a class="markdownIt-Anchor" href="#跑马表仿真测试"></a> 跑马表仿真测试</h1><p><mark>在中断<strong>对应</strong>的位置打上断点，点击仿真运行，即可通过跑马表查看每次进中断的运行时间</mark></p><img src="/posts/15341/image-20240405155601030.png" class="" title="image-20240405155601030"><h1 id="车辆里程表"><a class="markdownIt-Anchor" href="#车辆里程表"></a> 车辆里程表</h1><h2 id="proteus仿真"><a class="markdownIt-Anchor" href="#proteus仿真"></a> proteus仿真</h2><p><mark>可以通过工具栏<strong>调试</strong>选项</mark>，查看各个所需的调试窗口，运行调试工具。</p><p>ps:<strong>step into</strong>可以跳过断点</p><img src="/posts/15341/image-20240405170845407.png" class="" title="image-20240405170845407"><p>第二次进中断，LED灯点亮</p><img src="/posts/15341/image-20240405171351683.png" class="" title="image-20240405171351683"><p>ps:<strong>cof为仿真文件,hex为下载文件</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何打开stop-watch窗口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何打开stop-watch窗口&quot;&gt;&lt;/a&gt; 如何打开Stop Watch窗口？&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在DEBUG下选</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MPLAB" scheme="https://szturin.github.io/tags/MPLAB/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[2]中断系统</title>
    <link href="https://szturin.github.io/posts/18816/"/>
    <id>https://szturin.github.io/posts/18816/</id>
    <published>2024-03-27T13:27:47.000Z</published>
    <updated>2024-05-10T05:21:04.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="保护现场"><a class="markdownIt-Anchor" href="#保护现场"></a> 保护现场</h2><img src="/posts/18816/image-20240327212904491.png" class="" title="image-20240327212904491">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;保护现场&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#保护现场&quot;&gt;&lt;/a&gt; 保护现场&lt;/h2&gt;
&lt;img src=&quot;/posts/18816/image-20240327212904491.png&quot; class=&quot;&quot; title=&quot;i</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
</feed>
