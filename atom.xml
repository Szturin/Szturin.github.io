<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Turin&#39;s Blog</title>
  
  <subtitle>数理照亮世界</subtitle>
  <link href="https://szturin.github.io/atom.xml" rel="self"/>
  
  <link href="https://szturin.github.io/"/>
  <updated>2024-10-29T08:05:28.755Z</updated>
  <id>https://szturin.github.io/</id>
  
  <author>
    <name>Szturin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【stm32单片机】[操作系统][RT-Thread][1]内核与线程</title>
    <link href="https://szturin.github.io/posts/64776/"/>
    <id>https://szturin.github.io/posts/64776/</id>
    <published>2024-10-16T14:17:26.000Z</published>
    <updated>2024-10-29T08:05:28.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="裸机开发与操作系统的区别"><a class="markdownIt-Anchor" href="#裸机开发与操作系统的区别"></a> 裸机开发与操作系统的区别</h1><h2 id="裸机开发"><a class="markdownIt-Anchor" href="#裸机开发"></a> 裸机开发</h2><ul><li>单一任务（阻塞式）</li><li>手动分配资源</li><li>缺乏抽象层</li><li>灵活性、实时性较高</li></ul><h2 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h2><ul><li>多任务调度</li><li>自动资源管理</li><li>硬件抽象层</li></ul><h1 id="rt-thread的线程"><a class="markdownIt-Anchor" href="#rt-thread的线程"></a> RT-Thread的线程</h1><h2 id="线程的概念"><a class="markdownIt-Anchor" href="#线程的概念"></a> 线程的概念</h2><p>在RT-thread中，线程是最小的工作单元。每个线程负责一个任务。RT-Thread根据线程的优先级决定哪个任务先完成.。</p><p>RT-Thread 支持多达 256 个优先级。0是最高的优先级。</p><h2 id="线程的组成部分"><a class="markdownIt-Anchor" href="#线程的组成部分"></a> 线程的组成部分</h2><ol><li>线程控制块：线程的名字，线程要执行的任务，线程的优先级，线程的状态</li><li>线程栈：保存临时数据</li><li>入口函数：线程的任务内容</li></ol><h2 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h2><p>线程有五种工作状态：</p><ol><li>初始状态：线程创建还未使用</li><li>就绪状态：线程准备好，但是没有拿到资源</li><li>运行状态：线程正在执行任务，占用CPU</li><li>挂起状态：线程暂时停止工作</li><li>关闭状态：线程的任务完成了，线程结束，不再使用</li></ol><h2 id="线程的优先级"><a class="markdownIt-Anchor" href="#线程的优先级"></a> 线程的优先级</h2><p>RT-Thread支持256个优先级</p><h2 id="时间片"><a class="markdownIt-Anchor" href="#时间片"></a> 时间片</h2><p>时间片是线程允许工作的时间。如果多个线程的优先级相同，则根据”时间片“，执行完任务A后再执行任务B，轮询进行。</p><h1 id="rt-thread工程"><a class="markdownIt-Anchor" href="#rt-thread工程"></a> RT-Thread工程</h1><h2 id="rt-thread项目创建"><a class="markdownIt-Anchor" href="#rt-thread项目创建"></a> RT-Thread项目创建</h2><img src="/posts/64776/image-20241017014526806.png" class="" title="image-20241017014526806"><p>RT-Thread工程创建完毕，硬件底层还没有初始化，需要我们自己进行配置</p><p>点击CubeMX_Setting进行联调</p><img src="/posts/64776/image-20241017014950565.png" class="" title="image-20241017014950565"><p>CubeMX完成RCC、时钟树、串口、工程选项等关键配置后，生成代码，关闭CubeMX</p><p>在RT-Thread Studio中生成了CubemxI相关文件</p><p>进行编译后，出现一个小bug</p><img src="/posts/64776/image-20241017020104564.png" class="" title="image-20241017020104564"><p>这个时候，需要我们将API更换掉</p><p>对cubemx文件夹下的main.c进行分析，发现被进行了弱定义</p><img src="/posts/64776/image-20241017020406174.png" class="" title="image-20241017020406174"><p>转到RT-thread重定义的main.c</p><p>结论：RT-Thread对Hal库进行了硬件层的抽象</p><img src="/posts/64776/image-20241017020503940.png" class="" title="image-20241017020503940"><p>RT-Thread初始化默认集成了Shell</p><img src="/posts/64776/image-20241017021855733.png" class="" title="image-20241017021855733"><h2 id="创建线程"><a class="markdownIt-Anchor" href="#创建线程"></a> 创建线程</h2><p>函数API</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> (*entry)(<span class="type">void</span> *parameter),</span></span><br><span class="line"><span class="params">                             <span class="type">void</span>       *parameter,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint8_t</span>  priority,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint32_t</span> tick)</span></span><br></pre></td></tr></tbody></table></figure><p>程序实现</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建线程*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义入口函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span>  *parameter)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        rt_kprintf(<span class="string">"Thread1 is running, count:%d\n"</span>,count);</span><br><span class="line">        count++;</span><br><span class="line">        rt_thread_delay(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*创建线程1*/</span></span><br><span class="line">    <span class="comment">//tid为线程id，线程名称为thread1,入口函数为thread1_entry，入口参数为RT_NULL即无入口参数</span></span><br><span class="line">    <span class="comment">//堆栈空间设置为1024</span></span><br><span class="line">    <span class="comment">//优先级为20</span></span><br><span class="line">    <span class="comment">//时间片为10</span></span><br><span class="line">    tid1 = rt_thread_create(<span class="string">"thread1"</span>,</span><br><span class="line">                             thread1_entry,RT_NULL,</span><br><span class="line">                             <span class="number">1024</span>,<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*启动线程*/</span></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL){<span class="comment">//判断身份id是否为空</span></span><br><span class="line">        rt_thread_startup(tid1);<span class="comment">//激活线程</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>编译后烧写</p><p>实验结果：线程在循环运行</p><img src="/posts/64776/image-20241017023340933.png" class="" title="image-20241017023340933"><blockquote><p>rt_thread_delay()的作用：</p><ul><li>休眠当前进程，释放CPU资源</li><li>将任务挂起</li></ul><p>rt_thread_delay(1000)即任务以1000ms周期运行</p><p>注意：</p><ul><li>时间片是允许运行的时间</li><li>rt_thread_delay作用是运行的周期，并且是非阻塞的。</li></ul></blockquote><p>多线程创建</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建线程*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid1 = RT_NULL;<span class="comment">//储存线程信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid2 = RT_NULL;<span class="comment">//储存线程信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程1入口函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span>  *parameter)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        rt_kprintf(<span class="string">"Thread1 is running, count:%d\n"</span>,count);</span><br><span class="line">        count++;</span><br><span class="line">        rt_thread_delay(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*线程2入口函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span>  *parameter)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        rt_kprintf(<span class="string">"Thread2 is running, count:%d\n"</span>,count);</span><br><span class="line">        count++;</span><br><span class="line">        rt_thread_delay(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*创建线程1*/</span></span><br><span class="line">    tid1 = rt_thread_create(<span class="string">"thread1"</span>,</span><br><span class="line">                             thread1_entry,RT_NULL,</span><br><span class="line">                             <span class="number">1024</span>,<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建线程1*/</span></span><br><span class="line">    tid2 = rt_thread_create(<span class="string">"thread2"</span>,</span><br><span class="line">                             thread2_entry,RT_NULL,</span><br><span class="line">                             <span class="number">1024</span>,<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*启动线程*/</span></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL){rt_thread_startup(tid1);}<span class="comment">//线程1不为空，激活线程</span></span><br><span class="line">    <span class="keyword">if</span>(tid2 != RT_NULL){rt_thread_startup(tid2);}<span class="comment">//线程2不为空，激活线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;裸机开发与操作系统的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#裸机开发与操作系统的区别&quot;&gt;&lt;/a&gt; 裸机开发与操作系统的区别&lt;/h1&gt;
&lt;h2 id=&quot;裸机开发&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】-Hal库-嵌入式-6-PWM、输入捕获</title>
    <link href="https://szturin.github.io/posts/12030/"/>
    <id>https://szturin.github.io/posts/12030/</id>
    <published>2024-10-15T13:54:15.000Z</published>
    <updated>2024-10-29T08:06:01.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="按键状态机与回调函数的封装思想"><a class="markdownIt-Anchor" href="#按键状态机与回调函数的封装思想"></a> # 按键状态机与回调函数的封装思想</h1><h1 id="一-pwm配置"><a class="markdownIt-Anchor" href="#一-pwm配置"></a> 一、PWM配置</h1><blockquote><p>生成频率为1000HZ的PWM信号，占空比可调</p></blockquote><h2 id="1-cubemx配置"><a class="markdownIt-Anchor" href="#1-cubemx配置"></a> 1. CubeMX配置</h2><ul><li>选择Internal(内部时钟)</li></ul><img src="/posts/12030/image-20241015222342274.png" class="" title="image-20241015222342274"><p>根据CubeMX的芯片引脚图，选中引脚后的相关外设提示，可以便捷的配置定时器的作用通道</p><img src="/posts/12030/image-20241015222740979.png" class="" title="image-20241015222216707"><p>定时器PWM相关配置项</p><p>这里50有误，应该改为500——&gt;对应50%的占空比</p><img src="/posts/12030/image-20241015223259551.png" class="" title="image-20241015223259551"><h1 id="二-输入捕获"><a class="markdownIt-Anchor" href="#二-输入捕获"></a> 二、输入捕获</h1><h2 id="1-cubemx配置-2"><a class="markdownIt-Anchor" href="#1-cubemx配置-2"></a> 1. CubeMX配置</h2><img src="/posts/12030/image-20241015230019438.png" class="" title="image-20241015230019438"><p><strong>Slave Mode</strong>: Reset Mode</p><ul><li><p><strong>从模式 (Slave Mode)</strong>：在定时器中，“Slave Mode” 是指定时器可以被外部信号触发或由另一个定时器控制。定时器可以通过外部输入或其他定时器的输出信号来复位、启动或停止。</p></li><li><p><strong>Reset Mode</strong>：在从模式的复位模式下，每当触发事件发生时，定时器的计数器（CNT寄存器）会被重置。这对于需要周期性重置定时器的应用很有用。</p></li></ul><p><strong>Trigger Source</strong>: TI1FP1</p><ul><li><strong>触发源 (Trigger Source)</strong>：TI1FP1 通常表示 “Timer Input 1 Filtered Pin 1”，即定时器通道1的输入引脚（TI1）的滤波信号。这个触发源指示定时器使用来自外部引脚的输入信号作为触发源。</li><li>TI1FP1 作为触发源意味着定时器的操作（如复位）将根据 TI1 引脚接收到的信号进行控制。</li></ul><p><strong>Clock Source</strong>: Internal Clock</p><ul><li><p><strong>时钟源 (Clock Source)</strong>：内部时钟意味着定时器使用微控制器内部的时钟源作为定时器的时间基准。通常，内部时钟是处理器的时钟或系统时钟（如 <code>HCLK</code> 或 <code>PCLK</code>）。</p></li><li><p>使用内部时钟意味着定时器的计数将基于微控制器的时钟频率进行递增，直到外部触发信号（例如 TI1FP1）复位它。</p></li></ul><p><strong>Channel1</strong>: Input Capture direct mode</p><ul><li><p><strong>通道1 (Channel 1)</strong>：配置为输入捕获模式意味着定时器的通道1正在监视一个外部信号（通过 TI1 引脚），并在检测到信号变化（如上升沿或下降沿）时捕获当前计数器值。</p></li><li><p><strong>Direct mode</strong>：直通模式表示信号直接进入输入捕获模块，而<mark>没有通过滤波器或其他复杂处理</mark>。这通常用于<mark>快速响应</mark>的<mark>输入捕获</mark>操作。</p></li></ul><blockquote><p>思考：为什么输入捕获要设置为从模式？</p></blockquote><img src="/posts/12030/image-20241015230241742.png" class="" title="image-20241015230241742"><img src="/posts/12030/image-20241016190503917.png" class="" title="image-20241016190503917"><p>DMA转运TIM通道1数据</p><img src="/posts/12030/image-20241015230459480.png" class="" title="image-20241015230459480"><p>继续配置PA15</p><img src="/posts/12030/image-20241015230709867.png" class="" title="image-20241015230709867"><blockquote><p>问题：通过输入捕获测出来频率可能为4000</p><p>解决方法：使用不同的定时器通道进行输入捕获</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;按键状态机与回调函数的封装思想&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#按键状态机与回调函数的封装思想&quot;&gt;&lt;/a&gt; # 按键状态机与回调函数的封装思想&lt;/h1&gt;
&lt;h1 id=&quot;一-pwm配置&quot;&gt;&lt;a class=&quot;markdow</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][5]IIC,RTC</title>
    <link href="https://szturin.github.io/posts/27956/"/>
    <id>https://szturin.github.io/posts/27956/</id>
    <published>2024-10-07T15:40:59.000Z</published>
    <updated>2024-10-29T08:05:57.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iic模块"><a class="markdownIt-Anchor" href="#iic模块"></a> IIC模块</h1><h2 id="一-mcp4017"><a class="markdownIt-Anchor" href="#一-mcp4017"></a> 一、MCP4017</h2><p>MCP4017 是一款由 Microchip Technology 公司生产的数字电位器。它是一种电子元件，通常用于调整电压、增益或信号强度，类似于传统的机械电位器，但可以通过数字控制来调节。</p><p>以下是 MCP4017 的一些主要特点：</p><ol><li><strong>数字电位器</strong>：MCP4017 是一个单通道的 7 位数字电位器，分辨率为 128 个不同的电阻值（2^7 = 128 步）。</li><li><strong>I²C 接口</strong>：它使用 I²C 通信协议进行控制，通过两个引脚（SCL 和 SDA）与主设备通信。I²C 是一种广泛使用的双线通信协议，适合用于低速设备。</li><li><strong>低功耗</strong>：MCP4017 设计为低功耗设备，适合需要节能的应用场景。</li><li><strong>电阻范围</strong>：MCP4017 提供了不同的电阻范围，常见的型号包括 5kΩ、10kΩ、50kΩ 和 100kΩ 等。用户可以通过 I²C 指令在这些范围内调节电阻值。</li><li><strong>非易失性存储器</strong>：该器件不带非易失性存储器（EEPROM），因此每次上电后，电位器的默认设置是中间值（即 64/128 的位置）。</li><li><strong>应用场景</strong>：MCP4017 常用于音频调节、信号处理、传感器校准等需要精确调节电阻的场合。</li></ol><h2 id="二-阅读芯片手册"><a class="markdownIt-Anchor" href="#二-阅读芯片手册"></a> 二、阅读芯片手册</h2><p>I2C地址：0101111</p><img src="/posts/27956/image-20241007234812331.png" class="" title="image-20241007234812331"><h2 id="三-hal库api"><a class="markdownIt-Anchor" href="#三-hal库api"></a> 三、Hal库API</h2><h2 id="四-cubemx配置"><a class="markdownIt-Anchor" href="#四-cubemx配置"></a> 四、CubeMX配置</h2><blockquote><h2 id="rtc"><a class="markdownIt-Anchor" href="#rtc"></a> RTC :</h2><p>STM32 的 <strong>RTC</strong>（实时时钟）是集成在 STM32 微控制器中的一个外设，用于保持时间和日期信息，即使在主系统电源断电时也能继续工作。STM32 的 RTC 是独立的、低功耗的，可以通过外部备用电源（如纽扣电池）或内置备用电源来运行。</p><h3 id="stm32-rtc-的主要功能"><a class="markdownIt-Anchor" href="#stm32-rtc-的主要功能"></a> STM32 RTC 的主要功能：</h3><ol><li><strong>实时时钟</strong>：提供年、月、日、星期、小时、分钟、秒的时间和日期计时功能。</li><li><strong>闹钟功能</strong>：STM32 的 RTC 可以设置定时闹钟，在指定时间触发事件，常用于定时唤醒或触发任务。</li><li><strong>时间戳</strong>：能够记录事件发生时的精确时间，例如在外部中断或特定事件发生时。</li><li><strong>周期性唤醒</strong>：RTC 支持通过定时唤醒系统进入低功耗模式，如待机模式或休眠模式，帮助实现低功耗设计。</li><li><strong>低功耗</strong>：RTC 在超低功耗模式下运行，可以使用独立的低速时钟源（如 LSE，外部 32.768 kHz 晶振）或内部低速时钟（LSI）。</li></ol><h3 id="rtc-的时钟源"><a class="markdownIt-Anchor" href="#rtc-的时钟源"></a> RTC 的时钟源</h3><p>STM32 的 RTC 通常依赖于一个低速的时钟源来保持准确的时间。常见的时钟源有：</p><ul><li><strong>LSE (Low-Speed External)</strong>：外部 32.768 kHz 晶振，精度高，适合精确计时。</li><li><strong>LSI (Low-Speed Internal)</strong>：内部低速 RC 振荡器，功耗低，但精度较差。</li></ul><h3 id="常见应用场景"><a class="markdownIt-Anchor" href="#常见应用场景"></a> 常见应用场景：</h3><ul><li><strong>电子钟表、日历</strong>：嵌入式系统中经常需要长时间保持准确时间的设备。</li><li><strong>低功耗设计</strong>：通过 RTC 实现系统定时唤醒和进入低功耗模式，节省电池能量。</li><li><strong>时间戳记录</strong>：在数据记录系统或日志系统中，RTC 用于标记数据生成的时间。</li></ul></blockquote><h3 id="配置rtc"><a class="markdownIt-Anchor" href="#配置rtc"></a> 配置RTC</h3><img src="/posts/27956/image-20241008003141122.png" class="" title="image-20241008003141122"><ul><li>Activate Clock Source：激活时钟源</li><li>Activate Calendar：激活日历</li></ul><h3 id="配置时钟树"><a class="markdownIt-Anchor" href="#配置时钟树"></a> 配置时钟树</h3><img src="/posts/27956/image-20241008003433105.png" class="" title="image-20241008003433105"><img src="/posts/27956/image-20241008003518489.png" class="" title="image-20241008003518489"><p>Asynchronous Predivider和Synchronous Predivider是用来分频的两个寄存器，RTC的时钟源（LSE、LSI或HSE/32）需要经过这些分频器后，才能提供给RTC时钟</p><ul><li>Asynchronous Predivider value：异步预分器值，125，通常用于降低功耗，</li><li>Synchronous Predivider value：同步预分频器值，6000，用于精确调节RTC的计时</li></ul><p>6000 x 125 = 750KHz，速度最快，精度最高</p><img src="/posts/27956/image-20241008003736355.png" class="" title="image-20241008003736355"><ul><li>二进制</li><li>时、分、秒</li></ul><h2 id="五-编写底层驱动"><a class="markdownIt-Anchor" href="#五-编写底层驱动"></a> 五、编写底层驱动</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_app.h"</span></span></span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef time;<span class="comment">//定义时间结构体</span></span><br><span class="line">RTC_DataTypeDef date;<span class="comment">//定义日期结构体</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    HAL_RTC_GetTime(&amp;hrtc,&amp;time,RTC_FORMAT_BIN);</span><br><span class="line">    HAL_RTC_GetDate(&amp;hrtc,&amp;date,RTC_FORMAT_BIN);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"bsp_system.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_proc</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>HAL库源码</strong></p><p>1.RTC数据类型</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Time structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint8_t</span> Hours;            <span class="comment">/*!&lt; Specifies the RTC Time Hour.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the RTC_HourFormat_12 is selected.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the RTC_HourFormat_24 is selected */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Minutes;          <span class="comment">/*!&lt; Specifies the RTC Time Minutes.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Seconds;          <span class="comment">/*!&lt; Specifies the RTC Time Seconds.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> TimeFormat;       <span class="comment">/*!&lt; Specifies the RTC AM/PM Time.</span></span><br><span class="line"><span class="comment">                                 This parameter can be a value of @ref RTC_AM_PM_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> SubSeconds;     <span class="comment">/*!&lt; Specifies the RTC_SSR RTC Sub Second register content.</span></span><br><span class="line"><span class="comment">                                 This parameter corresponds to a time unit range between [0-1] Second</span></span><br><span class="line"><span class="comment">                                 with [1 Sec / SecondFraction +1] granularity */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> SecondFraction;  <span class="comment">/*!&lt; Specifies the range or granularity of Sub Second register content</span></span><br><span class="line"><span class="comment">                                 corresponding to Synchronous pre-scaler factor value (PREDIV_S)</span></span><br><span class="line"><span class="comment">                                 This parameter corresponds to a time unit range between [0-1] Second</span></span><br><span class="line"><span class="comment">                                 with [1 Sec / SecondFraction +1] granularity.</span></span><br><span class="line"><span class="comment">                                 This field will be used only by HAL_RTC_GetTime function */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DayLightSaving;  <span class="comment">/*!&lt; This interface is deprecated. To manage Daylight Saving Time,</span></span><br><span class="line"><span class="comment">                                 please use HAL_RTC_DST_xxx functions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> StoreOperation;  <span class="comment">/*!&lt; This interface is deprecated. To manage Daylight Saving Time,</span></span><br><span class="line"><span class="comment">                                 please use HAL_RTC_DST_xxx functions */</span></span><br><span class="line">} RTC_TimeTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Date structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint8_t</span> WeekDay;  <span class="comment">/*!&lt; Specifies the RTC Date WeekDay.</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_WeekDay_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Month;    <span class="comment">/*!&lt; Specifies the RTC Date Month (in BCD format).</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_Month_Date_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Date;     <span class="comment">/*!&lt; Specifies the RTC Date.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Year;     <span class="comment">/*!&lt; Specifies the RTC Date Year.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */</span></span><br><span class="line">} RTC_DateTypeDef;</span><br></pre></td></tr></tbody></table></figure><p>2.RTC函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, <span class="type">uint32_t</span> Format)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">uint32_t</span> tmpreg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_RTC_FORMAT(Format));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get subseconds structure field from the corresponding register*/</span></span><br><span class="line">  sTime-&gt;SubSeconds = READ_REG(hrtc-&gt;Instance-&gt;SSR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get SecondFraction structure field from the corresponding register field*/</span></span><br><span class="line">  sTime-&gt;SecondFraction = (<span class="type">uint32_t</span>)(READ_REG(hrtc-&gt;Instance-&gt;PRER) &amp; RTC_PRER_PREDIV_S);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TR register */</span></span><br><span class="line">  tmpreg = (<span class="type">uint32_t</span>)(READ_REG(hrtc-&gt;Instance-&gt;TR) &amp; RTC_TR_RESERVED_MASK);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fill the structure fields with the read parameters */</span></span><br><span class="line">  sTime-&gt;Hours = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_HT | RTC_TR_HU)) &gt;&gt; RTC_TR_HU_Pos);</span><br><span class="line">  sTime-&gt;Minutes = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_MNT | RTC_TR_MNU)) &gt;&gt; RTC_TR_MNU_Pos);</span><br><span class="line">  sTime-&gt;Seconds = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_ST | RTC_TR_SU)) &gt;&gt; RTC_TR_SU_Pos);</span><br><span class="line">  sTime-&gt;TimeFormat = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_PM)) &gt;&gt; RTC_TR_PM_Pos);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the input parameters format */</span></span><br><span class="line">  <span class="keyword">if</span> (Format == RTC_FORMAT_BIN)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">/* Convert the time structure parameters to Binary format */</span></span><br><span class="line">    sTime-&gt;Hours = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Hours);</span><br><span class="line">    sTime-&gt;Minutes = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Minutes);</span><br><span class="line">    sTime-&gt;Seconds = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Seconds);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HAL_OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>枚举类型：HAL_StatusTypeDef</strong></p><blockquote><p>typedef enum<br>{<br>HAL_OK       = 0x00U,<br>HAL_ERROR    = 0x01U,<br>HAL_BUSY     = 0x02U,<br>HAL_TIMEOUT  = 0x03U<br>} HAL_StatusTypeDef;</p></blockquote><p>Hal库封装的一个典型思想</p></blockquote><h2 id="多串口重定向-适合项目复用"><a class="markdownIt-Anchor" href="#多串口重定向-适合项目复用"></a> 多串口重定向-适合项目复用</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> {</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">512</span>];<span class="comment">//创建字符缓冲区</span></span><br><span class="line">    va_list arg;<span class="comment">//创建可变参数列表</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    va_start(arg, format);<span class="comment">// 初始化可变参数列表，获取my_printf传入的可变参数</span></span><br><span class="line">    len = vsnprintf(buffer, <span class="keyword">sizeof</span>(buffer), format, arg);<span class="comment">// 将格式化后的可变参数传入缓存区</span></span><br><span class="line">    va_end(arg);<span class="comment">// 结束可变参数列表</span></span><br><span class="line">    HAL_UART_Transmit(huart, (<span class="type">uint8_t</span> *)buffer, (<span class="type">uint16_t</span>)len, <span class="number">0xFF</span>); <span class="comment">// 将字符缓存数组发送出去</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iic模块&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#iic模块&quot;&gt;&lt;/a&gt; IIC模块&lt;/h1&gt;
&lt;h2 id=&quot;一-mcp4017&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-mcp4017&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][4]ADC采集系统</title>
    <link href="https://szturin.github.io/posts/26676/"/>
    <id>https://szturin.github.io/posts/26676/</id>
    <published>2024-09-29T14:14:00.000Z</published>
    <updated>2024-10-29T08:05:54.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vscode配置stm32编译调试环境"><a class="markdownIt-Anchor" href="#vscode配置stm32编译调试环境"></a> <strong># <mark>VsCode配置STM32编译调试环境</mark></strong></h1><p><a href="https://www.bilibili.com/video/BV1BJeJehEkb/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7026df729530ac261e29b43864230918">【保姆】vscode配置单片机编译调试烧录环境（以STM32为例）_哔哩哔哩_bilibili</a></p><h1 id="一-adc采集系统"><a class="markdownIt-Anchor" href="#一-adc采集系统"></a> 一、ADC采集系统</h1><h2 id="1-adc通道外部电路"><a class="markdownIt-Anchor" href="#1-adc通道外部电路"></a> 1. ADC通道(外部电路)</h2><img src="/posts/26676/image-20241001005738016.png" class="" title="image-20241001005738016"><h2 id="2-功能要求"><a class="markdownIt-Anchor" href="#2-功能要求"></a> 2. 功能要求</h2><img src="/posts/26676/image-20241001005805205.png" class="" title="image-20241001005805205"><h2 id="3-动态窗口"><a class="markdownIt-Anchor" href="#3-动态窗口"></a> 3. <mark>动态窗口</mark></h2><img src="/posts/26676/image-20241001005817305.png" class="" title="image-20241001005817305"><p><strong>"动态"的含义：3秒的实时采集<mark>窗口</mark>随着时间自行移动，adc采集的值动态实时更新在3s的窗口数据内</strong></p><img src="/posts/26676/image-20241001010344145.png" class="" title="image-20241001010344145"><h1 id="二-功能实现"><a class="markdownIt-Anchor" href="#二-功能实现"></a> 二、功能实现</h1><h2 id="1-adc解算"><a class="markdownIt-Anchor" href="#1-adc解算"></a> 1. ADC解算</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//双通道DMA</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">adc_proc</span><span class="params">()</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) </span><br><span class="line">{</span><br><span class="line">adc_value[<span class="number">0</span>] += (<span class="type">float</span>)dma_buff[<span class="number">0</span>][i]; </span><br><span class="line">adc_value[<span class="number">1</span>] += (<span class="type">float</span>)dma_buff[<span class="number">1</span>][i];</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10进制模拟量电压</span></span><br><span class="line"><span class="comment">//adc_value[0] = adc_value[0] / 30 *3.3f / 4096; </span></span><br><span class="line"><span class="comment">//adc_value[1] = adc_value[1] / 30 *3.3f / 4096;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不对分辨率和参考电压进行解算</span></span><br><span class="line">    <span class="comment">//16进制数字量电压</span></span><br><span class="line">adc_value[<span class="number">0</span>] = adc_value[<span class="number">0</span>] / (<span class="number">30</span>+<span class="number">1</span>);</span><br><span class="line">adc_value[<span class="number">1</span>] = adc_value[<span class="number">1</span>] / (<span class="number">30</span>+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-lcd底层实现"><a class="markdownIt-Anchor" href="#2-lcd底层实现"></a> 2. LCD底层实现</h2><h3 id="21-变量定义"><a class="markdownIt-Anchor" href="#21-变量定义"></a> 2.1 <strong>变量定义</strong></h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> lcd_disp_mode;<span class="comment">//lcd显示模式</span></span><br><span class="line"><span class="type">uint16_t</span> ph_value;<span class="comment">//PH值</span></span><br><span class="line"><span class="type">uint16_t</span> pd_value;<span class="comment">//PD值</span></span><br></pre></td></tr></tbody></table></figure><p>参数界面</p><img src="/posts/26676/image-20240929225356591.png" class="" title="image-20240929225356591"><p>记录界面</p><img src="/posts/26676/image-20240929225307555.png" class="" title="image-20240929225307555"><h3 id="22-lcd进程"><a class="markdownIt-Anchor" href="#22-lcd进程"></a> 2.2 <strong>LCD进程</strong></h3><p>由于4T官方提供的LCD底层驱动，当显示的数据位数增加时，显示的位数会增加，但是当位数减小时，却不能对旧的数据进行清空。</p><p>所以这里用“空格”来覆盖刷新，达到位数减小显示缩减的效果。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span>(lcd_disp_mode){</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            LCD_Sprintf(Line1,<span class="string">"        DATA"</span>);</span><br><span class="line">            LCD_Sprintf(Line3,<span class="string">"   R37:%d    "</span>,(<span class="type">int</span>)adc_value[<span class="number">0</span>]);</span><br><span class="line">            LCD_Sprintf(Line4,<span class="string">"   R38:%d    "</span>,(<span class="type">int</span>)adc_value[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="lcd背光-问题"><a class="markdownIt-Anchor" href="#lcd背光-问题"></a> #<mark>LCD背光 问题</mark></h3><p><strong>现象：如图所示，只有在对LCD写入的片段，LCD才有正常的背景</strong></p><img src="/posts/26676/3ee14bc0dc0d49a3647ae193e51b544.jpg" class="" title="3ee14bc0dc0d49a3647ae193e51b544"><p><strong>原因：未对LCD进行初始化清屏</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">system_init();</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_Clear(Black);</span><br><span class="line">LCD_SetTextColor(White);</span><br><span class="line">LCD_SetBackColor(Black);</span><br><span class="line">scheduler_init();</span><br></pre></td></tr></tbody></table></figure><p><strong>来源：lcd.c</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_Clear</span></span><br><span class="line"><span class="comment">* Description    : Clears the hole LCD.</span></span><br><span class="line"><span class="comment">* Input          : Color: the color of the background.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Clear</span><span class="params">(u16 Color)</span></span><br><span class="line">{</span><br><span class="line">    u32 index = <span class="number">0</span>;</span><br><span class="line">    LCD_SetCursor(<span class="number">0x00</span>, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; <span class="number">76800</span>; index++)</span><br><span class="line">    {</span><br><span class="line">        LCD_WR_DATA(Color);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="23-led功能和初始化状态"><a class="markdownIt-Anchor" href="#23-led功能和初始化状态"></a> 2.3 LED功能和初始化状态</h3><img src="/posts/26676/image-20241001001209075.png" class="" title="image-20241001001209075"><h3 id="24-lcd底层完整代码实现"><a class="markdownIt-Anchor" href="#24-lcd底层完整代码实现"></a> 2.4 LCD底层完整代码实现</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"bsp_system.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> lcd_disp_mode;    <span class="comment">// lcd显示模式</span></span><br><span class="line"><span class="type">uint16_t</span> ph_value = <span class="number">2000</span>; <span class="comment">// PH值</span></span><br><span class="line"><span class="type">uint16_t</span> pd_value = <span class="number">1000</span>; <span class="comment">// PD值</span></span><br><span class="line"><span class="type">uint16_t</span> vh_value;        <span class="comment">// PH值</span></span><br><span class="line"><span class="type">uint16_t</span> vd_value;        <span class="comment">// PD值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  格式化字符串并显示在指定的LCD行上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数接受一个行号和一个格式化字符串（类似于printf），</span></span><br><span class="line"><span class="comment"> * 格式化字符串后，将其显示在LCD的指定行上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  Line    要显示字符串的LCD行号。</span></span><br><span class="line"><span class="comment"> * @param  format  格式化字符串，后跟要格式化的参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数内部使用 `vsprintf` 来格式化字符串，然后</span></span><br><span class="line"><span class="comment"> * 调用 `LCD_DisplayStringLine` 在LCD上显示格式化后的字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例用法:</span></span><br><span class="line"><span class="comment"> * @code</span></span><br><span class="line"><span class="comment"> * LcdSprintf(0, "Temperature: %d C", temperature);</span></span><br><span class="line"><span class="comment"> * @endcode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdSprintf</span><span class="params">(<span class="type">uint8_t</span> Line, <span class="type">char</span> *format, ...)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> String[<span class="number">21</span>];                     <span class="comment">// 缓冲区用于存储格式化后的字符串</span></span><br><span class="line">    va_list arg;                         <span class="comment">// 参数列表用于存储可变参数</span></span><br><span class="line">    va_start(arg, format);               <span class="comment">// 使用格式化字符串初始化参数列表</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(String, format, arg);       <span class="comment">// 格式化字符串并存储在缓冲区中</span></span><br><span class="line">    va_end(arg);                         <span class="comment">// 清理参数列表</span></span><br><span class="line">    LCD_DisplayStringLine(Line, String); <span class="comment">// 在LCD的指定行显示格式化后的字符串</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (lcd_disp_mode)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//测量界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        DATA"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   R37:%d    "</span>, (<span class="type">int</span>)adc_value[<span class="number">0</span>]);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   R38:%d    "</span>, (<span class="type">int</span>)adc_value[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//参数界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        PARA"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   PH:%d    "</span>, ph_value);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   PD:%d    "</span>, pd_value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//参数界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        RECD"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   VH:%d    "</span>, vh_value);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   VD:%d    "</span>, vd_value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-按键底层"><a class="markdownIt-Anchor" href="#3-按键底层"></a> 3. 按键底层</h2><p>uwTick：在Systick（系统滴答定时器）中断中自增，可以用作单片机运行的时间戳</p><p><a href="https://cloud.tencent.com/developer/article/1861964">HAL库与Cubemx系列|Systick-系统滴答定时器详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h3 id="31-按键处理进程"><a class="markdownIt-Anchor" href="#31-按键处理进程"></a> 3.1 按键处理进程</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> ph_pd_flag; <span class="comment">//参数修改切换标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键处理函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数用于扫描按键的状态，并更新按键按下和释放的标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// 读取当前按键状态</span></span><br><span class="line">key_val = key_read();</span><br><span class="line"><span class="comment">// 计算按下的按键（当前按下状态与前一状态异或，并与当前状态相与）</span></span><br><span class="line">key_down = key_val &amp; (key_old ^ key_val);</span><br><span class="line"><span class="comment">// 计算释放的按键（当前未按下状态与前一状态异或，并与前一状态相与）</span></span><br><span class="line">key_up = ~key_val &amp; (key_old ^ key_val);</span><br><span class="line"><span class="comment">// 更新前一按键状态</span></span><br><span class="line">key_old = key_val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key_down == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">ph_pd_flag ^= <span class="number">1</span>;<span class="comment">//参数选择标志位取反</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lcd_disp_mode == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">key_tick = uwTick; <span class="comment">//记录按键按下时的时间</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(key_up == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(lcd_disp_mode == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(uwTick - key_tick &gt; <span class="number">2000</span>)</span><br><span class="line">{</span><br><span class="line">key_tick = <span class="number">0</span>;<span class="comment">//清理按键时间戳</span></span><br><span class="line">vd_value = vh_value = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (key_down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span> (++lcd_disp_mode == <span class="number">3</span>)<span class="comment">//模式切换</span></span><br><span class="line">{</span><br><span class="line">lcd_disp_mode = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)<span class="comment">//参数切换界面s</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//创建一个指针，根据参数选择标志位切换指向</span></span><br><span class="line"><span class="comment">//这样，使用逻辑语句和一个指针变量就可以实现对两个参数的地址指向-&gt;数据内容更改</span></span><br><span class="line"><span class="type">uint16_t</span> *p = (ph_pd_flag) ? &amp;ph_value : &amp;pd_value;</span><br><span class="line">*p += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*p &gt; <span class="number">4096</span>)</span><br><span class="line">{</span><br><span class="line">*p = <span class="number">4096</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> *p = (ph_pd_flag) ? &amp;ph_value : &amp;pd_value;</span><br><span class="line">*p -= <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="number">65536</span> - <span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-adc采集"><a class="markdownIt-Anchor" href="#4-adc采集"></a> 4. adc采集</h2><h3 id="41-变量定义"><a class="markdownIt-Anchor" href="#41-变量定义"></a> 4.1 变量定义</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//DMA接收缓存</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];<span class="comment">//ADC采样数组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINDOWS_SIZE 3000 <span class="comment">//动态窗口的大小为3秒</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">adc_data_t</span> adc_buffer[BUFFER_SIZE];<span class="comment">//adc采集周期为100ms,动态窗口大小为3s</span></span><br><span class="line"><span class="type">int</span> buffer_start = <span class="number">0</span>;<span class="comment">//头指针</span></span><br><span class="line"><span class="type">int</span> buffer_end = <span class="number">0</span>;<span class="comment">//尾指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> vd_flag;<span class="comment">//标志位，表示当前窗口内是否检测到突变</span></span><br></pre></td></tr></tbody></table></figure><h3 id="42-添加数据到动态串口缓冲区"><a class="markdownIt-Anchor" href="#42-添加数据到动态串口缓冲区"></a> 4.2 添加数据到动态串口（缓冲区）</h3><p>本例中,ADC采样的环形缓冲区比较特殊，具备动态时间窗口的特性</p><ul><li>和一般的环形缓冲区一样，具备头指针和尾指针的概念，环形存取数据。</li><li>缓冲区具备“时间窗口”的概念，那么就要让缓冲区中最<mark>老</mark>的数据，存在时间不能超过三秒，超过则移除（实际上是写指针移位，相当于队这个无用的数据不再进行读取，环形缓冲区中读取数据，就相当于将这个数据移除缓存区，因为索引指针不会再指向这个数据。）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief添加adc采集数据，当前时间到adc缓冲区(环形)</span></span><br><span class="line"><span class="comment">  * @paramadc采集数据，当前时间，指定的buffer</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_adc_data</span><span class="params">(<span class="type">uint32_t</span> adc,<span class="type">uint32_t</span> current_time,<span class="type">adc_data_t</span> *buffer)</span></span><br><span class="line">{</span><br><span class="line">buffer[buffer_end].timestamp = current_time;<span class="comment">//记录当前时间到尾指针指向的缓冲区</span></span><br><span class="line">buffer[buffer_end].adc = adc;<span class="comment">//记录adc采集值到尾指针指向的缓冲区 </span></span><br><span class="line"></span><br><span class="line">buffer_end = (buffer_end + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//表示尾指针自加，0~30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer_end == buffer_start)<span class="comment">// 如果缓冲区满了，调整buffer_start，使得窗口始终保持在3秒内</span></span><br><span class="line">{</span><br><span class="line">buffer_start = (buffer_start + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//头指针移位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前时间是否超过窗口时间戳3秒，即操作时间超过3秒,// 移除超出3秒窗口的数据</span></span><br><span class="line"><span class="keyword">while</span>((current_time - buffer[buffer_start].timestamp &gt; WINDOWS_SIZE))</span><br><span class="line">{</span><br><span class="line">buffer_start = (buffer_start + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//头指针移位</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="43-检查缓冲区的突变"><a class="markdownIt-Anchor" href="#43-检查缓冲区的突变"></a> 4.3 检查缓冲区的突变</h3><p>对当前窗口进行极大值，极小值的检测。</p><p>注意区分极大值，极小值和最大值最小值的区别。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief检测当前窗口是否发生ADC突变</span></span><br><span class="line"><span class="comment">  * @param突变计数，adc缓冲区</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_adc_sudden_change</span><span class="params">(<span class="type">uint16_t</span> *sudden_change_count,<span class="type">adc_data_t</span> *buffer)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> f_max = buffer[buffer_start].adc;</span><br><span class="line"><span class="comment">// uint16_t f_min = buffer[buffer_end].adc;</span></span><br><span class="line"><span class="type">uint16_t</span> f_min = buffer[buffer_start].adc;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = buffer_start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(index != buffer_end)<span class="comment">//读取完整个环形缓冲区</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//极大值</span></span><br><span class="line"><span class="keyword">if</span>(buffer[index].adc &gt; f_max)</span><br><span class="line">{</span><br><span class="line">f_max = buffer[index].adc;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//极小值</span></span><br><span class="line"><span class="keyword">if</span>(buffer[index].adc &lt; f_min)</span><br><span class="line">{</span><br><span class="line">f_min = buffer[index].adc;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//指针加1</span></span><br><span class="line">index = (index + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> diff = f_max - f_min;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测ADC突变</span></span><br><span class="line"><span class="keyword">if</span>(diff &lt; pd_value)</span><br><span class="line">{</span><br><span class="line">vd_flag = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vd_flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">vd_flag = <span class="number">0</span>;</span><br><span class="line">(*sudden_change_count) ++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ucLed[<span class="number">2</span>] = (diff &gt; pd_value)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="44-adc解析进程"><a class="markdownIt-Anchor" href="#44-adc解析进程"></a> 4.4 ADC解析进程</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_proc</span><span class="params">()</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Time_tick = HAL_GetTick();<span class="comment">//获取当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> vh_flag;<span class="comment">//超限标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对adc1,adc2两个adc通道进行数据采集</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) </span><br><span class="line">{</span><br><span class="line">adc_value[<span class="number">0</span>] += (<span class="type">float</span>)dma_buff[<span class="number">0</span>][i]; <span class="comment">//采集30次</span></span><br><span class="line">adc_value[<span class="number">1</span>] += (<span class="type">float</span>)dma_buff[<span class="number">1</span>][i]; <span class="comment">//采集30次</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">adc_value[<span class="number">0</span>] = adc_value[<span class="number">0</span>] / (<span class="number">30</span> + <span class="number">1</span>); <span class="comment">//采集30后，但是累加值是(30+1)次，因为采集30次之前本身adc_value[0]就有值</span></span><br><span class="line">adc_value[<span class="number">1</span>] = adc_value[<span class="number">1</span>] / (<span class="number">30</span> + <span class="number">1</span>); <span class="comment">//否则会出现如采集到的ADC值大于4096的现象</span></span><br><span class="line"></span><br><span class="line">add_adc_data(adc_value[<span class="number">0</span>],Time_tick,adc_buffer);<span class="comment">//将adc采集值写入缓冲区</span></span><br><span class="line">check_adc_sudden_change(&amp;vd_value,adc_buffer);<span class="comment">//判断是否发生值突变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(adc_value[<span class="number">1</span>] &lt; ph_value) </span><br><span class="line">{</span><br><span class="line">vh_flag = <span class="number">0</span>; <span class="comment">//当adc_value小于参数时，标志位才会置0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vh_flag == <span class="number">0</span>) <span class="comment">// adc_value大于参数且标志位为0</span></span><br><span class="line">{</span><br><span class="line">vh_flag = <span class="number">1</span>;<span class="comment">//标志位置1</span></span><br><span class="line">vh_value++;<span class="comment">//超限次数加1</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-led底层"><a class="markdownIt-Anchor" href="#5-led底层"></a> 5. LED底层</h2><h2 id="51-led显示进程"><a class="markdownIt-Anchor" href="#51-led显示进程"></a> 5.1 LED显示进程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief LED 显示处理函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每次调用该函数时，LED 灯根据 ucLed 数组中的值来决定是开启还是关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 显示当前 Led_Pos 位置的 LED 灯状态</span></span><br><span class="line">    ucLed[<span class="number">0</span>] = (lcd_disp_mode == <span class="number">0</span>);<span class="comment">//当前界面为数据采集时LED1点亮 </span></span><br><span class="line">    ucLed[<span class="number">1</span>] = adc_value[<span class="number">1</span>] &gt; ph_value ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ucLed[2] = (adc_value[0] &gt; pd_value);//放入窗口突变判断中</span></span><br><span class="line">    </span><br><span class="line">    led_disp(ucLed);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-串口通信"><a class="markdownIt-Anchor" href="#6-串口通信"></a> 6. 串口通信</h2><h3 id="61-串口通信进程"><a class="markdownIt-Anchor" href="#61-串口通信进程"></a> 6.1 串口通信进程</h3><blockquote><p><strong><code>sscanf</code></strong>:</p><ul><li><code>sscanf</code> 是一个格式化输入函数，主要用于从字符串中提取数据。</li><li>它按照指定的格式读取输入字符串，并将解析后的数据存储到指定的变量中。</li><li>语法：<code>int sscanf(const char *str, const char *format, ...)</code></li></ul><p><strong><code>strcmp</code></strong>:</p><ul><li><code>strcmp</code> 是一个字符串比较函数，用于比较两个字符串是否相等。</li><li>它返回一个整数，表示两个字符串的字典顺序。</li><li>语法：<code>int strcmp(const char *str1, const char *str2)</code></li><li>返回值：<ul><li>小于 0：<code>str1</code> 小于 <code>str2</code></li><li>等于 0：<code>str1</code> 等于 <code>str2</code></li><li>大于 0：<code>str1</code> 大于 <code>str2</code></li></ul></li></ul><p>总结：</p><p>sscanf：将stream内容取出，并根据入口参数的格式化过滤内容，取出数据</p><p>strcmp：比较两个字符串的内容</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb)) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 从环形缓冲区读取数据到读取缓冲区 </span></span><br><span class="line">ringbuffer_read(&amp;usart_rb, usart_read_buffer, usart_rb.itemCount);</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> value;</span><br><span class="line"><span class="type">uint16_t</span> *p = <span class="literal">NULL</span>;<span class="comment">//创建一个空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析串口数据，如果匹配，那么将解释后的数据存入value中</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sscanf</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"$PD(%hu)"</span>,&amp;value) == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">        <span class="comment">// 指针指向pd_value</span></span><br><span class="line">p = &amp;pd_value;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sscanf</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"$PH(%hu)"</span>,&amp;value) == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">        <span class="comment">// 指针指向ph_value</span></span><br><span class="line">p = &amp;ph_value;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"#VH"</span>) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VH:%d\n"</span>,vh_value);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"#VD"</span>) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VD:%d\n"</span>,vd_value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数范围是否合法</span></span><br><span class="line"><span class="keyword">if</span>(value &lt; <span class="number">4096</span>)</span><br><span class="line">{</span><br><span class="line">        <span class="comment">// 通过指针解引用修改数据</span></span><br><span class="line">*p = value; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(usart_read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * BUUFER_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vscode配置stm32编译调试环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vscode配置stm32编译调试环境&quot;&gt;&lt;/a&gt; &lt;strong&gt;# &lt;mark&gt;VsCode配置STM32编译调试环境&lt;/mark&gt;&lt;/stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【FPGA】[Quartus]补充[1]——工程创建和仿真设置</title>
    <link href="https://szturin.github.io/posts/30892/"/>
    <id>https://szturin.github.io/posts/30892/</id>
    <published>2024-09-21T15:16:04.000Z</published>
    <updated>2024-09-21T16:05:02.389Z</updated>
    
    <content type="html"><![CDATA[<p>author: sz_jmu</p><h1 id="一-新建工程"><a class="markdownIt-Anchor" href="#一-新建工程"></a> 一、新建工程</h1><img src="/posts/30892/image-20240921231843304.png" class="" title="image-20240921231843304"><hr><img src="/posts/30892/image-20240921232007449.png" class="" title="image-20240921232007449"><hr><img src="/posts/30892/image-20240921232158703.png" class="" title="image-20240921232158703"><hr><img src="/posts/30892/image-20240921232252862.png" class="" title="image-20240921232252862"><img src="/posts/30892/image-20240921232444167.png" class="" title="image-20240921232444167"><hr><img src="/posts/30892/image-20240921232539812.png" class="" title="image-20240921232539812"><hr><p>完成工程创建后，如果想要修改之前的EDA tools Settings，可以：</p><img src="/posts/30892/image-20240921232809899.png" class="" title="image-20240921232809899"><p>默认情况下没有仿真组件路径，需要手动添加</p><p>手动设置仿真软件的路径：Tools-&gt;Options</p><img src="/posts/30892/image-20240921233059815.png" class="" title="image-20240921233059815"><hr><p>创建元件</p><img src="/posts/30892/image-20240921234523862.png" class="" title="image-20240921234523862"><hr><p>新建原理图文件</p><img src="/posts/30892/image-20240921234842876.png" class="" title="image-20240921234842876"><hr><p><a href="https://www.bilibili.com/video/BV1Rc411J7FW?p=4&amp;vd_source=7026df729530ac261e29b43864230918">4.编写和编译代码 / 解决编译报错问题_哔哩哔哩_bilibili</a></p><img src="/posts/30892/image-20240921233524839.png" class="" title="image-20240921233524839"><p>将原理图设置为顶层设计实体，无需重复创建工程编译</p><p>以后在同一个工程对单个程序或者原理图进行编译时，选择为顶层设计实体即可</p><img src="/posts/30892/image-20240921235755270.png" class="" title="image-20240921235755270"><hr><img src="/posts/30892/image-20240921235550901.png" class="" title="image-20240921235550901"><h1 id="二-quartus-优化配置"><a class="markdownIt-Anchor" href="#二-quartus-优化配置"></a> 二、Quartus 优化配置</h1><h2 id="1-字体"><a class="markdownIt-Anchor" href="#1-字体"></a> 1. 字体</h2><img src="/posts/30892/image-20240921234417742.png" class="" title="image-20240921234417742"><h2 id="2-编译加速"><a class="markdownIt-Anchor" href="#2-编译加速"></a> 2. 编译加速</h2><img src="/posts/30892/image-20240922000307027.png" class="" title="image-20240922000307027">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;author: sz_jmu&lt;/p&gt;
&lt;h1 id=&quot;一-新建工程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-新建工程&quot;&gt;&lt;/a&gt; 一、新建工程&lt;/h1&gt;
&lt;img src=&quot;/posts/30892/image-202409212318</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[RM电控][1]开发板的使用与CAN总线控制3508电机</title>
    <link href="https://szturin.github.io/posts/31666/"/>
    <id>https://szturin.github.io/posts/31666/</id>
    <published>2024-09-18T15:03:22.000Z</published>
    <updated>2024-10-29T08:06:07.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-a板介绍"><a class="markdownIt-Anchor" href="#一-a板介绍"></a> 一、A板介绍*</h1><ul><li>A板外部晶振为12MHZ，最高主频为168MHZ</li></ul><h1 id="二-can总线通信原理"><a class="markdownIt-Anchor" href="#二-can总线通信原理"></a> 二、CAN总线通信原理</h1><h2 id="1-can总线是什么"><a class="markdownIt-Anchor" href="#1-can总线是什么"></a> 1. CAN总线是什么</h2><h3 id="11-can总线简介"><a class="markdownIt-Anchor" href="#11-can总线简介"></a> 1.1 CAN总线简介</h3><p>​CAN 是 Controller Area Network 的缩写，最初是汽车行业为了减少车身上的线束，而且还能进行大量数据的高速通信，由德国电气商博世公司在1986 年开发出的面向汽车的通信协议。现在，CAN 的高性能和可靠性已被认同，并被广泛地应用于工业自动化、船舶、医疗设备、工业设备等方面。RM的电机（3508、2006、6020）的控制也采用了CAN协议进行通信。<br>CAN 总线由 CAN_H 和 CAN_L 一对差分线构成，各个设备一起挂载在总线上。</p><p>参考文章：<a href="https://blog.csdn.net/weixin_54448108/article/details/125881138">【RoboMaster】从零开始控制RM电机（2）-CAN通信原理及电调通信协议_can通讯 同步触发控制电机-CSDN博客</a></p><h3 id="12-can通信的特点"><a class="markdownIt-Anchor" href="#12-can通信的特点"></a> 1.2 CAN通信的特点</h3><p><strong>1) 多主控制</strong><br>多个单元同时开始发送时，发送高优先级 ID 消息的单元可获得发送权。</p><p><strong>2) 消息的发送</strong></p><p>所有的消息由固定格式发送，标识符（Identifier 以下称为 ID）决定优先级。</p><p><strong>3) 通信速度</strong></p><p>同一CAN总线网络，所有单元必须同一通信速率。</p><h2 id="2-can通信协议"><a class="markdownIt-Anchor" href="#2-can通信协议"></a> 2. CAN通信协议</h2><h3 id="21-帧的种类"><a class="markdownIt-Anchor" href="#21-帧的种类"></a> 2.1 帧的种类</h3><p>CAN通信由五种帧类型</p><img src="/posts/31666/88d8d711fa24f37edff930d2be7b5e5d.png" class="" title="在这里插入图片描述"><p>其中数据帧和遥控帧有标准格式和扩展格式两种格式。</p><p>标准格式有 11 个位的标识符（Identifier: 以下称 ID），扩展格式有 29 个位的 ID。</p><p>控制RM电机使用标准帧。</p><h3 id="22-数据帧"><a class="markdownIt-Anchor" href="#22-数据帧"></a> 2.2 数据帧</h3><p>CAN总线数据帧的帧结构：</p><p>主要处理</p><img src="/posts/31666/7cec510a164a96bf6d346eee189c9cee.png" class="" title="在这里插入图片描述"><ol><li>帧起始<br>表示数据帧开始的段。</li><li>仲裁场<br>表示该帧优先级的段。</li><li>控制场<br>表示数据的字节数及保留位的段。</li><li>数据场<br>数据的内容，可发送 0～8 个字节的数据。</li><li>CRC 场<br>检查帧的传输错误的段。</li><li>应答场<br>表示确认正常接收的段。</li><li>帧结尾<br>表示数据帧结束的段。</li></ol><h5 id="1仲裁场"><a class="markdownIt-Anchor" href="#1仲裁场"></a> (1)仲裁场</h5><p>CAN 的 ID 分为标准 ID 和 拓展 ID 两类，每个设备都有自己独有的ID，CAN通信通过仲裁ID决定优先级。</p><h5 id="2控制场"><a class="markdownIt-Anchor" href="#2控制场"></a> (2)控制场</h5><p>控制场由 6 个位构成，表示数据段的字节数，C620电调的数据段长度为8</p><img src="/posts/31666/b63bd68d7d77e03f2e2bfed4439523e7.png" class="" title="在这里插入图片描述"><h5 id="3数据场"><a class="markdownIt-Anchor" href="#3数据场"></a> (3)数据场</h5><p>如果控制场的DLC表示为DRRR，CAN 总线的一个数据帧中所需要传输的有效数据实际上就是这 8Byte。这8字节的排列顺序为从高到低。</p><img src="/posts/31666/0519eb8c409db49546fc1b6b25fcd174.png" class="" title="在这里插入图片描述"><h1 id="三-电调通信"><a class="markdownIt-Anchor" href="#三-电调通信"></a> 三、电调通信</h1><h2 id="1-m3508m2006电机"><a class="markdownIt-Anchor" href="#1-m3508m2006电机"></a> 1. M3508&amp;M2006电机</h2><p>这两种电机代码通用</p><ul><li>M3508使用C620电调</li><li>M2006使用C610电调</li></ul><h3 id="11-单片机-数据帧-电调"><a class="markdownIt-Anchor" href="#11-单片机-数据帧-电调"></a> 1.1 单片机-&gt;数据帧-&gt;电调</h3><p>单片机向电调发送控制指令控制电调的<mark>电流输出</mark>。</p><p>一个数据帧只能给四个电机发送数据，</p><p>控制前四个电机时将ID设为 0x200</p><p>控制后四个电机时将ID设为 0x1FF</p><img src="/posts/31666/1af85c7b717809c098b68813f8100bb1.png" class="" title="img"><h3 id="12-电调-数据帧-单片机"><a class="markdownIt-Anchor" href="#12-电调-数据帧-单片机"></a> 1.2 电调-&gt;数据帧-&gt;单片机</h3><p>为了实现闭环控制，单片机需要接收电调的反馈报文得到电机的转速、机械转子角度、实时电流数据。</p><p>根据接收到的<mark>ID</mark>判断是哪一个电调的数据，电调反馈报文ID规定为 0x200+电调ID(1-8),如0x201(电调ID为1)。</p><img src="/posts/31666/89de834dbe0df93d0de87c331cc4970f.png" class="" title="在这里插入图片描述"><h2 id="2-gm6020电机"><a class="markdownIt-Anchor" href="#2-gm6020电机"></a> 2. GM6020电机</h2><h3 id="21-发送"><a class="markdownIt-Anchor" href="#21-发送"></a> 2.1 发送</h3><img src="/posts/31666/f5cec08ec56db6f2c90f9cd3b1b886b5.png" class="" title="在这里插入图片描述"><h3 id="22-接收"><a class="markdownIt-Anchor" href="#22-接收"></a> 2.2 接收</h3><img src="/posts/31666/d8dde436c117927177cdeeb6b356c8a7.png" class="" title="在这里插入图片描述"><h2 id="3-cubemx配置can总线协议"><a class="markdownIt-Anchor" href="#3-cubemx配置can总线协议"></a> 3. CubeMX配置CAN总线协议</h2><ul><li>波特率要设置成1M</li></ul><h2 id="4-程序实现"><a class="markdownIt-Anchor" href="#4-程序实现"></a> 4. 程序实现</h2><h3 id="41-can数据帧发送"><a class="markdownIt-Anchor" href="#41-can数据帧发送"></a> 4.1 CAN数据帧发送</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置并发送电机控制命令</span></span><br><span class="line"><span class="comment"> * @param hcan CAN句柄</span></span><br><span class="line"><span class="comment"> * @param STDID 标准ID</span></span><br><span class="line"><span class="comment"> * @param motor1 电机1控制值</span></span><br><span class="line"><span class="comment"> * @param motor2 电机2控制值</span></span><br><span class="line"><span class="comment"> * @param motor3 电机3控制值</span></span><br><span class="line"><span class="comment"> * @param motor4 电机4控制值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_motor_cmd</span><span class="params">(CAN_HandleTypeDef *hcan, <span class="type">uint32_t</span> STDID,</span></span><br><span class="line"><span class="params">                   <span class="type">int16_t</span> motor1, <span class="type">int16_t</span> motor2, <span class="type">int16_t</span> motor3, <span class="type">int16_t</span> motor4)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> send_mail_box;  <span class="comment">// 定义一个变量用于存储发送邮箱编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置发送消息的标识符</span></span><br><span class="line">    CANx_tx_message.StdId = STDID;</span><br><span class="line">    CANx_tx_message.IDE = CAN_ID_STD;  <span class="comment">// 标识符选择位，STD-标准帧</span></span><br><span class="line">    CANx_tx_message.RTR = CAN_RTR_DATA;  <span class="comment">// 定义帧类型</span></span><br><span class="line">    CANx_tx_message.DLC = <span class="number">0x08</span>;  <span class="comment">// 数据帧长度为8位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充要发送的数据</span></span><br><span class="line">    CANx_send_data[<span class="number">0</span>] = motor1 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">1</span>] = motor1;</span><br><span class="line">    CANx_send_data[<span class="number">2</span>] = motor2 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">3</span>] = motor2;</span><br><span class="line">    CANx_send_data[<span class="number">4</span>] = motor3 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">5</span>] = motor3;</span><br><span class="line">    CANx_send_data[<span class="number">6</span>] = motor4 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">7</span>] = motor4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送CAN数据</span></span><br><span class="line">    HAL_CAN_AddTxMessage(hcan, &amp;CANx_tx_message, CANx_send_data, &amp;send_mail_box);  <span class="comment">// hal库CAN发送函数：该函数用于向发送邮箱添加发送报文，并激活发送请求</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="42-can数据帧接收"><a class="markdownIt-Anchor" href="#42-can数据帧接收"></a> 4.2 CAN数据帧接收</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief CAN接收回调函数</span></span><br><span class="line"><span class="comment"> *        处理CAN接收到的数据帧</span></span><br><span class="line"><span class="comment"> * @param hcan CAN句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_CAN_RxFifo0MsgPendingCallback</span><span class="params">(CAN_HandleTypeDef *hcan)</span></span><br><span class="line">{</span><br><span class="line">    CAN_RxHeaderTypeDef RX_Header;  <span class="comment">// 定义数据帧的帧头</span></span><br><span class="line">    <span class="type">uint8_t</span> RX_BUFFER[<span class="number">8</span>];           <span class="comment">// 接收存放数据帧数据的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取CAN接收到的数据帧并存入局部变量</span></span><br><span class="line">    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &amp;RX_Header, RX_BUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断接收的是CAN1还是CAN2</span></span><br><span class="line">    <span class="keyword">if</span> (hcan == &amp;hcan1) {</span><br><span class="line">        <span class="comment">// CAN1：通过反馈数据的ID确定这一组数据存放的地址</span></span><br><span class="line">        i = RX_Header.StdId - Chassis_3508A;</span><br><span class="line">        Motor_measure_fun(&amp;Motor_measure[i], RX_BUFFER);  <span class="comment">// 调用函数把数据存入结构体数组</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (hcan == &amp;hcan2) {</span><br><span class="line">        <span class="comment">// CAN2：通过反馈数据的ID确定这一组数据存放的地址</span></span><br><span class="line">        i = RX_Header.StdId - CAN2_3508_ID1 + <span class="number">7</span>;</span><br><span class="line">        Motor_measure_fun(&amp;Motor_measure[i], RX_BUFFER);  <span class="comment">// 调用函数把数据存入结构体数组</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-a板介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-a板介绍&quot;&gt;&lt;/a&gt; 一、A板介绍*&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;A板外部晶振为12MHZ，最高主频为168MHZ&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;二-can总线通信</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【电赛】2024年H题-自动行驶小车</title>
    <link href="https://szturin.github.io/posts/37775/"/>
    <id>https://szturin.github.io/posts/37775/</id>
    <published>2024-09-15T14:24:02.000Z</published>
    <updated>2024-10-11T14:46:26.608Z</updated>
    
    <content type="html"><![CDATA[<p>注意：CCS Theia编译可能无法找到报错位置，建议每次小幅修改后就立即编译</p><p>主要问题：</p><ul><li><p>如何进行调参？</p></li><li><p>如何设计一个完整的系统？</p></li><li><p>小车如何走直线？</p><ul><li>PID速度环</li><li>陀螺仪</li></ul></li><li><p>小车在循迹时如何保证沿中线行驶？</p></li><li><p>如何解决陀螺仪漂移的问题</p><ul><li>滤波算法</li></ul></li><li><p>如何避免/减少场地干扰？</p></li><li><p>如何提高速度的同时保证行驶稳定？</p></li></ul><h1 id="程序结构-底层驱动"><a class="markdownIt-Anchor" href="#程序结构-底层驱动"></a> 程序结构-底层驱动</h1><h2 id="一-基础电机控制"><a class="markdownIt-Anchor" href="#一-基础电机控制"></a> 一、基础电机控制</h2><p>源文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"motor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iso646.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief电机启动</span></span><br><span class="line"><span class="comment">  * @param    None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_On</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    DL_GPIO_setPins(GPIO_MOTOR_PIN_FSTBY_PORT, GPIO_MOTOR_PIN_FSTBY_PIN);<span class="comment">//置位对应端口-&gt;引脚电平,STBY</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief    电机关闭</span></span><br><span class="line"><span class="comment">  * @param    None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    DL_GPIO_clearPins(GPIO_MOTOR_PIN_FSTBY_PORT, GPIO_MOTOR_PIN_FSTBY_PIN);<span class="comment">//清除对应端口-&gt;引脚电平，STBY</span></span><br><span class="line">    <span class="comment">//逻辑口电平清除</span></span><br><span class="line">    DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN);</span><br><span class="line">    DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN);</span><br><span class="line">    DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN);</span><br><span class="line">    DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief速度设置</span></span><br><span class="line"><span class="comment">  * @param    左右轮占空比（百分值）</span></span><br><span class="line"><span class="comment">  * @retval     None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Speed</span><span class="params">(<span class="type">float</span> duty1,<span class="type">float</span> duty2)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> compareValue = <span class="number">0</span>;<span class="comment">//比较值最大为3199，最小值为0</span></span><br><span class="line">    <span class="keyword">if</span>(duty1 &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//PWM定时器向下计数，比较值计算</span></span><br><span class="line">        compareValue = <span class="number">3199</span> - <span class="number">3199</span> * (-duty1/<span class="number">100.0</span>);</span><br><span class="line">        <span class="comment">//比较值设置</span></span><br><span class="line">        DL_TimerA_setCaptureCompareValue(PWM_MOTOR_INST, compareValue, DL_TIMER_CC_0_INDEX); </span><br><span class="line">        <span class="comment">//电机逻辑引脚设置</span></span><br><span class="line">        DL_GPIO_setPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN);</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(duty1 &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        compareValue = <span class="number">3199</span> - <span class="number">3199</span> * (duty1/<span class="number">100.0</span>);</span><br><span class="line">        DL_TimerA_setCaptureCompareValue(PWM_MOTOR_INST, compareValue, DL_TIMER_CC_0_INDEX);</span><br><span class="line">        DL_GPIO_setPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(duty2 &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        compareValue = <span class="number">3199</span> - <span class="number">3199</span> * (-duty2/<span class="number">100.0</span>);</span><br><span class="line">        DL_TimerA_setCaptureCompareValue(PWM_MOTOR_INST, compareValue, DL_TIMER_CC_1_INDEX);  </span><br><span class="line">        DL_GPIO_setPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(duty2 &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        compareValue = <span class="number">3199</span> - <span class="number">3199</span> * (duty2/<span class="number">100.0</span>);</span><br><span class="line">        DL_TimerA_setCaptureCompareValue(PWM_MOTOR_INST, compareValue, DL_TIMER_CC_1_INDEX);</span><br><span class="line">        DL_GPIO_setPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>头文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义简化写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AIN1(x)   x?DL_GPIO_setPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN):DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AIN2(x)   x?DL_GPIO_setPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN):DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN1(x)   x?DL_GPIO_setPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN):DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN2(x)   x?DL_GPIO_setPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN):DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_On</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Off</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Speed</span><span class="params">(<span class="type">float</span> duty1,<span class="type">float</span> duty2)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="二-pid控制算法"><a class="markdownIt-Anchor" href="#二-pid控制算法"></a> 二、PID控制算法</h2><h3 id="参数定义"><a class="markdownIt-Anchor" href="#参数定义"></a> # 参数定义</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"PID.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Serial.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"main.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"math.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Trace_Byte;<span class="comment">//循迹总状态</span></span><br><span class="line"><span class="type">uint8_t</span> Angle_PID_Flag =<span class="number">0</span>;<span class="comment">//角度环开启标志位</span></span><br><span class="line"><span class="type">uint8_t</span> CV_flag=<span class="number">0</span>;<span class="comment">//视觉循迹开启标志位</span></span><br><span class="line"><span class="type">uint8_t</span> Test_pid_flag=<span class="number">0</span>;<span class="comment">//PID调试标志位</span></span><br><span class="line"><span class="type">float</span> K_trace = <span class="number">0.0615</span>;<span class="comment">//减速系数</span></span><br><span class="line"><span class="type">float</span> Speed_midset = <span class="number">30</span>;<span class="comment">//预设直线速度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*灰度GPIO口宏定义*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO1 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_0_PORT,GPIO_TRACE_PIN_TRACE_0_PIN) == GPIO_TRACE_PIN_TRACE_0_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO2 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_1_PORT,GPIO_TRACE_PIN_TRACE_1_PIN) == GPIO_TRACE_PIN_TRACE_1_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO3 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_2_PORT,GPIO_TRACE_PIN_TRACE_2_PIN) == GPIO_TRACE_PIN_TRACE_2_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO4 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_3_PORT,GPIO_TRACE_PIN_TRACE_3_PIN) == GPIO_TRACE_PIN_TRACE_3_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO5 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_4_PORT,GPIO_TRACE_PIN_TRACE_4_PIN) == GPIO_TRACE_PIN_TRACE_4_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO6 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_5_PORT,GPIO_TRACE_PIN_TRACE_5_PIN) == GPIO_TRACE_PIN_TRACE_5_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO7 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_6_PORT,GPIO_TRACE_PIN_TRACE_6_PIN) == GPIO_TRACE_PIN_TRACE_6_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO8 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_7_PORT,GPIO_TRACE_PIN_TRACE_7_PIN) == GPIO_TRACE_PIN_TRACE_7_PIN)?1:0)</span></span><br></pre></td></tr></tbody></table></figure><p><strong>结构体类型</strong></p><p>创建结构体类型的方法，方便进行同类型变量元素组的创建，减少代码重复度。</p><p>这里定义了PID类型结构体，在之后新建其他用于PID控制的变量组时，只要用PID类型定义变量即可、</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*结构体类型定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">float</span> Kp;</span><br><span class="line"><span class="type">float</span> Ki;</span><br><span class="line"><span class="type">float</span> Kd;</span><br><span class="line"><span class="type">float</span> error;</span><br><span class="line"><span class="type">float</span> last_error;</span><br><span class="line"><span class="type">float</span> error_sum;</span><br><span class="line"><span class="type">float</span> error_difference;</span><br><span class="line"><span class="type">float</span> velocity_sum;</span><br><span class="line">}PID;</span><br></pre></td></tr></tbody></table></figure><p><strong>PID初始化相关函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PID类型变量声明*/</span></span><br><span class="line">PID Velocity;</span><br><span class="line">PID Velocity_L;</span><br><span class="line">PID trace_hd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*速度环PID*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Velocity_PID_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Velocity.Kp = <span class="number">-1.33</span>;</span><br><span class="line">    Velocity.Kd = <span class="number">-0.22</span>;</span><br><span class="line">    Velocity.Ki = <span class="number">-0.012</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Velocity_L_PID_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Velocity_L.Kp = <span class="number">-1.34</span>;</span><br><span class="line">    Velocity_L.Kd = <span class="number">-0.22</span>;</span><br><span class="line">    Velocity_L.Ki = <span class="number">-0.012</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*循迹环PID*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trace_hd_PID_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    trace_hd.Kp = <span class="number">-1.75</span>;</span><br><span class="line">    trace_hd.Kd = <span class="number">-0.65</span>;</span><br><span class="line">    trace_hd.Ki = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*PID初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Velocity_PID_Init();</span><br><span class="line">    Velocity_L_PID_Init();</span><br><span class="line">    trace_hd_PID_Init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*限幅函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I_amplitude_limiting</span><span class="params">(<span class="type">float</span> number,<span class="type">float</span> *Error_sum)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(*Error_sum &gt; number)</span><br><span class="line">{</span><br><span class="line">*Error_sum = number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*Error_sum &lt;- number)</span><br><span class="line">{</span><br><span class="line">*Error_sum = -number;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>辅助函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*限幅函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I_amplitude_limiting</span><span class="params">(<span class="type">float</span> number,<span class="type">float</span> *Error_sum)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(*Error_sum &gt; number)</span><br><span class="line">{</span><br><span class="line">*Error_sum = number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*Error_sum &lt;- number)</span><br><span class="line">{</span><br><span class="line">*Error_sum = -number;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief获取灰度巡线路数</span></span><br><span class="line"><span class="comment">  * @param    无</span></span><br><span class="line"><span class="comment">  * @retval 识别路数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">Huidu_Counter</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> hd_sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)<span class="comment">//灰度循迹个数统计</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(((~Trace_Byte)&gt;&gt;i)&amp;<span class="number">0x01</span>) hd_sum++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hd_sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief灰度状态读取函数</span></span><br><span class="line"><span class="comment">  * @param    无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_TraceData</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Trace_Byte = (Read_Huidu_IO1&lt;&lt;<span class="number">7</span>) + (Read_Huidu_IO2 &lt;&lt; <span class="number">6</span>) + (Read_Huidu_IO3 &lt;&lt; <span class="number">5</span>) + (Read_Huidu_IO4 &lt;&lt;<span class="number">4</span>) </span><br><span class="line">                 + (Read_Huidu_IO5 &lt;&lt; <span class="number">3</span>) +(Read_Huidu_IO6 &lt;&lt;<span class="number">2</span>) +(Read_Huidu_IO7 &lt;&lt;<span class="number">1</span>) + Read_Huidu_IO8;<span class="comment">//8路灰度循迹状态</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1循迹控制pd控制自适应曲线减速"><a class="markdownIt-Anchor" href="#1循迹控制pd控制自适应曲线减速"></a> 1.循迹控制（PD控制+自适应曲线减速）</h3><p>此函数包含：</p><ul><li>循迹路数统计：可用于判断小车是否脱线、循线、特征值检测</li><li>适用于圆弧的循迹状态穷举</li><li>自适应的曲线减速函数，提高循迹的稳定性</li><li>PD环控制，提高循迹的抗干扰能力与拟合程度</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*八路循迹环PID控制器*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_hd_PID</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp_hd_sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    temp_hd_sum = Huidu_Counter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(temp_hd_sum &lt;=<span class="number">2</span>)<span class="comment">//差速循迹</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span>(Trace_Byte)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xE7</span>: <span class="comment">// 1110 0111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xC3</span>: <span class="comment">// 1100 0011</span></span><br><span class="line">                trace_hd.error = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x00</span>: <span class="comment">// 0000 0000</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0F</span>: <span class="comment">// 0000 1111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x07</span>: <span class="comment">// 0000 0111</span></span><br><span class="line">                trace_hd.error = <span class="number">-9</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF0</span>: <span class="comment">// 1111 0000</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xE0</span>: <span class="comment">// 1110 0000</span></span><br><span class="line">                trace_hd.error = <span class="number">9</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xE3</span>: <span class="comment">// 1110 0011</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF7</span>: <span class="comment">// 1111 0111</span></span><br><span class="line">                trace_hd.error = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xC1</span>: <span class="comment">// 1100 0001</span></span><br><span class="line">                trace_hd.error = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF3</span>: <span class="comment">// 1111 0011</span></span><br><span class="line">                trace_hd.error = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF1</span>: <span class="comment">// 1111 0001</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFB</span>: <span class="comment">// 1111 1011</span></span><br><span class="line">                trace_hd.error = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF9</span>: <span class="comment">// 1111 1001</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFD</span>: <span class="comment">// 1111 1101</span></span><br><span class="line">                trace_hd.error = <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF8</span>: <span class="comment">// 1111 1000</span></span><br><span class="line">                trace_hd.error = <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFC</span>: <span class="comment">// 1111 1100</span></span><br><span class="line">                trace_hd.error = <span class="number">12</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFE</span>: <span class="comment">// 1111 1110</span></span><br><span class="line">                trace_hd.error = <span class="number">14</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x87</span>: <span class="comment">// 1000 0111</span></span><br><span class="line">                trace_hd.error = <span class="number">-2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xC7</span>: <span class="comment">// 1100 0111</span></span><br><span class="line">                trace_hd.error = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xEF</span>: <span class="comment">// 1110 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xCF</span>: <span class="comment">// 1100 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8F</span>: <span class="comment">// 1000 1111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xDF</span>: <span class="comment">// 1101 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-6</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x9F</span>: <span class="comment">// 1001 1111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xBF</span>: <span class="comment">// 1011 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1F</span>: <span class="comment">// 0001 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x3F</span>: <span class="comment">// 0011 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-12</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7F</span>: <span class="comment">// 0111 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-14</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFF</span>: <span class="comment">// 1111 1111</span></span><br><span class="line">                trace_hd.error = trace_hd.last_error &gt; <span class="number">0</span> ? <span class="number">16</span> : <span class="number">-16</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                trace_hd.error = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp_hd_sum &gt;= <span class="number">6</span> &amp;&amp; temp_hd_sum &lt;= <span class="number">8</span>)<span class="comment">//掉头</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//Angle_PID_Flag = 1;</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//停车</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    trace_hd.error_difference = trace_hd.error - trace_hd.last_error;</span><br><span class="line">    trace_hd.error_sum += trace_hd.error;<span class="comment">//误差累加量</span></span><br><span class="line">    trace_hd.last_error = trace_hd.error;</span><br><span class="line">    I_amplitude_limiting(<span class="number">1000</span>,&amp;trace_hd.error_sum);<span class="comment">//误差累加量限幅</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    K_trace =  <span class="number">1</span>/<span class="number">16.0</span> * <span class="built_in">pow</span>((<span class="number">1</span>-(<span class="number">20</span>/Speed_midset)),<span class="number">0.5</span>);<span class="comment">//弯道减速系数</span></span><br><span class="line">    MID_Speed = Speed_midset * (<span class="number">1</span> - (<span class="type">uint8_t</span>)(trace_hd.error)*K_trace) * (<span class="number">1</span> + (<span class="type">uint8_t</span>)(trace_hd.error)*K_trace);<span class="comment">//基准速度变换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> trace_hd.error*trace_hd.Kp  + trace_hd.error_difference * trace_hd.Kd;<span class="comment">//PD环循迹，比例+积分</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2陀螺仪角度环小车姿态控制"><a class="markdownIt-Anchor" href="#2陀螺仪角度环小车姿态控制"></a> 2.陀螺仪角度环(小车姿态控制)</h3><p>此函数功能：</p><ul><li>输入陀螺仪传感器测量的姿态，进行PID解算</li><li>PD环控制，确保小车转向迅速并且稳定。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*转向环PID控制器*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_imu_PID</span><span class="params">(<span class="type">int</span> yaw, <span class="type">int</span> caclu_yaw)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">float</span> Kp = <span class="number">-1.35</span>;</span><br><span class="line">    <span class="type">float</span> Kd = <span class="number">-9.5</span>;</span><br><span class="line">    <span class="type">float</span> Ki = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> error ;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> last_error;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> error_diff;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> error_sum;</span><br><span class="line"></span><br><span class="line">    error = yaw -caclu_yaw;</span><br><span class="line">    error_sum += error;</span><br><span class="line"></span><br><span class="line">    I_amplitude_limiting(<span class="number">1000</span>,&amp;error_sum);<span class="comment">//误差累加量限幅</span></span><br><span class="line"></span><br><span class="line">    error_diff = error-last_error;</span><br><span class="line">    last_error = error;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error &gt; <span class="number">180</span>) <span class="comment">// 防止小车转到180度时一直旋转的问题</span></span><br><span class="line">        error = error - <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">-180</span>)</span><br><span class="line">        error = error + <span class="number">360</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Kp * error + Kd * error_diff + Ki*error_sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>PID头文件</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Trace_Byte;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Angle_PID_Flag;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Test_pid_flag;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> Speed_midset;<span class="comment">//预设直线速度</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_cv_PID</span><span class="params">(<span class="type">int</span> measure, <span class="type">int</span> caclu)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_hd_PID</span><span class="params">()</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_hd_PID_Seven</span><span class="params">()</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Velocity_PID_L</span><span class="params">(<span class="type">float</span> velocity,<span class="type">float</span> velocity_calcu)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Velocity_PID_R</span><span class="params">(<span class="type">float</span> velocity,<span class="type">float</span> velocity_calcu)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_TraceData</span><span class="params">()</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_imu_PID</span><span class="params">(<span class="type">int</span> yaw, <span class="type">int</span> caclu_yaw)</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">Huidu_Counter</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="三-陀螺仪串口通信"><a class="markdownIt-Anchor" href="#三-陀螺仪串口通信"></a> 三、陀螺仪串口通信</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接收变量</span></span><br><span class="line"><span class="type">uint8_t</span> RollL, RollH, PitchL, PitchH, YawL, YawH, VL, VH, SUM;</span><br><span class="line"><span class="type">float</span> Pitch,Roll,Yaw;</span><br><span class="line"><span class="comment">// 串口接收状态标识</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_HEADER1 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_HEADER2 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECEIVE_DATA 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxState_JY = WAIT_HEADER1;</span><br><span class="line"><span class="type">uint8_t</span> receivedData[<span class="number">9</span>];</span><br><span class="line"><span class="type">uint8_t</span> dataIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送置偏航角置零命令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_JY61P_Zero_Yaw</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X69</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X88</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XB5</span>);</span><br><span class="line">delay_ms(<span class="number">100</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X01</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X04</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line">delay_ms(<span class="number">100</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>头文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __JY61P_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __JY61P_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_JY61P_Zero_Yaw</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_JY61P_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> Pitch,Roll,Yaw;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="四-常规外设串口通信"><a class="markdownIt-Anchor" href="#四-常规外设串口通信"></a> 四、常规外设串口通信</h2><h3 id="1-变量声明"><a class="markdownIt-Anchor" href="#1-变量声明"></a> 1. 变量声明</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"main.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 256  <span class="comment">// 定义缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">100</span>];</span><br><span class="line"><span class="comment">/*PID调试*/</span></span><br><span class="line"><span class="type">float</span> Test_Kp;<span class="comment">//比例</span></span><br><span class="line"><span class="type">float</span> Test_Ki;<span class="comment">//积分</span></span><br><span class="line"><span class="type">float</span> Test_Kd;<span class="comment">//微分</span></span><br><span class="line"><span class="type">float</span> Test_Ks;<span class="comment">//目标速度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*系统调试串口变量*/</span></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"><span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> pRxState;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="type">uint8_t</span> RxData_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上位机串口变量*/</span></span><br><span class="line"><span class="type">uint8_t</span> Soc_RxFlag;</span><br><span class="line"><span class="type">uint8_t</span> RxState_SOC = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> SOC_RxData_type;</span><br><span class="line"><span class="type">uint8_t</span> SOC_pRxState;<span class="comment">//串口接收数据索引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口屏串口变量*/</span></span><br><span class="line"><span class="type">uint8_t</span> Screen_RxFlag;</span><br><span class="line"><span class="type">uint8_t</span> RxState_Screen;</span><br><span class="line"><span class="type">uint8_t</span> Screen_RxData_type;</span><br><span class="line"><span class="type">uint8_t</span> Screen_pRxState;<span class="comment">//串口接收数据索引号</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">100</span>];</span><br></pre></td></tr></tbody></table></figure><h2 id="2-辅助函数"><a class="markdownIt-Anchor" href="#2-辅助函数"></a> 2. 辅助函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统串口初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SYS_UART0_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">NVIC_ClearPendingIRQ(UART_0_INST_INT_IRQN);</span><br><span class="line">NVIC_EnableIRQ(UART_0_INST_INT_IRQN);</span><br><span class="line">    DL_UART_clearInterruptStatus(UART_0_INST,DL_UART_INTERRUPT_RX);<span class="comment">//清除中断标志位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//SOC通信串口初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SOC_UART1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">NVIC_ClearPendingIRQ(UART_SOC_INST_INT_IRQN);</span><br><span class="line">NVIC_EnableIRQ(UART_SOC_INST_INT_IRQN);</span><br><span class="line">    DL_UART_clearInterruptStatus(UART_SOC_INST,DL_UART_INTERRUPT_RX);<span class="comment">//清除中断标志位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符串给SOC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SOC_SendString</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">'\0'</span>)</span><br><span class="line">    {</span><br><span class="line">        DL_UART_Main_transmitDataBlocking(UART_SOC_INST, *str++);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口屏通信串口初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Screen_UART2_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">NVIC_ClearPendingIRQ(UART_Screen_INST_INT_IRQN);</span><br><span class="line">NVIC_EnableIRQ(UART_Screen_INST_INT_IRQN);</span><br><span class="line">    DL_UART_clearInterruptStatus(UART_Screen_INST,DL_UART_INTERRUPT_RX);<span class="comment">//清除中断标志位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符串给串口屏</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Screen_SendString</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">'\0'</span>)</span><br><span class="line">    {</span><br><span class="line">        DL_UART_Main_transmitDataBlocking(UART_Screen_INST, *str++);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int_to_binary_string</span><span class="params">(<span class="type">uint32_t</span> value, <span class="type">char</span> *binary_str, <span class="type">int</span> max_bits)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 生成二进制字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = max_bits - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    {</span><br><span class="line">        binary_str[i] = (value &amp; (<span class="number">1U</span> &lt;&lt; i)) ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">    }</span><br><span class="line">    binary_str[max_bits] = <span class="string">'\0'</span>; <span class="comment">// 确保字符串以 null 结尾</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将浮点数转换为字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">float_to_string</span><span class="params">(<span class="type">float</span> value, <span class="type">char</span> *str, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">snprintf</span>(str, size, <span class="string">"%.2f"</span>, value); <span class="comment">// 格式化为两位小数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_send_string</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *showdata)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造要发送的字符串，确保缓冲区足够大</span></span><br><span class="line">    length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"%s=\"%s\"\xff\xff\xff"</span>, name, showdata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否发生了缓冲区溢出</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt;= <span class="keyword">sizeof</span>(buffer))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理，例如可以通过截断字符串或者增加缓冲区大小来解决</span></span><br><span class="line">        <span class="comment">// 这里只是简单地截断字符串以确保不会发送超出缓冲区的内容</span></span><br><span class="line">        buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>; <span class="comment">// 确保字符串以 null 结尾</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Screen_SendString 发送构造好的字符串</span></span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_send_number</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"%s=%d\xff\xff\xff"</span>, name, num);</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= BUFFER_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理</span></span><br><span class="line">    }</span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_send_float</span><span class="params">(<span class="type">char</span>* name, <span class="type">float</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> num_int = (<span class="type">int</span>)(num * <span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"%s=%d\xff\xff\xff"</span>, name, num_int);</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= BUFFER_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理</span></span><br><span class="line">    }</span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_Wave</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> ch, <span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"add %s,%d,%d\xff\xff\xff"</span>, name, ch, val);</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= BUFFER_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理</span></span><br><span class="line">    }</span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_Wave_Fast</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> ch, <span class="type">int</span> count, <span class="type">int</span>* show_data)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"addt %s,%d,%d\xff\xff\xff"</span>, name, ch, count);</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= BUFFER_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理</span></span><br><span class="line">    }</span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 发送每个字符</span></span><br><span class="line">        DL_UART_Main_transmitDataBlocking(UART_Screen_INST, (<span class="type">char</span>)show_data[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发送结束标志</span></span><br><span class="line">    Screen_SendString(<span class="string">"\xff\xff\xff"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_Wave_Clear</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> ch)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"cle %s,%d\xff\xff\xff"</span>, name, ch);</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= BUFFER_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理</span></span><br><span class="line">    }</span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="程序结构-中断服务函数"><a class="markdownIt-Anchor" href="#程序结构-中断服务函数"></a> 程序结构-中断服务函数</h1><h2 id="1常规串口中断"><a class="markdownIt-Anchor" href="#1常规串口中断"></a> 1.常规串口中断</h2><ul><li>Uart0: 系统串口，用作与计算机通信调试</li><li>Uart_Screen：串口屏串口，用于和串口屏进行通信调试，串口屏可以直接控制小车，也可以显示小车实时参数</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_0_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (DL_UART_Main_getPendingInterrupt(UART_0_INST)) {<span class="comment">//判断中断的类型，DL_UART_Main_getPendingInterrupt(UART_0_INST)调用具有清空标志位的功能？</span></span><br><span class="line">        <span class="keyword">case</span> DL_UART_MAIN_IIDX_RX:<span class="comment">//如果触发串口接收事件</span></span><br><span class="line">       RxData = DL_UART_Main_receiveData(UART_0_INST);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)<span class="comment">//帧头检测</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'#'</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">1</span>)<span class="comment">//数据类型检测s</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">switch</span>(RxData)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="string">'P'</span>:<span class="comment">//x+</span></span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">RxData_type=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'I'</span>:<span class="comment">//x-</span></span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">RxData_type=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'D'</span>:<span class="comment">//x-</span></span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">RxData_type=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">RxData_type=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)<span class="comment">//数据，接收范围限制在单字节，足够完成任务要求</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'!'</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">RxState=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line">pRxState++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Screen_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (DL_UART_Main_getPendingInterrupt(UART_Screen_INST))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> DL_UART_MAIN_IIDX_RX:<span class="comment">//如果触发串口接收事件</span></span><br><span class="line">            RxData = DL_UART_Main_receiveData(UART_Screen_INST);</span><br><span class="line">            <span class="keyword">if</span>(RxState_Screen == <span class="number">0</span>)<span class="comment">//帧头检测</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(RxData == <span class="number">0xEF</span> &amp;&amp; Screen_RxFlag == <span class="number">0</span>)</span><br><span class="line">                {</span><br><span class="line">                    RxState_Screen = <span class="number">1</span>;<span class="comment">//串口屏的数据帧</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(RxState_Screen == <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                Serial_RxPacket[<span class="number">0</span>]=RxData;</span><br><span class="line">                RxState_Screen = <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(RxState_Screen == <span class="number">2</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(RxData == <span class="number">0xEE</span>)</span><br><span class="line">                {</span><br><span class="line">                    Screen_RxFlag=<span class="number">1</span>;</span><br><span class="line">                    RxState_Screen=<span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-陀螺仪串口中断函数"><a class="markdownIt-Anchor" href="#2-陀螺仪串口中断函数"></a> 2. 陀螺仪串口中断函数</h2><p>用于处理从陀螺仪传感器接收到的通信数据，其中主要的部分是Roll，Pitch，Yaw角</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串口中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_JY61P_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">uint8_t</span> uartdata = DL_UART_Main_receiveData(UART_JY61P_INST); <span class="comment">// 接收一个uint8_t数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (RxState_JY) {</span><br><span class="line">    <span class="keyword">case</span> WAIT_HEADER1:</span><br><span class="line">        <span class="keyword">if</span> (uartdata == <span class="number">0x55</span>) {</span><br><span class="line">            RxState_JY = WAIT_HEADER2;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WAIT_HEADER2:</span><br><span class="line">        <span class="keyword">if</span> (uartdata == <span class="number">0x53</span>) {</span><br><span class="line">            RxState_JY = RECEIVE_DATA;</span><br><span class="line">            dataIndex = <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            RxState_JY = WAIT_HEADER1; <span class="comment">// 如果不是期望的第二个头，重置状态</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RECEIVE_DATA:</span><br><span class="line">        receivedData[dataIndex++] = uartdata;</span><br><span class="line">        <span class="keyword">if</span> (dataIndex == <span class="number">9</span>) {</span><br><span class="line">            <span class="comment">// 数据接收完毕，分配给具体的变量</span></span><br><span class="line">            RollL = receivedData[<span class="number">0</span>];</span><br><span class="line">            RollH = receivedData[<span class="number">1</span>];</span><br><span class="line">            PitchL = receivedData[<span class="number">2</span>];</span><br><span class="line">            PitchH = receivedData[<span class="number">3</span>];</span><br><span class="line">            YawL = receivedData[<span class="number">4</span>];</span><br><span class="line">            YawH = receivedData[<span class="number">5</span>];</span><br><span class="line">            VL = receivedData[<span class="number">6</span>];</span><br><span class="line">            VH = receivedData[<span class="number">7</span>];</span><br><span class="line">            SUM = receivedData[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验SUM是否正确</span></span><br><span class="line">            <span class="type">uint8_t</span> calculatedSum = <span class="number">0x55</span> + <span class="number">0x53</span> + RollH + RollL + PitchH + PitchL + YawH + YawL + VH + VL;</span><br><span class="line">            <span class="keyword">if</span> (calculatedSum == SUM) {</span><br><span class="line">                <span class="comment">// 校验成功，可以进行后续处理</span></span><br><span class="line">                <span class="keyword">if</span>((<span class="type">float</span>)(((<span class="type">uint16_t</span>)RollH &lt;&lt; <span class="number">8</span>) | RollL)/<span class="number">32768</span>*<span class="number">180</span>&gt;<span class="number">180</span>){</span><br><span class="line">                    Roll = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)RollH &lt;&lt; <span class="number">8</span>) | RollL)/<span class="number">32768</span>*<span class="number">180</span> - <span class="number">360</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    Roll = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)RollH &lt;&lt; <span class="number">8</span>) | RollL)/<span class="number">32768</span>*<span class="number">180</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>((<span class="type">float</span>)(((<span class="type">uint16_t</span>)PitchH &lt;&lt; <span class="number">8</span>) | PitchL)/<span class="number">32768</span>*<span class="number">180</span>&gt;<span class="number">180</span>){</span><br><span class="line">                    Pitch = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)PitchH &lt;&lt; <span class="number">8</span>) | PitchL)/<span class="number">32768</span>*<span class="number">180</span> - <span class="number">360</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    Pitch = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)PitchH &lt;&lt; <span class="number">8</span>) | PitchL)/<span class="number">32768</span>*<span class="number">180</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>((<span class="type">float</span>)(((<span class="type">uint16_t</span>)YawH &lt;&lt; <span class="number">8</span>) | YawL)/<span class="number">32768</span>*<span class="number">180</span> &gt;<span class="number">180</span>){</span><br><span class="line">                    Yaw = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)YawH &lt;&lt; <span class="number">8</span>) | YawL)/<span class="number">32768</span>*<span class="number">180</span> - <span class="number">360</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    Yaw = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)YawH &lt;&lt; <span class="number">8</span>) | YawL)/<span class="number">32768</span>*<span class="number">180</span>;</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 校验失败，处理错误</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            RxState_JY = WAIT_HEADER1; <span class="comment">// 重置状态以等待下一个数据包</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//DL_UART_Main_transmitData(UART_JY61P_INST, uartdata); // 可选：回传接收到的数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="程序结构-任务进程"><a class="markdownIt-Anchor" href="#程序结构-任务进程"></a> 程序结构-任务进程</h1><p>在此文件中，定义各种不同的任务</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Process.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************串口进程*********************************/</span></span><br><span class="line"><span class="comment">/*系统串口(UART1)解码进程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SYS_RxPro</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*PID调试*/</span></span><br><span class="line">    <span class="keyword">if</span>(Serial_RxFlag)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span>(RxData_type)<span class="comment">//判断数据帧的数据类型</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span>(pRxState == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Kp = Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">2</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Kp = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Kp = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">100</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">2</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span>(pRxState == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ki = Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">2</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ki = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ki = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">100</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">2</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span>(pRxState == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Kd = Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">2</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Kd = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line"></span><br><span class="line">                    Test_Kd = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">100</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">2</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span>(pRxState == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ks = Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">2</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ks = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ks = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">100</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">2</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        Serial_RxFlag=<span class="number">0</span>;</span><br><span class="line">        pRxState=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口屏通信解码进程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Screen_RxPro</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(Screen_RxFlag == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span>(Serial_RxPacket[<span class="number">0</span>])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Motor_On();</span><br><span class="line">                Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(System_Mode == <span class="number">0</span> | System_Mode == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    yaw_detect = yaw_val;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    yaw_detect = yaw_val - LX_3_IMU_ANGEL_1;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                Motor_flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                Serial_JY61P_Zero_Yaw();</span><br><span class="line">                Motor_Off();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//PID参数模式切换：调试模式&lt;-&gt;固定模式</span></span><br><span class="line">                Test_pid_flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                Test_pid_flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        DL_UART_Main_transmitData(UART_Screen_INST,Serial_RxPacket[<span class="number">0</span>]);</span><br><span class="line">        Screen_RxFlag=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************特殊功能进程**********************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Beep_Proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(beep_flag == <span class="number">1</span> || beep_key_flag == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        DL_GPIO_setPins(GPIO_BEEP_PORT,GPIO_BEEP_PIN_1_PIN);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        DL_GPIO_clearPins(GPIO_BEEP_PORT,GPIO_BEEP_PIN_1_PIN);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*OlED进程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Oled_Proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    OLED_ShowString(<span class="number">0</span>, <span class="number">8</span>,<span class="string">"Mode:"</span>,<span class="number">8</span>);</span><br><span class="line">    OLED_ShowNum(<span class="number">42</span>, <span class="number">8</span>, System_Mode+<span class="number">1</span>, <span class="number">1</span> ,<span class="number">8</span>);</span><br><span class="line">    OLED_ShowBinNum(<span class="number">0</span>, <span class="number">28</span>, Trace_Byte, <span class="number">8</span> ,<span class="number">8</span>);</span><br><span class="line">    OLED_ShowSignedNum(<span class="number">0</span>, <span class="number">45</span>,Yaw,<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line">    OLED_Update();    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口屏进程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_Proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    int_to_binary_string(Trace_Byte, data_HMI, <span class="number">8</span>);</span><br><span class="line">    HMI_send_string(hmi_trace, data_HMI);<span class="comment">//串口屏打印循迹状态</span></span><br><span class="line"></span><br><span class="line">    float_to_string(Yaw,data_HMI,<span class="number">8</span>);</span><br><span class="line">    HMI_send_string(hmi_yaw, data_HMI);<span class="comment">//串口屏打印陀螺仪实际的Yaw角度</span></span><br><span class="line"></span><br><span class="line">    float_to_string(M_Speed_L,data_HMI,<span class="number">8</span>);</span><br><span class="line">    HMI_send_string(hmi_speed, data_HMI);<span class="comment">//串口屏打印速度</span></span><br><span class="line"></span><br><span class="line">    float_to_string(System_Mode,data_HMI,<span class="number">8</span>);</span><br><span class="line">    HMI_send_string(hmi_imu, data_HMI);<span class="comment">//串口屏打印单片机记忆的Yaw角度</span></span><br><span class="line"></span><br><span class="line">    float_to_string(NEncoder.right_motor_total_cnt,data_HMI,<span class="number">8</span>);</span><br><span class="line">    HMI_send_string(hmi_totol, data_HMI);<span class="comment">//串口屏打印总的脉冲数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(Key_Down)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            beep_key_flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(++System_Mode == <span class="number">4</span>)</span><br><span class="line">            {</span><br><span class="line">                System_Mode = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            Motor_On();</span><br><span class="line">            Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line">            Speed_midset = Speed_ZX;</span><br><span class="line">            <span class="keyword">if</span>(System_Mode == <span class="number">0</span> | System_Mode == <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                yaw_detect = yaw_val;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            {</span><br><span class="line">                yaw_detect = yaw_val - LX_3_IMU_ANGEL_1;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Motor_flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            Motor_flag = <span class="number">0</span>;</span><br><span class="line">            Serial_JY61P_Zero_Yaw();</span><br><span class="line">            Motor_Off();            </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="程序结构-路径规划"><a class="markdownIt-Anchor" href="#程序结构-路径规划"></a> 程序结构-路径规划</h1><h2 id="1-路径1"><a class="markdownIt-Anchor" href="#1-路径1"></a> 1. 路径1</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************路线进程***********************************/</span></span><br><span class="line"><span class="comment">//要求1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LX_Proc_1</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp_hd_sum;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> LX_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    temp_hd_sum =  Huidu_Counter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(LX_state ==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        Speed_midset = <span class="number">30</span> - NEncoder.right_motor_total_cnt/<span class="number">8000</span> * <span class="number">15.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp_hd_sum &gt;=<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            beep_flag = <span class="number">1</span>;</span><br><span class="line">            LX_state = <span class="number">1</span>;</span><br><span class="line">            Motor_Off();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-路径2"><a class="markdownIt-Anchor" href="#2-路径2"></a> 2. 路径2</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LX_Proc_2</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp_hd_sum;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> LX_state = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> LuChen_Counter;</span><br><span class="line">    </span><br><span class="line">    temp_hd_sum =  Huidu_Counter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LuChen_Counter = (NEncoder.left_motor_total_cnt + NEncoder.right_motor_total_cnt)/2;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(LX_state ==<span class="number">0</span>)<span class="comment">//从A触发</span></span><br><span class="line">    {</span><br><span class="line">        Speed_midset = <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp_hd_sum &gt;=<span class="number">1</span>)<span class="comment">//碰到B</span></span><br><span class="line">        {</span><br><span class="line">            Speed_midset = <span class="number">35</span>;</span><br><span class="line">            LX_state = <span class="number">1</span>;</span><br><span class="line">            Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">            beep_flag = <span class="number">1</span>;</span><br><span class="line">            motor_total_cnt_reset();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">1</span>)<span class="comment">//从B出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt;= <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到C</span></span><br><span class="line">            {</span><br><span class="line">                Speed_midset = <span class="number">40</span>;</span><br><span class="line">                yaw_detect -= LX_2_IMU_ANGEL;</span><br><span class="line">                Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">2</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">            }                   </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">2</span>)<span class="comment">//从C出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(temp_hd_sum &gt;= <span class="number">1</span>)<span class="comment">//碰到D</span></span><br><span class="line">        {</span><br><span class="line">            motor_total_cnt_reset();</span><br><span class="line">            Speed_midset = <span class="number">35</span>;</span><br><span class="line">            Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">            LX_state = <span class="number">3</span>;</span><br><span class="line">            beep_flag = <span class="number">1</span>;     </span><br><span class="line">        }    </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">3</span>)<span class="comment">//从D出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt;= <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到A</span></span><br><span class="line">            {</span><br><span class="line">                LX_state = <span class="number">4</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                Motor_Off();</span><br><span class="line">            }                 </span><br><span class="line">        }</span><br><span class="line">                   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-路径3"><a class="markdownIt-Anchor" href="#3-路径3"></a> 3. 路径3</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求3</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LX_Proc_3</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp_hd_sum;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> LX_state = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    temp_hd_sum =  Huidu_Counter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(LX_state ==<span class="number">0</span>)<span class="comment">//从A触发</span></span><br><span class="line">    {</span><br><span class="line">        Speed_midset=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(Angle_PID_Flag)</span><br><span class="line">        {</span><br><span class="line">            Timer_Angel_Sleep_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fabsf(Yaw - yaw_detect) &lt;= <span class="number">1.5</span>)</span><br><span class="line">            {</span><br><span class="line">                Speed_midset=Speed_ZX<span class="number">-15</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">11</span>;</span><br><span class="line">            }            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">11</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp_hd_sum &gt;=<span class="number">1</span>)<span class="comment">//碰到C</span></span><br><span class="line">        {</span><br><span class="line">            Speed_midset=Speed_WD<span class="number">-10</span>;</span><br><span class="line">            LX_state = <span class="number">1</span>;</span><br><span class="line">            Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">            beep_flag = <span class="number">1</span>;</span><br><span class="line">            motor_total_cnt_reset();</span><br><span class="line">        }        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">1</span>)<span class="comment">//从C出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到B</span></span><br><span class="line">            {</span><br><span class="line">                Speed_midset=Speed_ZX<span class="number">-15</span>;</span><br><span class="line">                yaw_detect = yaw_val + LX_4_IMU_ANGEL_1 + <span class="number">0.5</span>;</span><br><span class="line">                Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">2</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">            }                    </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">2</span>)<span class="comment">//从B出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(temp_hd_sum &gt;= <span class="number">1</span>)<span class="comment">//碰到D</span></span><br><span class="line">        {</span><br><span class="line">            Speed_midset=Speed_WD<span class="number">-10</span>;</span><br><span class="line">            Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">            LX_state = <span class="number">3</span>;</span><br><span class="line">            beep_flag = <span class="number">1</span>;     </span><br><span class="line">            motor_total_cnt_reset();</span><br><span class="line">        }    </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">3</span>)<span class="comment">//从D出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到A</span></span><br><span class="line">            {</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">4</span>;</span><br><span class="line">                Motor_Off();</span><br><span class="line">            }              </span><br><span class="line">        }             </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-路径4"><a class="markdownIt-Anchor" href="#4-路径4"></a> 4. 路径4</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求4</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LX_Proc_4</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp_hd_sum;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> LX_state = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line">    temp_hd_sum =  Huidu_Counter();</span><br><span class="line">    K_ZX = <span class="number">1</span>-(<span class="number">20</span>/Speed_ZX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(LX_state ==<span class="number">0</span>)<span class="comment">//从A触发</span></span><br><span class="line">    {</span><br><span class="line">        Speed_midset=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Angle_PID_Flag)</span><br><span class="line">        {</span><br><span class="line">            Timer_Angel_Sleep_flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(fabsf(Yaw - yaw_detect) &lt;= <span class="number">1.5</span>)</span><br><span class="line">            {</span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line"></span><br><span class="line">                Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX * K_ZX);</span><br><span class="line"></span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">11</span>;</span><br><span class="line">            }            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">11</span>)</span><br><span class="line">    {</span><br><span class="line">        Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX *K_ZX);</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">4000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum &gt;=<span class="number">1</span>)<span class="comment">//碰到C</span></span><br><span class="line">            {</span><br><span class="line">                Speed_midset=Speed_WD;</span><br><span class="line">                LX_state = <span class="number">1</span>;</span><br><span class="line">                Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line">     </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">1</span>)<span class="comment">//从C出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到B</span></span><br><span class="line">            {</span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line">                Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX * K_ZX);</span><br><span class="line">                yaw_detect = yaw_val + LX_4_IMU_ANGEL_1 + <span class="number">0.65</span>;</span><br><span class="line">                Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">2</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">            }                    </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">2</span>)<span class="comment">//从B出发</span></span><br><span class="line">    {</span><br><span class="line">        Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX * K_ZX);</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">4000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum &gt;= <span class="number">1</span>)<span class="comment">//碰到D</span></span><br><span class="line">            {</span><br><span class="line">                Speed_midset=Speed_WD;</span><br><span class="line">                Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">                LX_state = <span class="number">3</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;     </span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line">                    Speed_midset = Speed_WD - <span class="number">5</span>;</span><br><span class="line">                }</span><br><span class="line">            }              </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">3</span>)<span class="comment">//从D出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到A</span></span><br><span class="line">            {</span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line">                Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX * K_ZX);</span><br><span class="line">                LX_state = <span class="number">12</span>;</span><br><span class="line">                Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line">                yaw_detect = yaw_val - LX_4_IMU_ANGEL_1 + <span class="number">1.0</span>;                </span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(++i&gt;=<span class="number">4</span>)</span><br><span class="line">                {</span><br><span class="line">                    LX_state = <span class="number">4</span>;</span><br><span class="line">                    Motor_Off();</span><br><span class="line">                }</span><br><span class="line">            }              </span><br><span class="line">        }             </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">12</span>)<span class="comment">//从A出发</span></span><br><span class="line">    {</span><br><span class="line">        Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX * K_ZX);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">4000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum &gt;= <span class="number">1</span>)<span class="comment">//碰到C</span></span><br><span class="line">            {</span><br><span class="line">                Speed_midset=Speed_WD;</span><br><span class="line">                Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">                LX_state = <span class="number">1</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;     </span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line">            }       </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="程序结构-主程序"><a class="markdownIt-Anchor" href="#程序结构-主程序"></a> 程序结构-主程序</h1><h2 id="1-参数声明"><a class="markdownIt-Anchor" href="#1-参数声明"></a> 1. 参数声明</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"main.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Serial.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"nqei.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti/driverlib/dl_gpio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Path.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Key_Number;<span class="comment">//按键调试 </span></span><br><span class="line"><span class="type">uint8_t</span> Key_Val,Key_Down,Key_Up,Key_Old;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PS:PWM可调范围，0~100以内任意浮点数</span></span><br><span class="line"><span class="type">float</span> MT_L = <span class="number">20.0</span>;<span class="comment">//左轮速度初值</span></span><br><span class="line"><span class="type">float</span> MT_R = <span class="number">20.0</span>;<span class="comment">//右轮速度初值</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxData;<span class="comment">//串口接收寄存器存储变量</span></span><br><span class="line"><span class="type">uint8_t</span> MID_Speed;<span class="comment">//基准速度</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> yaw_val;<span class="comment">//记录Yaw角</span></span><br><span class="line"><span class="type">float</span> yaw_detect;<span class="comment">//预测yaw角</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> Velocity_IL,Velocity_IR;<span class="comment">//左右轮速度环PID输入</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> Dif_Out;<span class="comment">//差速环PID输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Motor_flag;<span class="comment">//电机使能标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> M_Speed_L;<span class="comment">//左轮测速</span></span><br><span class="line"><span class="type">float</span> M_Speed_R;<span class="comment">//右轮测速</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Timer_Angel_Sleep;</span><br><span class="line"><span class="type">uint8_t</span> Timer_Angel_Sleep_flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外设列表：</span></span><br><span class="line"><span class="comment">//1.GPIO        LED</span></span><br><span class="line"><span class="comment">//2.PWM         定时器G0,两路PWM</span></span><br><span class="line"><span class="comment">//3.定时器      定时器A0</span></span><br><span class="line"><span class="comment">//4.串口        USART0:调试串口</span></span><br><span class="line"><span class="comment">//5.按键      </span></span><br><span class="line"><span class="comment">//6.OLED      硬件IIC</span></span><br><span class="line"><span class="comment">//7.MPU6050   硬件IIC</span></span><br><span class="line"><span class="comment">//8.串口屏</span></span><br><span class="line"><span class="comment">//9.陀螺仪串口</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> beep_flag = <span class="number">0</span>;<span class="comment">//声光提示标志位</span></span><br><span class="line"><span class="type">uint8_t</span> beep_key_flag;<span class="comment">//按键提示音</span></span><br><span class="line"><span class="type">uint8_t</span> beep_timer = <span class="number">0</span>;<span class="comment">//声光提示持续时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> hmi_speed[]=<span class="string">"n1.txt"</span>;<span class="comment">//测速</span></span><br><span class="line"><span class="type">char</span> hmi_yaw[]=<span class="string">"n2.txt"</span>;<span class="comment">//测角度</span></span><br><span class="line"><span class="type">char</span> hmi_trace[]=<span class="string">"n3.txt"</span>;<span class="comment">//测循迹</span></span><br><span class="line"><span class="type">char</span> hmi_totol[]=<span class="string">"n4.txt"</span>;<span class="comment">//测里程</span></span><br><span class="line"><span class="type">char</span> hmi_imu[]=<span class="string">"n5.txt"</span>;<span class="comment">//测记忆角度</span></span><br><span class="line"><span class="type">char</span> data_HMI[]=<span class="string">""</span>;<span class="comment">//串口屏数据存储空间</span></span><br><span class="line"><span class="type">uint8_t</span> Key_Timer;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Timer_1ms_counter;</span><br><span class="line"><span class="type">uint8_t</span> System_Mode;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> WD_Protect_Flag;</span><br><span class="line"><span class="type">uint8_t</span> WD_Protect_time;</span><br><span class="line"><span class="type">uint8_t</span> WD_Protect_err;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> K_ZX = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*初始加速函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Speed_InitPro</span><span class="params">(<span class="type">uint8_t</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">    {</span><br><span class="line">        Set_Speed(i,i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-主循环"><a class="markdownIt-Anchor" href="#2-主循环"></a> 2. 主循环</h2><p>执行系统所需要的初始化部分，注意初始化的顺序。</p><p>用于显示的部分放在主循环中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始加速函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Speed_InitPro</span><span class="params">(<span class="type">uint8_t</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">    {</span><br><span class="line">        Set_Speed(i,i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*开启系统时钟中断，会导致串口工作异常或者程序卡死*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SYSCFG_DL_init();<span class="comment">//syscfg初始化</span></span><br><span class="line">    delay_ms(<span class="number">100</span>);<span class="comment">//等待初始化稳定</span></span><br><span class="line">    OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">    OLED_ShowString(<span class="number">16</span>,<span class="number">8</span>,<span class="string">"OK"</span>,<span class="number">8</span>);</span><br><span class="line">    delay_ms(<span class="number">100</span>);<span class="comment">//等待陀螺仪稳定</span></span><br><span class="line">    Motor_Off();<span class="comment">//初始电机关闭，等待按键控制</span></span><br><span class="line">    </span><br><span class="line">    SYS_UART0_Init();<span class="comment">//串口0初始化</span></span><br><span class="line">    Screen_UART2_Init();<span class="comment">//串口2初始化</span></span><br><span class="line"></span><br><span class="line">    BP_Encoder_Init();<span class="comment">//编码器初始化</span></span><br><span class="line">    PID_Init();</span><br><span class="line">    delay_ms(<span class="number">1000</span>);<span class="comment">//等待初始化稳定</span></span><br><span class="line">    <span class="comment">//Speed_InitPro(Speed_midset*0.8);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编码器中断使能</span></span><br><span class="line">    delay_ms(<span class="number">50</span>);<span class="comment">//等待初始化稳定</span></span><br><span class="line">    TIMER_1_Init();<span class="comment">//定时器1初始化</span></span><br><span class="line">    TIMER_2_Init();</span><br><span class="line"></span><br><span class="line">    NVIC_EnableIRQ(UART_JY61P_INST_INT_IRQN);  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    { </span><br><span class="line">        Oled_Proc();</span><br><span class="line">        HMI_Proc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="维特陀螺仪"><a class="markdownIt-Anchor" href="#维特陀螺仪"></a> 维特陀螺仪</h1><h2 id="一-通信协议"><a class="markdownIt-Anchor" href="#一-通信协议"></a> 一、通信协议</h2><img src="/posts/37775/image-20241011224055889.png" class="" title="image-20241011224055889"><h3 id="11-读格式"><a class="markdownIt-Anchor" href="#11-读格式"></a> 1.1 读格式</h3><img src="/posts/37775/image-20241011224134268.png" class="" title="image-20241011224134268"><p>代码实现（仅读取角度）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接收变量</span></span><br><span class="line"><span class="type">uint8_t</span> RollL, RollH, PitchL, PitchH, YawL, YawH, VL, VH, SUM;</span><br><span class="line"><span class="type">float</span> Pitch,Roll,Yaw;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 串口接收状态标识</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_HEADER1 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_HEADER2 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECEIVE_DATA 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxState_JY = WAIT_HEADER1;</span><br><span class="line"><span class="type">uint8_t</span> receivedData[<span class="number">9</span>];<span class="comment">//接收数据储存数组</span></span><br><span class="line"><span class="type">uint8_t</span> dataIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 串口中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_JY61P_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">uint8_t</span> uartdata = DL_UART_Main_receiveData(UART_JY61P_INST); <span class="comment">// 接收一个uint8_t数据</span></span><br><span class="line">    <span class="keyword">switch</span> (RxState_JY) {</span><br><span class="line">    <span class="keyword">case</span> WAIT_HEADER1:</span><br><span class="line">        <span class="keyword">if</span> (uartdata == <span class="number">0x55</span>) { <span class="comment">//协议头</span></span><br><span class="line">            RxState_JY = WAIT_HEADER2;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WAIT_HEADER2:</span><br><span class="line">        <span class="keyword">if</span> (uartdata == <span class="number">0x53</span>) { <span class="comment">//数据内容：角度</span></span><br><span class="line">            RxState_JY = RECEIVE_DATA;</span><br><span class="line">            dataIndex = <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            RxState_JY = WAIT_HEADER1; <span class="comment">// 如果不是期望的第二个头，重置状态</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RECEIVE_DATA:</span><br><span class="line">        receivedData[dataIndex++] = uartdata;</span><br><span class="line">        <span class="keyword">if</span> (dataIndex == <span class="number">9</span>) {</span><br><span class="line">            <span class="comment">// 数据接收完毕，分配给具体的变量</span></span><br><span class="line">            RollL = receivedData[<span class="number">0</span>];</span><br><span class="line">            RollH = receivedData[<span class="number">1</span>];</span><br><span class="line">            PitchL = receivedData[<span class="number">2</span>];</span><br><span class="line">            PitchH = receivedData[<span class="number">3</span>];</span><br><span class="line">            YawL = receivedData[<span class="number">4</span>];</span><br><span class="line">            YawH = receivedData[<span class="number">5</span>];</span><br><span class="line">            VL = receivedData[<span class="number">6</span>];</span><br><span class="line">            VH = receivedData[<span class="number">7</span>];</span><br><span class="line">            SUM = receivedData[<span class="number">8</span>];</span><br><span class="line">            <span class="comment">// 校验SUM是否正确</span></span><br><span class="line">            <span class="type">uint8_t</span> calculatedSum = <span class="number">0x55</span> + <span class="number">0x53</span> + RollH + RollL + PitchH + PitchL + YawH + YawL + VH + VL;</span><br><span class="line">            <span class="keyword">if</span> (calculatedSum == SUM) {</span><br><span class="line">                <span class="comment">// 校验成功，可以进行后续处理</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 校验失败，处理错误</span></span><br><span class="line">            }</span><br><span class="line">            RxState_JY = WAIT_HEADER1; <span class="comment">// 重置状态以等待下一个数据包</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//DL_UART_Main_transmitData(UART_JY61P_INST, uartdata); // 可选：回传接收到的数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="12-写格式"><a class="markdownIt-Anchor" href="#12-写格式"></a> 1.2 写格式</h3><img src="/posts/37775/image-20241011224231172.png" class="" title="image-20241011224231172"><p>代码实现（Z轴置零）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送置偏航角置零命令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_JY61P_Zero_Yaw</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*解锁指令*/</span></span><br><span class="line">    DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X69</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X88</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XB5</span>);</span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">200</span>);<span class="comment">//延迟200ms</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*修改指令（Z轴置零）*/</span></span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X01</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X04</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">3000</span>);<span class="comment">//延迟3秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*保存指令*/</span></span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注意：CCS Theia编译可能无法找到报错位置，建议每次小幅修改后就立即编译&lt;/p&gt;
&lt;p&gt;主要问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何进行调参？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何设计一个完整的系统？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小车如何走直线？&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][3]UART、DMA、ADC</title>
    <link href="https://szturin.github.io/posts/24028/"/>
    <id>https://szturin.github.io/posts/24028/</id>
    <published>2024-09-15T13:56:13.000Z</published>
    <updated>2024-10-29T08:05:51.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-串口中断超时解析"><a class="markdownIt-Anchor" href="#一-串口中断超时解析"></a> 一、串口中断+超时解析</h1><h2 id="1-cubemx配置"><a class="markdownIt-Anchor" href="#1-cubemx配置"></a> 1. CubeMX配置</h2><h2 id="11-属性配置"><a class="markdownIt-Anchor" href="#11-属性配置"></a> 1.1 <strong>属性配置</strong></h2><p>主要配置波特率，其余默认</p><style>.khzyvdwxppsv{}</style><img src="/posts/24028/image-20240919224239733.png" class="khzyvdwxppsv" alt="image-20240919224239733"><p><strong>中断配置</strong></p><p>Preemption Priority：抢占优先级</p><p>Sub Priority: 子优先级</p><img src="/posts/24028/image-20240919224306805.png" class="" title="image-20240919224306805"><p><strong>串口的DMA设置</strong></p><p>只开接收DMA即可</p><p>DMA的模式：</p><ul><li>Normol</li><li>Circual</li></ul><img src="/posts/24028/image-20240919224441445.png" class="" title="image-20240919224441445"><img src="/posts/24028/image-20240919224501610.png" class="" title="image-20240919224501610"><h2 id="2-驱动程序编写"><a class="markdownIt-Anchor" href="#2-驱动程序编写"></a> 2. 驱动程序编写</h2><h3 id="21-串口重定向"><a class="markdownIt-Anchor" href="#21-串口重定向"></a> 2.1 串口重定向</h3><p><strong>在uasrt.c中进行修改</strong></p><img src="/posts/24028/image-20240919225413251.png" class="" title="image-20240919225413251"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE * str)</span></span><br><span class="line">{</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,(<span class="type">uint8_t</span> *)&amp;ch,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="22-app_uartc-变量定义"><a class="markdownIt-Anchor" href="#22-app_uartc-变量定义"></a> 2.2 <strong>app_uart.c 变量定义</strong></h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> uart_rx_index = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> uart_tx_ticks = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br></pre></td></tr></tbody></table></figure><h3 id="23-中断初始化"><a class="markdownIt-Anchor" href="#23-中断初始化"></a> 2.3 <strong>中断初始化</strong></h3><p>放入Core-&gt;Src-&gt;usart.c中</p><p>在初始化中使能串口中断，往buffer中每次填充一个字节，触发中断回调</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart1,uart_rx_buffer,<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><img src="/posts/24028/image-20240920223856904.png" class="" title="image-20240920223856904"><blockquote><p><mark>Hal库——中断回调函数</mark></p><p>在 STM32 的 HAL（硬件抽象层）库中，<strong>中断回调函数</strong>用于处理各种外设的中断事件。这些回调函数由 HAL 库提供，用户只需实现这些函数以响应特定的中断。</p><h3 id="1-一般函数-vs-回调函数"><a class="markdownIt-Anchor" href="#1-一般函数-vs-回调函数"></a> 1. <strong>一般函数 vs. 回调函数</strong></h3><ul><li><p><strong>逻辑限定普通函数的调用</strong>：</p><ul><li>逻辑条件通常在调用函数之前进行检查，确保在满足特定条件时再执行该函数。</li><li>这种方式在函数内部或外部使用条件语句（如 <code>if</code>）来控制函数的执行。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">normalFunction</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (condition) {  <span class="comment">// 条件检查</span></span><br><span class="line">        normalFunction();  <span class="comment">// 仅在条件满足时调用</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>回调函数</strong>：</p><ul><li>回调函数通过传递函数指针来实现灵活的调用，调用发生在某个事件或特定条件下。</li><li>这种机制允许外部函数（如事件处理或异步操作）在需要时调用传递的回调，而不需要直接控制逻辑。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callbackFunction</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line">        </span><br><span class="line"><span class="type">void</span> <span class="title function_">eventHandler</span><span class="params">(<span class="type">void</span> (*callback)())</span> {</span><br><span class="line">    <span class="comment">// 某个事件发生后调用回调</span></span><br><span class="line">    callback();  <span class="comment">// 不需要在这里检查条件</span></span><br><span class="line">}</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    eventHandler(callbackFunction);  <span class="comment">// 传递回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="2-中断函数-vs-回调函数"><a class="markdownIt-Anchor" href="#2-中断函数-vs-回调函数"></a> 2. <strong>中断函数 vs. 回调函数</strong></h3><ul><li><strong>中断函数</strong>：<ul><li>直接处理外设中断的代码，通常是在中断服务例程 (ISR) 中实现。</li><li>代码较为复杂，涉及中断向量、优先级、屏蔽等设置。</li><li>可能会引入较长的中断处理时间，不适合执行复杂的任务。</li></ul></li><li><strong>回调函数</strong>：<ul><li>是一个更高层次的抽象，允许用户在中断发生时执行特定的处理逻辑。</li><li>HAL 库提供的回调函数允许用户定义中断后要执行的操作，而不需要直接修改中断服务例程。</li><li>更易于维护和调试，因为用户只需关注回调函数的逻辑，而不需要管理中断相关的低层实现。</li></ul></li></ul></blockquote><h3 id="24-回调函数声明"><a class="markdownIt-Anchor" href="#24-回调函数声明"></a> 2.4 回调函数声明</h3><p><strong>弱定义</strong></p><img src="/posts/24028/image-20240915220013260.png" class="" title="image-20240915220013260"><img src="/posts/24028/image-20240920223951975.png" class="" title="image-20240920223951975"><p><strong>自定义回调函数</strong></p><p>可以自行声明与弱定义回调函数同名的函数，会优先执行自定义的函数</p><p>Hal库中各种弱定义都是用__weak修饰的</p><img src="/posts/24028/image-20240915220050996.png" class="" title="image-20240915220050996"><p>过程：串口接收-&gt;触发回调-&gt;进入回调函数</p><p>PS: void HAL_UART_RxCpliCallback(UART_HandleTypeDef *huart) 不要用成 void HAL_UART_TxCpliCallback(UART_HandleTypeDef *huart)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(huart-&gt;Instance == USART1)</span><br><span class="line">    {</span><br><span class="line">        uart_rx_ticks = uwTick;</span><br><span class="line">        uart_rx_index++;<span class="comment">//索引自增</span></span><br><span class="line">        <span class="comment">//每次触发回调，都要重新初始化接收中断，定义接收的位置</span></span><br><span class="line">        HAL_UART_Receive_IT(&amp;huart1,&amp;uart_r_buffer[uart_rx_index],<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="25-串口解析"><a class="markdownIt-Anchor" href="#25-串口解析"></a> 2.5 串口解析</h3><p><strong>超时解析</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(uart_rx_index == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(uwTick - uart_rx_ticks &gt; <span class="number">100</span>)<span class="comment">//时间超过100</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"uart data:%s\n"</span>,uart_rx_buffer);<span class="comment">//发送串口接收内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span> (uart_rx_buffer,<span class="number">0</span>,uart_rx_index);<span class="comment">//清空</span></span><br><span class="line">        uart_rx_index = <span class="number">0</span>;<span class="comment">//指针指令</span></span><br><span class="line">        huart1.pRxBuffPtr = uart_rx_buffer;<span class="comment">//uart1缓存区指针指向buffer</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="无dma和环形缓冲区的问题"><a class="markdownIt-Anchor" href="#无dma和环形缓冲区的问题"></a> <strong># <mark>无DMA和环形缓冲区的问题</mark></strong></h2><blockquote><p><strong>当串口接收速率过快时，如视觉上位机频繁向单片机发送识别到的坐标数据，可能会导致单片机程序阻塞</strong></p><p><mark><strong>1. 串口阻塞的解决方案</strong></mark></p><img src="/posts/24028/image-20240919233036903.png" class="" title="image-20240919233036903"><p>DMA:数据转运</p><p>RingBuffer:环形缓存区</p><p><mark><strong>2. # 环形缓冲区的概念：</strong></mark></p><ul><li>头指针</li><li>尾指针</li></ul></blockquote><h2 id="现象"><a class="markdownIt-Anchor" href="#现象"></a> # 现象：</h2><h3 id="1-串口无解析发送上位机"><a class="markdownIt-Anchor" href="#1-串口无解析发送上位机"></a> 1. 串口无解析发送上位机</h3><p>CubeMX未定义串口引脚，未注意STM32外设引脚可复用问题</p><img src="/posts/24028/image-20240920234311280.png" class="" title="image-20240920234311280"><h3 id="2-回调函数名称错误"><a class="markdownIt-Anchor" href="#2-回调函数名称错误"></a> 2. 回调函数名称错误</h3><img src="/posts/24028/image-20240920231957317.png" class="" title="image-20240920231957317"><h1 id="二-dma空闲中断"><a class="markdownIt-Anchor" href="#二-dma空闲中断"></a> 二、DMA+空闲中断</h1><h2 id="dma的作用"><a class="markdownIt-Anchor" href="#dma的作用"></a> # DMA的作用</h2><blockquote><p>无DMA：数据-&gt;Uart寄存器-&gt;CPU访问Uart寄存器-&gt;执行其他程序部分</p><p>​-------如果串口通信速率过快------&gt;CPU频繁访问Uart寄存器--------&gt;程序阻塞</p><p>有DMA：数据-&gt;Uart-&gt;DMA访问Uart数据-&gt;存放到单片机内存地址</p><p>​CPU与DMA并行工作</p></blockquote><p>在上述配置的基础上对程序文件进行进一步修改。</p><h2 id="空闲中断"><a class="markdownIt-Anchor" href="#空闲中断"></a> # 空闲中断</h2><blockquote><h3 id="1-什么是空闲中断"><a class="markdownIt-Anchor" href="#1-什么是空闲中断"></a> 1. 什么是空闲中断？</h3><p>空闲中断（Idle Line Interrupt）是串口通信（UART）中常用的一种硬件中断机制。它用于检测串口接收线路在一段时间内没有接收到数据时触发。<strong>空闲中断的核心原理是检测 UART 外设的接收线路在数据传输结束后变为“空闲”状态</strong>（即，停止接收数据，线路上没有任何活动）。</p><p>当串口在接收数据时，硬件会自动维护一个“忙状态”标志。所有数据帧（包括起始位、数据位和停止位）都被接收完成后，接收线路进入空闲状态，此时 UART 硬件会触发“空闲中断”。这个中断标志仅在接收数据后首次空闲时触发，而不是每次线路空闲都会触发。因此，空闲中断能够用于判断数据帧的结束或检测数据包的传输完成。(比如，一个数据帧的长度为8个字节，在串口通信时每帧间隔一个字节来发送，在间隔的这个字节，触发空闲中断，进而可以在中断程序中处理数据帧)</p><h3 id="2-空闲中断在串口通信中的作用"><a class="markdownIt-Anchor" href="#2-空闲中断在串口通信中的作用"></a> 2. 空闲中断在串口通信中的作用</h3><p>空闲中断主要用于处理非固定长度的串口数据帧和高效的 DMA（Direct Memory Access，直接内存访问）数据传输。其作用和优势如下：</p><h4 id="21-非固定长度数据包接收"><a class="markdownIt-Anchor" href="#21-非固定长度数据包接收"></a> 2.1 <strong>非固定长度数据包接收</strong></h4><ul><li>当接收的数据是非固定长度时，很难在接收时预先设定要接收的数据长度。这时，可以利用空闲中断判断数据的结束。</li><li>当串口在 DMA 模式下接收数据时，无法使用常规的中断方式逐字节进行处理。使用空闲中断可以更高效地处理数据流，从而判断整个数据包的接收是否完成。</li></ul><h4 id="22-提高串口通信的效率"><a class="markdownIt-Anchor" href="#22-提高串口通信的效率"></a> 2.2 <strong>提高串口通信的效率</strong></h4><ul><li>使用空闲中断能够在 DMA 模式下提高串口通信的效率。当 DMA 缓冲区被填满或者数据接收超时时，空闲中断可以用于自动触发数据处理，避免了使用传统的定时器轮询方式。</li><li>通过判断空闲中断触发时间，可以精确判断数据包的传输完成，不必每次都等待接收缓冲区被填满才进行处理，从而提高系统响应速度。</li></ul><h4 id="23-降低-cpu-占用"><a class="markdownIt-Anchor" href="#23-降低-cpu-占用"></a> 2.3 <strong>降低 CPU 占用</strong></h4><ul><li>使用空闲中断配合 DMA 接收，可以降低 CPU 的使用率。在 DMA 接收过程中，数据自动从串口移入缓冲区，不需要 CPU 的参与，只有在接收结束或空闲中断触发时才进行数据处理。</li><li>对于接收频繁但数量不定的数据流（如传感器数据、通信协议数据包），使用空闲中断能极大地减少 CPU 的负担。</li></ul><h3 id="3-空闲中断在串口通信中的典型应用场景"><a class="markdownIt-Anchor" href="#3-空闲中断在串口通信中的典型应用场景"></a> 3. 空闲中断在串口通信中的典型应用场景</h3><h4 id="31-接收数据包的完整性判断"><a class="markdownIt-Anchor" href="#31-接收数据包的完整性判断"></a> 3.1 <strong>接收数据包的完整性判断</strong></h4><p>对于 UART 接收非固定长度的数据包（如 Modbus、串口通信协议），可以使用空闲中断来判断数据帧的结束。</p><p><strong>典型场景：</strong><br>假设通过 UART 接收的数据包长度不定，当接收到一个完整的数据帧时，串口线路会进入空闲状态，此时触发空闲中断，可以认为本次数据接收结束。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c复制代码// 空闲中断回调函数示例</span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {</span><br><span class="line">    if (__HAL_UART_GET_FLAG(huart, UART_FLAG_</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="1-变量声明"><a class="markdownIt-Anchor" href="#1-变量声明"></a> 1. 变量声明</h2><p><strong>声明 uart_rx_dma_buffer变量，用于数据转运</strong></p><img src="/posts/24028/image-20240919233721950.png" class="" title="image-20240919233721950"><h2 id="2-中断初始化"><a class="markdownIt-Anchor" href="#2-中断初始化"></a> 2. <strong>中断初始化</strong></h2><p>启用DMA相关中断</p><p>关闭DMA<mark>半中断</mark></p><img src="/posts/24028/image-20240919233901381.png" class="" title="image-20240919233901381"><p><strong>PS: 不再适用串口回调，改用DMA的方法</strong></p><img src="/posts/24028/image-20240919234047785.png" class="" title="image-20240919234047785"><h2 id="3-串口中断函数"><a class="markdownIt-Anchor" href="#3-串口中断函数"></a> 3. <strong>串口中断函数</strong></h2><p>每次触发串口中断，触发DMA中断</p><img src="/posts/24028/image-20240920200100912.png" class="" title="image-20240920200100912"><p><strong>取消使用串口中断回调函数</strong></p><img src="/posts/24028/image-20240920200332492.png" class="" title="image-20240920200332492"><p><strong>改用空闲中断回调函数</strong></p><p>PS: 不再需要串口超时解析</p><img src="/posts/24028/image-20240920200417955.png" class="" title="image-20240920200417955"><img src="/posts/24028/image-20240920200913934.png" class="" title="image-20240920200913934"><h2 id="现象-2"><a class="markdownIt-Anchor" href="#现象-2"></a> # 现象：</h2><img src="/posts/24028/image-20240921001109060.png" class="" title="image-20240921001109060"><h2 id="补充中断函数与回调函数的区别"><a class="markdownIt-Anchor" href="#补充中断函数与回调函数的区别"></a> # <mark>补充——中断函数与回调函数的区别</mark></h2><blockquote><p>在嵌入式编程中，HAL（硬件抽象层）库的中断函数和回调函数是常见的机制，尤其是在处理外设操作时。这两者的作用有时容易混淆，但它们的概念和使用场景有所不同。下面详细解释它们的区别：</p><h3 id="1-中断函数interrupt-service-routine-isr"><a class="markdownIt-Anchor" href="#1-中断函数interrupt-service-routine-isr"></a> 1. 中断函数（Interrupt Service Routine, ISR）</h3><p>中断函数是一段处理硬件中断的代码。当外设或处理器触发中断时，处理器会暂停当前的代码执行，转而执行与该中断对应的ISR。一旦中断被处理完毕，程序会恢复到原来的执行状态。</p><ul><li><strong>执行方式</strong>：硬件触发，直接由处理器执行，通常是高优先级。</li><li><strong>响应时间</strong>：要求短小精悍，不能执行耗时的任务，因为会阻塞其他中断。</li><li><strong>位置</strong>：ISR通常定义在HAL库或用户代码中，是一个固定的函数（如<code>TIM_IRQHandler</code>等）。</li><li><strong>调用方式</strong>：自动触发，由硬件中断控制器（NVIC）决定何时调用中断处理函数。</li></ul><h3 id="2-回调函数callback-function"><a class="markdownIt-Anchor" href="#2-回调函数callback-function"></a> 2. 回调函数（Callback Function）</h3><p>回调函数是一个函数指针，通过预先注册到某个模块或API中，等到某个事件发生时，由该模块或API负责调用。HAL库中的回调函数通常是在中断处理完毕后，由ISR或HAL库内部调用，用来进一步处理用户逻辑。</p><ul><li><strong>执行方式</strong>：由程序代码（比如ISR或定时器事件）调用，响应某个事件。</li><li><strong>响应时间</strong>：回调函数不要求像中断处理函数那样必须快速完成，往往用于处理稍复杂的业务逻辑。</li><li><strong>位置</strong>：回调函数通常由用户实现，并由HAL库的中断处理函数或其他机制调用（如<code>HAL_TIM_PeriodElapsedCallback</code>）。</li><li><strong>调用方式</strong>：回调函数不是直接由硬件触发，而是由软件触发，即当中断函数处理完硬件中断后，再调用用户注册的回调函数。</li></ul><h3 id="简单总结区别"><a class="markdownIt-Anchor" href="#简单总结区别"></a> 简单总结区别：</h3><ul><li><strong>触发机制</strong>：中断函数是由硬件事件（如定时器溢出、外部信号等）直接触发，而回调函数是由软件（如ISR）触发。</li><li><strong>职责范围</strong>：中断函数负责处理硬件中断，通常需要快速执行；回调函数则处理用户定义的业务逻辑，通常可以有更多的处理空间和时间。</li><li><strong>优先级</strong>：中断函数的优先级较高，回调函数的执行时间不受硬件中断控制，通常在中断函数结束之后才执行。</li></ul><h3 id="典型应用场景"><a class="markdownIt-Anchor" href="#典型应用场景"></a> 典型应用场景</h3><p>以定时器为例：</p><ul><li>当定时器溢出时，触发一个中断，执行定时器的中断函数<code>TIM_IRQHandler</code>。</li><li>在中断函数内部，可能会调用HAL库的定时器回调函数<code>HAL_TIM_PeriodElapsedCallback</code>，用于用户自定义的定时器周期性任务处理。</li></ul><p>这就是中断函数和回调函数的核心区别。</p></blockquote><h1 id="三-环形缓冲区"><a class="markdownIt-Anchor" href="#三-环形缓冲区"></a> 三、环形缓冲区</h1><h2 id="环形缓冲区的简介"><a class="markdownIt-Anchor" href="#环形缓冲区的简介"></a> # 环形缓冲区的简介</h2><blockquote><p>环形缓存区，也叫环形缓冲区（Ring Buffer）或循环缓冲区，是一种数据结构。它的特点 是缓存区的头和尾是连接在一起的，形成一个环。当数据写入缓冲区时，指针会不断前进，当到达缓冲区的末尾时，会重新回到开头，这样就实现了一个循环。</p><p><strong>环形缓冲区的组成</strong>：</p><ul><li>缓冲区数组：存放数据</li><li>头指针（读指针）</li><li>尾指针（写指针）</li></ul><p>环形缓冲区满足“先进先出的原则”</p><p><strong>环形缓冲区的优势</strong>：</p><ul><li>在普通串口接收中，数据是线性接收的，通常是通过中断或者轮询的方式处理数据。</li><li>而环形缓冲区适用于需要持续接收和处理数据的应用，如串口通信</li><li>环形缓冲区效率和可靠性高，但是需要复杂的管理逻辑</li></ul><p><strong>环形缓冲区的原理及实现</strong>：</p><p><a href="https://blog.csdn.net/2401_86353562/article/details/141830232">环形缓冲区(ring buffer)原理与实现详解-CSDN博客</a></p><img src="/posts/24028/9af5be294e82d063ae8d1eb1d642ed7a.png" class="" title="img"><p><strong>简单代码实现：</strong></p><p>缓冲区结构体定义</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFFER_SIZE (30) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">uint32_t</span> w;</span><br><span class="line">    <span class="type">uint32_t</span> r;</span><br><span class="line">    <span class="type">uint8_t</span> buffer[RINGBUFFER_SIZE];</span><br><span class="line">    <span class="type">uint32_t</span> itemCount;</span><br><span class="line">}<span class="type">ringbuffer_t</span>;</span><br></pre></td></tr></tbody></table></figure><p>初始化环形缓冲区</p><p>置零环形缓冲区中的元素</p><p>这里用到<code>memset</code>函数</p><ul><li>解释：复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</li><li>作用：是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法</li><li>头文件：C中<code>#include&lt;string.h&gt;</code>，C++中<code>#include&lt;cstring&gt;</code></li></ul><p>这里指向的是环形缓冲区内容buffer，为uint8_t类型的数组变量，数组大小为<code>RINGBUFFER_SIZE</code>，使用这段语句将buffer中的内存块内容置零。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ringbuffer_init</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 设置读指针和写指针初始值为0</span></span><br><span class="line">    rb-&gt;r = <span class="number">0</span>;</span><br><span class="line">    rb-&gt;w = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将缓冲区内存清零</span></span><br><span class="line">    <span class="built_in">memset</span>(rb-&gt;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * RINGBUFFER_SIZE);</span><br><span class="line">    <span class="comment">// 初始化项目计数为0</span></span><br><span class="line">    rb-&gt;itemCount = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>检查缓冲区是否已满</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查环形缓冲区是否已满</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">ringbuffer_is_full</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果项目计数等于缓冲区大小，返回1（已满），否则返回0（未满）</span></span><br><span class="line">    <span class="keyword">return</span> (rb-&gt;itemCount == RINGBUFFER_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>检查缓冲区是否为空</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查环形缓冲区是否为空</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">ringbuffer_is_empty</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果项目计数为0，返回1（为空），否则返回0（非空）</span></span><br><span class="line">    <span class="keyword">return</span> (rb-&gt;itemCount == <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>向环形缓冲区写入数据</p><p>这里限制了向环形缓冲区写入数据的个数：即限定在环形缓冲区数组索引大小内</p><p>数据根据写指针当前指向的位置，进行写入。数据完成写入后，写指针递增。如果写指针当前到达缓冲区索引尾部，那么返回索引头部，即指向0</p><p>此段代码管理逻辑中，如果当前的环形缓冲区已经写满，需要经过将缓冲区的数据取出后，才能继续对缓冲区进行写入操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向环形缓冲区写入数据</span></span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">ringbuffer_write</span><span class="params">(<span class="type">ringbuffer_t</span> *rb, <span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果缓冲区已满，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_full(rb))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 将数据写入缓冲区</span></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        rb-&gt;buffer[rb-&gt;w] = *data++;  <span class="comment">// 写入数据并移动写指针</span></span><br><span class="line">        rb-&gt;w = (rb-&gt;w + <span class="number">1</span>) % RINGBUFFER_SIZE;  <span class="comment">// 写指针循环递增</span></span><br><span class="line">        rb-&gt;itemCount++;  <span class="comment">// 增加项目计数</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 写入成功返回0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从缓冲区读取数据</p><p>缓冲区有数据，操作才有效</p><p>数据根据读指针当前指向的位置，进行读取。数据完成读取后，读指针递增。如果读指针当前到达缓冲区索引尾部，那么返回索引头部，即指向0。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从环形缓冲区读取数据</span></span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">ringbuffer_read</span><span class="params">(<span class="type">ringbuffer_t</span> *rb, <span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果缓冲区为空，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_empty(rb))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓冲区读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        *data++ = rb-&gt;buffer[rb-&gt;r];  <span class="comment">// 读取数据并移动读指针</span></span><br><span class="line">        rb-&gt;r = (rb-&gt;r + <span class="number">1</span>) % RINGBUFFER_SIZE;  <span class="comment">// 读指针循环递增</span></span><br><span class="line">        rb-&gt;itemCount--;  <span class="comment">// 减少项目计数</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 读取成功返回0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="1-移植环形缓冲区驱动文件"><a class="markdownIt-Anchor" href="#1-移植环形缓冲区驱动文件"></a> 1. <strong>移植环形缓冲区驱动文件</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ringbuffer_t</span> usart_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> usart_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br></pre></td></tr></tbody></table></figure><ul><li>判断ringbuffer是否满</li><li>写入数据</li><li>清空结构体</li></ul><h2 id="2-空闲中断回调函数"><a class="markdownIt-Anchor" href="#2-空闲中断回调函数"></a> 2. <strong>空闲中断回调函数</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief UART DMA接收完成回调函数 </span></span><br><span class="line"><span class="comment">将接收到的数据写入环形缓冲区，并清空DMA缓冲区</span></span><br><span class="line"><span class="comment">  * @param huart UART句柄 </span></span><br><span class="line"><span class="comment">  * @param Size 接收到的数据大小 </span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//空闲中断回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (huart-&gt;Instance == USART1)  <span class="comment">// 判断是 USART1 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//引入环形缓存区</span></span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line">ringbuffer_write(&amp;usart_rb,uart_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-修改串口解析"><a class="markdownIt-Anchor" href="#2-修改串口解析"></a> 2. <strong>修改串口解析</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb))<span class="keyword">return</span>;</span><br><span class="line">    ringbuffer_read(&amp;usart_rb,usart_read_buffer,usart_rb.itemCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ringbuffer data:%s\n"</span>,usart_read_buffer);</span><br><span class="line">    meset(usart_read_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>)*<span class="number">128</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><mark><strong>STM32串口通信方法总结:</strong></mark></p><ul><li><p>超时解析</p></li><li><p>DMA空闲中断</p></li><li><p>环形缓存区</p></li></ul><h1 id="四-adc和dma"><a class="markdownIt-Anchor" href="#四-adc和dma"></a> 四、ADC和DMA</h1><blockquote><p>STM32的ADC（模数转换器）通道IN11指的是STM32微控制器上一个特定的ADC输入通道。每个STM32芯片的ADC都有多个模拟输入引脚，这些引脚标记为<code>INx</code>（例如IN0、IN1、IN2等），对应不同的GPIO引脚。</p><p>具体到<strong>IN11</strong>，它是ADC的第11个输入通道，通常与一个特定的GPIO引脚连接。该引脚用于将模拟信号输入到ADC进行模数转换。</p><p>CT117E原理图：</p><img src="/posts/24028/image-20240921165117470.png" class="" title="image-20240921165117470"></blockquote><h2 id="1-cubemx配置-2"><a class="markdownIt-Anchor" href="#1-cubemx配置-2"></a> 1. CubeMX配置</h2><h3 id="11-adc通道分配"><a class="markdownIt-Anchor" href="#11-adc通道分配"></a> 1.1 <strong>ADC通道分配：</strong></h3><ul><li>ADC1: IN11</li><li>ADC2: IN15</li></ul><img src="/posts/24028/image-20240920205816075.png" class="" title="image-20240920205816075"><h3 id="12-配置dma"><a class="markdownIt-Anchor" href="#12-配置dma"></a> 1.2 配置DMA</h3><h4 id="121-配置dma通道"><a class="markdownIt-Anchor" href="#121-配置dma通道"></a> 1.2.1 配置DMA通道</h4><img src="/posts/24028/image-20240920205900067.png" class="" title="image-20240920205900067"><h4 id="122-配置为循环模式"><a class="markdownIt-Anchor" href="#122-配置为循环模式"></a> 1.2.2 配置为循环模式</h4><img src="/posts/24028/image-20240921004004318.png" class="" title="image-20240921004004318"><h4 id="123-配置dma速度"><a class="markdownIt-Anchor" href="#123-配置dma速度"></a> 1.2.3 配置DMA速度</h4><p>设置为中、高均可</p><img src="/posts/24028/image-20240920210046359.png" class="" title="image-20240920210046359"><h3 id="13-配置adc属性"><a class="markdownIt-Anchor" href="#13-配置adc属性"></a> 1.3 <strong>配置ADC属性</strong></h3><ul><li>四分频</li><li>DMA使能</li><li>循环使能</li></ul><img src="/posts/24028/image-20240920210259713.png" class="" title="image-20240920210259713"><h3 id="14-配置adc中断"><a class="markdownIt-Anchor" href="#14-配置adc中断"></a> 1.4  <strong>配置ADC中断</strong></h3><p>优先级为2即可</p><img src="/posts/24028/image-20240920210416469.png" class="" title="image-20240920210416469"><h2 id="2-驱动程序编写-2"><a class="markdownIt-Anchor" href="#2-驱动程序编写-2"></a> 2. 驱动程序编写</h2><h3 id="21-创建adc_appc"><a class="markdownIt-Anchor" href="#21-创建adc_appc"></a> 2.1 <strong>创建adc_app.c</strong></h3><p><strong>变量声明</strong></p><img src="/posts/24028/image-20240920211129892.png" class="" title="image-20240920211129892"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//双通道DMA</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure><p><strong>在主程序初始化启用DMA 转运 ADC 数据</strong></p><img src="/posts/24028/image-20240920211606752.png" class="" title="image-20240920211606752"><h3 id="22-定义adc进程"><a class="markdownIt-Anchor" href="#22-定义adc进程"></a> 2.2 <strong>定义ADC进程</strong></h3><img src="/posts/24028/image-20240920211903715.png" class="" title="image-20240920211903715"><ul><li>读取电压dma储存数据</li><li>转换为模拟电压值</li></ul><p>同样的，记得在任务调度器中添加proc</p><h3 id="23-lcd显示"><a class="markdownIt-Anchor" href="#23-lcd显示"></a> 2.3 <strong>lcd显示</strong></h3><img src="/posts/24028/image-20240920212245141.png" class="" title="image-20240920212245141"><h2 id="动态窗口"><a class="markdownIt-Anchor" href="#动态窗口"></a> # <strong><mark>动态窗口</mark></strong></h2><ul><li>使用环形缓存区</li><li>定义结构体</li></ul><img src="/posts/24028/image-20240920214629559.png" class="" title="image-20240920214629559"><img src="/posts/24028/image-20240920214552510.png" class="" title="image-20240920214552510"><h1 id="多串口通信"><a class="markdownIt-Anchor" href="#多串口通信"></a> 多串口通信</h1><h2 id="示例一"><a class="markdownIt-Anchor" href="#示例一"></a> 示例一</h2><p>使用DMA+环形缓冲区+空闲中断回调的方法，使用串口通信，在解析函数中每次解析对象为串口一次性连续接收到的数据。</p><p>所以，在解析函数<code>uart_proc</code>中一次完成对串口数据内容的解析即可，不需要再用状态机的判断逻辑。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"usart_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> uart_rx_index = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> uart_rx_ticks = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_dma_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">ringbuffer_t</span> usart_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"><span class="type">uint8_t</span> usart_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> uart2_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">uint8_t</span> uart2_rx_dma_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">ringbuffer_t</span> usart2_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"><span class="type">uint8_t</span> usart2_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br><span class="line"></span><br><span class="line">DataPacket context; <span class="comment">// 初始化上下文</span></span><br><span class="line"><span class="comment">//串口中断回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//    if(huart-&gt;Instance == USART1)</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        uart_rx_ticks = uwTick;</span></span><br><span class="line"><span class="comment">//        uart_rx_index++;//索引自增</span></span><br><span class="line"><span class="comment">//        //每次触发回调，都要重新初始化接收中断，定义接收的位置</span></span><br><span class="line"><span class="comment">//        HAL_UART_Receive_IT(&amp;huart1,&amp;uart_rx_buffer[uart_rx_index],1);</span></span><br><span class="line"><span class="comment">////printf("test");//排错</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//空闲中断回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"dma data:%s\n"</span>,uart2_rx_dma_buffer);<span class="comment">//发送串口接收内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (huart-&gt;Instance == USART1)  <span class="comment">// 判断是 USART1 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//引入环形缓存区</span></span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line">ringbuffer_write(&amp;usart_rb,uart_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(huart-&gt;Instance == USART2)  <span class="comment">// 判断是 USART2 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart2_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">ringbuffer_write(&amp;usart2_rb,uart2_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart2_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart2_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//    if(uart_rx_index == 0) return;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    if(uwTick - uart_rx_ticks &gt; 100)//时间超过100</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        printf("uart data:%s\n",uart_rx_buffer);//发送串口接收内容</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//        memset (uart_rx_buffer,0,uart_rx_index);//清空</span></span><br><span class="line"><span class="comment">//        uart_rx_index = 0;//指针指令</span></span><br><span class="line"><span class="comment">//        huart1.pRxBuffPtr = uart_rx_buffer;//uart1缓存区指针指向buffer</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">// 如果环形缓冲区为空，直接返回 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb) &amp;&amp; ringbuffer_is_empty(&amp;usart2_rb)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从环形缓冲区读取数据到读取缓冲区 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ringbuffer_read(&amp;usart_rb, usart_read_buffer, usart_rb.itemCount);</span></span><br><span class="line">ringbuffer_read(&amp;usart2_rb, usart2_read_buffer, usart2_rb.itemCount);</span><br><span class="line"><span class="comment">// 打印读取缓冲区中的数据 </span></span><br><span class="line"><span class="comment">//printf("ringbuffer data: %s\n", usart_read_buffer);</span></span><br><span class="line"><span class="comment">// 上位机&lt;test协议&gt;</span></span><br><span class="line"><span class="comment">//printf("{plotter}%s\r\n", usart_read_buffer);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//问题1：用状态机写，会导致无法一次性解码；</span></span><br><span class="line"><span class="comment">//使用串口上位机，发现每次发送串口数据，状态机才会+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(usart_read_buffer[0] == 0xFF &amp;&amp; usart_read_buffer[3] == 0xFB)//帧头帧尾检测</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(usart_read_buffer[1] == 0x2A){</span></span><br><span class="line"><span class="comment">context.data_type = 1;//正数</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else if(usart_read_buffer[1] == 0x2B){</span></span><br><span class="line"><span class="comment">context.data_type = 2;//负数</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">context.data = usart_read_buffer[2];</span></span><br><span class="line"><span class="comment">number_detect = context.data;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parse_buffer(usart_read_buffer,sizeof(usart_read_buffer),&amp;context);</span></span><br><span class="line">parse_buffer(usart2_read_buffer,<span class="keyword">sizeof</span>(usart2_read_buffer),&amp;context);</span><br><span class="line"><span class="comment">//问题2：无memset会怎么样？</span></span><br><span class="line"><span class="comment">//memset(usart_read_buffer, 0, sizeof(uint8_t) * BUUFER_SIZE);</span></span><br><span class="line"><span class="built_in">memset</span>(usart2_read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * BUUFER_SIZE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据帧解析函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_buffer</span><span class="params">(<span class="type">uint8_t</span> *buffer,<span class="type">size_t</span> size,DataPacket* data)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(size &lt; <span class="number">4</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//数据帧长度小于4，返回 0 表示解析失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; buffer[<span class="number">3</span>] == <span class="number">0xFB</span>)<span class="comment">//帧头帧尾检测</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer[<span class="number">1</span>] == <span class="number">0x2A</span>){</span><br><span class="line">data -&gt; data_type = <span class="number">1</span>;<span class="comment">//正数</span></span><br><span class="line">data -&gt; data = buffer[<span class="number">2</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(buffer[<span class="number">1</span>] == <span class="number">0x2B</span>){</span><br><span class="line">data -&gt; data_type = <span class="number">2</span>;<span class="comment">//负数</span></span><br><span class="line">data -&gt; data = buffer[<span class="number">2</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//非正确类型，解析失败</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//解析成功</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//帧头帧尾错误，解析失败</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("%c%c\n", context.state,usart_read_buffer[2]);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-串口中断超时解析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-串口中断超时解析&quot;&gt;&lt;/a&gt; 一、串口中断+超时解析&lt;/h1&gt;
&lt;h2 id=&quot;1-cubemx配置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][1]嵌入式工程模板与“任务调度器”</title>
    <link href="https://szturin.github.io/posts/56683/"/>
    <id>https://szturin.github.io/posts/56683/</id>
    <published>2024-09-09T14:35:16.000Z</published>
    <updated>2024-10-29T08:05:48.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-任务调度器"><a class="markdownIt-Anchor" href="#一-任务调度器"></a> 一、任务调度器</h1><h2 id="1-调度器结构体"><a class="markdownIt-Anchor" href="#1-调度器结构体"></a> 1. 调度器结构体</h2><p><strong>函数指针和指针函数:</strong><a href="https://blog.csdn.net/baidu_37973494/article/details/83150266">C语言基础知识：函数指针&amp;指针函数（定义格式、作用及用法说明）_指针函数的定义-CSDN博客</a></p><p>PS: 函数指针本身上还是一个指针，和一般指针没有区别，指向函数的执行地址</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调度器类型的结构体类型声明</span></span><br><span class="line"><span class="comment">//任务结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">void</span> (*task_func)(<span class="type">void</span>);<span class="comment">//函数指针</span></span><br><span class="line">    <span class="type">uint32_t</span> rate_ms;<span class="comment">//任务运行周期</span></span><br><span class="line">    <span class="type">uint32_t</span> last_run;<span class="comment">//上次运行时间</span></span><br><span class="line">} <span class="type">scheduler_task_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><code>typedef struct {} scheduler_task_t;</code>是⼀种定义新结构体类型的⽅式，这⾥定义 了⼀个名为  scheduler_task_t 的结构体类型。这个结构体类型包含三个成员。</p><ul><li><p><code>void *task_func(void);</code>定义了一个函数指针，用于储存任务函数的地址，便于进行任务调度</p></li><li><p><code>rate_ms</code>表示任务具体的执行周期</p></li><li><p><code>last_run</code>⽤于存储任务上次运⾏的时间戳（以毫秒为单位）。该成员⽤于 记录任务上⼀次被调度执⾏的时间点，以便计算任务是否需要再次执⾏</p></li></ul><p>静态任务数组，每个任务包括任务函数，执行周期，和上次执行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Led_task</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义调度器类型的变量 任务</span></span><br><span class="line"><span class="comment">//任务数组</span></span><br><span class="line"><span class="comment">//给scheduler_task_t类型变量tasks赋初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">scheduler_task_t</span> tasks[] ={</span><br><span class="line">    {Led_task,<span class="number">1000</span>,<span class="number">0</span>}<span class="comment">//定义一个任务，任务函数为Led_Proc,执行周期为1000毫秒，初始上次运行时间为0</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="2-调度器初始化"><a class="markdownIt-Anchor" href="#2-调度器初始化"></a> 2. 调度器初始化</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">//计算任务数组中任务函数的个数，结果储存在tasks_num中</span></span><br><span class="line">    tasks_num = <span class="keyword">sizeof</span>(tasks)/<span class="keyword">sizeof</span>(<span class="type">scheduler_task_t</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-调度器函数"><a class="markdownIt-Anchor" href="#3-调度器函数"></a> 3. 调度器函数</h2><p>遍历任务数组，检查是否有任务需要进行，如果系统当前时间超过任务的执行周期，那么执行任务变更，并且更新上次运行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_run</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">/*任务轮询*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>; i&lt; tasks_num; i++){</span><br><span class="line">        <span class="comment">//获取当前时间（毫秒）</span></span><br><span class="line">        <span class="type">uint8_t</span> time_now = HAL_GetTick();</span><br><span class="line">        <span class="comment">//检查任务是否到达当前时间点</span></span><br><span class="line">        <span class="keyword">if</span>(time_now &gt;= tasks[i].rate_ms + tasks[i].last_run){</span><br><span class="line">            <span class="comment">//更新任务的上次运行时间，保存时间戳</span></span><br><span class="line">            tasks[i].last_run = time_now;<span class="comment">//保存当前时间</span></span><br><span class="line">            tasks[i].task_func();<span class="comment">//执行对应指向的任务</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-任务调度器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-任务调度器&quot;&gt;&lt;/a&gt; 一、任务调度器&lt;/h1&gt;
&lt;h2 id=&quot;1-调度器结构体&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-调度器结</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【深度学习】[1]神经网络的基本概念</title>
    <link href="https://szturin.github.io/posts/23492/"/>
    <id>https://szturin.github.io/posts/23492/</id>
    <published>2024-08-16T17:36:58.000Z</published>
    <updated>2024-09-07T17:16:24.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-神经网络的基本概念"><a class="markdownIt-Anchor" href="#一-神经网络的基本概念"></a> 一、神经网络的基本概念</h1><h2 id="1-神经元感知器"><a class="markdownIt-Anchor" href="#1-神经元感知器"></a> 1. 神经元（感知器）</h2><p>一种被称为感知器的人工神经元在20世纪五六十年代被科学家Frank提出。通过数学模型，可以认识到<strong>感知器</strong>是一个根据输入与权重来做出决定的设备，随着<strong>权重</strong>和<strong>阈值</strong>的变化，可以得到不同的<strong>决策模型</strong>。当一个感知器计算后得到的值大于阈值时，从神经学的角度来讲这个感知器被激活，反之为0。感知器可以一定程度上模仿人脑做出决策，但是感知器的决策过程全部是线性的，在处理图像处理、语音识别等复杂问题时，难以仅靠线性模型达到良好的识别效果，因此需要在感知器模型种引入非线性部分。</p><h2 id="2-非线性神经元"><a class="markdownIt-Anchor" href="#2-非线性神经元"></a> 2. 非线性神经元</h2><p>为解决复杂的数学模型，引入<strong>激活函数</strong>，激活函数给神经元带来了非线性因素，使得神经网络可以任意逼近任何非线性函数。</p><p>通常将激活函数与线性神经元合并使之成为<strong>非线性神经元</strong></p><p>如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的<a href="https://baike.baidu.com/item/%E6%84%9F%E7%9F%A5%E6%9C%BA/12723581">感知机</a>（Perceptron）。</p><img src="/posts/23492/34d6b14bf4b79175276eac52abacdf94.png" class="" title="img"><p>激活函数可以分为<strong>两大类：</strong></p><img src="/posts/23492/e41598583c8b35dcbb907f9fd66d8351.png" class="" title="img"><ul><li><strong>饱和激活函数：</strong> sigmoid、 tanh…</li><li><strong>非饱和激活函数:</strong> ReLU 、Leaky Relu  、ELU、PReLU、RReLU…</li></ul><p><a href="https://blog.csdn.net/qq_42691298/article/details/126590726">深度学习中常见的10种激活函数（Activation Function）总结_激活函数有哪些-CSDN博客</a></p><h2 id="3常见的激活函数"><a class="markdownIt-Anchor" href="#3常见的激活函数"></a> 3.常见的激活函数</h2><h3 id="31-sigmoid函数"><a class="markdownIt-Anchor" href="#31-sigmoid函数"></a> 3.1 Sigmoid函数</h3><img src="/posts/23492/6c9269a456ee0497c9bb0d1383e51cc8.png" class="" title="img"><img src="/posts/23492/af5f15ef44f1b276c78bec5e140e7082.png" class="" title="img"><h3 id="32-tanh函数"><a class="markdownIt-Anchor" href="#32-tanh函数"></a> 3.2 tanh函数</h3><p><strong>tanh</strong>激活函数的数学表达式为：</p><img src="/posts/23492/70ad61d6f8c019d3dee98ad6ef45cb1a.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/e58d7204fef7f7410e92b4bf82e91938.png" class="" title="img"><h3 id="33-relu函数"><a class="markdownIt-Anchor" href="#33-relu函数"></a> 3.3 ReLU函数</h3><p><strong>ReLU</strong>激活函数的数学表达式为：</p><img src="/posts/23492/ae65877d14768ad1b6789c6ccdcd6e31.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/a2f4f9f3c522518908e20d7865beb48c.png" class="" title="img"><p>什么情况下适合使用ReLU？</p><ul><li><p>ReLU解决了梯度消失的问题，当输入值为正时，神经元不会饱和</p></li><li><p>由于ReLU线性、非饱和的性质，在SGD中能够快速收敛</p></li><li><p>计算复杂度低，不需要进行指数运算</p></li></ul><p>ReLU有哪些缺点？</p><ul><li><p>与Sigmoid一样，其输出不是以0为中心的</p></li><li><p>Dead ReLU 问题。当输入为负时，梯度为0。这个神经元及之后的神经元梯度永远为0，不再对任何数据有所响应，导致相应参数永远不会被更新</p></li><li><p>训练神经网络的时候，一旦学习率没有设置好，第一次更新权重的时候，输入是负值，那么这个含有ReLU的神经节点就会死亡，再也不会被激活。所以，要设置一个合适的较小的学习率，来降低这种情况的发生</p></li></ul><h2 id="4-神经网络的基本架构"><a class="markdownIt-Anchor" href="#4-神经网络的基本架构"></a> 4. 神经网络的基本架构</h2><img src="/posts/23492/bf32fef369b3823adc20dcdf9af603e3.jpg" class="" title="bf32fef369b3823adc20dcdf9af603e3"><ul><li><p>神经网络最左边的称为<strong>输入层</strong>，其中的神经元称为<strong>输入神经元</strong>，原始数据经由该层输入到神经网络进行后续处理。</p></li><li><p>最右边的称为<strong>输出层</strong>，包含输出神经元，该层的输出是神经网络对样本处理后的最终结果，如分类结果。</p></li><li><p>在输入层和输出层之间的是中间层，也称为 <strong>隐藏层</strong>，即既非输入也非输出的神经网络层，一个神经网络可以有一个或者多个隐藏层，隐藏层的主要作用是处理从上一层神经元传递来的信号。</p></li></ul><p>一般的，<strong>输入层</strong>和 <strong>输出层</strong>在整体神经网络的外部，称为可见层。设计神经网络的输入输出通常比较简单，直接，例如，假设我们知道了一朵花的4个明显特征（如花瓣的长度，宽度），可以利用这4个特征确定它是哪一种类的花，由于我们已经知道这朵花的4个特征，那么就需要4个输入神经元，每个数值代表花朵的一种特征的具体数值。<strong>输出层</strong>可以包含一个或者多个神经元，这由我们想要设定的具体花朵类别决定，可以根据输出的数字，确定花朵的类型。我们可以使用每一个<strong>输出神经元</strong>代表一种类型的花，这种方法称为One-Hot，One-Hot是一种常见的输出层编码方法。</p><h2 id="5-梯度下降"><a class="markdownIt-Anchor" href="#5-梯度下降"></a> 5. 梯度下降</h2><p><a href="https://blog.csdn.net/iqdutao/article/details/107174240">机器学习-梯度下降算法原理及公式推导_梯度下降计算公式-CSDN博客</a></p><h2 id="6-反向传播"><a class="markdownIt-Anchor" href="#6-反向传播"></a> 6. 反向传播</h2><p><a href="https://blog.csdn.net/ft_sunshine/article/details/90221691">“反向传播算法”过程及公式推导（超直观好懂的Backpropagation）_反向传播算法(过程及公式推导)-CSDN博客</a></p><p><strong>“正向传播”求损失，“反向传播”回传误差</strong>。同时，神经网络每层的每个神经元都可以<strong>根据误差信号修正每层的权重</strong></p><h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h1><h2 id="一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"><a class="markdownIt-Anchor" href="#一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"></a> 一、输入x是 784长度的向量，什么机制使得输出y变成的长度为10的向量？</h2><p>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的。具体操作通过 <strong>权重矩阵</strong> 和 <strong>偏置向量</strong> 来完成。</p><h3 id="1-全连接层的基本机制"><a class="markdownIt-Anchor" href="#1-全连接层的基本机制"></a> 1. <strong>全连接层的基本机制：</strong></h3><p>全连接层的工作机制可以用矩阵乘法来描述。给定输入向量 x<em>x</em>（长度为784），要转换为长度为10的输出向量，通常通过如下步骤：</p><h4 id="2-步骤"><a class="markdownIt-Anchor" href="#2-步骤"></a> 2. <strong>步骤：</strong></h4><ol><li><p><strong>输入向量 <img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"></strong>：这是一个长度为784的向量，表示神经网络的输入。</p><img src="/posts/23492/image-20240907224042533.png" class="" title="image-20240907224042533"></li><li><p><strong>权重矩阵 <img src="/posts/23492/image-20240907224200098.png" class="" title="image-20240907224200098"></strong>：全连接层会有一个权重矩阵 W<em>W</em>，其维度是 10×78410×784，表示从输入784维向量到输出10维向量的权重连接。每一行表示一个输出神经元与所有输入神经元的权重连接。</p></li><li><p><strong>偏置向量 <img src="/posts/23492/image-20240907224226570.png" class="" title="image-20240907224226570"></strong>：偏置向量 b<em>b</em> 是一个长度为10的向量，表示每个输出神经元的偏置。</p></li><li><p><strong>计算输出向量 <img src="/posts/23492/image-20240907224234671.png" class="" title="image-20240907224234671"></strong>：通过矩阵乘法计算输出向量。输出向量 o<em>o</em> 的维度是10。具体计算方式如下：</p><img src="/posts/23492/image-20240907224051327.png" class="" title="image-20240907224051327"><ul><li>W \cdot x )：矩阵 ( W ) 乘以向量 ( x )，将784维的输入向量映射为10维的输出向量。</li></ul></li></ol><h3 id="3-矩阵乘法具体步骤"><a class="markdownIt-Anchor" href="#3-矩阵乘法具体步骤"></a> 3. <strong>矩阵乘法具体步骤：</strong></h3><ul><li><p>假设输入向量<img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"> 是长度为784的向量：</p><img src="/posts/23492/image-20240907224100515.png" class="" title="image-20240907224100515"></li><li><p>权重矩阵 W<em>W</em> 是一个 10×78410×784 的矩阵：</p><img src="/posts/23492/image-20240907224116095.png" class="" title="image-20240907224116095"></li><li><p>偏置向量 b<em>b</em> 是一个长度为10的向量：</p><img src="/posts/23492/image-20240907224125174.png" class="" title="image-20240907223954313"></li><li><p>输出向量 o<em>o</em> 通过矩阵乘法和加法得到，维度为10：</p><img src="/posts/23492/image-20240907224134345.png" class="" title="image-20240907224134345"></li></ul><p>每一行表示一个输出神经元的结果，最终得到一个长度为10的向量。</p><h3 id="4-激活函数"><a class="markdownIt-Anchor" href="#4-激活函数"></a> 4. <strong>激活函数：</strong></h3><p>在得到长度为10的向量后，通常会将其通过激活函数进行处理。在分类任务中，输出层通常使用 <strong>Softmax</strong> 函数，将每个输出值转换为概率值。Softmax 函数公式为：</p><img src="/posts/23492/image-20240907224012315.png" class="" title="image-20240907224012315"><p>这会将输出向量 o<em>o</em> 转换为一个概率分布，表示输入属于不同类别的概率。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>将784长度的输入向量变为10长度的输出向量的关键步骤是通过 <strong>全连接层的矩阵乘法</strong> 和 <strong>偏置项</strong>，最终计算出长度为10的向量，并通过 <strong>Softmax</strong> 函数将其转换为概率分布，从而实现分类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-神经网络的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-神经网络的基本概念&quot;&gt;&lt;/a&gt; 一、神经网络的基本概念&lt;/h1&gt;
&lt;h2 id=&quot;1-神经元感知器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    
    <category term="学习笔记,深度学习" scheme="https://szturin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][2]stm32时钟树</title>
    <link href="https://szturin.github.io/posts/9067/"/>
    <id>https://szturin.github.io/posts/9067/</id>
    <published>2024-08-14T13:47:44.000Z</published>
    <updated>2024-10-29T08:06:04.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-锁相环的原理与应用"><a class="markdownIt-Anchor" href="#一-锁相环的原理与应用"></a> 一、锁相环的原理与应用</h1><p>参考文章：<a href="https://blog.csdn.net/weixin_46274168/article/details/130437627">【STM32】知识补充 锁相环原理与应用解析_stm32数字锁相-CSDN博客</a></p><h2 id="什么是锁相环-ppl"><a class="markdownIt-Anchor" href="#什么是锁相环-ppl"></a> 什么是锁相环 (PPL)</h2><p>锁相环是一种闭环反馈控制系统. 用于生成与输入信号同步且<a href="https://so.csdn.net/so/search?q=%E7%9B%B8%E4%BD%8D&amp;spm=1001.2101.3001.7020">相位</a>相同的输出信号. 它的核心功能是在输入信号的相位变化时, 自动调整输出信号以保持同步. 这使得锁相环成为了一种理想的频率和相位控制技术.</p><img src="/posts/9067/f9cb0a753bddf1fb37003ddd1310111b.png" class="" title="锁相环原理图"><h2 id="锁相环的基本组成"><a class="markdownIt-Anchor" href="#锁相环的基本组成"></a> 锁相环的基本组成</h2><p>锁相环主要由以下几个部分组成:</p><ul><li>相位比较器 (Phase Detector): 相位比较器负责比较输入信号和反馈信号的相位差, 并将其转换为电压信号</li><li>低通滤波器 (Low-Pass Filter): 低通滤波器对相位比较器的输出信号进行滤波, 以消除高频噪声和相位抖动</li><li>电压控制振荡器 (Voltage-Controlled Oscillator): 根据低通过滤波器的输出电压调整输出信号的频率和相位</li><li>反馈分频器 (Feedback Divider): 反馈分频器对 VCO 的输出信号进行分频处理, 并将其反馈给相位比较器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-锁相环的原理与应用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-锁相环的原理与应用&quot;&gt;&lt;/a&gt; 一、锁相环的原理与应用&lt;/h1&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://blog.csdn.net/weixin_46</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
  </entry>
  
  <entry>
    <title>【电赛】[2023E题]运动控制与目标追踪系统复刻[视觉部分]</title>
    <link href="https://szturin.github.io/posts/38463/"/>
    <id>https://szturin.github.io/posts/38463/</id>
    <published>2024-07-16T17:31:48.000Z</published>
    <updated>2024-10-01T18:12:26.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> # 注意</h1><p><mark><strong>本项目创建时间：2024-7-17</strong></mark></p><p><mark><strong>本文标记为OpenCV入门参考项目以及电赛典型范例，由题主长期维护 --2024-10-2</strong></mark></p><h1 id="一-图像处理方案"><a class="markdownIt-Anchor" href="#一-图像处理方案"></a> 一、图像处理方案</h1><p>Opencv: 开源计算机视觉处理库，使用嵌入式SOC板卡作为摄像头模块，提供相对可靠的性能。</p><p>由于激光点的亮度远高于其他位置，所以采用HSV格式的色彩空间，对图像H,S,V域进行识别。</p><p>若要区分红绿激光，那么就对图像的RGB空间进行处理</p><h2 id="2-电工胶带的识别"><a class="markdownIt-Anchor" href="#2-电工胶带的识别"></a> 2. 电工胶带的识别</h2><ul><li><p>使用原图像-&gt;灰度图像-&gt;设置阈值后进行二值化的方法，使得黑胶带区域识别为纯白色，其余部分全部为纯黑色区域。关于调参：建议使用创建滑块窗口的方法，进行动态调参，减少调参上浪费的时间。</p></li><li><p>摄像头容易受到外接环境光的干扰，可以通过调节分辨率，设置摄像头的图像获取范围，也有一种更为实用的方法：ROI（感兴趣区），可以通过创建<mark>掩膜</mark>的方式，只对ROI区域进行处理，这样就排除了外界环境的干扰。当然也可以使用切片的方法，定义一个变量用于读取图像的指定范围，然后再进行图像处理，需要显示参数时，再将一些特征点、辅助线、坐标点、数据显示在想要观看的图像上，使用opencv中的imshow进行可视化显示（注意：imshow是非常耗时的操作，在调试时可以使用，在最终运行时建议注释掉，提升程序执行效率，或者采取图像编解码的方法，使用TCP/UDP协议，ROS通信等方式进行远程图传，降低软件资源的使用）</p></li><li><p>ROI区域也不一定是适宜的图像处理区域，也可能有一些噪声信号的干扰，这可能就要需要用到一些滤波处理的算法，如：高斯平滑滤波（高斯模糊）。</p></li><li><p>胶带容易受激光点的影响，导致二值化图像被==“分割”==，所以需要对胶带的二值化图像先膨胀，后进行图形学闭运算缝合胶带二值化图像漏洞</p></li></ul><h2 id="3-串口通信的关键问题"><a class="markdownIt-Anchor" href="#3-串口通信的关键问题"></a> 3. 串口通信的关键问题</h2><ul><li>数据帧：一开始采用字符串发送地方法。结果单片机很容易接收不到一些数据帧</li><li>通信速率：19200</li></ul><h2 id="3-激光巡线的路径规划"><a class="markdownIt-Anchor" href="#3-激光巡线的路径规划"></a> 3. 激光“巡线”的路径规划</h2><ul><li><p>第一种方法：程序不断对图像进行处理，边缘检测，封闭图形检测，然后激光沿着检测出来的图形边沿进行巡线</p></li><li><p>第二种方法：采用“路径规划的方法”，进行一定时间的图像采集后，确定好激光的运行路径，这样，即避免了激光对矩形框识别的强光干扰，又大大减少了程序运行的资源损耗，只需要执行激光跟随部分的程序，不需要再对图像进行边沿检测。</p></li></ul><h1 id="二-程序设计"><a class="markdownIt-Anchor" href="#二-程序设计"></a> 二、程序设计</h1><h2 id="视觉部分"><a class="markdownIt-Anchor" href="#视觉部分"></a> 视觉部分</h2><h2 id="1-摄像头处理部分"><a class="markdownIt-Anchor" href="#1-摄像头处理部分"></a> 1. 摄像头处理部分</h2><h3 id="11-摄像头的类封装"><a class="markdownIt-Anchor" href="#11-摄像头的类封装"></a> 1.1 摄像头的类封装</h3><p>GuideLine 的作用：绘制辅助线</p><p>思考：Python中函数对形参的调用，会不会影响到实参？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 摄像头类创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pi_Camera</span>():</span><br><span class="line">    <span class="comment"># 类的初始化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 图像初始化配置</span></span><br><span class="line">        self.Video = cv2.VideoCapture(<span class="number">8</span>, cv2.CAP_V4L2)<span class="comment"># 使能摄像头8的驱动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查摄像头是否打开</span></span><br><span class="line">        ret = self.Video.isOpened()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The video is opened."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"No video."</span>)</span><br><span class="line">    </span><br><span class="line">        codec = cv2.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>)   </span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FOURCC, codec)</span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FPS, <span class="number">60</span>)                 <span class="comment"># 帧数</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">640</span>)        <span class="comment"># 列 宽度</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>)       <span class="comment"># 行 高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制辅助线</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GuideLine</span>(<span class="params">self, c1, c2</span>):</span><br><span class="line">        ret, image = self.Video.read()<span class="comment"># 注意：read返回一个bull值和图像数据list！，需要用两个变量获取</span></span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">360</span>), (<span class="number">640</span>, <span class="number">360</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)<span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">240</span>), (<span class="number">640</span>, <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)<span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="built_in">int</span>(c1), <span class="number">360</span>), (<span class="built_in">int</span>(c2), <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">2</span>)<span class="comment"># 绘出倾角线</span></span><br><span class="line">            cv2.imshow(<span class="string">"GuideLine"</span>, image)</span><br></pre></td></tr></tbody></table></figure><h3 id="12-摄像头的图像获取"><a class="markdownIt-Anchor" href="#12-摄像头的图像获取"></a> 1.2 摄像头的图像获取</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret, frame = Watch.Video.read() <span class="comment">#获取摄像头图像数据</span></span><br></pre></td></tr></tbody></table></figure><h3 id="13-相机资源的释放"><a class="markdownIt-Anchor" href="#13-相机资源的释放"></a> 1.3 相机资源的释放</h3><p>思考：Python中不对窗口，或者使用Python语言的硬件资源不释放会怎么样？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Watch.Video.release()</span><br></pre></td></tr></tbody></table></figure><h2 id="2-激光追踪相关"><a class="markdownIt-Anchor" href="#2-激光追踪相关"></a> 2. 激光追踪相关</h2><p>要想实现激光点的巡线，以及红绿激光的相互跟随，首先要做到单个激光点的精确识别与控制移动，这里我们使用了二维舵机云台，精度在能够完成基本要求之内。使用USB 1080P摄像头进行画面捕获。</p><p>激光点在图像中的亮度远远大于其他图像像素点，不难想到在HSV空间中对图像进行操作更容易识别到激光点。</p><h3 id="21-激光点识别的图形预处理"><a class="markdownIt-Anchor" href="#21-激光点识别的图形预处理"></a> 2.1 激光点识别的图形预处理</h3><p>通过调用v2.cvtColor()函数的方法，将图像颜色空间转换到 HSV中，然后通过设定阈值，进行图像的二值化（阈值调节建议采用滑块创建的方法，并且函数需要赋初值）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找激光点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_lasers</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># imgae:用于处理的画布图像，frame：原图像，且是最终数据展示的图像</span></span><br><span class="line">    <span class="keyword">global</span> load_process<span class="comment"># 声明使用外部定义的 load_process</span></span><br><span class="line">    </span><br><span class="line">    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)<span class="comment"># 转换颜色空间为HSV</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义红色激光点hsv色彩阈值范围，用作二值化</span></span><br><span class="line">    lower_laser = np.array([<span class="number">0</span>, <span class="number">100</span>, <span class="number">180</span>])</span><br><span class="line">    upper_laser = np.array([<span class="number">179</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建二值化图像</span></span><br><span class="line">    mask_laser = cv2.inRange(hsv, lower_laser, upper_laser) </span><br><span class="line">    <span class="comment"># cv2.imshow("mask_laser1", mask_laser)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 闭运算</span></span><br><span class="line">    kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">    mask_laser = cv2.morphologyEx(mask_laser, cv2.MORPH_CLOSE, kernel)</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-激光点的轮廓识别"><a class="markdownIt-Anchor" href="#2-2-激光点的轮廓识别"></a> 2. 2 激光点的轮廓识别</h3><p><strong>调用cv2.findContours()函数，对封闭图形进行检测，并且绘制出激光点的图形识别轮廓</strong></p><p>函数解释：</p><ol><li><strong><code>mask_laser</code></strong>：这是输入的二值图像，也就是说，它应该是经过阈值处理或其他形式的图像处理后得到的黑白图像（通常是单通道的，只有 0 和 255 两个像素值）。</li><li><strong><code>cv2.RETR_EXTERNAL</code></strong>：这是轮廓检索模式（Contour Retrieval Mode），指定了轮廓的检索模式。<code>RETR_EXTERNAL</code> 表示只检索最外层的轮廓，忽略内部的轮廓。还有其他的检索模式，比如 <code>RETR_LIST</code>、<code>RETR_TREE</code> 等，可以根据需要选择不同的模式。</li><li><strong><code>cv2.CHAIN_APPROX_SIMPLE</code></strong>：这是轮廓的逼近方法（Contour Approximation Method），指定了轮廓的表示方法。<code>CHAIN_APPROX_SIMPLE</code> 表示压缩水平、垂直和对</li><li>第一个返回值 <code>contours_laser</code> 是一个列表，其中每个元素是一个 numpy 数组，表示一个检测到的轮廓</li></ol><p><strong>cv2.minAreaRect()</strong></p><p>函数解释：</p><ul><li><strong><code>contour</code></strong>：这是一个轮廓，通常是通过 <code>findContours</code> 函数找到的其中一个轮廓对象，它是一个包含轮廓点的 numpy 数组。</li><li><strong><code>cv2.minAreaRect(contour)</code></strong>：这个函数接收一个轮廓作为输入，并返回一个 <code>RotatedRect</code> 对象，它表示包围轮廓的最小旋转矩形框。</li></ul><p>具体来说，返回的 <code>RotatedRect</code> 对象包含以下信息：</p><ul><li><strong><code>center</code></strong>：矩形框的中心点坐标 <code>(cx, cy)</code>。</li><li><strong><code>size</code></strong>：矩形框的宽度和高度 <code>(width, height)</code>。</li><li><strong><code>angle</code></strong>：矩形框相对于水平方向的旋转角度（逆时针为正）</li></ul><p><strong>获取矩形框角点：</strong></p><ol><li><strong><code>box = cv2.boxPoints(rect)</code></strong>：<ul><li><code>cv2.boxPoints</code> 函数接收一个 <code>RotatedRect</code> 对象作为输入，并返回该旋转矩形框的四个顶点坐标。</li><li>这些顶点坐标是浮点型数据，表示为一个包含四个点的 numpy 数组。</li></ul></li><li><strong><code>box = np.int0(box)</code></strong>：<ul><li>这一步将上一步得到的四个顶点坐标 <code>box</code> 转换为整数类型的 numpy 数组。</li><li><code>np.int0()</code> 函数会将浮点数数组四舍五入为最接近的整数，并返回一个整数类型的 numpy 数组。</li></ul></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找轮廓</span></span><br><span class="line">contours_laser, _ = cv2.findContours(mask_laser, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">laser_coords = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours_laser:</span><br><span class="line">    rect = cv2.minAreaRect(contour)<span class="comment"># 获取最小矩形框</span></span><br><span class="line">    laser_coords = <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, rect[<span class="number">0</span>]))<span class="comment"># 矩形框的中心坐标</span></span><br><span class="line">    box = cv2.boxPoints(rect)<span class="comment"># 矩形框的四个角点</span></span><br><span class="line">    box = np.int0(box)</span><br><span class="line">    cv2.drawContours(frame, [box], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)<span class="comment"># 绘制矩形框(原图像中) </span></span><br></pre></td></tr></tbody></table></figure><h3 id="23激光点的颜色区分"><a class="markdownIt-Anchor" href="#23激光点的颜色区分"></a> 2.3激光点的颜色区分</h3><p><strong>imge.shape[]</strong></p><ul><li><strong><code>image.shape</code></strong>：这是一个 numpy 数组属性，用于获取图像的尺寸和通道数信息。</li><li><strong><code>image.shape[:2]</code></strong>：这是对 <code>shape</code> 属性进行切片操作，<code>[:2]</code> 表示取前两个元素，即图像的高度和宽度。</li></ul><p>具体来说，如果 <code>image</code> 是一个图像的 numpy 数组，例如形状为 <code>(height, width, channels)</code>，那么 <code>image.shape[:2]</code> 将返回一个包含图像高度和宽度的元组 <code>(height, width)</code>。</p><p>这种操作通常用于获取图像的空间尺寸信息，以便在处理图像时进行尺寸相关的计算或操作</p><p><strong>方圆坐标确定：</strong></p><ol><li><strong>获取输入坐标：</strong><ul><li><code>x, y = coords</code>：这行代码将变量 <code>coords</code> 解构为 <code>x</code> 和 <code>y</code>，分别表示中心点的横纵坐标。</li></ul></li><li><strong>确定左上角坐标：</strong><ul><li><code>x_start = max(0, x - radius)</code>：计算方形区域的左上角横坐标。<code>x - radius</code> 表示以中心点 <code>x</code> 为基础，向左偏移半径 <code>radius</code> 的距离。<code>max(0, ...)</code> 确保左上角横坐标不会小于 0，即不会超出图像左边界。</li><li><code>y_start = max(0, y - radius)</code>：计算方形区域的左上角纵坐标。同理，<code>y - radius</code> 表示以中心点 <code>y</code> 为基础，向上偏移半径 <code>radius</code> 的距离。<code>max(0, ...)</code> 确保左上角纵坐标不会小于 0，即不会超出图像上边界。</li></ul></li><li><strong>确定右下角坐标：</strong><ul><li><code>x_end = min(width - 1, x + radius)</code>：计算方形区域的右下角横坐标。<code>x + radius</code> 表示以中心点 <code>x</code> 为基础，向右偏移半径 <code>radius</code> 的距离。<code>min(width - 1, ...)</code> 确保右下角横坐标不会超过图像的右边界。</li><li><code>y_end = min(height - 1, y + radius)</code>：计算方形区域的右下角纵坐标。同理，<code>y + radius</code> 表示以中心点 <code>y</code> 为基础，向下偏移半径 <code>radius</code> 的距离。<code>min(height - 1, ...)</code> 确保右下角纵坐标不会超过图像的下边界。</li></ul></li></ol><p><strong>get_pixel_sum</strong></p><p>这段代码用于从给定的区域中提取红色（R）和绿色（G）颜色通道的值。让我来解释一下这段代码的含义：</p><ol><li><strong><code>roi[:, :, 2]</code>：</strong><ul><li><code>roi</code> 应该是图像的一个区域，即感兴趣的区域（Region of Interest，ROI）。</li><li><code>:</code> 是一个表示所有行或所有列的切片操作。</li><li><code>[ : , : , 2]</code> 表示选取所有行的所有列的第三个颜色通道。在 BGR 颜色空间中，第三个通道对应的是红色通道，所以这行代码获取了 ROI 中所有的红色通道值。</li></ul></li><li><strong><code>roi[:, :, 1]</code>：</strong><ul><li>与上面的代码类似，这行代码选取了所有行的所有列的第二个颜色通道。在 BGR 颜色空间中，第二个通道对应的是绿色通道，所以这行代码获取了 ROI 中所有的绿色通道值。</li></ul></li></ol><p>在大多数图像处理库中（如 OpenCV），图像默认是以 BGR 顺序存储的，而不是 RGB。这意味着在获取颜色通道时需要使用 <code>[ : , : , 2]</code> 来获取红色通道，<code>[ : , : , 1]</code> 来获取绿色通道，<code>[ : , : , 0]</code> 来获取蓝色通道。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激光点RGB值获取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pixel_sum</span>(<span class="params">image, coords</span>):</span><br><span class="line">    <span class="comment"># 获取图像宽度和高度</span></span><br><span class="line">    height, width = image.shape[:<span class="number">2</span>]</span><br><span class="line">    radius = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确定方圆的左上角和右下角坐标</span></span><br><span class="line">    x, y = coords</span><br><span class="line">    x_start = <span class="built_in">max</span>(<span class="number">0</span>, x - radius)</span><br><span class="line">    y_start = <span class="built_in">max</span>(<span class="number">0</span>, y - radius)</span><br><span class="line">    x_end = <span class="built_in">min</span>(width - <span class="number">1</span>, x + radius)</span><br><span class="line">    y_end = <span class="built_in">min</span>(height - <span class="number">1</span>, y + radius)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取方圆区域</span></span><br><span class="line">    roi = image[y_start:y_end, x_start:x_end]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算 R 和 G 通道总值</span></span><br><span class="line">    r_channel = roi[:, :, <span class="number">2</span>]</span><br><span class="line">    g_channel = roi[:, :, <span class="number">1</span>]</span><br><span class="line">    r_sum = <span class="built_in">int</span>(r_channel.<span class="built_in">sum</span>())</span><br><span class="line">    g_sum = <span class="built_in">int</span>(g_channel.<span class="built_in">sum</span>())</span><br><span class="line">    <span class="keyword">return</span> r_sum, g_sum</span><br></pre></td></tr></tbody></table></figure><p><strong>cv2.circle(frame, laser_coords, 4, (0, 0, 255), -1)</strong></p><p>绘制实心圆</p><p><strong>cv2.putText()</strong></p><ol><li><strong>参数解释：</strong><ul><li><code>frame</code>：这是目标图像帧，即要在其上添加文本的图像。</li><li><code>"RED"</code>：要写入的文本内容，这里是字符串 “RED”。</li><li><code>(laser_coords[0] - 10, laser_coords[1] - 10)</code>：文本放置的起始位置，由 <code>laser_coords</code> 提供，向左上方偏移了 <code>(10, 10)</code> 的像素值。</li><li><code>cv2.FONT_HERSHEY_SIMPLEX</code>：字体类型，这里使用了简单的字体类型。</li><li><code>0.5</code>：字体大小因子，控制文本大小相对于基础字体的比例。</li><li><code>(0, 0, 255)</code>：文本的颜色，这里是红色，对应 BGR 颜色空间中的 <code>(0, 0, 255)</code>。</li><li><code>2</code>：文本的线宽，即文本轮廓的粗细。</li></ul></li><li><strong>作用说明：</strong><ul><li>这行代码的主要作用是在图像帧的指定位置绘制红色的文本 “RED”。通常用于在图像或视频中标记特定的对象、位置或状态信息。</li></ul></li><li><strong>注意事项：</strong><ul><li>如果 <code>laser_coords</code> 提供的坐标 <code>(x, y)</code> 位于图像的边缘，确保 <code>(x - 10, y - 10)</code> 不会超出图像边界，以避免出现越界错误。</li></ul></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否获取到激光点矩形框的中心坐标，防止读取值为空</span></span><br><span class="line"><span class="keyword">if</span> laser_coords <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 获取激光点的RGB数据</span></span><br><span class="line">    color_vel = get_pixel_sum(image, laser_coords)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在红色激光点中心坐标出绘制圆点图像(原图像中)</span></span><br><span class="line">    cv2.circle(frame, laser_coords, <span class="number">4</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 打印文本数据“RED”在红色激光点上 </span></span><br><span class="line">    cv2.putText(frame ,<span class="string">"RED"</span>, (laser_coords[<span class="number">0</span>] - <span class="number">10</span>, laser_coords[<span class="number">1</span>] - <span class="number">10</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)    </span><br></pre></td></tr></tbody></table></figure><h3 id="24差值计算与串口通信"><a class="markdownIt-Anchor" href="#24差值计算与串口通信"></a> 2.4差值计算与串口通信</h3><p>PS:上位机与下位机通信，建议采用十六进制：帧头+数据类型+数据内容 的单帧数据包格式，这样才能保证下位机能够同步反应上位机发送的特征值，减小通信的复杂度，同时可靠性和速率较高，不建议采用发送字符串类型的通信。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> mode == <span class="string">'A'</span>:</span><br><span class="line">        direction = long_path[load_process]</span><br><span class="line">        <span class="comment"># 获取激光点与图像中心坐标或目标坐标的差值</span></span><br><span class="line">        x_err = laser_coords[<span class="number">0</span>]-direction[<span class="number">0</span>]</span><br><span class="line">        y_err = laser_coords[<span class="number">1</span>]-direction[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">'B'</span>:     </span><br><span class="line">        x_err = laser_coords[<span class="number">0</span>]-center_point_x</span><br><span class="line">        y_err = laser_coords[<span class="number">1</span>]-center_point_y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果激光点到达目标点（误差小于定值），目标点切换到下一个路径点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x_err) &lt;= <span class="number">5</span> <span class="keyword">and</span> <span class="built_in">abs</span>(y_err) &lt;= <span class="number">5</span>:</span><br><span class="line">        load_process-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> load_process == -<span class="number">1</span>:</span><br><span class="line">        load_process=<span class="number">11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 串口发送，数据帧格式:0xFF(帧头),&lt;x轴误差的数据类型&gt;,&lt;y轴误差的数据类型&gt;,&lt;x轴误差大小&gt;,&lt;y轴误差大小&gt;</span></span><br><span class="line">    <span class="keyword">if</span> x_err &lt; <span class="number">0</span>:</span><br><span class="line">        x_data_type = <span class="number">0x2D</span>  <span class="comment"># -x</span></span><br><span class="line">        x_data = <span class="built_in">abs</span>(x_err)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x_data_type = <span class="number">0x2B</span>  <span class="comment"># +x</span></span><br><span class="line">        x_data = x_err</span><br><span class="line">    <span class="keyword">if</span> y_err &lt; <span class="number">0</span>:</span><br><span class="line">        y_data_type = <span class="number">0x3D</span>  <span class="comment"># -y</span></span><br><span class="line">        y_data = <span class="built_in">abs</span>(y_err)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_data_type = <span class="number">0x3B</span>  <span class="comment"># +y</span></span><br><span class="line">        y_data = y_err</span><br><span class="line"></span><br><span class="line">    hex_data = <span class="built_in">bytes</span>([<span class="number">0xFF</span>,x_data_type,y_data_type,x_data, y_data])<span class="comment">#y-</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(hex_data.<span class="built_in">hex</span>())</span><br><span class="line">    ser.write(hex_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print('x:'+ str(x_err))</span></span><br><span class="line">    <span class="comment">#print('y:'+ str(y_err))</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"没找到激光点"</span>)</span><br><span class="line"><span class="keyword">return</span> image</span><br><span class="line"><span class="comment">#cv2.circle(image, (center_x, center_y), 5, (0, 255, 0), -1)</span></span><br><span class="line"><span class="comment">#cv2.imshow("Laser Detection", image)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3胶带矩形框识别"><a class="markdownIt-Anchor" href="#3胶带矩形框识别"></a> 3.胶带矩形框识别</h2><h3 id="31-roi区域的创建"><a class="markdownIt-Anchor" href="#31-roi区域的创建"></a> 3.1 ROI区域的创建</h3><p>PS: 使用ROI区域后，又想还原到原图像上对图像进行处理，就需要对坐标进行还原操作，保证图形每个像素点的索引和原图像对应</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROIPixelProcessor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_roi</span>(<span class="params">self, image, roi</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        取得 ROI 区域的像素值进行处理，但不改变索引号</span></span><br><span class="line"><span class="string">        :param image: 输入图像</span></span><br><span class="line"><span class="string">        :param roi: ROI 参数 (x, y, width, height)</span></span><br><span class="line"><span class="string">        :return: ROI 区域的像素值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x, y, w, h = roi</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确保 ROI 在图像范围内</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            w += x</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> y &lt; <span class="number">0</span>:</span><br><span class="line">            h += y</span><br><span class="line">            y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x + w &gt; image.shape[<span class="number">1</span>]:</span><br><span class="line">            w = image.shape[<span class="number">1</span>] - x</span><br><span class="line">        <span class="keyword">if</span> y + h &gt; image.shape[<span class="number">0</span>]:</span><br><span class="line">            h = image.shape[<span class="number">0</span>] - y</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 提取 ROI 区域的像素值</span></span><br><span class="line">        roi_pixels = image[y:y+h, x:x+w]</span><br><span class="line">        <span class="keyword">return</span> roi_pixels</span><br></pre></td></tr></tbody></table></figure><h3 id="32-图像的预处理"><a class="markdownIt-Anchor" href="#32-图像的预处理"></a> 3.2 图像的预处理</h3><p>通过BGR转灰度，自设定阈值进行二值化地方法，将胶带部分转换为白色单值，其他部分全为黑色单值，并且通过滤波、腐蚀、闭运算地方法对图形进行处理，降低噪点干扰，提高图形识别完整性。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> time.time()-start_time &lt;= <span class="number">5</span>:       </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将图像转换为灰度图</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment">#cv2.imshow('gray',gray)</span></span><br><span class="line"></span><br><span class="line">    gray = cv2.GaussianBlur(gray, (<span class="number">9</span>, <span class="number">9</span>), <span class="number">0</span>) <span class="comment">#高斯平滑滤波,(9,9)是卷积核，0 代表函数自动计算标准差</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#cv2.imshow('gauss',gray)</span></span><br><span class="line">    <span class="comment"># 对灰度图进行阈值处理，将黑色部分变为白色，其他部分变为黑色</span></span><br><span class="line">    _, threshold = cv2.threshold(gray, <span class="number">120</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行形态学闭操作，填充内部空洞</span></span><br><span class="line">    kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">    closing = cv2.morphologyEx(threshold, cv2.MORPH_CLOSE, kernel, iterations=<span class="number">3</span>)       </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行形态学腐蚀操作，缩小黑框大小，减少噪点信号干扰</span></span><br><span class="line">    kernel = np.ones((<span class="number">3</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">    erosion = cv2.erode(closing,kernel,iterations = <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#dilation = cv2.dilate(threshold, kernel, iterations=1) </span></span><br></pre></td></tr></tbody></table></figure><h3 id="33-矩形框轮廓的识别"><a class="markdownIt-Anchor" href="#33-矩形框轮廓的识别"></a> 3.3 矩形框轮廓的识别</h3><p>同样地，使用封闭图形检测算法，检测矩形框轮廓，这里使用 ROI处理，要特别注意像素点索引（坐标）的复原的操作。</p><p>即：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将轮廓绘制在原始图像上</span></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    <span class="comment"># 将轮廓点的坐标映射回原始图像的坐标系</span></span><br><span class="line">    contour += (x, y)  <span class="comment"># 将ROI的偏移加回来</span></span><br></pre></td></tr></tbody></table></figure><p><strong>近似曲线</strong></p><p>注意：这里approx_contour得到的是最终近似矩形的四个角点的坐标！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epsilon = 0.01 * cv2.arcLength(max_contour, True)</span><br><span class="line">approx_contour = cv2.approxPolyDP(max_contour, epsilon, True)</span><br></pre></td></tr></tbody></table></figure><ul><li><code>cv2.arcLength</code> 用于计算轮廓的周长或弧长。</li><li><code>epsilon</code> 是一个近似精度参数，通常是轮廓周长的某个百分比，这里设定为总周长的1%。</li><li><code>cv2.approxPolyDP</code> 用来对轮廓进行多边形逼近，通过减少顶点的数量来近似表示轮廓。</li><li><code>approx_contour</code> 是近似后的多边形轮廓。</li></ul><p><strong>找到左右轮廓的边界点（列表）</strong></p><p>leftmost[0]就是左轮廓第一个点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftmost = min(path, key=lambda x: x[0])  # 左轮廓边界坐标点</span><br><span class="line">rightmost = max(path, key=lambda x: x[0])  # 右轮廓边界坐标点</span><br></pre></td></tr></tbody></table></figure><ul><li><code>path</code> 是一组坐标点的集合，通常表示为一个列表或数组。</li><li><code>min(path, key=lambda x: x[0])</code> 和 <code>max(path, key=lambda x: x[0])</code> 分别用于找到 <code>path</code> 中横坐标 <code>x</code> 最小和最大的点，即左轮廓和右轮廓的边界点。</li></ul><p><strong>参数说明</strong>：</p><ul><li><code>lambda x: x[0]</code> 是一个匿名函数，用于指定以每个点的横坐标 <code>x</code> 作为比较的关键字。因此，<code>min</code> 函数找到具有最小横坐标的点，而 <code>max</code> 函数找到具有最大横坐标的点。</li></ul><p><strong>计算轮廓的中心点</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">center_point_x = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">0</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">center_point_y = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">1</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">center_point = (center_point_x, center_point_y)</span><br></pre></td></tr></tbody></table></figure><ul><li><code>path</code> 是一组轮廓的坐标点集合，通常表示为一个列表或数组。</li><li><code>sum([point[0] for point in path])</code> 对 <code>path</code> 中所有点的横坐标进行求和。</li><li><code>sum([point[1] for point in path])</code> 对 <code>path</code> 中所有点的纵坐标进行求和。</li><li><code>len(path)</code> 是 <code>path</code> 中点的数量，即轮廓的长度或大小。</li></ul><p><strong>参数说明</strong>：</p><ul><li><code>center_point_x</code> 和 <code>center_point_y</code> 分别是计算得到的轮廓中心点的横坐标和纵坐标。</li><li><code>center_point</code> 是由 <code>center_point_x</code> 和 <code>center_point_y</code> 组成的元组，表示轮廓的中心点坐标 <code>(x, y)</code>。</li></ul><p><strong>作用</strong>：</p><ul><li>这段代码的作用是计算轮廓 <code>path</code> 的几何中心点，通过对所有点的坐标进行平均值计算得出</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cv2.imshow('dilation',erosion)</span></span><br><span class="line"></span><br><span class="line">roi = closing[center_y-<span class="number">120</span>:center_y+<span class="number">120</span>, center_x-<span class="number">120</span>:center_x+<span class="number">120</span>]<span class="comment">#创建ROI图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow('roi',roi)</span></span><br><span class="line">x,y,w,h = center_x-<span class="number">120</span>,center_y-<span class="number">120</span>,<span class="number">240</span>,<span class="number">240</span> <span class="comment">#ROI左上角点为220,140，ROI检测框高度为200，宽度为200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制ROI矩形</span></span><br><span class="line">cv2.rectangle(frame,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow('erosion',erosion)</span></span><br><span class="line"><span class="comment"># 利用轮廓检测函数找到黑色框的轮廓</span></span><br><span class="line">contours, hierarchy = cv2.findContours(roi, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"><span class="comment"># 轮廓      层级                               轮廓检索模式  轮廓逼近方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将轮廓绘制在原始图像上</span></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    <span class="comment"># 将轮廓点的坐标映射回原始图像的坐标系</span></span><br><span class="line">    contour += (x, y)  <span class="comment"># 将ROI的偏移加回来</span></span><br><span class="line">    <span class="comment">#cv2.drawContours(frame, [contour], -1, (0, 0, 255), 2) 原始轮廓，这里用近似法得到更平滑的外围轮廓</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果找到了轮廓</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(contours) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 提取最大的轮廓</span></span><br><span class="line">    max_contour = <span class="built_in">max</span>(contours, key=cv2.contourArea)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 近似曲线</span></span><br><span class="line">    epsilon = <span class="number">0.01</span> * cv2.arcLength(max_contour, <span class="literal">True</span>)</span><br><span class="line">    approx_contour = cv2.approxPolyDP(max_contour, epsilon, <span class="literal">True</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 获取路径坐标</span></span><br><span class="line">    path = []</span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> approx_contour:</span><br><span class="line">        path.append(<span class="built_in">tuple</span>(point[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到左右轮廓的边界点</span></span><br><span class="line">    leftmost = <span class="built_in">min</span>(path, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])<span class="comment"># 左轮廓边界坐标点</span></span><br><span class="line">    rightmost = <span class="built_in">max</span>(path, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])<span class="comment"># 右轮廓边界坐标点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算左右轮廓的中间点</span></span><br><span class="line">    middle_x = <span class="built_in">int</span>((leftmost[<span class="number">0</span>] + rightmost[<span class="number">0</span>]) / <span class="number">2</span>)<span class="comment"># x中心坐标</span></span><br><span class="line">    middle_y = <span class="built_in">int</span>((leftmost[<span class="number">1</span>] + rightmost[<span class="number">1</span>]) / <span class="number">2</span>)<span class="comment"># y中心坐标</span></span><br><span class="line">    middle_point = (middle_x, middle_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制左右轮廓中心点                 </span></span><br><span class="line">    <span class="comment">#cv2.circle(frame, middle_point, 5, (0, 255, 0), -1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算轮廓的中心点</span></span><br><span class="line">    center_point_x = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">0</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">    center_point_y = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">1</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">    center_point = (center_point_x, center_point_y)            </span><br><span class="line"></span><br><span class="line">    cv2.drawContours(frame, [np.array(path)], -<span class="number">1</span>, (<span class="number">125</span>, <span class="number">255</span>, <span class="number">125</span>), <span class="number">1</span>) <span class="comment">#近似后的轮廓</span></span><br><span class="line">    <span class="comment">#                           轮廓     第几个(默认-1：所有)   颜色       线条厚度       </span></span><br><span class="line">    <span class="comment"># 绘制轮廓中心点</span></span><br><span class="line">    cv2.circle(frame, center_point, <span class="number">3</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)        </span><br><span class="line"></span><br><span class="line">    resize = <span class="number">0.92</span></span><br><span class="line"></span><br><span class="line">    resize_path = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> path:</span><br><span class="line">        resize_x =  <span class="built_in">int</span>(center_point_x + resize*(point[<span class="number">0</span>]-center_point_x))</span><br><span class="line">        resize_y =  <span class="built_in">int</span>(center_point_y + resize*(point[<span class="number">1</span>]-center_point_y))</span><br><span class="line">        resize_path.append((resize_x,resize_y))</span><br><span class="line"></span><br><span class="line">    cv2.drawContours(frame, [np.array(resize_path)], -<span class="number">1</span>, (<span class="number">125</span>, <span class="number">255</span>, <span class="number">125</span>), <span class="number">1</span>) <span class="comment"># 内缩后的轮廓</span></span><br><span class="line">    long_path = interpolate_points(resize_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> long_path:</span><br><span class="line">        cv2.circle(frame, point, <span class="number">4</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="3-4-矩形框的路径规划-插值算法"><a class="markdownIt-Anchor" href="#3-4-矩形框的路径规划-插值算法"></a> 3-4 矩形框的路径规划-插值算法</h3><p>如果让激光点沿着轮廓一个一个坐标点去走，这样计算量会相当大，不如将矩形轮廓通过近似得到四个角点，再通过插值法，设置相邻点的插值参数，得到12个路径点，这样就既保证了巡线的稳定性，也大大减少了巡线的计算量。同时，通过调用time库来计时，程序启动时定时5s后，这段时间提供给我们确认摄像机状态，移动ROI区域，完成路径规划，实现“动态建图”的效果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#插值算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">interpolate_points</span>(<span class="params">points</span>):</span><br><span class="line">    interpolated_points = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">        start_point = points[i]</span><br><span class="line">        end_point = points[(i+<span class="number">1</span>) % <span class="built_in">len</span>(points)]</span><br><span class="line">        <span class="comment"># 计算两点之间的距离</span></span><br><span class="line">        dx = end_point[<span class="number">0</span>] - start_point[<span class="number">0</span>]</span><br><span class="line">        dy = end_point[<span class="number">1</span>] - start_point[<span class="number">1</span>]</span><br><span class="line">        distance = <span class="number">3</span></span><br><span class="line">        <span class="comment"># 根据距离进行插值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(distance):</span><br><span class="line">            x = start_point[<span class="number">0</span>] + <span class="built_in">int</span>(dx * j / distance)</span><br><span class="line">            y = start_point[<span class="number">1</span>] + <span class="built_in">int</span>(dy * j / distance)</span><br><span class="line">            interpolated_points.append((x, y))</span><br><span class="line">    <span class="keyword">return</span> interpolated_points</span><br></pre></td></tr></tbody></table></figure><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;注意&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#注意&quot;&gt;&lt;/a&gt; # 注意&lt;/h1&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;本项目创建时间：2024-7-17&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;本</summary>
      
    
    
    
    <category term="RDK X3" scheme="https://szturin.github.io/categories/RDK-X3/"/>
    
    <category term="OpenCV" scheme="https://szturin.github.io/categories/OpenCV/"/>
    
    
    <category term="电赛" scheme="https://szturin.github.io/tags/%E7%94%B5%E8%B5%9B/"/>
    
    <category term="OpenCV" scheme="https://szturin.github.io/tags/OpenCV/"/>
    
    <category term="激光追踪" scheme="https://szturin.github.io/tags/%E6%BF%80%E5%85%89%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【Opencv】[1]图像处理基本概念</title>
    <link href="https://szturin.github.io/posts/51713/"/>
    <id>https://szturin.github.io/posts/51713/</id>
    <published>2024-07-07T16:42:28.000Z</published>
    <updated>2024-10-03T11:24:34.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="opencv中文文档"><a class="markdownIt-Anchor" href="#opencv中文文档"></a> # OpenCV中文文档</h1><p><a href="https://woshicver.com/">https://woshicver.com/</a></p><h1 id="一-图像处理常见基本概念"><a class="markdownIt-Anchor" href="#一-图像处理常见基本概念"></a> 一、图像处理常见基本概念</h1><h2 id="1bgr和rgb格式"><a class="markdownIt-Anchor" href="#1bgr和rgb格式"></a> 1.BGR和RGB格式</h2><blockquote><ul><li><p>BGR和RGB是两种常见的颜色编码格式，它们在像素颜色排列的顺序上有所不同：</p><ol><li><strong>RGB格式</strong>：<ul><li>RGB指的是红色（R）、绿色（G）、蓝色（B）三个颜色通道的顺序。</li><li>在RGB格式中，像素的颜色值按照红、绿、蓝的顺序排列，即最开始的三个字节依次表示红色、绿色和蓝色分量。</li></ul></li><li><strong>BGR格式</strong>：<ul><li>BGR则是蓝色（B）、绿色（G）、红色（R）的顺序。</li><li>在BGR格式中，像素的颜色值按照蓝、绿、红的顺序排列，即最开始的三个字节依次表示蓝色、绿色和红色分量。</li></ul></li></ol><p>这两种格式主要在图像处理中有所区别。例如，<mark>在OpenCV中，默认情况下读取的图像格式是BGR而非RGB</mark>，这意味着你在处理图像数据时需要注意颜色通道的顺序。如果需要与其他软件或标准的RGB格式进行交互，通常需要进行颜色通道的重新排列。</p><p>总结：</p><ul><li><strong>RGB</strong>：红色、绿色、蓝色，像素颜色排列顺序是RGB。</li><li><strong>BGR</strong>：蓝色、绿色、红色，像素颜色排列顺序是BGR。</li></ul></li></ul><p>RGB格式的缺陷：自然条件下截取的图像，容易受到光线的影响，即对亮度比较敏感，RGB的三个分量都会受亮度的影响。</p></blockquote><h2 id="2-hsv格式"><a class="markdownIt-Anchor" href="#2-hsv格式"></a> 2. HSV格式</h2><blockquote><p>在图像处理中使用较多的是 HSV 颜色空间，它比 RGB 更接近人们对彩色的感知经验。非常直观地表达颜色的色调、鲜艳程度和明暗程度，方便进行颜色的对比。</p><p>​    在 HSV 颜色空间下，比 RGB 更容易跟踪某种颜色的物体，常用于分割指定颜色的物体。</p><p>​    HSV 表达彩色图像的方式由三个部分组成：</p><ul><li>Hue（色调、色相），相当于基调，是下图的俯视图得到的圆，圆上不同位置的颜色基调不同，把颜色分成了360°，每个位置有不同的颜色基调；</li><li>Saturation（饱和度、色彩纯净度）：纯度，沿着俯视图得到的圆的半径看，因为圆弧上的点代表该处的颜色的基调，那么半径上就是从纯白色到该基调颜色过渡过程中不同位置的纯度，在圆心处纯度为0，在圆弧上（该色调）纯度为100；</li><li>Value（明度）：亮度，沿着圆柱的高来看，圆柱表面上平行于圆柱轴上的点的颜色基调相同，纯度也相同，但是明暗程度不同。同时，该圆柱的半径也不同，相当于磁盘的柱面。</li></ul><p>​    用下面这个圆柱体来表示 HSV 颜色空间，圆柱体的横截面可以看做是一个极坐标系 ，H 用极坐标的极角表示，S 用极坐标的极轴长度表示，V 用圆柱中轴的高度表示。</p><img src="/posts/51713/a8d376f7eceb5a45001650bde730f019.png" class="" title="img"></blockquote><h2 id="3-分辨率和像素"><a class="markdownIt-Anchor" href="#3-分辨率和像素"></a> 3. 分辨率和像素</h2><p>1、像素是指照片的点数(表示照片是由多少点构成的)，分辨率是指照片像素点的密度(是用单位尺寸内的像素点，一般用每英寸多少点表示–dpi)。照片实际大小是像素决定的。一个像素很大的照片，如果将分辨率设置很大的话，打印出来的照片可能并不大(但是很清晰)。反之，一个像素并不很大的照片，如果将分辨率设置得很小，那么打印出来的照片可能很大(但是不清晰)。</p><p>2、 分辨率指单位长度上的像素值，与打印质量有关，一般使用的量纲为PPI; 总像素指图片的样本精度，与可打印尺寸有关，通常使用“长×宽”的方式表示，乘积就是通常所说的总像素。由于图片的宽高比不同，所以，同一总像素可以有多种规格。</p><h2 id="4-roi区域"><a class="markdownIt-Anchor" href="#4-roi区域"></a> 4. ROI区域</h2><blockquote><p>在计算机视觉和图像处理中，感兴趣区域（Region of Interest, ROI）是指图像中特别关注的部分。ROI 通常用于提取图像中的特定区域进行进一步的处理和分析，比如特征提取、对象识别、图像分割等。</p><h3 id="roi-的主要作用"><a class="markdownIt-Anchor" href="#roi-的主要作用"></a> ROI 的主要作用：</h3><ol><li><strong>减少处理时间</strong>：通过只处理图像中的特定区域，可以显著减少处理时间，提高效率。</li><li><strong>集中处理目标</strong>：可以将处理的焦点集中在图像中最相关的部分，忽略背景或其他不相关的区域。</li><li><strong>提高精度</strong>：在某些情况下，ROI 的提取可以提高图像处理的精度，尤其是在目标对象占据图像较小区域时。</li></ol><h3 id="如何定义和提取-roi"><a class="markdownIt-Anchor" href="#如何定义和提取-roi"></a> 如何定义和提取 ROI：</h3><p>通常，ROI 是一个矩形区域，可以通过指定其左上角和右下角的坐标来定义。在 OpenCV 中，可以通过数组切片的方式来提取 ROI。</p><h4 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码：</h4><p>以下是一个使用 OpenCV 提取 ROI 的简单示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># 读取图像</span><br><span class="line">image = cv2.imread('image.jpg')</span><br><span class="line"></span><br><span class="line"># 定义ROI的坐标（左上角和右下角）</span><br><span class="line">x1, y1 = 100, 100  # 左上角坐标</span><br><span class="line">x2, y2 = 300, 300  # 右下角坐标</span><br><span class="line"></span><br><span class="line"># 提取ROI区域</span><br><span class="line">roi = image[y1:y2, x1:x2]</span><br><span class="line"></span><br><span class="line"># 显示原图和ROI区域</span><br><span class="line">cv2.imshow('Original Image', image)</span><br><span class="line">cv2.imshow('ROI', roi)</span><br><span class="line"></span><br><span class="line"># 等待按键</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明：</h3><ol><li><strong>读取图像</strong>：使用 <code>cv2.imread()</code> 读取图像文件。</li><li><strong>定义 ROI</strong>：通过指定矩形的左上角 <code>(x1, y1)</code> 和右下角 <code>(x2, y2)</code> 坐标来定义感兴趣区域。</li><li><strong>提取 ROI</strong>：使用切片操作 <code>image[y1:y2, x1:x2]</code> 提取 ROI 区域。</li><li><strong>显示图像</strong>：使用 <code>cv2.imshow()</code> 显示原图和提取的 ROI。</li></ol><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><ul><li><strong>坐标有效性</strong>：确保 ROI 的坐标在图像的范围内，否则会导致错误。</li><li><strong>矩形定义</strong>：左上角坐标 <code>(x1, y1)</code> 应小于右下角坐标 <code>(x2, y2)</code>。</li></ul><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h3><ul><li><strong>目标检测</strong>：提取图像中检测到的目标区域进行进一步分析。</li><li><strong>图像分割</strong>：提取图像中特定的分割区域进行处理。</li><li><strong>特征提取</strong>：只对感兴趣的区域进行特征提取，减少计算量。</li></ul><p>通过合理定义和提取 ROI，可以有效地提高图像处理的效率和精度。</p></blockquote><h1 id="二-opencv介绍"><a class="markdownIt-Anchor" href="#二-opencv介绍"></a> 二、OpenCV介绍</h1><blockquote><p>OpenCV（open source computer vision library）是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。<br>它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。<br>OpenCV用C<ins>语言编写，它的主要接口也是C</ins>语言，但是依然保留了大量的C语言接口。</p></blockquote><p>安装opencv</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></tbody></table></figure><h1 id="三-opencv常用接口"><a class="markdownIt-Anchor" href="#三-opencv常用接口"></a> 三、OpenCV常用接口</h1><h2 id="一-图像入门"><a class="markdownIt-Anchor" href="#一-图像入门"></a> 一、图像入门</h2><p>Opencv常见相关功能库：</p><ul><li>numpy</li><li>Matplotlib</li></ul><h3 id="1-读取图像"><a class="markdownIt-Anchor" href="#1-读取图像"></a> 1. 读取图像</h3><p><code>cv2.imread()</code></p><ul><li>cv.IMREAD_COLOR： 加载彩色图像。任何图像的透明度都会被忽视。它是默认标志。</li><li>cv.IMREAD_GRAYSCALE：以灰度模式加载图像</li><li>cv.IMREAD_UNCHANGED：加载图像，包括alpha通道</li></ul><p><strong>注意</strong>： 除了这三个标志，你可以分别简单地传递整数1、0或-1。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以灰度格式加载图像</span></span><br><span class="line">img_file = cv.imread(<span class="string">"123.jpg"</span>,<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="2-显示图像与用户交互"><a class="markdownIt-Anchor" href="#2-显示图像与用户交互"></a> 2. 显示图像与用户交互</h3><p><code>cv2.imshow()</code></p><p>使用函数**cv2.imshow()**在窗口中显示图像。窗口自动适合图像尺寸。</p><p>第一个参数是窗口名称，它是一个字符串。第二个参数是我们的对象。可以根据需要创建任意多个窗口，可以使用不同的窗口名称</p><p><code>cv.waitKey()</code>是一个键盘绑定函数。其参数是以毫秒为单位的时间。该函数等待任何键盘事件指定的毫秒。如果您在这段时间内按下任何键，程序将继续运行。如果<strong>0</strong>被传递，它将无限期地等待一次敲击键。</p><p><code>cv.destroyAllWindows()</code>破坏创建的所有窗口。</p><p><code>cv.destroyWindow()</code>在其中传递确切的窗口名称作为参数。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv.imshow(<span class="string">"img"</span>,img_file)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><p>PS: <code>cv.namedWindow()</code>可以创建一个空窗口</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv.namedWindow(<span class="string">'image'</span>,cv.WINDOW_NORMAL)</span><br><span class="line">cv.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h3 id="3-写入图像"><a class="markdownIt-Anchor" href="#3-写入图像"></a> 3. 写入图像</h3><p><code>cv2.imwrite()</code></p><p>第一个参数是文件名，第二个参数是要保存的图像。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.imwrite(<span class="string">'messigray.png'</span>,img)</span><br></pre></td></tr></tbody></table></figure><p>这会将图像以PNG格式保存在工作目录中。</p><h3 id="示例总结"><a class="markdownIt-Anchor" href="#示例总结"></a> # 示例总结</h3><p><strong>加载灰度图像，显示图像，按s保存图像，按Esc退出</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">img_file = cv.imread(<span class="string">'img.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">'img'</span>,img_file)</span><br><span class="line">key = cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> key == <span class="number">27</span> : <span class="comment"># 按Esc退出</span></span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line"><span class="keyword">elif</span> key == <span class="built_in">ord</span>(<span class="string">'s'</span>): <span class="comment"># 按s保存图像并退出</span></span><br><span class="line">    cv.imwrite(<span class="string">'img_file_save.png'</span>,img_file)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h3 id="matplotlib"><a class="markdownIt-Anchor" href="#matplotlib"></a> # Matplotlib</h3><p>Matplotlib 是 Python 2D-绘图领域使用最广泛的套件。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用matplotlib库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img =  cv.imread(<span class="string">'img.png'</span>,<span class="number">0</span>)</span><br><span class="line">plt.imshow(img, cmap = <span class="string">'gray'</span>, interpolation = <span class="string">'bicubic'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])  <span class="comment"># 隐藏 x 轴和 y 轴上的刻度值</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><h2 id="二-视频入门"><a class="markdownIt-Anchor" href="#二-视频入门"></a> 二、视频入门</h2><h3 id="1-驱动相机读取视频"><a class="markdownIt-Anchor" href="#1-驱动相机读取视频"></a> 1. 驱动相机读取视频</h3><p>可以通过<code>cap.isOpened()</code>方法检查它是否已初始化。如果是<code>True</code>，那么确定。否则，使用<code>cap.open()</code>打开它</p><p><code>cap.read()</code>返回布尔值(<code>True</code>/ <code>False</code>)。如果正确读取了帧，它将为<code>True</code>。因此，你可以通过检查此返回值来检查视频的结尾</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"can't not open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'can not recevie frame'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">'video'</span>,gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) ==  <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">cap.release() <span class="comment"># 释放视频捕获</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><p>注意：waitKey() 传入参数’0’会导致视频显示卡在一帧中</p><blockquote><p>正确使用方法：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) ==  <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure><p>waitKey()相当于一个阻塞式的函数,如<code>delay()</code></p></blockquote><h3 id="2-获取视频格式"><a class="markdownIt-Anchor" href="#2-获取视频格式"></a> 2. 获取视频格式</h3><p>可以使用<code>cap.get(propId)</code>方法访问该视频的某些功能，其中propId是0到18之间的一个数字。每个数字表示视频的属性（如果适用于该视频），并且可以显示完整的详细信息在这里看到：<strong>cv::VideoCapture::get()</strong></p><p>例如，我可以通过<code>cap.get(cv.CAP_PROP_FRAME_WIDTH)</code>和<code>cap.get(cv.CAP_PROP_FRAME_HEIGHT)</code>检查框架的宽度和高度</p><h3 id="3-设置视频格式"><a class="markdownIt-Anchor" href="#3-设置视频格式"></a> 3. 设置视频格式</h3><p>默认情况下，视频的分辨率为640x480，使用<code>cap.set()</code>设置即可</p><ul><li><code>cap.set(cv.CAP_PROP_FOURCC, codec)</code></li><li><code>cap.set(cv.CAP_PROP_FPS, 30)</code> #帧数</li><li><code>cap.set(cv.CAP_PROP_FRAME_WIDTH, 1920)</code>#列 宽度</li><li><code>cap.set(cv.CAP_PROP_FRAME_HEIGHT, 1080)</code> # 行 高度</li></ul><p>PS :  <code>codec = cv.VideoWriter_fourcc('M', 'J', 'P', 'G')</code></p><blockquote><p>**一、简介 **<br><code>cv2.VideoWriter_fourcc</code>是 OpenCV 中用于定义视频编解码器的函数，它将四个字符的编码（FourCC）转换为一个用于视频编码器的整数。FourCC 是一种四字符编码，用于指定视频文件中使用的压缩方式。</p><p><strong>二、语法和参数</strong></p><ol><li>语法<br><code>cv2.VideoWriter_fourcc(c1, c2, c3, c4)</code><br>2.参数<br>c1, c2, c3, c4：表示四个字符的编码，每个字符是一个字符，代表不同的视频编码器。常用的编码器包括：</li></ol><ul><li>‘XVID’：常用于 .avi 格式的视频文件。</li><li>‘MP4V’：常用于 .mp4 格式的视频文件。</li><li>‘MJPG’：适用于使用 Motion JPEG 编码的视频。</li></ul><p>3.返回值</p><p>返回一个整数，该整数用于创建 cv2.VideoWriter 对象时指定视频编码格式。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line">codec = cv.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FOURCC, codec)</span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FPS, <span class="number">30</span>) <span class="comment">#帧数</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_WIDTH, <span class="number">1920</span>) <span class="comment">#列 宽度</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_HEIGHT, <span class="number">1080</span>) <span class="comment"># 行 高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"can't not open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'can not recevie frame'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">'video'</span>,gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) ==  <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">cap.release() <span class="comment"># 释放视频捕获</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h2 id="4-保存视频"><a class="markdownIt-Anchor" href="#4-保存视频"></a> 4. 保存视频</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line">fourcc = cv.VideoWriter_fourcc(*<span class="string">'XVID'</span>)</span><br><span class="line">out = cv.VideoWriter(<span class="string">'output.avi'</span>,fourcc,<span class="number">20.0</span>,(<span class="number">1920</span>,<span class="number">1080</span>))</span><br><span class="line"></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FPS, <span class="number">30</span>) <span class="comment">#帧数</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_WIDTH, <span class="number">1920</span>) <span class="comment">#列 宽度</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_HEIGHT, <span class="number">1080</span>) <span class="comment"># 行 高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"can't open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'not get'</span>)</span><br><span class="line">    </span><br><span class="line">    frame = cv.flip(frame, <span class="number">0</span>)</span><br><span class="line">    out.write(frame)</span><br><span class="line">    cv.imshow(<span class="string">"video"</span>,frame)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h2 id="5-播放视频"><a class="markdownIt-Anchor" href="#5-播放视频"></a> 5. 播放视频</h2><p>跟捕获摄像头一致，只需要修改捕获的对象即可</p><p>如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="string">'vtest.avi'</span>)</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># 如果正确读取帧，ret为True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Can't receive frame (stream end?). Exiting ..."</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">'frame'</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h2 id="三-绘图功能"><a class="markdownIt-Anchor" href="#三-绘图功能"></a> 三、绘图功能</h2><h2 id="四-鼠标事件"><a class="markdownIt-Anchor" href="#四-鼠标事件"></a> 四、鼠标事件</h2><h2 id="五-滑块调参"><a class="markdownIt-Anchor" href="#五-滑块调参"></a> 五、滑块调参</h2><p><code>cv.createTrackbar()</code>：</p><ul><li><p>第一个参数是轨迹栏名称</p></li><li><p>第二个参数是它附加到的窗口名称</p></li><li><p>第三个参数是默认值</p></li><li><p>第四个参数是最大值</p></li><li><p>第五个是执行的回调函数每次跟踪栏值更改</p></li></ul><p>Opencv本身没有提供按钮相关的api，可以利用滑块函数，设定参数值为0/1，达到按钮的效果。</p><p><code>cv.getTrackbarPos()</code></p><ul><li><p>第一个参数是轨迹栏名称</p></li><li><p>第二个参数是窗口名称</p><p>使用<code>cv.getTrackbarPos()</code>函数，在主循环中可以实时响应滑块调节的对应轨道参数值</p></li></ul><p><strong>示例程序</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个黑色的图像，一个窗口</span></span><br><span class="line">img = np.zeros((<span class="number">300</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">'image'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建RGB调整滑块栏</span></span><br><span class="line">cv.createTrackbar(<span class="string">'R'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">'G'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">'B'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 ON/OFF 功能创建开关</span></span><br><span class="line">switch = <span class="string">'0 : OFF \n1 : ON'</span></span><br><span class="line">cv.createTrackbar(switch, <span class="string">'image'</span>,<span class="number">0</span>,<span class="number">1</span>,nothing)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">'image'</span>,img)</span><br><span class="line"></span><br><span class="line">    r = cv.getTrackbarPos(<span class="string">'R'</span>,<span class="string">'image'</span>)</span><br><span class="line">    g = cv.getTrackbarPos(<span class="string">'G'</span>,<span class="string">'image'</span>)</span><br><span class="line">    b = cv.getTrackbarPos(<span class="string">'B'</span>,<span class="string">'image'</span>)</span><br><span class="line">    s = cv.getTrackbarPos(switch,<span class="string">'image'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">        img[:] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img[:] = [b,g,r]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h1 id="四-opencv核心操作"><a class="markdownIt-Anchor" href="#四-opencv核心操作"></a> 四、OpenCV核心操作</h1><h2 id="一-图像的基本操作"><a class="markdownIt-Anchor" href="#一-图像的基本操作"></a> 一、图像的基本操作</h2><h2 id="二-图像的位运算"><a class="markdownIt-Anchor" href="#二-图像的位运算"></a> 二、图像的位运算</h2><h2 id="三-性能优化"><a class="markdownIt-Anchor" href="#三-性能优化"></a> 三、性能优化</h2><h3 id="1-衡量代码性能的方式"><a class="markdownIt-Anchor" href="#1-衡量代码性能的方式"></a> 1. 衡量代码性能的方式</h3><p><code>cv.getTickCount</code>函数返回从参考事件（如打开机器的那一刻）到调用此函数那一刻之间的时钟周期数。因此，如果在函数执行之前和之后调用它，则会获得用于执行函数的时钟周期数。</p><p><code>cv.getTickFrequency</code>函数返回时钟周期的频率或每秒的时钟周期数。因此，要找到执行时间（以秒为单位），你可以执行以下操作：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1 = cv.getTickCount()</span><br><span class="line"><span class="comment"># 你的执行代码</span></span><br><span class="line">e2 = cv.getTickCount()</span><br><span class="line">time = (e2 - e1)/ cv.getTickFrequency()</span><br></pre></td></tr></tbody></table></figure><p>除了OpenCV，Python还提供了一个模块<strong>time</strong>，这有助于衡量执行时间。另一个模块<strong>profile</strong>有助于获取有关代码的详细报告，例如代码中每个函数花费了多少时间，调用了函数的次数等。</p><h3 id="2-opencv默认的性能优化"><a class="markdownIt-Anchor" href="#2-opencv默认的性能优化"></a> 2. OpenCV默认的性能优化</h3><p>许多 OpenCV 函数都是使用 SSE2、 AVX 等进行优化的。 它还包含未优化的代码。因此，如果我们的系统支持这些特性，我们就应该利用它们(几乎所有现代的处理器都支持它们)。在编译时默认启用它。因此，如果启用了 OpenCV，它将运行优化的代码，否则它将运行未优化的代码。可以使用 <strong>cvUseoptimized</strong> 检查是否启用 / 禁用和 <strong>cvSetuseoptimized</strong> 以启用 / 禁用它。让我们看一个简单的例子。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查是否启用了优化</span></span><br><span class="line">In [<span class="number">5</span>]: cv.useOptimized()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="literal">True</span></span><br><span class="line">In [<span class="number">6</span>]: %timeit res = cv.medianBlur(img,<span class="number">49</span>)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">34.9</span> ms per loop</span><br><span class="line"><span class="comment"># 关闭它</span></span><br><span class="line">In [<span class="number">7</span>]: cv.setUseOptimized(<span class="literal">False</span>)</span><br><span class="line">In [<span class="number">8</span>]: cv.useOptimized()</span><br><span class="line">Out[<span class="number">8</span>]: <span class="literal">False</span></span><br><span class="line">In [<span class="number">9</span>]: %timeit res = cv.medianBlur(img,<span class="number">49</span>)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">64.1</span> ms per loop</span><br></pre></td></tr></tbody></table></figure><p>优化的中值滤波比未优化的版本快2倍。如果你检查其来源，可以看到中值滤波是 SIMD 优化。因此，可以使用它在代码顶部启用优化(默认启用的)</p><h3 id="3-性能优化方式"><a class="markdownIt-Anchor" href="#3-性能优化方式"></a> 3. 性能优化方式</h3><blockquote><p>在Python和NumPy中优化性能的技术和编码方法的关键技术：</p><h3 id="1-避免显式循环"><a class="markdownIt-Anchor" href="#1-避免显式循环"></a> 1. <strong>避免显式循环</strong></h3><ul><li><strong>描述</strong>：尽量避免使用<code>for</code>循环，尤其是双重或三重循环。使用NumPy的向量化操作。</li><li><strong>来源</strong>：NumPy User Guide - Array Programming</li></ul><h3 id="2-向量化操作"><a class="markdownIt-Anchor" href="#2-向量化操作"></a> 2. <strong>向量化操作</strong></h3><ul><li><strong>描述</strong>：利用NumPy的数组运算和广播功能来实现高效的向量化操作，避免逐元素计算。</li><li><strong>来源</strong>：NumPy Vectorization</li></ul><h3 id="3-缓存一致性"><a class="markdownIt-Anchor" href="#3-缓存一致性"></a> 3. <strong>缓存一致性</strong></h3><ul><li><strong>描述</strong>：确保数据在内存中的布局有利于CPU缓存，从而提高访问速度。例如，使用行优先的存储方式。</li><li><strong>来源</strong>：Understanding Cache and Memory</li></ul><h3 id="4-避免不必要的数组复制"><a class="markdownIt-Anchor" href="#4-避免不必要的数组复制"></a> 4. <strong>避免不必要的数组复制</strong></h3><ul><li><strong>描述</strong>：尽量使用数组视图而非副本，这样可以减少内存开销。使用<code>np.view()</code>或切片来创建视图。</li><li><strong>来源</strong>：NumPy Views</li></ul><h3 id="5-使用cython和numba"><a class="markdownIt-Anchor" href="#5-使用cython和numba"></a> 5. <strong>使用Cython和Numba</strong></h3><ul><li><p>描述</p><p>：如果在使用NumPy和向量化后代码仍然很慢，可以考虑使用Cython或Numba对性能关键部分进行加速。</p><ul><li><strong>Cython</strong>：允许将Python代码转换为C，以提高性能。</li><li><strong>Numba</strong>：通过JIT编译加速NumPy代码，特别是循环。</li></ul></li><li><p>来源：</p><ul><li><a href="https://cython.readthedocs.io/en/latest/">Cython Documentation</a></li><li>Numba Documentation</li></ul></li></ul><h3 id="6-使用并行计算"><a class="markdownIt-Anchor" href="#6-使用并行计算"></a> 6. <strong>使用并行计算</strong></h3><ul><li><strong>描述</strong>：对于大规模计算任务，可以利用并行处理库（如<code>multiprocessing</code>或<code>joblib</code>）来加速计算。</li><li><strong>来源</strong>：<a href="https://docs.python.org/3/library/multiprocessing.html">Python Multiprocessing</a></li></ul><h3 id="7-profiling和性能分析"><a class="markdownIt-Anchor" href="#7-profiling和性能分析"></a> 7. <strong>Profiling和性能分析</strong></h3><ul><li><strong>描述</strong>：使用性能分析工具（如<code>cProfile</code>和<code>line_profiler</code>）找出性能瓶颈，针对性优化。</li><li>来源：<ul><li><a href="https://docs.python.org/3/library/profile.html">cProfile Documentation</a></li><li><a href="https://github.com/pyutils/line_profiler">line_profiler</a></li></ul></li></ul><h3 id="8-利用科学计算库"><a class="markdownIt-Anchor" href="#8-利用科学计算库"></a> 8. <strong>利用科学计算库</strong></h3><ul><li><strong>描述</strong>：对于特定任务，利用专门的科学计算库（如SciPy、Pandas）进行更高效的数据处理和分析。</li><li><strong>来源</strong>：SciPy Documentation</li></ul></blockquote><h1 id="向量化"><a class="markdownIt-Anchor" href="#向量化"></a> # 向量化</h1><blockquote><p>在Python中，向量化主要是指使用NumPy和其他库（如Pandas和TensorFlow）来处理数组和矩阵数据的能力，从而提高计算效率。以下是一些在Python中向量化的常见用法：</p><h3 id="1-使用numpy进行向量化"><a class="markdownIt-Anchor" href="#1-使用numpy进行向量化"></a> 1. 使用NumPy进行向量化</h3><p>NumPy是Python中用于数值计算的库，它提供了高效的数组操作。通过向量化，你可以避免使用显式的循环，从而提高代码的性能。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个NumPy数组</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素加2</span></span><br><span class="line">b = a + <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出: [3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素平方</span></span><br><span class="line">c = a ** <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出: [ 1  4  9 16 25]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-使用pandas进行向量化"><a class="markdownIt-Anchor" href="#2-使用pandas进行向量化"></a> 2. 使用Pandas进行向量化</h3><p>Pandas是用于数据分析的库，它提供了类似于NumPy的向量化操作，适用于处理DataFrame和Series对象。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Pandas Series</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素乘以3</span></span><br><span class="line">s2 = s * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(s2)  <span class="comment"># 输出: 0    3, 1    6, 2    9, 3   12, 4   15</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-使用tensorflow进行向量化"><a class="markdownIt-Anchor" href="#3-使用tensorflow进行向量化"></a> 3. 使用TensorFlow进行向量化</h3><p>在深度学习中，TensorFlow也广泛使用向量化来进行大规模的矩阵运算。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TensorFlow张量</span></span><br><span class="line">x = tf.constant([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素加5</span></span><br><span class="line">y = x + <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(y.numpy())  <span class="comment"># 输出: [ 6  7  8  9 10]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>向量化通过批量处理数据，减少了循环的使用，从而提高了代码的性能和可读性。在进行数值计算时，推荐尽量使用向量化的方法。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;opencv中文文档&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#opencv中文文档&quot;&gt;&lt;/a&gt; # OpenCV中文文档&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://woshicver.com/&quot;&gt;https://woshi</summary>
      
    
    
    
    
    <category term="学习笔记,计算机视觉" scheme="https://szturin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>2024微机原理课程设计-小车跟随系统</title>
    <link href="https://szturin.github.io/posts/50511/"/>
    <id>https://szturin.github.io/posts/50511/</id>
    <published>2024-06-20T20:44:16.000Z</published>
    <updated>2024-09-03T04:41:07.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小车基本控制设计"><a class="markdownIt-Anchor" href="#小车基本控制设计"></a> 小车基本控制设计</h1><h2 id="一-前期系统分析与设计"><a class="markdownIt-Anchor" href="#一-前期系统分析与设计"></a> 一、前期系统分析与设计</h2><p>​      在本次设计的前期准备工作中，通过对题目的分析，小车运动的精确低延迟控制+蓝牙通信都是相当重要的关键点。本次课程设计，使用电机型号为带霍尔传感器地无刷电机，能够通过内置编码器的A,B相固定输出390次/圈的脉冲，可以用于精准测量电机转速以及作为<mark>车辆里程表</mark>。因此，我基于所用电机的特性，利用PIC单片机CCP极其优秀的PWM输出功能，设计了一个易用的电机驱动程序，能够使得单片机输出频率10KHZ，占空比可调范围在0~100的PWM信号。对比于常规的使用定时器作为计时基准的方法，直接利用单片机设计好的电路外设模块，减轻了单片机<mark>程序</mark>上消耗的资源，也大幅提高了后续小车的运动性能以及稳定性。重要的一点是，基于对自动控制原理的粗略学习，我们可以利用本次电机所带的编码器模块，实现<strong>单片机测速——程序PID控制器——输出PWM波</strong>的一个PID自动控速系统以及能够精准记录脉冲数的<strong>车辆里程表（这在后面进行内外圈转向时发挥了关键的作用）</strong>，同时，蓝牙模块也是一个极其便捷的工具，使用两片蓝牙模块，分别连接单片机和计算机，在一些串口助手软件上，能够迅速实现基于上位机的参数检测以及调试系统。</p><p>注：本次设计的串口助手为VOFA，可以兼容所有串口调试的基本功能，能够根据数值的大小显示波形。</p><h3 id="设计框图蓝牙控速小车"><a class="markdownIt-Anchor" href="#设计框图蓝牙控速小车"></a> 设计框图：蓝牙控速小车</h3><p><strong>基于上述程序的编写以及小车板块的搭建，首先设计一个可以通过计算机或者手机终端等设备进行蓝牙遥控的小车运动系统。本次课程设计我们基于实验以及课程的理论经验，从搭建<mark>底层框架</mark>再到完成其余功能要求的设计思想，分阶段、板块完成设计，更有利于后面的高效分工与调试。</strong></p><img src="/posts/50511/image-20240625013830066.png" class="" title="image-20240625013830066"><h2 id="1电机驱动程序设计"><a class="markdownIt-Anchor" href="#1电机驱动程序设计"></a> 1.电机驱动程序设计</h2><p><strong>问题1：PWM输出</strong></p><p>​常见的8位单片机（stc89c52），产生PWM，通常是利用到定时器模块，以定时器计时为基准（时间基准t1，假设为1ms），程序上定义计时变量time(每次进定时器中断time自加1)、周期时间变量T（假设T=100）、占空比时间变量N（假设N=50），然后通过IF语句判断，翻转设定的引脚（假设为RC1）输出PWM方波信号。但是考虑到如果使用定时器，如果定时器的计数寄存器（计时溢出周期）设置过小，程序会频繁进入中断，不利于其他部分程序的执行，占用了软件上的资源；如果定时器计时周期设置的太大，比如10ms，又想输出一个可调范围0~100的PWM，那么PWM方波信号的周期就高达1s，PWM频率仅仅只有1HZ，这样就会使得电机无法正常驱动或者运动过程有明显的卡顿（PWM分辨率过低）。而本次使用的PIC16F877A单片机，具备CCP1+CCP2模块，能够通过配置寄存器，硬件自动生成两路的PWM信号，节省了软件资源，并且PIC单片机的CCP模块生成的PWM方波相当的精准可靠，在完成CCP模块PWM模式的初始化后，只需要修改CCP1L/CCP2L的值即可修改PWM（RC6、RC7）的占空比。</p><hr><p>电机驱动模块子程序设计</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_A RC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_B RC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_1 RB4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_2 RB5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_1 RB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_2 RB7</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函    数</span></span><br><span class="line"><span class="comment">参    数要写入的命令</span></span><br><span class="line"><span class="comment">返 回 值无</span></span><br><span class="line"><span class="comment">特殊说明无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_GPIO_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISB4=<span class="number">0</span>;</span><br><span class="line">TRISB5=<span class="number">0</span>;</span><br><span class="line">TRISB6=<span class="number">0</span>;</span><br><span class="line">TRISB7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;</span><br><span class="line">TRISC2=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_CCP_PWM_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*定义CCP1工作在PWM模式*/</span></span><br><span class="line">CCP1CON=<span class="number">0X0C</span>;<span class="comment">//定义CCP1模块工作在PWM模式</span></span><br><span class="line">CCPR1L=<span class="number">50</span>;<span class="comment">//定义脉宽为50us</span></span><br><span class="line">PR2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义CCP2工作在PWM模式*/</span></span><br><span class="line">    CCP2CON = <span class="number">0x0c</span>; <span class="comment">// 配置CCP2为PWM模式</span></span><br><span class="line">    CCPR2L = <span class="number">50</span>;          <span class="comment">// 设置CCP2 PWM占空比（高位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*与CCP模块PWM模式配合的TMR2*/</span></span><br><span class="line">T2CON=<span class="number">0</span>;<span class="comment">//定义TM2模块工作在预、后分频比都是1:1的定时器模式</span></span><br><span class="line">TMR2=<span class="number">0</span>;</span><br><span class="line">TMR2ON=<span class="number">1</span>;<span class="comment">//启动TMR2，此刻从RC2引脚输出所设的波形</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Speed_Set</span><span class="params">(<span class="type">int</span> Speed1,<span class="type">int</span> Speed2)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Speed1 &gt; <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">0</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">1</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Speed2 &gt;<span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">0</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">1</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>问题2：测速</strong></p><p><mark><strong>通过外部中断配合定时器1测速</strong></mark></p><p>​我们可以按照实验课中的方法，使用定时器1和外部中断配合设计测速系统，通过检测信号跳变，配合定时器1的TMR1ON控制启停，计算电平的持续时间，这样就能测量PWM的占空比。但是，通过对本次课程设计电机模块的分析以及学习（本次设计为无刷电机==(注意固定螺丝不能太长会磨损电机减速箱)==，并且自带霍尔编码器）</p><p>​霍尔编码器：通过霍尔传感器感应电机转过的次数，相应的，在本次设计中使用的电机模块，转动一圈产生390个脉冲。直接使用实验五的方法，通过串口调试助手打印测得速度，发现速度是不连续的（此图出现如290km/h 71km/h 15 km/h等速度）。因为如果要使用霍尔传感器，它的脉冲实际上不是代表的PWM，只有通过记录编码器输出的脉冲次数才能实现单位时间内小车的速度/里程计算。</p><img src="/posts/50511/image-20240621050939454.png" class="" title="image-20240621050939454"><hr><p><mark><strong>采用外部中断计数的方法测速，如下图</strong></mark></p><p><strong>我们改用定时器0（50ms为计数周期)，外部中断（测量电机驱动输出的编码器脉冲计数），这样就能轻而易举地计算出50ms内地脉冲数目，进而进行速度的精准测量+里程的累计。</strong></p><p>可见，直接通过计算脉冲次数的方法，速度的测量基本无波动（横坐标表示50ms时间内的脉冲计数,此图位48-49范围内波动，基本无误差）。</p><img src="/posts/50511/d34fd09e3d5cd10c526f393554abff6.png" class="" title="d34fd09e3d5cd10c526f393554abff6"><hr><p><strong>子函数设计</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_A RC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_B RC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_1 RB4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_2 RB5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_1 RB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_2 RB7</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函    数</span></span><br><span class="line"><span class="comment">参    数要写入的命令</span></span><br><span class="line"><span class="comment">返 回 值无</span></span><br><span class="line"><span class="comment">特殊说明无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_GPIO_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISB4=<span class="number">0</span>;</span><br><span class="line">TRISB5=<span class="number">0</span>;</span><br><span class="line">TRISB6=<span class="number">0</span>;</span><br><span class="line">TRISB7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;</span><br><span class="line">TRISC2=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_CCP_PWM_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*定义CCP1工作在PWM模式*/</span></span><br><span class="line">CCP1CON=<span class="number">0X0C</span>;<span class="comment">//定义CCP1模块工作在PWM模式</span></span><br><span class="line">CCPR1L=<span class="number">50</span>;<span class="comment">//定义脉宽为50us</span></span><br><span class="line">PR2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义CCP2工作在PWM模式*/</span></span><br><span class="line">    CCP2CON = <span class="number">0x0c</span>; <span class="comment">// 配置CCP2为PWM模式</span></span><br><span class="line">    CCPR2L = <span class="number">50</span>;          <span class="comment">// 设置CCP2 PWM占空比（高位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*与CCP模块PWM模式配合的TMR2*/</span></span><br><span class="line">T2CON=<span class="number">0</span>;<span class="comment">//定义TM2模块工作在预、后分频比都是1:1的定时器模式</span></span><br><span class="line">TMR2=<span class="number">0</span>;</span><br><span class="line">TMR2ON=<span class="number">1</span>;<span class="comment">//启动TMR2，此刻从RC2引脚输出所设的波形</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Speed_Set</span><span class="params">(<span class="type">int</span> Speed1,<span class="type">int</span> Speed2)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Speed1 &gt; <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">0</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">1</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Speed2 &gt;<span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">0</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">1</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>电机的速度计算准确后，通过我们对自动控制原理的学习了解，或许可以应用一些简单的算法，进行小车的速度闭环负反馈控制？</li></ul><h3 id="3串口通信初始化"><a class="markdownIt-Anchor" href="#3串口通信初始化"></a> 3.串口通信初始化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//putch 重定向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putch</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">    TXREG=ch;</span><br><span class="line">    <span class="keyword">while</span>(TRMT==<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*??????????*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_PrintString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *String)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(*String != <span class="string">'\0'</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,*String++);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口引脚初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">TRISC6=<span class="number">1</span>;</span><br><span class="line">TRISC7=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    SPBRG=<span class="number">12</span>;<span class="comment">//波特率设置为19200</span></span><br><span class="line">    TXSTA=<span class="number">0B</span>00100100;<span class="comment">//异步模式。发送8位数据，允许发送</span></span><br><span class="line">    RCSTA=<span class="number">0B</span>10010000;<span class="comment">//允许串口工作，连续接收使能，接收8位数据</span></span><br><span class="line">    GIE=<span class="number">1</span>;PEIE=<span class="number">1</span>;RCIE=<span class="number">1</span>;<span class="comment">//开放USART接收中断</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将连接单片机的蓝牙模块配置为主机模式，连接计算机的蓝牙模块配置为从机模式，并且两片蓝牙的密码设置为一致，波特率与单片机、电脑串口助手都设置为19200。这样，单片机就能够发送数据到串口助手，串口中断打印出数据/波形，实现远程调参效果。</p><h3 id="pid控速的尝试与应用"><a class="markdownIt-Anchor" href="#pid控速的尝试与应用"></a> PID控速的尝试与应用</h3><p>1.给定占空比</p><p>​通过修改CCP1L和CCP2L的值，可以实现指定PWM占空比的电机变速效果，通过串口助手显示编码器测速的波形，发现给定PWM的速度也是比较稳定的。</p><img src="/posts/50511/image-20240625022659866.png" class="" title="image-20240625022659866"><p>2.PID控速</p><p>​编写PID速度环控制子程序，将速度测量值以及速度目标值作为输入，返回值为PID的输出值，作为PWM的输出，形成闭环反馈系统。经上位机显示速度波形，测量速度（红线）能够逐渐趋近于目标速度（绿线），说明PID速度闭环的程序是正确的，后面对各个参数（Kp、Ki、Kd）进行优化，减少过充现象，增大反应速度，提高PID速度闭环系统的抗干扰能力。</p><img src="/posts/50511/image-20240625023158792.png" class="" title="image-20240625023158792"><p>​经过我们后面对PIC16F877A的引脚分配，发现它能够进行速度测量的引脚基本上只能使用外部中断，CCP模块以及被用作PWM输出，那么PID控速的想法就暂时被搁置了。但是，我们后面将编码器的脉冲输入作为车辆里程表，也可以实现灵活度更高的功能（内外圈转向区分）。</p><h1 id="灰度巡线pid-数学模型解决工程问题"><a class="markdownIt-Anchor" href="#灰度巡线pid-数学模型解决工程问题"></a> 灰度巡线PID - 数学模型解决工程问题</h1><img src="/posts/50511/image-20240621050902381.png" class="" title="image-20240621050902381"><p><strong>头文件定义/变量定义</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span><span class="comment">//PIC库</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);<span class="comment">//配置起始位</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//C语言库</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*PIC单片机驱动相关子函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\LCD1602.H"</span><span class="comment">//LCD1602子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\KeyBoard.H"</span><span class="comment">//按键子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\iic.H"</span><span class="comment">//iic通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Motor.H"</span><span class="comment">//电机驱动</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Usart.H"</span><span class="comment">//串口（蓝牙）通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Led.H"</span><span class="comment">//Led</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Encoder.H"</span><span class="comment">//霍尔编码器测速</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\PID.H"</span><span class="comment">//PID控制程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\csb.H"</span><span class="comment">//超声波控制程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*PIC单片机系统相关子函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\System\Timer.H"</span><span class="comment">//定时器初始化程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\System\Delay.H"</span><span class="comment">//延时子程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bluetooth;<span class="comment">//蓝牙接收字节存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*外部中断测速*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Counter_temp;<span class="comment">//车辆旋转圈数计数变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Timer0_Counter;<span class="comment">//定时器0溢出计数变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Encoder_Counter;<span class="comment">//脉冲计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*循迹控制主要变量*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Motor_Flag;<span class="comment">//电机允许模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Turn_PWM;<span class="comment">//转向PWM，由循迹PID控制函数输出赋值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Byte;<span class="comment">//八路循迹对应一个字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_left,Speed_right;<span class="comment">//寻线速度77y89-</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_Velcolity=<span class="number">33</span>;<span class="comment">//直行速度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> IO_flag=<span class="number">0</span>;<span class="comment">//（90度转向）启停标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Circle_Mode=<span class="number">0</span>;<span class="comment">//车辆运行模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Start_Find_flag=<span class="number">0</span>;<span class="comment">//脉冲计数标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Bifurcate_Flag=<span class="number">0</span>;<span class="comment">//分叉路口标志位，0表示第一个，1表示第二个</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Stop_Flag=<span class="number">0</span>;<span class="comment">//停车标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Mode=<span class="number">0</span>;<span class="comment">//八路循迹状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> distance;<span class="comment">//超声波距离</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> BT_State=<span class="number">0</span>;<span class="comment">//蓝牙通信状态机，无线调参</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> csb_Flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> NQ_fast_Flag=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*//循迹工作验证函数</span></span><br><span class="line"><span class="comment">unsigned char yz[8]={0};</span></span><br><span class="line"><span class="comment">unsigned char mod;</span></span><br><span class="line"><span class="comment">void yanzheng()</span></span><br><span class="line"><span class="comment">{ </span></span><br><span class="line"><span class="comment">unsigned char temp = mod;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">yz[i] = temp %2;</span></span><br><span class="line"><span class="comment">temp/=2;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>模块验证函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*//循迹工作验证函数</span></span><br><span class="line"><span class="comment">unsigned char yz[8]={0};</span></span><br><span class="line"><span class="comment">unsigned char mod;</span></span><br><span class="line"><span class="comment">void yanzheng()</span></span><br><span class="line"><span class="comment">{ </span></span><br><span class="line"><span class="comment">unsigned char temp = mod;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">yz[i] = temp %2;</span></span><br><span class="line"><span class="comment">temp/=2;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>循迹控制函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Byte;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Kp=<span class="number">3.2</span>;</span><br><span class="line"><span class="type">int</span> Kd=<span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> turn_err;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> last_err;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> err_difference;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Trace_PID</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Trace_Byte = (RC0&lt;&lt;<span class="number">7</span>|RC3&lt;&lt;<span class="number">6</span>|RE0&lt;&lt;<span class="number">5</span>|RE1&lt;&lt;<span class="number">4</span>|RE2&lt;&lt;<span class="number">3</span>|RA4&lt;&lt;<span class="number">2</span>|RC4&lt;&lt;<span class="number">1</span>|RC5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Trace_Byte)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//直行</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11100111: </span><br><span class="line">turn_err=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11110111:</span><br><span class="line">turn_err=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11101111:</span><br><span class="line">turn_err=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//左转</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11001111:</span><br><span class="line">turn_err=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11011111:</span><br><span class="line">turn_err=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>10011111:</span><br><span class="line">turn_err=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>10111111:</span><br><span class="line">turn_err=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>00111111:</span><br><span class="line">turn_err=<span class="number">6</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>01111111:</span><br><span class="line">turn_err=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右转</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11110011:</span><br><span class="line">turn_err=<span class="number">-2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111011:</span><br><span class="line">turn_err=<span class="number">-3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111001:</span><br><span class="line">turn_err=<span class="number">-4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111101:</span><br><span class="line">turn_err=<span class="number">-5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111100:</span><br><span class="line">turn_err=<span class="number">-6</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111110:</span><br><span class="line">turn_err=<span class="number">-7</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err_difference= turn_err - last_err;</span><br><span class="line"></span><br><span class="line">last_err= turn_err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)(turn_err*Kp + err_difference*Kd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>路线控制函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Trace_Control</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Circle_Mode == <span class="number">0</span>)<span class="comment">//起始点</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">1</span>;<span class="comment">//脉冲计数标志位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt;<span class="number">550</span>)<span class="comment">//固定距离，越过黑线</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">1</span>)<span class="comment">//第一圈，外圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag =<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Find_flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">200</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">IO_flag = <span class="number">1</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">2</span>;<span class="comment">//内圈</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">2</span>)<span class="comment">//第二圈，内圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IO_flag == <span class="number">0</span>)<span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//putch(3);//进入第三圈</span></span><br><span class="line">Start_Find_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Find_flag == <span class="number">1</span>  &amp;&amp; NQ_fast_Flag == <span class="number">0</span>)<span class="comment">//开启计脉冲且，内圈没有加速</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">300</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">IO_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">3</span>;</span><br><span class="line">csb_Flag= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(NQ_fast_Flag)<span class="comment">//开启内圈加速</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">800</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">NQ_fast_Flag = <span class="number">0</span>;</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;<span class="comment">//回归</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//内圈固定转向</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(<span class="number">20</span>,<span class="number">60</span>);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">320</span>)</span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">NQ_fast_Flag = <span class="number">1</span>;</span><br><span class="line">IO_flag = <span class="number">0</span>;</span><br><span class="line">Speed_Velcolity+=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">3</span>)<span class="comment">//第三圈，外圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">1</span>;</span><br><span class="line">Stop_Flag=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Stop_Flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">putch(<span class="number">0x08</span>);</span><br><span class="line">Motor_Speed_Set(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//停车</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;小车基本控制设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#小车基本控制设计&quot;&gt;&lt;/a&gt; 小车基本控制设计&lt;/h1&gt;
&lt;h2 id=&quot;一-前期系统分析与设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MSPM0G3507" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MSPM0G3507/"/>
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】PID平衡小车项目实战</title>
    <link href="https://szturin.github.io/posts/25248/"/>
    <id>https://szturin.github.io/posts/25248/</id>
    <published>2024-06-09T08:22:17.000Z</published>
    <updated>2024-10-29T08:05:20.478Z</updated>
    
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][1]Hal库初始化配置</title>
    <link href="https://szturin.github.io/posts/253/"/>
    <id>https://szturin.github.io/posts/253/</id>
    <published>2024-06-09T07:31:45.000Z</published>
    <updated>2024-10-29T08:05:30.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><ul><li>xxxxxxxxxx&nbsp;$ tags: -数字电路与VHDL设计"bash</li><li>需要安装java环境，才能正常允许CubeMX</li><li>确保以及安装了Keil MDK，Keil完成了stm32的芯片包配置，至少下载串口通信（FLY MCU） , STLink Unit中其中一款下载/串口通信软件。</li></ul><h1 id="一-cubemx初始配置"><a class="markdownIt-Anchor" href="#一-cubemx初始配置"></a> 一、CubeMX初始配置</h1><h2 id="1cubemx安装芯片固件包"><a class="markdownIt-Anchor" href="#1cubemx安装芯片固件包"></a> 1.CubeMX安装芯片固件包</h2><img src="/posts/253/image-20240609153709278.png" class="" title="image-20240609153709278"><p>xxxxxxxxxx&nbsp;typedef struct//typedef为成员列表提供了一个GPIO_InitTypeDef的名字{}GPIO_InitTypeDef;c</p><p><strong>像常用的stm32f103c8t6，我们就选择STM32F1，勾选最新固件包，点击Install Now进行在线安装</strong></p><hr><img src="/posts/253/image-20240609155414174.png" class="" title="image-20240609155414174"><hr><h2 id="2工程创建"><a class="markdownIt-Anchor" href="#2工程创建"></a> 2.工程创建</h2><p>1.打开stm32cubeMX，File &gt; New project &gt;MCU/MPU Selector &gt;Part Number<br>2.输入stm32f103c8,Start Project<br>3.Project Manager &gt; Project</p><h2 id="3引脚配置"><a class="markdownIt-Anchor" href="#3引脚配置"></a> 3.引脚配置</h2><img src="/posts/253/image-20240609154359188.png" class="" title="image-20240609154359188"><h2 id="3外设配置"><a class="markdownIt-Anchor" href="#3外设配置"></a> 3.外设配置</h2><p><mark>GPIO属性配置</mark></p><img src="/posts/253/image-20240609155305797.png" class="" title="image-20240609155305797"><blockquote><p>GPIO output level &gt; High 输出等级 高</p><p>GPIO mode Output &gt; Push Pull 输出模式 推挽输出</p><p>GPIO Pull-up/Pull-down &gt; Pull-down 初始输出 设为低</p><p>User Label &gt;  用户标签，方便代码中使用，如图：</p><p>​<img src="/posts/253/image-20240609154825836.png" class="" title="image-20240609154825836"></p></blockquote><img src="/posts/253/image-20240609154611816.png" class="" title="image-20240609154611816"><p><mark>配置时钟模式</mark></p><p>Pinout &amp; Configuration &gt; A-Z &gt; RCC &gt; High Speed Clock<br>Crystal/Ceramic Resonator 使用外部时钟源</p><img src="/posts/253/image-20240609155203231.png" class="" title="image-20240609155203231"><p><mark>时钟可视化配置</mark></p><p>Clock Configuration<br>选中HSE,倍频x9，不分频</p><img src="/posts/253/image-20240609154912764.png" class="" title="image-20240609154912764"><h2 id="4工程设置"><a class="markdownIt-Anchor" href="#4工程设置"></a> 4.工程设置</h2><blockquote><p>Project Name 项目名称，填写led</p><p>Project Location 项目位置，选择一个你喜欢的文件夹，不要出现中文 Toolchain/IDE</p><p>交叉编译链，选择MDK，V5</p><p>勾选 Use latest available version</p></blockquote><img src="/posts/253/image-20240609155924976.png" class="" title="image-20240609155924976"><blockquote><p>Project Manager &gt; Code Generator</p><p>勾选Generate peripheral…</p></blockquote><img src="/posts/253/image-20240609160038284.png" class="" title="image-20240609160038284"><blockquote><p>其余默认配置即可</p></blockquote><img src="/posts/253/image-20240609160159606.png" class="" title="image-20240609160159606"><blockquote><p>GENERATE CODE生成代码，Open Project</p></blockquote><h1 id="二-mdk代码编写"><a class="markdownIt-Anchor" href="#二-mdk代码编写"></a> 二、MDK代码编写</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">  HAL_Init();<span class="comment">//HAL库初始化</span></span><br><span class="line">  SystemClock_Config();<span class="comment">//时钟初始化</span></span><br><span class="line">  MX_GPIO_Init();<span class="comment">//GPIO初始化</span></span><br><span class="line"><span class="comment">/* USER CODE END 1 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_5);<span class="comment">//翻转引脚电平</span></span><br><span class="line">  HAL_Delay(<span class="number">500</span>);<span class="comment">//延时500ms</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em><em>==注意：    /</em> USER CODE BEGIN 3 <em>/之内的代码不会杯CubeMX重新生成代码时覆盖掉！ /</em> USER CODE END 3 <em>/==</em></em></p><img src="/posts/253/image-20240609160459831.png" class="" title="image-20240609160459831"><img src="/posts/253/image-20240609160610985.png" class="" title="image-20240609160610985"><p>下载后编译，观察PA5引脚电平变化（利用LED），是否以0.5s周期变化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;xxxxxxxxxx&amp;nbsp;$ tags: -数字电路与VHDL设计&quot;bash&lt;/li&gt;
&lt;li&gt;需要安装java环境，才能正常</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
  </entry>
  
  <entry>
    <title>【蓝桥杯单片机】客观题</title>
    <link href="https://szturin.github.io/posts/24737/"/>
    <id>https://szturin.github.io/posts/24737/</id>
    <published>2024-05-26T04:04:07.000Z</published>
    <updated>2024-09-03T04:20:24.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rc低通滤波器"><a class="markdownIt-Anchor" href="#rc低通滤波器"></a> RC低通滤波器</h1><h2 id="截止频率"><a class="markdownIt-Anchor" href="#截止频率"></a> 截止频率</h2><img src="/posts/24737/image-20240526121741003.png" class="" title="image-20240526121741003">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rc低通滤波器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rc低通滤波器&quot;&gt;&lt;/a&gt; RC低通滤波器&lt;/h1&gt;
&lt;h2 id=&quot;截止频率&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#截止频率&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="学习笔记,蓝桥杯" scheme="https://szturin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[11]IIC通信(mpu6050)</title>
    <link href="https://szturin.github.io/posts/5621/"/>
    <id>https://szturin.github.io/posts/5621/</id>
    <published>2024-05-24T12:55:20.000Z</published>
    <updated>2024-10-29T08:05:16.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iic通信协议"><a class="markdownIt-Anchor" href="#iic通信协议"></a> IIC通信协议</h1><h2 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h2><ul><li><p>同步时序的稳定性比异步时序更高</p></li><li><p>半双工</p></li><li><p>SCL、SDA两根通信线</p></li><li><p>支持总线挂载（一主多从，多主多从）</p></li></ul><h2 id="硬件电路"><a class="markdownIt-Anchor" href="#硬件电路"></a> 硬件电路</h2><ul><li>所有I2C设备的SCL连接在一起，SDA连接在一起</li><li>设备的SCL和SDA均要配置成开漏输出模式(防止形成短路电流，SDA要么<mark>被上拉</mark>，要么<mark>输出低电平</mark>)，会有“线与”的现象。在多主机的模式下，可以利用线与的特性，实现总线仲裁和时钟同步。</li><li>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</li></ul><img src="/posts/5621/image-20240524211453559.png" class="" title="image-20240524211453559"><hr><img src="/posts/5621/image-20240524212810776.png" class="" title="image-20240524212810776"><p><strong>PS：IIC时序是高位先行，串口是低位先行</strong></p><hr><img src="/posts/5621/image-20240524212934134.png" class="" title="image-20240524212934134"><p><strong>PS：主机接收时，需要释放SDA，即输入模式</strong></p><hr><img src="/posts/5621/image-20240524213709342.png" class="" title="image-20240524213709342"><p><strong>PS:从机的地址可以通过电路改变</strong></p><hr><img src="/posts/5621/image-20240524214219090.png" class="" title="image-20240524214219090"><p><strong><mark>红线处，此时需要从机应答，这里如果但看主机的SDA，应该会释放SDA，即高电平，由于从机要发送应答，根据线与的特性，这里拉低了SDA，所以最后SDA呈现图中所示。</mark></strong></p><hr><img src="/posts/5621/image-20240524214908190.png" class="" title="image-20240524214908190"><p><strong>IIC通信的设备中会有单独一个字节空间存储地址指针，当给IIC设备指定地址写时，地址指针会加一，这时如果使用当前地址读，就是读取指针地址指向的内存。此时序较为少用、</strong></p><hr><img src="/posts/5621/image-20240524215204768.png" class="" title="image-20240524215204768"><p><strong><mark>指定地址读的实现原理：先调用指定地址写，但是不写数据。再次调用当前地址读，这样复合的时序就能完成指定地址读的功能了</mark></strong></p><h1 id="mpu6050"><a class="markdownIt-Anchor" href="#mpu6050"></a> MPU6050</h1><img src="/posts/5621/image-20240524220155605.png" class="" title="image-20240524220155605"><h2 id="姿态角欧拉角"><a class="markdownIt-Anchor" href="#姿态角欧拉角"></a> 姿态角（欧拉角）</h2><img src="/posts/5621/image-20240524220352017.png" class="" title="image-20240524220352017"><p><strong>飞机相对于初始三个轴的夹角：</strong></p><ul><li>俯仰角：Pitch</li><li>滚转：Roll</li><li>偏航：Yaw</li></ul><p>要想获得稳定的欧拉角，就需要进行数据融合，进一步得到姿态角。</p><p><strong>常见的数据融合算法：</strong></p><ul><li>互补滤波</li><li>卡尔曼滤波</li></ul><p>ps:惯性导航领域里，姿态解算</p><h2 id="加速度计结构"><a class="markdownIt-Anchor" href="#加速度计结构"></a> 加速度计结构</h2><img src="/posts/5621/image-20240524220855509.png" class="" title="image-20240524220855509"><p><strong>F=ma(测力计)</strong></p><img src="/posts/5621/image-20240524221000525.png" class="" title="image-20240524221000525"><p><strong><mark>加速度计测得的是静态加速度，只能在物体静止的时候使用</mark></strong></p><h2 id="陀螺仪传感器"><a class="markdownIt-Anchor" href="#陀螺仪传感器"></a> 陀螺仪传感器</h2><img src="/posts/5621/image-20240524221506605.png" class="" title="image-20240524221506605"><p><strong>测得的是角速度，要想得到角度，可以进行求积分</strong></p><p><strong><mark>陀螺仪具有动态稳定性，不具有静态稳定性</mark></strong></p><p><strong><mark>对两种传感器进行互补滤波，就可以得到稳定的姿态角了</mark></strong></p><h2 id="mpu6050的参数"><a class="markdownIt-Anchor" href="#mpu6050的参数"></a> MPU6050的参数</h2><img src="/posts/5621/image-20240524221944683.png" class="" title="image-20240524221944683"><p>eg: mpu6050的从机地址：0x68 ，IIC时序中发送的第一个字节，高七位为从机地址，第八位为读写位。有时候把0XD0当作MPU6050的地址</p><h2 id="硬件结构"><a class="markdownIt-Anchor" href="#硬件结构"></a> 硬件结构</h2><img src="/posts/5621/image-20240525205511856.png" class="" title="image-20240525205511856"><blockquote><p><strong>六轴传感器的缺点：没有稳定的参考方向</strong></p><p>XCL，XDA：挂载磁力计，气压计</p><p>INT引脚：可以配置MPU6050内部一些事件，产生电平跳变</p><p>PS：MPU6050内部包含DMP单元：进行姿态融合和数据结算</p><p>包含稳压电路</p></blockquote><p><mark><strong>传感器内部含有自测单元</strong></mark></p><img src="/posts/5621/image-20240525210718105.png" class="" title="image-20240525210718105"><p>使能自测-&gt;读取数据1-&gt;失能自测-&gt;读取数据2，两个数据相减，得到的数据称作自测响应，自测响应如果在<mark>规定的范围内</mark>，说明芯片性能没问题。</p><hr><p><strong>电荷泵</strong></p><img src="/posts/5621/image-20240525210953979.png" class="" title="image-20240525210953979"><p>是一种<mark>升压电路</mark></p><p>原理：电源和电容串并联的切换（充电-&gt;串联-&gt;相当于电压升高（放电）-&gt;快速切换到并联-&gt;充电-&gt;循环）+ 电容滤波 = 平稳升压</p><img src="/posts/5621/image-20240525211051107.png" class="" title="image-20240525211051107"><hr><p><strong>DMP</strong>（数字运动处理器）</p><img src="/posts/5621/image-20240525211323304.png" class="" title="image-20240525211323304"><p>配合MPU6050官方的DMP库，进行姿态解算。</p><p><mark>引脚说明</mark></p><blockquote><p>FSYNC：帧同步</p></blockquote><blockquote><p>通信接口：用于和STM32通信</p><img src="/posts/5621/image-20240525211535797.png" class="" title="image-20240525211535797"></blockquote><blockquote><p>xxxxxxxxxx&nbsp;python script_name.py --train_data_dir “path/to/train_data” --test_data_dir “path/to/test_data” --img_height 128 --img_width 128 --batch_size 64 --epochs 15python</p><p>​可以拓展连接磁力计</p><img src="/posts/5621/image-20240525211622949.png" class="" title="image-20240525211622949"></blockquote><hr><h2 id="软件iic读写mpu6050"><a class="markdownIt-Anchor" href="#软件iic读写mpu6050"></a> 软件IIC读写MPU6050</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MyIIC.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主机寻址MPU6050*/</span></span><br><span class="line">MyIIC_Init();</span><br><span class="line">MyIIC_Start();</span><br><span class="line">MyIIC_SendByte(<span class="number">0xD0</span>);<span class="comment">//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="type">uint8_t</span> Ack = MyIIC_ReceiveAck();</span><br><span class="line">MyIIC_Stop();</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Ack,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> <img src="/posts/5621/image-20240525224436566.png" class="" title="image-20240525224436566"><hr><p><strong>修改MPU6050地址</strong></p><p>可见，寻址无应答</p><img src="/posts/5621/image-20240526152458852.png" class="" title="image-20240526152458852"><hr><p><strong>读取MPU6050 ID号</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="comment">/*//主机寻址MPU6050</span></span><br><span class="line"><span class="comment">MyIIC_Init();</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(0xD2);//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="comment">uint8_t Ack = MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">OLED_ShowNum(1,1,Ack,3);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//读取MPU6050ID号</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154358599.png" class="" title="image-20240526154358599"><hr><p><strong>写MPU6050</strong>，需要关闭MPU6050的睡眠模式</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//在电源管理器1，写入0x00，接触睡眠模式</span></span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//更改采样频率</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x19</span>);<span class="comment">//读取MPU6050采样频率</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154723015.png" class="" title="image-20240526154723015"><p><strong>PS:某种程度上来说，对寄存器的读写操作可以看作读写一个存储器，但是寄存器能反应硬件电路的状态，对硬件电路进行操作</strong></p><hr><h2 id="mpu6050读取六轴姿态值"><a class="markdownIt-Anchor" href="#mpu6050读取六轴姿态值"></a> MPU6050读取六轴姿态值</h2><p><strong>函数定义</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用指针，实现函数多返回值的操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params"><span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> DataH ,DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">*AccX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">*AccY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">*AccZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">*GyroX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">*GyroY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">*GyroZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int16_t</span> Ax,Ay,Az,Gx,Gy,Gz;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">MPU6050_GetData(&amp;Ax,&amp;Ay,&amp;Az,&amp;Gx,&amp;Gy,&amp;Gz);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">1</span>,Ax,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">1</span>,Ay,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">1</span>,Az,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">8</span>,Gx,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">8</span>,Gy,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">8</span>,Gz,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>加速度计最大量程为16g</strong></p><img src="/posts/5621/image-20240526162104183.png" class="" title="image-20240526162104183"><p>左侧为加速度计，右侧为角速度测量值</p><hr><h2 id="硬件iic读写mpu6050"><a class="markdownIt-Anchor" href="#硬件iic读写mpu6050"></a> 硬件IIC读写MPU6050</h2><p>CR：控制寄存器</p><p>DR：数据寄存器</p><p>SR：状态寄存器</p><p><strong>STM32IIC外设</strong></p><img src="/posts/5621/image-20240526162959527.png" class="" title="image-20240526162959527"><h3 id="多主机模型"><a class="markdownIt-Anchor" href="#多主机模型"></a> 多主机模型</h3><p><strong>一主多从</strong></p><img src="/posts/5621/image-20240526163123491.png" class="" title="image-20240526163123491"><p><strong>多主多从</strong></p><p>固定多主机：</p><img src="/posts/5621/image-20240526163142347.png" class="" title="image-20240526163142347"><p>可变多主机：</p><img src="/posts/5621/image-20240526163226138.png" class="" title="image-20240526163226138"><p><strong>GPIO复用输入和复用输出</strong></p><img src="/posts/5621/image-20240526164412282.png" class="" title="image-20240526164412282"><p><strong>IIC主机发送流程图</strong></p><img src="/posts/5621/image-20240526165109626.png" class="" title="image-20240526165109626"><p><strong>IIC主机接收流程图</strong></p><img src="/posts/5621/image-20240526165718823.png" class="" title="image-20240526165718823"><h3 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h3><blockquote><p><strong>产生起始条件</strong></p><p>void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>生成终止条件</strong></p><p>void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>配置在收到一个字节后，是否给从机应答</strong></p><p>void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>写数据到数据寄存器DR</strong></p><p>void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);</p><p><strong>读取DR的数据，作为返回值</strong></p><p>uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);</p><p><strong>发送7位地址</strong></p><p>void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);</p></blockquote><p><strong>状态监控函数的官方说明</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> ****************************************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                         I2C State Monitoring Functions</span></span><br><span class="line"><span class="comment"> *                       </span></span><br><span class="line"><span class="comment"> ****************************************************************************************   </span></span><br><span class="line"><span class="comment"> * This I2C driver provides three different ways for I2C state monitoring</span></span><br><span class="line"><span class="comment"> *  depending on the application requirements and constraints:</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 1) Basic state monitoring:</span></span><br><span class="line"><span class="comment"> *    Using I2C_CheckEvent() function:</span></span><br><span class="line"><span class="comment"> *    It compares the status registers (SR1 and SR2) content to a given event</span></span><br><span class="line"><span class="comment"> *    (can be the combination of one or more flags).</span></span><br><span class="line"><span class="comment"> *    It returns SUCCESS if the current status includes the given flags </span></span><br><span class="line"><span class="comment"> *    and returns ERROR if one or more flags are missing in the current status.</span></span><br><span class="line"><span class="comment"> *    - When to use:</span></span><br><span class="line"><span class="comment"> *      - This function is suitable for most applications as well as for startup </span></span><br><span class="line"><span class="comment"> *      activity since the events are fully described in the product reference manual </span></span><br><span class="line"><span class="comment"> *      (RM0008).</span></span><br><span class="line"><span class="comment"> *      - It is also suitable for users who need to define their own events.</span></span><br><span class="line"><span class="comment"> *    - Limitations:</span></span><br><span class="line"><span class="comment"> *      - If an error occurs (ie. error flags are set besides to the monitored flags),</span></span><br><span class="line"><span class="comment"> *        the I2C_CheckEvent() function may return SUCCESS despite the communication</span></span><br><span class="line"><span class="comment"> *        hold or corrupted real state. </span></span><br><span class="line"><span class="comment"> *        In this case, it is advised to use error interrupts to monitor the error</span></span><br><span class="line"><span class="comment"> *        events and handle them in the interrupt IRQ handler.</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *        @note </span></span><br><span class="line"><span class="comment"> *        For error management, it is advised to use the following functions:</span></span><br><span class="line"><span class="comment"> *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).</span></span><br><span class="line"><span class="comment"> *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.</span></span><br><span class="line"><span class="comment"> *            Where x is the peripheral instance (I2C1, I2C2 ...)</span></span><br><span class="line"><span class="comment"> *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()</span></span><br><span class="line"><span class="comment"> *            in order to determine which error occurred.</span></span><br><span class="line"><span class="comment"> *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()</span></span><br><span class="line"><span class="comment"> *            and/or I2C_GenerateStop() in order to clear the error flag and source,</span></span><br><span class="line"><span class="comment"> *            and return to correct communication status.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  2) Advanced state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetLastEvent() which returns the image of both status </span></span><br><span class="line"><span class="comment"> *     registers in a single word (uint32_t) (Status Register 2 value is shifted left </span></span><br><span class="line"><span class="comment"> *     by 16 bits and concatenated to Status Register 1).</span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *       - This function is suitable for the same applications above but it allows to</span></span><br><span class="line"><span class="comment"> *         overcome the limitations of I2C_GetFlagStatus() function (see below).</span></span><br><span class="line"><span class="comment"> *         The returned value could be compared to events already defined in the </span></span><br><span class="line"><span class="comment"> *         library (stm32f10x_i2c.h) or to custom values defined by user.</span></span><br><span class="line"><span class="comment"> *       - This function is suitable when multiple flags are monitored at the same time.</span></span><br><span class="line"><span class="comment"> *       - At the opposite of I2C_CheckEvent() function, this function allows user to</span></span><br><span class="line"><span class="comment"> *         choose when an event is accepted (when all events flags are set and no </span></span><br><span class="line"><span class="comment"> *         other flags are set or just when the needed flags are set like </span></span><br><span class="line"><span class="comment"> *         I2C_CheckEvent() function).</span></span><br><span class="line"><span class="comment"> *     - Limitations:</span></span><br><span class="line"><span class="comment"> *       - User may need to define his own events.</span></span><br><span class="line"><span class="comment"> *       - Same remark concerning the error management is applicable for this </span></span><br><span class="line"><span class="comment"> *         function if user decides to check only regular communication flags (and </span></span><br><span class="line"><span class="comment"> *         ignores error flags).</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3) Flag-based state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetFlagStatus() which simply returns the status of </span></span><br><span class="line"><span class="comment"> *     one single flag (ie. I2C_FLAG_RXNE ...). </span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *        - This function could be used for specific applications or in debug phase.</span></span><br><span class="line"><span class="comment"> *        - It is suitable when only one flag checking is needed (most I2C events </span></span><br><span class="line"><span class="comment"> *          are monitored through multiple flags).</span></span><br><span class="line"><span class="comment"> *     - Limitations: </span></span><br><span class="line"><span class="comment"> *        - When calling this function, the Status register is accessed. Some flags are</span></span><br><span class="line"><span class="comment"> *          cleared when the status register is accessed. So checking the status</span></span><br><span class="line"><span class="comment"> *          of one Flag, may clear other ones.</span></span><br><span class="line"><span class="comment"> *        - Function may need to be called twice or more in order to monitor one </span></span><br><span class="line"><span class="comment"> *          single event.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="iic配置占空比的缘由"><a class="markdownIt-Anchor" href="#iic配置占空比的缘由"></a> #IIC配置占空比的缘由</h3><p><strong>上升沿变化较慢，下降沿比较迅速，标准速度下，时钟占空比接近1：1，快速状态，占空比接近2：1</strong></p><img src="/posts/5621/image-20240526174725131.png" class="" title="image-20240526174725131"><p>100KHZ</p><img src="/posts/5621/image-20240526174831972.png" class="" title="image-20240526174831972"><p>400KHZ</p><img src="/posts/5621/image-20240526174841651.png" class="" title="image-20240526174841651"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> *  <span class="number">1</span>) Basic state monitoring</span><br><span class="line"> *******************************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Checks whether the last I2Cx Event is equal to the one passed</span></span><br><span class="line"><span class="comment">  *   as parameter.</span></span><br><span class="line"><span class="comment">  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.</span></span><br><span class="line"><span class="comment">  * @param  I2C_EVENT: specifies the event to be checked. </span></span><br><span class="line"><span class="comment">  *   This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     </span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9</span></span><br><span class="line"><span class="comment">  *     </span></span><br><span class="line"><span class="comment">  * @note: For detailed description of Events, please refer to section </span></span><br><span class="line"><span class="comment">  *    I2C_Events in stm32f10x_i2c.h file.</span></span><br><span class="line"><span class="comment">  *    </span></span><br><span class="line"><span class="comment">  * @retval An ErrorStatus enumeration value:</span></span><br><span class="line"><span class="comment">  * - SUCCESS: Last event is equal to the I2C_EVENT</span></span><br><span class="line"><span class="comment">  * - ERROR: Last event is different from the I2C_EVENT</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解决while死循环等待的问题"><a class="markdownIt-Anchor" href="#解决while死循环等待的问题"></a> 解决WHILE死循环等待的问题</h3><p><strong>多个while,比较危险，一旦通信出现问题，程序直接卡死</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*软件I2C，阻塞式程序</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();//可以加判断，确保时序的正确</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(RegAddress);//指定要写入的寄存器</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(Data);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//硬件IIC，非阻塞式程序</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT ) !=SUCCESS);<span class="comment">//事件监测</span></span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//选择I2C外设，从机地址，从机地址最低位。此函数自带接收应答的功能</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,RegAddress);<span class="comment">//写入DR，需要等待EV8事件</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,Data);</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) !=SUCCESS);<span class="comment">//发送完最后一个字节，需要监测EB8_1事件</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTOP(I2C2,ENABLE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>保护程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Timeout;</span><br><span class="line">Timeout= <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2Cx,I2C_EVENT) != SUCCESS)</span><br><span class="line">{</span><br><span class="line">Timeout--;</span><br><span class="line"><span class="keyword">if</span>(Timeout==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="dmp库"><a class="markdownIt-Anchor" href="#dmp库"></a> DMP库</h1><p>digital motion processor数字运动处理器，mpu6050自带的一个硬件，可以直接输出用于姿态结算的四元数</p><h1 id="卡尔曼滤波"><a class="markdownIt-Anchor" href="#卡尔曼滤波"></a> 卡尔曼滤波</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iic通信协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#iic通信协议&quot;&gt;&lt;/a&gt; IIC通信协议&lt;/h1&gt;
&lt;h2 id=&quot;基本功能&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本功能&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="IIC" scheme="https://szturin.github.io/tags/IIC/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[9]DMA数据转运</title>
    <link href="https://szturin.github.io/posts/10712/"/>
    <id>https://szturin.github.io/posts/10712/</id>
    <published>2024-05-22T03:44:18.000Z</published>
    <updated>2024-10-29T08:05:07.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h1><blockquote><p><strong>恢复缺省配置</strong></p><p>void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>初始化DMA</strong></p><p>void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>DMA使能</strong></p><p>void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);</p><p><strong>中断输出使能</strong></p><p>void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);</p><p><strong>DMA设置当前数据寄存器</strong></p><p>void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);</p><p><strong>DMA获取当前数据寄存器</strong></p><p>uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>获取DMA标志位状态</strong></p><p>FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);</p><p><strong>清除DMA标志位</strong></p><p>void DMA_ClearFlag(uint32_t DMAy_FLAG);</p><p><strong>获取DMA中断标志位状态</strong></p><p>ITStatus DMA_GetITStatus(uint32_t DMAy_IT);</p><p><strong>清除DMA中断标志位</strong></p><p>void DMA_ClearITPendingBit(uint32_t DMAy_IT);</p><p><strong>开启ADC DMA触发信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p></blockquote><ul><li><p><strong><mark>DMA是AHB总线的设备</mark></strong></p></li><li><p><strong><mark>DMA软件触发和硬件触发不能同时使用，如果同时使用DMA就会连续触发</mark></strong></p></li><li><p>DMA转运有三个条件：1.传输计数器大于0 2.触发源有触发信号 3.DMA使能</p></li></ul><h1 id="一-dma数据转运"><a class="markdownIt-Anchor" href="#一-dma数据转运"></a> 一、DMA数据转运</h1><h2 id="1stm32单片机ram和rom"><a class="markdownIt-Anchor" href="#1stm32单片机ram和rom"></a> 1.stm32单片机RAM和ROM</h2><h3 id="不加const修饰"><a class="markdownIt-Anchor" href="#不加const修饰"></a> 不加const修饰</h3><img src="/posts/10712/image-20240522115326572.png" class="" title="image-20240522115326572"><h3 id="加上const修饰"><a class="markdownIt-Anchor" href="#加上const修饰"></a> 加上const修饰</h3><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> aa =<span class="number">0x66</span>;<span class="comment">//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,aa,<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;aa,<span class="number">8</span>);<span class="comment">//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>现象</strong></p><p>flash里面编译的代码部分，地址位于flah最前面，所以这里变量的显示在靠后的地址</p><img src="/posts/10712/image-20240522115450140.png" class="" title="image-20240522115450140"><h2 id="const关键字节省sram空间"><a class="markdownIt-Anchor" href="#const关键字节省sram空间"></a> const关键字节省SRAM空间</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED字模库，宽8像素，高16像素*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> OLED_F8x16[][<span class="number">16</span>]=</span><br><span class="line">{</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//  0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="结构体访问寄存器ram地址"><a class="markdownIt-Anchor" href="#结构体访问寄存器ram地址"></a> 结构体访问寄存器RAM地址</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR,<span class="number">8</span>);</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522115913765.png" class="" title="image-20240522115913765"><p><strong><mark>外设的起始地址+寄存器的偏移地址=指定寄存器的地址</mark></strong></p><p><strong><mark>使用结构体访问，指定地址对应寄存器，这样，结构体访问就是寄存器的地址</mark></strong></p><h2 id="2dma转运数组"><a class="markdownIt-Anchor" href="#2dma转运数组"></a> 2.DMA转运数组</h2><p><strong>软件触发代码部分</strong></p> <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522143322783.png" class="" title="image-20240522143322783"><h2 id="3dma软件触发"><a class="markdownIt-Anchor" href="#3dma软件触发"></a> 3.DMA软件触发</h2><img src="/posts/10712/image-20240522144732279.png" class="" title="image-20240522144732279"><p><strong>DMA传输计数器软件重装</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyDMA_Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数DMA初始化配置</span></span><br><span class="line"><span class="comment">  * @参数要转运数据的首地址，存储器站点的起始地址，传输次数</span></span><br><span class="line"><span class="comment">  * @返回值</span></span><br><span class="line"><span class="comment">  * @特殊说明</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line">MyDMA_Size=Size;</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=Size;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Enable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=AddrB;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;<span class="comment">//以字节传输</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;</span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=AddrA;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte;<span class="comment">//转运数据宽度为一个字节</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，所以通道可以任意选择</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,MyDMA_Size);</span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"DataA"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">"DataB"</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataA,<span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataB,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">DataA[<span class="number">0</span>]++;</span><br><span class="line">DataA[<span class="number">1</span>]++;</span><br><span class="line">DataA[<span class="number">2</span>]++;</span><br><span class="line">DataA[<span class="number">3</span>]++;</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">MyDMA_Transfer();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522145131191.png" class="" title="image-20240522145131191"><p><strong>将DataA用const修饰</strong></p><p>DataA此时为flash里面的变量，所以地址为08开头</p><img src="/posts/10712/image-20240522145359406.png" class="" title="image-20240522145359406"><h1 id="adc-dma转运"><a class="markdownIt-Anchor" href="#adc-dma转运"></a> ADC+ DMA转运</h1><p><strong>ADC单次扫描，DMA单次转运+软件触发</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD_Value[<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=DISABLE;<span class="comment">//单次模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,<span class="number">4</span>);<span class="comment">//传输次数给4</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里选择了ADC触发DMA，标志位自动清零，所以不需要软件清零</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);//等待转换完成标志位置1</span></span><br><span class="line"><span class="comment">return ADC_GetConversionValue(ADC1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA转运完成总是在ADC完成之后的，所以这里等待DMA状态标志位即可*/</span></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>ADC连续扫描+DMA循环转运模式</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=ENABLE;<span class="comment">//连续模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Circular;<span class="comment">//传输模式，是否使用自动重装,DMA循环模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line"></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思考：</strong></p><ul><li>定时器触发ADC单词转换后通过DMA转运？</li><li>串口发送的数据使用DMA进行存储器到外设的转运</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;相关库函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#相关库函数&quot;&gt;&lt;/a&gt; 相关库函数&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;恢复缺省配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void DMA_DeInit(DMA</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="DMA数据转运" scheme="https://szturin.github.io/tags/DMA%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[10]串口通信</title>
    <link href="https://szturin.github.io/posts/19202/"/>
    <id>https://szturin.github.io/posts/19202/</id>
    <published>2024-05-20T03:50:54.000Z</published>
    <updated>2024-10-29T08:05:11.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p><strong>结构体初始化配置</strong></p><p>void USART_DeInit(USART_TypeDef* USARTx);<br>void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);<br>void USART_StructInit(USART_InitTypeDef* USART_InitStruct);</p><p><strong>同步时钟配置</strong></p><p>void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);<br>void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);</p><p><strong>发送数据</strong></p><p>void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);</p><ul><li>写DR寄存器</li></ul><p><strong>接收数据</strong></p><p>uint16_t USART_ReceiveData(USART_TypeDef* USARTx);</p><ul><li>读DR寄存器</li></ul></blockquote><h1 id="microlib"><a class="markdownIt-Anchor" href="#microlib"></a> MicroLIB</h1><p><strong>MicroLIB是Keil为嵌入式平台优化的一个精简库</strong></p><img src="/posts/19202/image-20240520133336274.png" class="" title="image-20240520133336274"><h1 id="多个串口同时使用printf"><a class="markdownIt-Anchor" href="#多个串口同时使用printf"></a> 多个串口同时使用printf</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(String,<span class="string">"Num=%d\r\n"</span>,<span class="number">666</span>);<span class="comment">//sprintf.可以将指定的数据复制到数组中</span></span><br><span class="line">Serial_SendString(String);<span class="comment">//打印字符串</span></span><br></pre></td></tr></tbody></table></figure><h1 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_Prinf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="汉字编码发送"><a class="markdownIt-Anchor" href="#汉字编码发送"></a> 汉字编码发送</h1><img src="/posts/19202/image-20240520135012811.png" class="" title="image-20240520135012811"><p><strong>统一选定为UTF-8编码</strong></p><h1 id="串口接收"><a class="markdownIt-Anchor" href="#串口接收"></a> 串口接收</h1><h2 id="1查询方法"><a class="markdownIt-Anchor" href="#1查询方法"></a> 1.查询方法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">RXData=USART_ReceiveData(USART1);<span class="comment">//读DR可以自动清除标志位</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2中断方法"><a class="markdownIt-Anchor" href="#2中断方法"></a> 2.中断方法</h2><h3 id="子程序"><a class="markdownIt-Anchor" href="#子程序"></a> 子程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxData;</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GerRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> Serial_RxData;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2主程序"><a class="markdownIt-Anchor" href="#2主程序"></a> 2.主程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"RxData:"</span>);</span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_GerRxFlag()==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RXData = Serial_GetRxData();</span><br><span class="line">Serial_SendByte(RXData);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">RXData=USART_ReceiveData(USART1);//读DR可以自动清除标志位</span></span><br><span class="line"><span class="comment">OLED_ShowHexNum(1,1,RXData,2);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="串口数据包"><a class="markdownIt-Anchor" href="#串口数据包"></a> 串口数据包</h1><p><strong>打包多字节为一个数据包，方便发送多字节的数据。将同一批的数据进行打包和分割</strong></p><p><strong>包头、包尾：简易通信协议</strong></p><ul><li>文本数据包</li><li>Hex数据包</li></ul><h2 id="状态机的方法来接收数据包"><a class="markdownIt-Anchor" href="#状态机的方法来接收数据包"></a> 状态机的方法来接收数据包</h2><img src="/posts/19202/image-20240520150733732.png" class="" title="image-20240520150733732"><h2 id="1发送数据包"><a class="markdownIt-Anchor" href="#1发送数据包"></a> 1.发送数据包</h2><img src="/posts/19202/image-20240520152533465.png" class="" title="image-20240520152533465"><h2 id="2接收数据包"><a class="markdownIt-Anchor" href="#2接收数据包"></a> 2.接收数据包</h2><p><strong>串口中断子程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_TxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送数据包*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(<span class="number">0xFF</span>);</span><br><span class="line">Serial_SendArray(Serial_TxPacket,<span class="number">4</span>);</span><br><span class="line">Serial_SendByte(<span class="number">0xFE</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line"><span class="keyword">if</span>(++pRxState&gt;=<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">pRxState=<span class="number">0</span>;</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="number">0xFE</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Serial.h</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_TxPacket[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_RxPacket[];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="小操作"><a class="markdownIt-Anchor" href="#小操作"></a> 小操作</h2><p><strong>按住alt选择一列进行修改</strong></p><img src="/posts/19202/image-20240520154534025.png" class="" title="image-20240520154534025"><h2 id="3文本收发数据包"><a class="markdownIt-Anchor" href="#3文本收发数据包"></a> 3.文本收发数据包</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">100</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'@'</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'\r'</span>)<span class="comment">//第一个包尾</span></span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line">pRxState++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)<span class="comment">//第二个包尾</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="string">'\n'</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">Serial_RxPacket[pRxState]=<span class="string">'\0'</span>;<span class="comment">//字符串结束时加上\0,表示字符串的结束</span></span><br><span class="line">pRxState=<span class="number">0</span>;<span class="comment">//MARK:忘记清零</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="串口下载"><a class="markdownIt-Anchor" href="#串口下载"></a> #串口下载</h1><h2 id="boot引脚"><a class="markdownIt-Anchor" href="#boot引脚"></a> Boot引脚</h2><p>BootLoder的作用相当于刷机</p><h2 id="调试使用"><a class="markdownIt-Anchor" href="#调试使用"></a> 调试使用</h2><img src="/posts/19202/image-20240520163851412.png" class="" title="image-20240520163851412"><p>可以保持跳线帽置1，但是复位后程序丢失，所以仅用来调试</p><h2 id="读flash生成bin文件"><a class="markdownIt-Anchor" href="#读flash生成bin文件"></a> 读FLASH生成bin文件</h2><img src="/posts/19202/image-20240520164112095.png" class="" title="image-20240520164112095"><h2 id="读保护写保护"><a class="markdownIt-Anchor" href="#读保护写保护"></a> 读保护/写保护</h2><img src="/posts/19202/image-20240520164217951.png" class="" title="image-20240520164217951"><h1 id="蓝牙串口通信"><a class="markdownIt-Anchor" href="#蓝牙串口通信"></a> 蓝牙串口通信</h1><p><a href="https://blog.csdn.net/struggle_success/article/details/130440579">电赛|项目|课设：蓝牙模块HC05主从配置与连接_蓝牙 master和 slave 服务-CSDN博客</a></p><p><strong>AT指令集</strong></p><p>AT+NAME = xlg 设置蓝牙名称为xlg</p><p>AT+ROLE=0 蓝牙模式为从模式 AT+ROLE=1 蓝牙模式为主模式<br>AT+CMODE=0 蓝牙连接模式为任意地址连接模式<br>AT+PSWD=1234 蓝牙配对密码为1234<br>AT+UART=9600，0，0 蓝牙通信串口波特率为9600，停止位1位，无校验位<br>AT+RMAAD 清空配对列表</p><p>一、更改波特率<br>AT+UART=a,b,c<br>蓝牙通信串口波特率为a，<br>b:停止位1位，无校验位<br>返回响应为OK</p><p>二、修改蓝牙模块密码</p><p>修改密码的AT指令格式如下：（以修改后的密码为1314为例）</p><pre><code>        AT+PSWD=1314（这里加回车）</code></pre><p>1<br>三、修改蓝牙模块名字</p><p>修改模块名字的AT指令如下：</p><pre><code>            AT+NAME =</code></pre><p>1<br>1， AT+ROLE设置主从模式：<br>AT+ROLE=1是设成主，AT+ROLE=0是设成从，AT+ROLE=2设成回环模式Slave-Loop：被动连接，接收远程蓝 牙主设备数据并将数据原样返回给远程蓝牙<br>AT+ROLE?：查询主从状态<br>2， AT+RESET:HC-05复位</p><p>3， AT+VERSION?：获取HC-05的软件版本号，只能获取，不能修改。</p><p>4， AT+ORGL:恢复出厂默认设置，当把模块设置乱了，使用此命令进行恢复默认值。</p><p>5， AT+ADDR?：获取HC-05的蓝牙地址码，只能获取，不能修改。</p><p>6， AT+NAME？:获取HC-05的名字,AT+NAME=xlg，修改模块的名字为xlg，具体名字自行修改。</p><p>7， AT+CLASS?：设置查询设备的类型，尽量不要去修改此参数。默认是1F00。</p><p>8， AT+IAC?：查询设置查询访问码，默认是9E8B33，尽量不要去修改此参数。</p><p>9， AT+PSWD？:查询设置配对密码,AT+PSWD=”0000”,密码要有双引号,密码是四位数字.</p><p>10， AT+UART：AT+UART？是查询当前模块的波特率，AT+UART=波特率,0,0。</p><p>11， AT+CMODE：AT+CMODE？是查询当前连接模式。AT+CMODE=0，1，2(0——指定蓝牙地址连接模式（指定蓝牙地址由绑定指令设置）1——任意蓝牙地址连接模式（不受绑定指令设置地址的约束）2——回环角色（Slave-Loop）默认连接模式：0)。</p><p>12， AT+BIND:AT+BIND?查询当前绑定地址,AT+BIND=NAP，UAP，LAP(用逗号隔开)。</p><p>13， AT+RMADD:从蓝牙配对列表中删除所有认证设备.</p><p>14， AT+STATE？:获取蓝牙模块工作状态.</p><p>15， AT+LINK=NAP,UAP,LAP：与远程设备建立连接。</p><p>16， AT+DISC:断开连接.</p><p>17， AT+RNAME？NAP，UAP，LAP:获取远程蓝牙设备名称.</p><p>18， AT+ADCN?：获取蓝牙配对列表中认证设备数。</p><p>19， AT+MRAD？获取最近使用过的蓝牙认证设备地址。</p><p>20， AT+INQM:设置查询模式,AT+INQM=1，9，48(1-带RSSI信号强度指示,9-超过9个蓝牙设备响应则终止查询,48-设定超时为48*1.28=61.44秒)</p><p><strong>ps: HC05模块的AT指令，蓝牙命名AT+NAME= 以及密码设置AT+PSWD= 需要加双引号！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;库函数解释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#库函数解释&quot;&gt;&lt;/a&gt; 库函数解释&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;结构体初始化配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void USART_DeInit</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="串口" scheme="https://szturin.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="蓝牙" scheme="https://szturin.github.io/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
</feed>
