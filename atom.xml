<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Turin&#39;s Blog</title>
  
  <subtitle>数理照亮世界</subtitle>
  <link href="https://szturin.github.io/atom.xml" rel="self"/>
  
  <link href="https://szturin.github.io/"/>
  <updated>2024-11-08T12:29:00.019Z</updated>
  <id>https://szturin.github.io/</id>
  
  <author>
    <name>Szturin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【stm32单片机】[操作系统][RT-Thread][1]内核与线程</title>
    <link href="https://szturin.github.io/posts/64776/"/>
    <id>https://szturin.github.io/posts/64776/</id>
    <published>2024-10-16T14:17:26.000Z</published>
    <updated>2024-11-08T12:29:00.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="裸机开发与操作系统的区别"><a class="markdownIt-Anchor" href="#裸机开发与操作系统的区别"></a> 裸机开发与操作系统的区别</h1><h2 id="裸机开发"><a class="markdownIt-Anchor" href="#裸机开发"></a> 裸机开发</h2><ul><li>单一任务（阻塞式）</li><li>手动分配资源</li><li>缺乏抽象层</li><li>灵活性、实时性较高</li></ul><h2 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h2><ul><li>多任务调度</li><li>自动资源管理</li><li>硬件抽象层</li></ul><h1 id="rt-thread的线程"><a class="markdownIt-Anchor" href="#rt-thread的线程"></a> RT-Thread的线程</h1><h2 id="线程的概念"><a class="markdownIt-Anchor" href="#线程的概念"></a> 线程的概念</h2><p>在RT-thread中，线程是最小的工作单元。每个线程负责一个任务。RT-Thread根据线程的优先级决定哪个任务先完成.。</p><p>RT-Thread 支持多达 256 个优先级。0是最高的优先级。</p><h2 id="线程的组成部分"><a class="markdownIt-Anchor" href="#线程的组成部分"></a> 线程的组成部分</h2><ol><li>线程控制块：线程的名字，线程要执行的任务，线程的优先级，线程的状态</li><li>线程栈：保存临时数据</li><li>入口函数：线程的任务内容</li></ol><h2 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h2><p>线程有五种工作状态：</p><ol><li>初始状态：线程创建还未使用</li><li>就绪状态：线程准备好，但是没有拿到资源</li><li>运行状态：线程正在执行任务，占用CPU</li><li>挂起状态：线程暂时停止工作</li><li>关闭状态：线程的任务完成了，线程结束，不再使用</li></ol><h2 id="线程的优先级"><a class="markdownIt-Anchor" href="#线程的优先级"></a> 线程的优先级</h2><p>RT-Thread支持256个优先级</p><h2 id="时间片"><a class="markdownIt-Anchor" href="#时间片"></a> 时间片</h2><p>时间片是线程允许工作的时间。如果多个线程的优先级相同，则根据”时间片“，执行完任务A后再执行任务B，轮询进行。</p><h1 id="rt-thread工程"><a class="markdownIt-Anchor" href="#rt-thread工程"></a> RT-Thread工程</h1><h2 id="rt-thread项目创建"><a class="markdownIt-Anchor" href="#rt-thread项目创建"></a> RT-Thread项目创建</h2><img src="/posts/64776/image-20241017014526806.png" class="" title="image-20241017014526806"><p>RT-Thread工程创建完毕，硬件底层还没有初始化，需要我们自己进行配置</p><p>点击CubeMX_Setting进行联调</p><img src="/posts/64776/image-20241017014950565.png" class="" title="image-20241017014950565"><p>CubeMX完成RCC、时钟树、串口、工程选项等关键配置后，生成代码，关闭CubeMX</p><p>在RT-Thread Studio中生成了CubemxI相关文件</p><p>进行编译后，出现一个小bug</p><img src="/posts/64776/image-20241017020104564.png" class="" title="image-20241017020104564"><p>这个时候，需要我们将API更换掉</p><p>对cubemx文件夹下的main.c进行分析，发现被进行了弱定义</p><img src="/posts/64776/image-20241017020406174.png" class="" title="image-20241017020406174"><p>转到RT-thread重定义的main.c</p><p>结论：RT-Thread对Hal库进行了硬件层的抽象</p><img src="/posts/64776/image-20241017020503940.png" class="" title="image-20241017020503940"><p>RT-Thread初始化默认集成了Shell</p><img src="/posts/64776/image-20241017021855733.png" class="" title="image-20241017021855733"><h2 id="创建线程"><a class="markdownIt-Anchor" href="#创建线程"></a> 创建线程</h2><p>函数API</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> (*entry)(<span class="type">void</span> *parameter),</span></span><br><span class="line"><span class="params">                             <span class="type">void</span>       *parameter,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint8_t</span>  priority,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint32_t</span> tick)</span></span><br></pre></td></tr></tbody></table></figure><p>程序实现</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建线程*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义入口函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span>  *parameter)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        rt_kprintf(<span class="string">"Thread1 is running, count:%d\n"</span>,count);</span><br><span class="line">        count++;</span><br><span class="line">        rt_thread_delay(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*创建线程1*/</span></span><br><span class="line">    <span class="comment">//tid为线程id，线程名称为thread1,入口函数为thread1_entry，入口参数为RT_NULL即无入口参数</span></span><br><span class="line">    <span class="comment">//堆栈空间设置为1024</span></span><br><span class="line">    <span class="comment">//优先级为20</span></span><br><span class="line">    <span class="comment">//时间片为10</span></span><br><span class="line">    tid1 = rt_thread_create(<span class="string">"thread1"</span>,</span><br><span class="line">                             thread1_entry,RT_NULL,</span><br><span class="line">                             <span class="number">1024</span>,<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*启动线程*/</span></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL){<span class="comment">//判断身份id是否为空</span></span><br><span class="line">        rt_thread_startup(tid1);<span class="comment">//激活线程</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>编译后烧写</p><p>实验结果：线程在循环运行</p><img src="/posts/64776/image-20241017023340933.png" class="" title="image-20241017023340933"><blockquote><p>rt_thread_delay()的作用：</p><ul><li>休眠当前进程，释放CPU资源</li><li>将任务挂起</li></ul><p>rt_thread_delay(1000)即任务以1000ms周期运行</p><p>注意：</p><ul><li>时间片是允许运行的时间</li><li>rt_thread_delay作用是运行的周期，并且是非阻塞的。</li></ul></blockquote><p>多线程创建</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建线程*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid1 = RT_NULL;<span class="comment">//储存线程信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid2 = RT_NULL;<span class="comment">//储存线程信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程1入口函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span>  *parameter)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        rt_kprintf(<span class="string">"Thread1 is running, count:%d\n"</span>,count);</span><br><span class="line">        count++;</span><br><span class="line">        rt_thread_delay(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*线程2入口函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span>  *parameter)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        rt_kprintf(<span class="string">"Thread2 is running, count:%d\n"</span>,count);</span><br><span class="line">        count++;</span><br><span class="line">        rt_thread_delay(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*创建线程1*/</span></span><br><span class="line">    tid1 = rt_thread_create(<span class="string">"thread1"</span>,</span><br><span class="line">                             thread1_entry,RT_NULL,</span><br><span class="line">                             <span class="number">1024</span>,<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建线程1*/</span></span><br><span class="line">    tid2 = rt_thread_create(<span class="string">"thread2"</span>,</span><br><span class="line">                             thread2_entry,RT_NULL,</span><br><span class="line">                             <span class="number">1024</span>,<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*启动线程*/</span></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL){rt_thread_startup(tid1);}<span class="comment">//线程1不为空，激活线程</span></span><br><span class="line">    <span class="keyword">if</span>(tid2 != RT_NULL){rt_thread_startup(tid2);}<span class="comment">//线程2不为空，激活线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;裸机开发与操作系统的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#裸机开发与操作系统的区别&quot;&gt;&lt;/a&gt; 裸机开发与操作系统的区别&lt;/h1&gt;
&lt;h2 id=&quot;裸机开发&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】-Hal库-嵌入式-6-PWM、输入捕获</title>
    <link href="https://szturin.github.io/posts/12030/"/>
    <id>https://szturin.github.io/posts/12030/</id>
    <published>2024-10-15T13:54:15.000Z</published>
    <updated>2024-10-29T08:06:01.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="按键状态机与回调函数的封装思想"><a class="markdownIt-Anchor" href="#按键状态机与回调函数的封装思想"></a> # 按键状态机与回调函数的封装思想</h1><h1 id="一-pwm配置"><a class="markdownIt-Anchor" href="#一-pwm配置"></a> 一、PWM配置</h1><blockquote><p>生成频率为1000HZ的PWM信号，占空比可调</p></blockquote><h2 id="1-cubemx配置"><a class="markdownIt-Anchor" href="#1-cubemx配置"></a> 1. CubeMX配置</h2><ul><li>选择Internal(内部时钟)</li></ul><img src="/posts/12030/image-20241015222342274.png" class="" title="image-20241015222342274"><p>根据CubeMX的芯片引脚图，选中引脚后的相关外设提示，可以便捷的配置定时器的作用通道</p><img src="/posts/12030/image-20241015222740979.png" class="" title="image-20241015222216707"><p>定时器PWM相关配置项</p><p>这里50有误，应该改为500——&gt;对应50%的占空比</p><img src="/posts/12030/image-20241015223259551.png" class="" title="image-20241015223259551"><h1 id="二-输入捕获"><a class="markdownIt-Anchor" href="#二-输入捕获"></a> 二、输入捕获</h1><h2 id="1-cubemx配置-2"><a class="markdownIt-Anchor" href="#1-cubemx配置-2"></a> 1. CubeMX配置</h2><img src="/posts/12030/image-20241015230019438.png" class="" title="image-20241015230019438"><p><strong>Slave Mode</strong>: Reset Mode</p><ul><li><p><strong>从模式 (Slave Mode)</strong>：在定时器中，“Slave Mode” 是指定时器可以被外部信号触发或由另一个定时器控制。定时器可以通过外部输入或其他定时器的输出信号来复位、启动或停止。</p></li><li><p><strong>Reset Mode</strong>：在从模式的复位模式下，每当触发事件发生时，定时器的计数器（CNT寄存器）会被重置。这对于需要周期性重置定时器的应用很有用。</p></li></ul><p><strong>Trigger Source</strong>: TI1FP1</p><ul><li><strong>触发源 (Trigger Source)</strong>：TI1FP1 通常表示 “Timer Input 1 Filtered Pin 1”，即定时器通道1的输入引脚（TI1）的滤波信号。这个触发源指示定时器使用来自外部引脚的输入信号作为触发源。</li><li>TI1FP1 作为触发源意味着定时器的操作（如复位）将根据 TI1 引脚接收到的信号进行控制。</li></ul><p><strong>Clock Source</strong>: Internal Clock</p><ul><li><p><strong>时钟源 (Clock Source)</strong>：内部时钟意味着定时器使用微控制器内部的时钟源作为定时器的时间基准。通常，内部时钟是处理器的时钟或系统时钟（如 <code>HCLK</code> 或 <code>PCLK</code>）。</p></li><li><p>使用内部时钟意味着定时器的计数将基于微控制器的时钟频率进行递增，直到外部触发信号（例如 TI1FP1）复位它。</p></li></ul><p><strong>Channel1</strong>: Input Capture direct mode</p><ul><li><p><strong>通道1 (Channel 1)</strong>：配置为输入捕获模式意味着定时器的通道1正在监视一个外部信号（通过 TI1 引脚），并在检测到信号变化（如上升沿或下降沿）时捕获当前计数器值。</p></li><li><p><strong>Direct mode</strong>：直通模式表示信号直接进入输入捕获模块，而<mark>没有通过滤波器或其他复杂处理</mark>。这通常用于<mark>快速响应</mark>的<mark>输入捕获</mark>操作。</p></li></ul><blockquote><p>思考：为什么输入捕获要设置为从模式？</p></blockquote><img src="/posts/12030/image-20241015230241742.png" class="" title="image-20241015230241742"><img src="/posts/12030/image-20241016190503917.png" class="" title="image-20241016190503917"><p>DMA转运TIM通道1数据</p><img src="/posts/12030/image-20241015230459480.png" class="" title="image-20241015230459480"><p>继续配置PA15</p><img src="/posts/12030/image-20241015230709867.png" class="" title="image-20241015230709867"><blockquote><p>问题：通过输入捕获测出来频率可能为4000</p><p>解决方法：使用不同的定时器通道进行输入捕获</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;按键状态机与回调函数的封装思想&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#按键状态机与回调函数的封装思想&quot;&gt;&lt;/a&gt; # 按键状态机与回调函数的封装思想&lt;/h1&gt;
&lt;h1 id=&quot;一-pwm配置&quot;&gt;&lt;a class=&quot;markdow</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][5]IIC,RTC</title>
    <link href="https://szturin.github.io/posts/27956/"/>
    <id>https://szturin.github.io/posts/27956/</id>
    <published>2024-10-07T15:40:59.000Z</published>
    <updated>2024-10-29T08:05:57.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iic模块"><a class="markdownIt-Anchor" href="#iic模块"></a> IIC模块</h1><h2 id="一-mcp4017"><a class="markdownIt-Anchor" href="#一-mcp4017"></a> 一、MCP4017</h2><p>MCP4017 是一款由 Microchip Technology 公司生产的数字电位器。它是一种电子元件，通常用于调整电压、增益或信号强度，类似于传统的机械电位器，但可以通过数字控制来调节。</p><p>以下是 MCP4017 的一些主要特点：</p><ol><li><strong>数字电位器</strong>：MCP4017 是一个单通道的 7 位数字电位器，分辨率为 128 个不同的电阻值（2^7 = 128 步）。</li><li><strong>I²C 接口</strong>：它使用 I²C 通信协议进行控制，通过两个引脚（SCL 和 SDA）与主设备通信。I²C 是一种广泛使用的双线通信协议，适合用于低速设备。</li><li><strong>低功耗</strong>：MCP4017 设计为低功耗设备，适合需要节能的应用场景。</li><li><strong>电阻范围</strong>：MCP4017 提供了不同的电阻范围，常见的型号包括 5kΩ、10kΩ、50kΩ 和 100kΩ 等。用户可以通过 I²C 指令在这些范围内调节电阻值。</li><li><strong>非易失性存储器</strong>：该器件不带非易失性存储器（EEPROM），因此每次上电后，电位器的默认设置是中间值（即 64/128 的位置）。</li><li><strong>应用场景</strong>：MCP4017 常用于音频调节、信号处理、传感器校准等需要精确调节电阻的场合。</li></ol><h2 id="二-阅读芯片手册"><a class="markdownIt-Anchor" href="#二-阅读芯片手册"></a> 二、阅读芯片手册</h2><p>I2C地址：0101111</p><img src="/posts/27956/image-20241007234812331.png" class="" title="image-20241007234812331"><h2 id="三-hal库api"><a class="markdownIt-Anchor" href="#三-hal库api"></a> 三、Hal库API</h2><h2 id="四-cubemx配置"><a class="markdownIt-Anchor" href="#四-cubemx配置"></a> 四、CubeMX配置</h2><blockquote><h2 id="rtc"><a class="markdownIt-Anchor" href="#rtc"></a> RTC :</h2><p>STM32 的 <strong>RTC</strong>（实时时钟）是集成在 STM32 微控制器中的一个外设，用于保持时间和日期信息，即使在主系统电源断电时也能继续工作。STM32 的 RTC 是独立的、低功耗的，可以通过外部备用电源（如纽扣电池）或内置备用电源来运行。</p><h3 id="stm32-rtc-的主要功能"><a class="markdownIt-Anchor" href="#stm32-rtc-的主要功能"></a> STM32 RTC 的主要功能：</h3><ol><li><strong>实时时钟</strong>：提供年、月、日、星期、小时、分钟、秒的时间和日期计时功能。</li><li><strong>闹钟功能</strong>：STM32 的 RTC 可以设置定时闹钟，在指定时间触发事件，常用于定时唤醒或触发任务。</li><li><strong>时间戳</strong>：能够记录事件发生时的精确时间，例如在外部中断或特定事件发生时。</li><li><strong>周期性唤醒</strong>：RTC 支持通过定时唤醒系统进入低功耗模式，如待机模式或休眠模式，帮助实现低功耗设计。</li><li><strong>低功耗</strong>：RTC 在超低功耗模式下运行，可以使用独立的低速时钟源（如 LSE，外部 32.768 kHz 晶振）或内部低速时钟（LSI）。</li></ol><h3 id="rtc-的时钟源"><a class="markdownIt-Anchor" href="#rtc-的时钟源"></a> RTC 的时钟源</h3><p>STM32 的 RTC 通常依赖于一个低速的时钟源来保持准确的时间。常见的时钟源有：</p><ul><li><strong>LSE (Low-Speed External)</strong>：外部 32.768 kHz 晶振，精度高，适合精确计时。</li><li><strong>LSI (Low-Speed Internal)</strong>：内部低速 RC 振荡器，功耗低，但精度较差。</li></ul><h3 id="常见应用场景"><a class="markdownIt-Anchor" href="#常见应用场景"></a> 常见应用场景：</h3><ul><li><strong>电子钟表、日历</strong>：嵌入式系统中经常需要长时间保持准确时间的设备。</li><li><strong>低功耗设计</strong>：通过 RTC 实现系统定时唤醒和进入低功耗模式，节省电池能量。</li><li><strong>时间戳记录</strong>：在数据记录系统或日志系统中，RTC 用于标记数据生成的时间。</li></ul></blockquote><h3 id="配置rtc"><a class="markdownIt-Anchor" href="#配置rtc"></a> 配置RTC</h3><img src="/posts/27956/image-20241008003141122.png" class="" title="image-20241008003141122"><ul><li>Activate Clock Source：激活时钟源</li><li>Activate Calendar：激活日历</li></ul><h3 id="配置时钟树"><a class="markdownIt-Anchor" href="#配置时钟树"></a> 配置时钟树</h3><img src="/posts/27956/image-20241008003433105.png" class="" title="image-20241008003433105"><img src="/posts/27956/image-20241008003518489.png" class="" title="image-20241008003518489"><p>Asynchronous Predivider和Synchronous Predivider是用来分频的两个寄存器，RTC的时钟源（LSE、LSI或HSE/32）需要经过这些分频器后，才能提供给RTC时钟</p><ul><li>Asynchronous Predivider value：异步预分器值，125，通常用于降低功耗，</li><li>Synchronous Predivider value：同步预分频器值，6000，用于精确调节RTC的计时</li></ul><p>6000 x 125 = 750KHz，速度最快，精度最高</p><img src="/posts/27956/image-20241008003736355.png" class="" title="image-20241008003736355"><ul><li>二进制</li><li>时、分、秒</li></ul><h2 id="五-编写底层驱动"><a class="markdownIt-Anchor" href="#五-编写底层驱动"></a> 五、编写底层驱动</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_app.h"</span></span></span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef time;<span class="comment">//定义时间结构体</span></span><br><span class="line">RTC_DataTypeDef date;<span class="comment">//定义日期结构体</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    HAL_RTC_GetTime(&amp;hrtc,&amp;time,RTC_FORMAT_BIN);</span><br><span class="line">    HAL_RTC_GetDate(&amp;hrtc,&amp;date,RTC_FORMAT_BIN);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"bsp_system.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_proc</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>HAL库源码</strong></p><p>1.RTC数据类型</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Time structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint8_t</span> Hours;            <span class="comment">/*!&lt; Specifies the RTC Time Hour.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the RTC_HourFormat_12 is selected.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the RTC_HourFormat_24 is selected */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Minutes;          <span class="comment">/*!&lt; Specifies the RTC Time Minutes.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Seconds;          <span class="comment">/*!&lt; Specifies the RTC Time Seconds.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> TimeFormat;       <span class="comment">/*!&lt; Specifies the RTC AM/PM Time.</span></span><br><span class="line"><span class="comment">                                 This parameter can be a value of @ref RTC_AM_PM_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> SubSeconds;     <span class="comment">/*!&lt; Specifies the RTC_SSR RTC Sub Second register content.</span></span><br><span class="line"><span class="comment">                                 This parameter corresponds to a time unit range between [0-1] Second</span></span><br><span class="line"><span class="comment">                                 with [1 Sec / SecondFraction +1] granularity */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> SecondFraction;  <span class="comment">/*!&lt; Specifies the range or granularity of Sub Second register content</span></span><br><span class="line"><span class="comment">                                 corresponding to Synchronous pre-scaler factor value (PREDIV_S)</span></span><br><span class="line"><span class="comment">                                 This parameter corresponds to a time unit range between [0-1] Second</span></span><br><span class="line"><span class="comment">                                 with [1 Sec / SecondFraction +1] granularity.</span></span><br><span class="line"><span class="comment">                                 This field will be used only by HAL_RTC_GetTime function */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DayLightSaving;  <span class="comment">/*!&lt; This interface is deprecated. To manage Daylight Saving Time,</span></span><br><span class="line"><span class="comment">                                 please use HAL_RTC_DST_xxx functions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> StoreOperation;  <span class="comment">/*!&lt; This interface is deprecated. To manage Daylight Saving Time,</span></span><br><span class="line"><span class="comment">                                 please use HAL_RTC_DST_xxx functions */</span></span><br><span class="line">} RTC_TimeTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Date structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint8_t</span> WeekDay;  <span class="comment">/*!&lt; Specifies the RTC Date WeekDay.</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_WeekDay_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Month;    <span class="comment">/*!&lt; Specifies the RTC Date Month (in BCD format).</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_Month_Date_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Date;     <span class="comment">/*!&lt; Specifies the RTC Date.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Year;     <span class="comment">/*!&lt; Specifies the RTC Date Year.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */</span></span><br><span class="line">} RTC_DateTypeDef;</span><br></pre></td></tr></tbody></table></figure><p>2.RTC函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, <span class="type">uint32_t</span> Format)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">uint32_t</span> tmpreg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_RTC_FORMAT(Format));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get subseconds structure field from the corresponding register*/</span></span><br><span class="line">  sTime-&gt;SubSeconds = READ_REG(hrtc-&gt;Instance-&gt;SSR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get SecondFraction structure field from the corresponding register field*/</span></span><br><span class="line">  sTime-&gt;SecondFraction = (<span class="type">uint32_t</span>)(READ_REG(hrtc-&gt;Instance-&gt;PRER) &amp; RTC_PRER_PREDIV_S);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TR register */</span></span><br><span class="line">  tmpreg = (<span class="type">uint32_t</span>)(READ_REG(hrtc-&gt;Instance-&gt;TR) &amp; RTC_TR_RESERVED_MASK);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fill the structure fields with the read parameters */</span></span><br><span class="line">  sTime-&gt;Hours = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_HT | RTC_TR_HU)) &gt;&gt; RTC_TR_HU_Pos);</span><br><span class="line">  sTime-&gt;Minutes = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_MNT | RTC_TR_MNU)) &gt;&gt; RTC_TR_MNU_Pos);</span><br><span class="line">  sTime-&gt;Seconds = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_ST | RTC_TR_SU)) &gt;&gt; RTC_TR_SU_Pos);</span><br><span class="line">  sTime-&gt;TimeFormat = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_PM)) &gt;&gt; RTC_TR_PM_Pos);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the input parameters format */</span></span><br><span class="line">  <span class="keyword">if</span> (Format == RTC_FORMAT_BIN)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">/* Convert the time structure parameters to Binary format */</span></span><br><span class="line">    sTime-&gt;Hours = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Hours);</span><br><span class="line">    sTime-&gt;Minutes = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Minutes);</span><br><span class="line">    sTime-&gt;Seconds = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Seconds);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HAL_OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>枚举类型：HAL_StatusTypeDef</strong></p><blockquote><p>typedef enum<br>{<br>HAL_OK       = 0x00U,<br>HAL_ERROR    = 0x01U,<br>HAL_BUSY     = 0x02U,<br>HAL_TIMEOUT  = 0x03U<br>} HAL_StatusTypeDef;</p></blockquote><p>Hal库封装的一个典型思想</p></blockquote><h2 id="多串口重定向-适合项目复用"><a class="markdownIt-Anchor" href="#多串口重定向-适合项目复用"></a> 多串口重定向-适合项目复用</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> {</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">512</span>];<span class="comment">//创建字符缓冲区</span></span><br><span class="line">    va_list arg;<span class="comment">//创建可变参数列表</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    va_start(arg, format);<span class="comment">// 初始化可变参数列表，获取my_printf传入的可变参数</span></span><br><span class="line">    len = vsnprintf(buffer, <span class="keyword">sizeof</span>(buffer), format, arg);<span class="comment">// 将格式化后的可变参数传入缓存区</span></span><br><span class="line">    va_end(arg);<span class="comment">// 结束可变参数列表</span></span><br><span class="line">    HAL_UART_Transmit(huart, (<span class="type">uint8_t</span> *)buffer, (<span class="type">uint16_t</span>)len, <span class="number">0xFF</span>); <span class="comment">// 将字符缓存数组发送出去</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iic模块&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#iic模块&quot;&gt;&lt;/a&gt; IIC模块&lt;/h1&gt;
&lt;h2 id=&quot;一-mcp4017&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-mcp4017&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][4]ADC采集系统</title>
    <link href="https://szturin.github.io/posts/26676/"/>
    <id>https://szturin.github.io/posts/26676/</id>
    <published>2024-09-29T14:14:00.000Z</published>
    <updated>2024-10-29T08:05:54.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vscode配置stm32编译调试环境"><a class="markdownIt-Anchor" href="#vscode配置stm32编译调试环境"></a> <strong># <mark>VsCode配置STM32编译调试环境</mark></strong></h1><p><a href="https://www.bilibili.com/video/BV1BJeJehEkb/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7026df729530ac261e29b43864230918">【保姆】vscode配置单片机编译调试烧录环境（以STM32为例）_哔哩哔哩_bilibili</a></p><h1 id="一-adc采集系统"><a class="markdownIt-Anchor" href="#一-adc采集系统"></a> 一、ADC采集系统</h1><h2 id="1-adc通道外部电路"><a class="markdownIt-Anchor" href="#1-adc通道外部电路"></a> 1. ADC通道(外部电路)</h2><img src="/posts/26676/image-20241001005738016.png" class="" title="image-20241001005738016"><h2 id="2-功能要求"><a class="markdownIt-Anchor" href="#2-功能要求"></a> 2. 功能要求</h2><img src="/posts/26676/image-20241001005805205.png" class="" title="image-20241001005805205"><h2 id="3-动态窗口"><a class="markdownIt-Anchor" href="#3-动态窗口"></a> 3. <mark>动态窗口</mark></h2><img src="/posts/26676/image-20241001005817305.png" class="" title="image-20241001005817305"><p><strong>"动态"的含义：3秒的实时采集<mark>窗口</mark>随着时间自行移动，adc采集的值动态实时更新在3s的窗口数据内</strong></p><img src="/posts/26676/image-20241001010344145.png" class="" title="image-20241001010344145"><h1 id="二-功能实现"><a class="markdownIt-Anchor" href="#二-功能实现"></a> 二、功能实现</h1><h2 id="1-adc解算"><a class="markdownIt-Anchor" href="#1-adc解算"></a> 1. ADC解算</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//双通道DMA</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">adc_proc</span><span class="params">()</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) </span><br><span class="line">{</span><br><span class="line">adc_value[<span class="number">0</span>] += (<span class="type">float</span>)dma_buff[<span class="number">0</span>][i]; </span><br><span class="line">adc_value[<span class="number">1</span>] += (<span class="type">float</span>)dma_buff[<span class="number">1</span>][i];</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10进制模拟量电压</span></span><br><span class="line"><span class="comment">//adc_value[0] = adc_value[0] / 30 *3.3f / 4096; </span></span><br><span class="line"><span class="comment">//adc_value[1] = adc_value[1] / 30 *3.3f / 4096;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不对分辨率和参考电压进行解算</span></span><br><span class="line">    <span class="comment">//16进制数字量电压</span></span><br><span class="line">adc_value[<span class="number">0</span>] = adc_value[<span class="number">0</span>] / (<span class="number">30</span>+<span class="number">1</span>);</span><br><span class="line">adc_value[<span class="number">1</span>] = adc_value[<span class="number">1</span>] / (<span class="number">30</span>+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-lcd底层实现"><a class="markdownIt-Anchor" href="#2-lcd底层实现"></a> 2. LCD底层实现</h2><h3 id="21-变量定义"><a class="markdownIt-Anchor" href="#21-变量定义"></a> 2.1 <strong>变量定义</strong></h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> lcd_disp_mode;<span class="comment">//lcd显示模式</span></span><br><span class="line"><span class="type">uint16_t</span> ph_value;<span class="comment">//PH值</span></span><br><span class="line"><span class="type">uint16_t</span> pd_value;<span class="comment">//PD值</span></span><br></pre></td></tr></tbody></table></figure><p>参数界面</p><img src="/posts/26676/image-20240929225356591.png" class="" title="image-20240929225356591"><p>记录界面</p><img src="/posts/26676/image-20240929225307555.png" class="" title="image-20240929225307555"><h3 id="22-lcd进程"><a class="markdownIt-Anchor" href="#22-lcd进程"></a> 2.2 <strong>LCD进程</strong></h3><p>由于4T官方提供的LCD底层驱动，当显示的数据位数增加时，显示的位数会增加，但是当位数减小时，却不能对旧的数据进行清空。</p><p>所以这里用“空格”来覆盖刷新，达到位数减小显示缩减的效果。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span>(lcd_disp_mode){</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            LCD_Sprintf(Line1,<span class="string">"        DATA"</span>);</span><br><span class="line">            LCD_Sprintf(Line3,<span class="string">"   R37:%d    "</span>,(<span class="type">int</span>)adc_value[<span class="number">0</span>]);</span><br><span class="line">            LCD_Sprintf(Line4,<span class="string">"   R38:%d    "</span>,(<span class="type">int</span>)adc_value[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="lcd背光-问题"><a class="markdownIt-Anchor" href="#lcd背光-问题"></a> #<mark>LCD背光 问题</mark></h3><p><strong>现象：如图所示，只有在对LCD写入的片段，LCD才有正常的背景</strong></p><img src="/posts/26676/3ee14bc0dc0d49a3647ae193e51b544.jpg" class="" title="3ee14bc0dc0d49a3647ae193e51b544"><p><strong>原因：未对LCD进行初始化清屏</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">system_init();</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_Clear(Black);</span><br><span class="line">LCD_SetTextColor(White);</span><br><span class="line">LCD_SetBackColor(Black);</span><br><span class="line">scheduler_init();</span><br></pre></td></tr></tbody></table></figure><p><strong>来源：lcd.c</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_Clear</span></span><br><span class="line"><span class="comment">* Description    : Clears the hole LCD.</span></span><br><span class="line"><span class="comment">* Input          : Color: the color of the background.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Clear</span><span class="params">(u16 Color)</span></span><br><span class="line">{</span><br><span class="line">    u32 index = <span class="number">0</span>;</span><br><span class="line">    LCD_SetCursor(<span class="number">0x00</span>, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; <span class="number">76800</span>; index++)</span><br><span class="line">    {</span><br><span class="line">        LCD_WR_DATA(Color);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="23-led功能和初始化状态"><a class="markdownIt-Anchor" href="#23-led功能和初始化状态"></a> 2.3 LED功能和初始化状态</h3><img src="/posts/26676/image-20241001001209075.png" class="" title="image-20241001001209075"><h3 id="24-lcd底层完整代码实现"><a class="markdownIt-Anchor" href="#24-lcd底层完整代码实现"></a> 2.4 LCD底层完整代码实现</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"bsp_system.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> lcd_disp_mode;    <span class="comment">// lcd显示模式</span></span><br><span class="line"><span class="type">uint16_t</span> ph_value = <span class="number">2000</span>; <span class="comment">// PH值</span></span><br><span class="line"><span class="type">uint16_t</span> pd_value = <span class="number">1000</span>; <span class="comment">// PD值</span></span><br><span class="line"><span class="type">uint16_t</span> vh_value;        <span class="comment">// PH值</span></span><br><span class="line"><span class="type">uint16_t</span> vd_value;        <span class="comment">// PD值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  格式化字符串并显示在指定的LCD行上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数接受一个行号和一个格式化字符串（类似于printf），</span></span><br><span class="line"><span class="comment"> * 格式化字符串后，将其显示在LCD的指定行上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  Line    要显示字符串的LCD行号。</span></span><br><span class="line"><span class="comment"> * @param  format  格式化字符串，后跟要格式化的参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数内部使用 `vsprintf` 来格式化字符串，然后</span></span><br><span class="line"><span class="comment"> * 调用 `LCD_DisplayStringLine` 在LCD上显示格式化后的字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例用法:</span></span><br><span class="line"><span class="comment"> * @code</span></span><br><span class="line"><span class="comment"> * LcdSprintf(0, "Temperature: %d C", temperature);</span></span><br><span class="line"><span class="comment"> * @endcode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdSprintf</span><span class="params">(<span class="type">uint8_t</span> Line, <span class="type">char</span> *format, ...)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> String[<span class="number">21</span>];                     <span class="comment">// 缓冲区用于存储格式化后的字符串</span></span><br><span class="line">    va_list arg;                         <span class="comment">// 参数列表用于存储可变参数</span></span><br><span class="line">    va_start(arg, format);               <span class="comment">// 使用格式化字符串初始化参数列表</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(String, format, arg);       <span class="comment">// 格式化字符串并存储在缓冲区中</span></span><br><span class="line">    va_end(arg);                         <span class="comment">// 清理参数列表</span></span><br><span class="line">    LCD_DisplayStringLine(Line, String); <span class="comment">// 在LCD的指定行显示格式化后的字符串</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (lcd_disp_mode)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//测量界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        DATA"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   R37:%d    "</span>, (<span class="type">int</span>)adc_value[<span class="number">0</span>]);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   R38:%d    "</span>, (<span class="type">int</span>)adc_value[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//参数界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        PARA"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   PH:%d    "</span>, ph_value);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   PD:%d    "</span>, pd_value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//参数界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        RECD"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   VH:%d    "</span>, vh_value);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   VD:%d    "</span>, vd_value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-按键底层"><a class="markdownIt-Anchor" href="#3-按键底层"></a> 3. 按键底层</h2><p>uwTick：在Systick（系统滴答定时器）中断中自增，可以用作单片机运行的时间戳</p><p><a href="https://cloud.tencent.com/developer/article/1861964">HAL库与Cubemx系列|Systick-系统滴答定时器详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h3 id="31-按键处理进程"><a class="markdownIt-Anchor" href="#31-按键处理进程"></a> 3.1 按键处理进程</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> ph_pd_flag; <span class="comment">//参数修改切换标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键处理函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数用于扫描按键的状态，并更新按键按下和释放的标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// 读取当前按键状态</span></span><br><span class="line">key_val = key_read();</span><br><span class="line"><span class="comment">// 计算按下的按键（当前按下状态与前一状态异或，并与当前状态相与）</span></span><br><span class="line">key_down = key_val &amp; (key_old ^ key_val);</span><br><span class="line"><span class="comment">// 计算释放的按键（当前未按下状态与前一状态异或，并与前一状态相与）</span></span><br><span class="line">key_up = ~key_val &amp; (key_old ^ key_val);</span><br><span class="line"><span class="comment">// 更新前一按键状态</span></span><br><span class="line">key_old = key_val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key_down == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">ph_pd_flag ^= <span class="number">1</span>;<span class="comment">//参数选择标志位取反</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lcd_disp_mode == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">key_tick = uwTick; <span class="comment">//记录按键按下时的时间</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(key_up == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(lcd_disp_mode == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(uwTick - key_tick &gt; <span class="number">2000</span>)</span><br><span class="line">{</span><br><span class="line">key_tick = <span class="number">0</span>;<span class="comment">//清理按键时间戳</span></span><br><span class="line">vd_value = vh_value = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (key_down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span> (++lcd_disp_mode == <span class="number">3</span>)<span class="comment">//模式切换</span></span><br><span class="line">{</span><br><span class="line">lcd_disp_mode = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)<span class="comment">//参数切换界面s</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//创建一个指针，根据参数选择标志位切换指向</span></span><br><span class="line"><span class="comment">//这样，使用逻辑语句和一个指针变量就可以实现对两个参数的地址指向-&gt;数据内容更改</span></span><br><span class="line"><span class="type">uint16_t</span> *p = (ph_pd_flag) ? &amp;ph_value : &amp;pd_value;</span><br><span class="line">*p += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*p &gt; <span class="number">4096</span>)</span><br><span class="line">{</span><br><span class="line">*p = <span class="number">4096</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> *p = (ph_pd_flag) ? &amp;ph_value : &amp;pd_value;</span><br><span class="line">*p -= <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="number">65536</span> - <span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-adc采集"><a class="markdownIt-Anchor" href="#4-adc采集"></a> 4. adc采集</h2><h3 id="41-变量定义"><a class="markdownIt-Anchor" href="#41-变量定义"></a> 4.1 变量定义</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//DMA接收缓存</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];<span class="comment">//ADC采样数组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINDOWS_SIZE 3000 <span class="comment">//动态窗口的大小为3秒</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">adc_data_t</span> adc_buffer[BUFFER_SIZE];<span class="comment">//adc采集周期为100ms,动态窗口大小为3s</span></span><br><span class="line"><span class="type">int</span> buffer_start = <span class="number">0</span>;<span class="comment">//头指针</span></span><br><span class="line"><span class="type">int</span> buffer_end = <span class="number">0</span>;<span class="comment">//尾指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> vd_flag;<span class="comment">//标志位，表示当前窗口内是否检测到突变</span></span><br></pre></td></tr></tbody></table></figure><h3 id="42-添加数据到动态串口缓冲区"><a class="markdownIt-Anchor" href="#42-添加数据到动态串口缓冲区"></a> 4.2 添加数据到动态串口（缓冲区）</h3><p>本例中,ADC采样的环形缓冲区比较特殊，具备动态时间窗口的特性</p><ul><li>和一般的环形缓冲区一样，具备头指针和尾指针的概念，环形存取数据。</li><li>缓冲区具备“时间窗口”的概念，那么就要让缓冲区中最<mark>老</mark>的数据，存在时间不能超过三秒，超过则移除（实际上是写指针移位，相当于队这个无用的数据不再进行读取，环形缓冲区中读取数据，就相当于将这个数据移除缓存区，因为索引指针不会再指向这个数据。）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief添加adc采集数据，当前时间到adc缓冲区(环形)</span></span><br><span class="line"><span class="comment">  * @paramadc采集数据，当前时间，指定的buffer</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_adc_data</span><span class="params">(<span class="type">uint32_t</span> adc,<span class="type">uint32_t</span> current_time,<span class="type">adc_data_t</span> *buffer)</span></span><br><span class="line">{</span><br><span class="line">buffer[buffer_end].timestamp = current_time;<span class="comment">//记录当前时间到尾指针指向的缓冲区</span></span><br><span class="line">buffer[buffer_end].adc = adc;<span class="comment">//记录adc采集值到尾指针指向的缓冲区 </span></span><br><span class="line"></span><br><span class="line">buffer_end = (buffer_end + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//表示尾指针自加，0~30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer_end == buffer_start)<span class="comment">// 如果缓冲区满了，调整buffer_start，使得窗口始终保持在3秒内</span></span><br><span class="line">{</span><br><span class="line">buffer_start = (buffer_start + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//头指针移位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前时间是否超过窗口时间戳3秒，即操作时间超过3秒,// 移除超出3秒窗口的数据</span></span><br><span class="line"><span class="keyword">while</span>((current_time - buffer[buffer_start].timestamp &gt; WINDOWS_SIZE))</span><br><span class="line">{</span><br><span class="line">buffer_start = (buffer_start + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//头指针移位</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="43-检查缓冲区的突变"><a class="markdownIt-Anchor" href="#43-检查缓冲区的突变"></a> 4.3 检查缓冲区的突变</h3><p>对当前窗口进行极大值，极小值的检测。</p><p>注意区分极大值，极小值和最大值最小值的区别。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief检测当前窗口是否发生ADC突变</span></span><br><span class="line"><span class="comment">  * @param突变计数，adc缓冲区</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_adc_sudden_change</span><span class="params">(<span class="type">uint16_t</span> *sudden_change_count,<span class="type">adc_data_t</span> *buffer)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> f_max = buffer[buffer_start].adc;</span><br><span class="line"><span class="comment">// uint16_t f_min = buffer[buffer_end].adc;</span></span><br><span class="line"><span class="type">uint16_t</span> f_min = buffer[buffer_start].adc;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = buffer_start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(index != buffer_end)<span class="comment">//读取完整个环形缓冲区</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//极大值</span></span><br><span class="line"><span class="keyword">if</span>(buffer[index].adc &gt; f_max)</span><br><span class="line">{</span><br><span class="line">f_max = buffer[index].adc;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//极小值</span></span><br><span class="line"><span class="keyword">if</span>(buffer[index].adc &lt; f_min)</span><br><span class="line">{</span><br><span class="line">f_min = buffer[index].adc;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//指针加1</span></span><br><span class="line">index = (index + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> diff = f_max - f_min;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测ADC突变</span></span><br><span class="line"><span class="keyword">if</span>(diff &lt; pd_value)</span><br><span class="line">{</span><br><span class="line">vd_flag = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vd_flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">vd_flag = <span class="number">0</span>;</span><br><span class="line">(*sudden_change_count) ++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ucLed[<span class="number">2</span>] = (diff &gt; pd_value)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="44-adc解析进程"><a class="markdownIt-Anchor" href="#44-adc解析进程"></a> 4.4 ADC解析进程</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_proc</span><span class="params">()</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Time_tick = HAL_GetTick();<span class="comment">//获取当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> vh_flag;<span class="comment">//超限标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对adc1,adc2两个adc通道进行数据采集</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) </span><br><span class="line">{</span><br><span class="line">adc_value[<span class="number">0</span>] += (<span class="type">float</span>)dma_buff[<span class="number">0</span>][i]; <span class="comment">//采集30次</span></span><br><span class="line">adc_value[<span class="number">1</span>] += (<span class="type">float</span>)dma_buff[<span class="number">1</span>][i]; <span class="comment">//采集30次</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">adc_value[<span class="number">0</span>] = adc_value[<span class="number">0</span>] / (<span class="number">30</span> + <span class="number">1</span>); <span class="comment">//采集30后，但是累加值是(30+1)次，因为采集30次之前本身adc_value[0]就有值</span></span><br><span class="line">adc_value[<span class="number">1</span>] = adc_value[<span class="number">1</span>] / (<span class="number">30</span> + <span class="number">1</span>); <span class="comment">//否则会出现如采集到的ADC值大于4096的现象</span></span><br><span class="line"></span><br><span class="line">add_adc_data(adc_value[<span class="number">0</span>],Time_tick,adc_buffer);<span class="comment">//将adc采集值写入缓冲区</span></span><br><span class="line">check_adc_sudden_change(&amp;vd_value,adc_buffer);<span class="comment">//判断是否发生值突变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(adc_value[<span class="number">1</span>] &lt; ph_value) </span><br><span class="line">{</span><br><span class="line">vh_flag = <span class="number">0</span>; <span class="comment">//当adc_value小于参数时，标志位才会置0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vh_flag == <span class="number">0</span>) <span class="comment">// adc_value大于参数且标志位为0</span></span><br><span class="line">{</span><br><span class="line">vh_flag = <span class="number">1</span>;<span class="comment">//标志位置1</span></span><br><span class="line">vh_value++;<span class="comment">//超限次数加1</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-led底层"><a class="markdownIt-Anchor" href="#5-led底层"></a> 5. LED底层</h2><h2 id="51-led显示进程"><a class="markdownIt-Anchor" href="#51-led显示进程"></a> 5.1 LED显示进程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief LED 显示处理函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每次调用该函数时，LED 灯根据 ucLed 数组中的值来决定是开启还是关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 显示当前 Led_Pos 位置的 LED 灯状态</span></span><br><span class="line">    ucLed[<span class="number">0</span>] = (lcd_disp_mode == <span class="number">0</span>);<span class="comment">//当前界面为数据采集时LED1点亮 </span></span><br><span class="line">    ucLed[<span class="number">1</span>] = adc_value[<span class="number">1</span>] &gt; ph_value ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ucLed[2] = (adc_value[0] &gt; pd_value);//放入窗口突变判断中</span></span><br><span class="line">    </span><br><span class="line">    led_disp(ucLed);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-串口通信"><a class="markdownIt-Anchor" href="#6-串口通信"></a> 6. 串口通信</h2><h3 id="61-串口通信进程"><a class="markdownIt-Anchor" href="#61-串口通信进程"></a> 6.1 串口通信进程</h3><blockquote><p><strong><code>sscanf</code></strong>:</p><ul><li><code>sscanf</code> 是一个格式化输入函数，主要用于从字符串中提取数据。</li><li>它按照指定的格式读取输入字符串，并将解析后的数据存储到指定的变量中。</li><li>语法：<code>int sscanf(const char *str, const char *format, ...)</code></li></ul><p><strong><code>strcmp</code></strong>:</p><ul><li><code>strcmp</code> 是一个字符串比较函数，用于比较两个字符串是否相等。</li><li>它返回一个整数，表示两个字符串的字典顺序。</li><li>语法：<code>int strcmp(const char *str1, const char *str2)</code></li><li>返回值：<ul><li>小于 0：<code>str1</code> 小于 <code>str2</code></li><li>等于 0：<code>str1</code> 等于 <code>str2</code></li><li>大于 0：<code>str1</code> 大于 <code>str2</code></li></ul></li></ul><p>总结：</p><p>sscanf：将stream内容取出，并根据入口参数的格式化过滤内容，取出数据</p><p>strcmp：比较两个字符串的内容</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb)) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 从环形缓冲区读取数据到读取缓冲区 </span></span><br><span class="line">ringbuffer_read(&amp;usart_rb, usart_read_buffer, usart_rb.itemCount);</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> value;</span><br><span class="line"><span class="type">uint16_t</span> *p = <span class="literal">NULL</span>;<span class="comment">//创建一个空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析串口数据，如果匹配，那么将解释后的数据存入value中</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sscanf</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"$PD(%hu)"</span>,&amp;value) == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">        <span class="comment">// 指针指向pd_value</span></span><br><span class="line">p = &amp;pd_value;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sscanf</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"$PH(%hu)"</span>,&amp;value) == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">        <span class="comment">// 指针指向ph_value</span></span><br><span class="line">p = &amp;ph_value;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"#VH"</span>) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VH:%d\n"</span>,vh_value);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"#VD"</span>) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VD:%d\n"</span>,vd_value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数范围是否合法</span></span><br><span class="line"><span class="keyword">if</span>(value &lt; <span class="number">4096</span>)</span><br><span class="line">{</span><br><span class="line">        <span class="comment">// 通过指针解引用修改数据</span></span><br><span class="line">*p = value; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(usart_read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * BUUFER_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vscode配置stm32编译调试环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vscode配置stm32编译调试环境&quot;&gt;&lt;/a&gt; &lt;strong&gt;# &lt;mark&gt;VsCode配置STM32编译调试环境&lt;/mark&gt;&lt;/stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[RM电控][1]开发板的使用与CAN总线控制3508电机</title>
    <link href="https://szturin.github.io/posts/31666/"/>
    <id>https://szturin.github.io/posts/31666/</id>
    <published>2024-09-18T15:03:22.000Z</published>
    <updated>2024-10-29T08:06:07.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-a板介绍"><a class="markdownIt-Anchor" href="#一-a板介绍"></a> 一、A板介绍*</h1><ul><li>A板外部晶振为12MHZ，最高主频为168MHZ</li></ul><h1 id="二-can总线通信原理"><a class="markdownIt-Anchor" href="#二-can总线通信原理"></a> 二、CAN总线通信原理</h1><h2 id="1-can总线是什么"><a class="markdownIt-Anchor" href="#1-can总线是什么"></a> 1. CAN总线是什么</h2><h3 id="11-can总线简介"><a class="markdownIt-Anchor" href="#11-can总线简介"></a> 1.1 CAN总线简介</h3><p>​CAN 是 Controller Area Network 的缩写，最初是汽车行业为了减少车身上的线束，而且还能进行大量数据的高速通信，由德国电气商博世公司在1986 年开发出的面向汽车的通信协议。现在，CAN 的高性能和可靠性已被认同，并被广泛地应用于工业自动化、船舶、医疗设备、工业设备等方面。RM的电机（3508、2006、6020）的控制也采用了CAN协议进行通信。<br>CAN 总线由 CAN_H 和 CAN_L 一对差分线构成，各个设备一起挂载在总线上。</p><p>参考文章：<a href="https://blog.csdn.net/weixin_54448108/article/details/125881138">【RoboMaster】从零开始控制RM电机（2）-CAN通信原理及电调通信协议_can通讯 同步触发控制电机-CSDN博客</a></p><h3 id="12-can通信的特点"><a class="markdownIt-Anchor" href="#12-can通信的特点"></a> 1.2 CAN通信的特点</h3><p><strong>1) 多主控制</strong><br>多个单元同时开始发送时，发送高优先级 ID 消息的单元可获得发送权。</p><p><strong>2) 消息的发送</strong></p><p>所有的消息由固定格式发送，标识符（Identifier 以下称为 ID）决定优先级。</p><p><strong>3) 通信速度</strong></p><p>同一CAN总线网络，所有单元必须同一通信速率。</p><h2 id="2-can通信协议"><a class="markdownIt-Anchor" href="#2-can通信协议"></a> 2. CAN通信协议</h2><h3 id="21-帧的种类"><a class="markdownIt-Anchor" href="#21-帧的种类"></a> 2.1 帧的种类</h3><p>CAN通信由五种帧类型</p><img src="/posts/31666/88d8d711fa24f37edff930d2be7b5e5d.png" class="" title="在这里插入图片描述"><p>其中数据帧和遥控帧有标准格式和扩展格式两种格式。</p><p>标准格式有 11 个位的标识符（Identifier: 以下称 ID），扩展格式有 29 个位的 ID。</p><p>控制RM电机使用标准帧。</p><h3 id="22-数据帧"><a class="markdownIt-Anchor" href="#22-数据帧"></a> 2.2 数据帧</h3><p>CAN总线数据帧的帧结构：</p><p>主要处理</p><img src="/posts/31666/7cec510a164a96bf6d346eee189c9cee.png" class="" title="在这里插入图片描述"><ol><li>帧起始<br>表示数据帧开始的段。</li><li>仲裁场<br>表示该帧优先级的段。</li><li>控制场<br>表示数据的字节数及保留位的段。</li><li>数据场<br>数据的内容，可发送 0～8 个字节的数据。</li><li>CRC 场<br>检查帧的传输错误的段。</li><li>应答场<br>表示确认正常接收的段。</li><li>帧结尾<br>表示数据帧结束的段。</li></ol><h5 id="1仲裁场"><a class="markdownIt-Anchor" href="#1仲裁场"></a> (1)仲裁场</h5><p>CAN 的 ID 分为标准 ID 和 拓展 ID 两类，每个设备都有自己独有的ID，CAN通信通过仲裁ID决定优先级。</p><h5 id="2控制场"><a class="markdownIt-Anchor" href="#2控制场"></a> (2)控制场</h5><p>控制场由 6 个位构成，表示数据段的字节数，C620电调的数据段长度为8</p><img src="/posts/31666/b63bd68d7d77e03f2e2bfed4439523e7.png" class="" title="在这里插入图片描述"><h5 id="3数据场"><a class="markdownIt-Anchor" href="#3数据场"></a> (3)数据场</h5><p>如果控制场的DLC表示为DRRR，CAN 总线的一个数据帧中所需要传输的有效数据实际上就是这 8Byte。这8字节的排列顺序为从高到低。</p><img src="/posts/31666/0519eb8c409db49546fc1b6b25fcd174.png" class="" title="在这里插入图片描述"><h1 id="三-电调通信"><a class="markdownIt-Anchor" href="#三-电调通信"></a> 三、电调通信</h1><h2 id="1-m3508m2006电机"><a class="markdownIt-Anchor" href="#1-m3508m2006电机"></a> 1. M3508&amp;M2006电机</h2><p>这两种电机代码通用</p><ul><li>M3508使用C620电调</li><li>M2006使用C610电调</li></ul><h3 id="11-单片机-数据帧-电调"><a class="markdownIt-Anchor" href="#11-单片机-数据帧-电调"></a> 1.1 单片机-&gt;数据帧-&gt;电调</h3><p>单片机向电调发送控制指令控制电调的<mark>电流输出</mark>。</p><p>一个数据帧只能给四个电机发送数据，</p><p>控制前四个电机时将ID设为 0x200</p><p>控制后四个电机时将ID设为 0x1FF</p><img src="/posts/31666/1af85c7b717809c098b68813f8100bb1.png" class="" title="img"><h3 id="12-电调-数据帧-单片机"><a class="markdownIt-Anchor" href="#12-电调-数据帧-单片机"></a> 1.2 电调-&gt;数据帧-&gt;单片机</h3><p>为了实现闭环控制，单片机需要接收电调的反馈报文得到电机的转速、机械转子角度、实时电流数据。</p><p>根据接收到的<mark>ID</mark>判断是哪一个电调的数据，电调反馈报文ID规定为 0x200+电调ID(1-8),如0x201(电调ID为1)。</p><img src="/posts/31666/89de834dbe0df93d0de87c331cc4970f.png" class="" title="在这里插入图片描述"><h2 id="2-gm6020电机"><a class="markdownIt-Anchor" href="#2-gm6020电机"></a> 2. GM6020电机</h2><h3 id="21-发送"><a class="markdownIt-Anchor" href="#21-发送"></a> 2.1 发送</h3><img src="/posts/31666/f5cec08ec56db6f2c90f9cd3b1b886b5.png" class="" title="在这里插入图片描述"><h3 id="22-接收"><a class="markdownIt-Anchor" href="#22-接收"></a> 2.2 接收</h3><img src="/posts/31666/d8dde436c117927177cdeeb6b356c8a7.png" class="" title="在这里插入图片描述"><h2 id="3-cubemx配置can总线协议"><a class="markdownIt-Anchor" href="#3-cubemx配置can总线协议"></a> 3. CubeMX配置CAN总线协议</h2><ul><li>波特率要设置成1M</li></ul><h2 id="4-程序实现"><a class="markdownIt-Anchor" href="#4-程序实现"></a> 4. 程序实现</h2><h3 id="41-can数据帧发送"><a class="markdownIt-Anchor" href="#41-can数据帧发送"></a> 4.1 CAN数据帧发送</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置并发送电机控制命令</span></span><br><span class="line"><span class="comment"> * @param hcan CAN句柄</span></span><br><span class="line"><span class="comment"> * @param STDID 标准ID</span></span><br><span class="line"><span class="comment"> * @param motor1 电机1控制值</span></span><br><span class="line"><span class="comment"> * @param motor2 电机2控制值</span></span><br><span class="line"><span class="comment"> * @param motor3 电机3控制值</span></span><br><span class="line"><span class="comment"> * @param motor4 电机4控制值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_motor_cmd</span><span class="params">(CAN_HandleTypeDef *hcan, <span class="type">uint32_t</span> STDID,</span></span><br><span class="line"><span class="params">                   <span class="type">int16_t</span> motor1, <span class="type">int16_t</span> motor2, <span class="type">int16_t</span> motor3, <span class="type">int16_t</span> motor4)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> send_mail_box;  <span class="comment">// 定义一个变量用于存储发送邮箱编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置发送消息的标识符</span></span><br><span class="line">    CANx_tx_message.StdId = STDID;</span><br><span class="line">    CANx_tx_message.IDE = CAN_ID_STD;  <span class="comment">// 标识符选择位，STD-标准帧</span></span><br><span class="line">    CANx_tx_message.RTR = CAN_RTR_DATA;  <span class="comment">// 定义帧类型</span></span><br><span class="line">    CANx_tx_message.DLC = <span class="number">0x08</span>;  <span class="comment">// 数据帧长度为8位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充要发送的数据</span></span><br><span class="line">    CANx_send_data[<span class="number">0</span>] = motor1 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">1</span>] = motor1;</span><br><span class="line">    CANx_send_data[<span class="number">2</span>] = motor2 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">3</span>] = motor2;</span><br><span class="line">    CANx_send_data[<span class="number">4</span>] = motor3 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">5</span>] = motor3;</span><br><span class="line">    CANx_send_data[<span class="number">6</span>] = motor4 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">7</span>] = motor4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送CAN数据</span></span><br><span class="line">    HAL_CAN_AddTxMessage(hcan, &amp;CANx_tx_message, CANx_send_data, &amp;send_mail_box);  <span class="comment">// hal库CAN发送函数：该函数用于向发送邮箱添加发送报文，并激活发送请求</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="42-can数据帧接收"><a class="markdownIt-Anchor" href="#42-can数据帧接收"></a> 4.2 CAN数据帧接收</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief CAN接收回调函数</span></span><br><span class="line"><span class="comment"> *        处理CAN接收到的数据帧</span></span><br><span class="line"><span class="comment"> * @param hcan CAN句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_CAN_RxFifo0MsgPendingCallback</span><span class="params">(CAN_HandleTypeDef *hcan)</span></span><br><span class="line">{</span><br><span class="line">    CAN_RxHeaderTypeDef RX_Header;  <span class="comment">// 定义数据帧的帧头</span></span><br><span class="line">    <span class="type">uint8_t</span> RX_BUFFER[<span class="number">8</span>];           <span class="comment">// 接收存放数据帧数据的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取CAN接收到的数据帧并存入局部变量</span></span><br><span class="line">    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &amp;RX_Header, RX_BUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断接收的是CAN1还是CAN2</span></span><br><span class="line">    <span class="keyword">if</span> (hcan == &amp;hcan1) {</span><br><span class="line">        <span class="comment">// CAN1：通过反馈数据的ID确定这一组数据存放的地址</span></span><br><span class="line">        i = RX_Header.StdId - Chassis_3508A;</span><br><span class="line">        Motor_measure_fun(&amp;Motor_measure[i], RX_BUFFER);  <span class="comment">// 调用函数把数据存入结构体数组</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (hcan == &amp;hcan2) {</span><br><span class="line">        <span class="comment">// CAN2：通过反馈数据的ID确定这一组数据存放的地址</span></span><br><span class="line">        i = RX_Header.StdId - CAN2_3508_ID1 + <span class="number">7</span>;</span><br><span class="line">        Motor_measure_fun(&amp;Motor_measure[i], RX_BUFFER);  <span class="comment">// 调用函数把数据存入结构体数组</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-a板介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-a板介绍&quot;&gt;&lt;/a&gt; 一、A板介绍*&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;A板外部晶振为12MHZ，最高主频为168MHZ&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;二-can总线通信</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][3]UART、DMA、ADC</title>
    <link href="https://szturin.github.io/posts/24028/"/>
    <id>https://szturin.github.io/posts/24028/</id>
    <published>2024-09-15T13:56:13.000Z</published>
    <updated>2024-10-29T08:05:51.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-串口中断超时解析"><a class="markdownIt-Anchor" href="#一-串口中断超时解析"></a> 一、串口中断+超时解析</h1><h2 id="1-cubemx配置"><a class="markdownIt-Anchor" href="#1-cubemx配置"></a> 1. CubeMX配置</h2><h2 id="11-属性配置"><a class="markdownIt-Anchor" href="#11-属性配置"></a> 1.1 <strong>属性配置</strong></h2><p>主要配置波特率，其余默认</p><style>.sogchoxtwkcg{}</style><img src="/posts/24028/image-20240919224239733.png" class="sogchoxtwkcg" alt="image-20240919224239733"><p><strong>中断配置</strong></p><p>Preemption Priority：抢占优先级</p><p>Sub Priority: 子优先级</p><img src="/posts/24028/image-20240919224306805.png" class="" title="image-20240919224306805"><p><strong>串口的DMA设置</strong></p><p>只开接收DMA即可</p><p>DMA的模式：</p><ul><li>Normol</li><li>Circual</li></ul><img src="/posts/24028/image-20240919224441445.png" class="" title="image-20240919224441445"><img src="/posts/24028/image-20240919224501610.png" class="" title="image-20240919224501610"><h2 id="2-驱动程序编写"><a class="markdownIt-Anchor" href="#2-驱动程序编写"></a> 2. 驱动程序编写</h2><h3 id="21-串口重定向"><a class="markdownIt-Anchor" href="#21-串口重定向"></a> 2.1 串口重定向</h3><p><strong>在uasrt.c中进行修改</strong></p><img src="/posts/24028/image-20240919225413251.png" class="" title="image-20240919225413251"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE * str)</span></span><br><span class="line">{</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,(<span class="type">uint8_t</span> *)&amp;ch,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="22-app_uartc-变量定义"><a class="markdownIt-Anchor" href="#22-app_uartc-变量定义"></a> 2.2 <strong>app_uart.c 变量定义</strong></h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> uart_rx_index = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> uart_tx_ticks = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br></pre></td></tr></tbody></table></figure><h3 id="23-中断初始化"><a class="markdownIt-Anchor" href="#23-中断初始化"></a> 2.3 <strong>中断初始化</strong></h3><p>放入Core-&gt;Src-&gt;usart.c中</p><p>在初始化中使能串口中断，往buffer中每次填充一个字节，触发中断回调</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart1,uart_rx_buffer,<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><img src="/posts/24028/image-20240920223856904.png" class="" title="image-20240920223856904"><blockquote><p><mark>Hal库——中断回调函数</mark></p><p>在 STM32 的 HAL（硬件抽象层）库中，<strong>中断回调函数</strong>用于处理各种外设的中断事件。这些回调函数由 HAL 库提供，用户只需实现这些函数以响应特定的中断。</p><h3 id="1-一般函数-vs-回调函数"><a class="markdownIt-Anchor" href="#1-一般函数-vs-回调函数"></a> 1. <strong>一般函数 vs. 回调函数</strong></h3><ul><li><p><strong>逻辑限定普通函数的调用</strong>：</p><ul><li>逻辑条件通常在调用函数之前进行检查，确保在满足特定条件时再执行该函数。</li><li>这种方式在函数内部或外部使用条件语句（如 <code>if</code>）来控制函数的执行。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">normalFunction</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (condition) {  <span class="comment">// 条件检查</span></span><br><span class="line">        normalFunction();  <span class="comment">// 仅在条件满足时调用</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>回调函数</strong>：</p><ul><li>回调函数通过传递函数指针来实现灵活的调用，调用发生在某个事件或特定条件下。</li><li>这种机制允许外部函数（如事件处理或异步操作）在需要时调用传递的回调，而不需要直接控制逻辑。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callbackFunction</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line">        </span><br><span class="line"><span class="type">void</span> <span class="title function_">eventHandler</span><span class="params">(<span class="type">void</span> (*callback)())</span> {</span><br><span class="line">    <span class="comment">// 某个事件发生后调用回调</span></span><br><span class="line">    callback();  <span class="comment">// 不需要在这里检查条件</span></span><br><span class="line">}</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    eventHandler(callbackFunction);  <span class="comment">// 传递回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="2-中断函数-vs-回调函数"><a class="markdownIt-Anchor" href="#2-中断函数-vs-回调函数"></a> 2. <strong>中断函数 vs. 回调函数</strong></h3><ul><li><strong>中断函数</strong>：<ul><li>直接处理外设中断的代码，通常是在中断服务例程 (ISR) 中实现。</li><li>代码较为复杂，涉及中断向量、优先级、屏蔽等设置。</li><li>可能会引入较长的中断处理时间，不适合执行复杂的任务。</li></ul></li><li><strong>回调函数</strong>：<ul><li>是一个更高层次的抽象，允许用户在中断发生时执行特定的处理逻辑。</li><li>HAL 库提供的回调函数允许用户定义中断后要执行的操作，而不需要直接修改中断服务例程。</li><li>更易于维护和调试，因为用户只需关注回调函数的逻辑，而不需要管理中断相关的低层实现。</li></ul></li></ul></blockquote><h3 id="24-回调函数声明"><a class="markdownIt-Anchor" href="#24-回调函数声明"></a> 2.4 回调函数声明</h3><p><strong>弱定义</strong></p><img src="/posts/24028/image-20240915220013260.png" class="" title="image-20240915220013260"><img src="/posts/24028/image-20240920223951975.png" class="" title="image-20240920223951975"><p><strong>自定义回调函数</strong></p><p>可以自行声明与弱定义回调函数同名的函数，会优先执行自定义的函数</p><p>Hal库中各种弱定义都是用__weak修饰的</p><img src="/posts/24028/image-20240915220050996.png" class="" title="image-20240915220050996"><p>过程：串口接收-&gt;触发回调-&gt;进入回调函数</p><p>PS: void HAL_UART_RxCpliCallback(UART_HandleTypeDef *huart) 不要用成 void HAL_UART_TxCpliCallback(UART_HandleTypeDef *huart)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(huart-&gt;Instance == USART1)</span><br><span class="line">    {</span><br><span class="line">        uart_rx_ticks = uwTick;</span><br><span class="line">        uart_rx_index++;<span class="comment">//索引自增</span></span><br><span class="line">        <span class="comment">//每次触发回调，都要重新初始化接收中断，定义接收的位置</span></span><br><span class="line">        HAL_UART_Receive_IT(&amp;huart1,&amp;uart_r_buffer[uart_rx_index],<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="25-串口解析"><a class="markdownIt-Anchor" href="#25-串口解析"></a> 2.5 串口解析</h3><p><strong>超时解析</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(uart_rx_index == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(uwTick - uart_rx_ticks &gt; <span class="number">100</span>)<span class="comment">//时间超过100</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"uart data:%s\n"</span>,uart_rx_buffer);<span class="comment">//发送串口接收内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span> (uart_rx_buffer,<span class="number">0</span>,uart_rx_index);<span class="comment">//清空</span></span><br><span class="line">        uart_rx_index = <span class="number">0</span>;<span class="comment">//指针指令</span></span><br><span class="line">        huart1.pRxBuffPtr = uart_rx_buffer;<span class="comment">//uart1缓存区指针指向buffer</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="无dma和环形缓冲区的问题"><a class="markdownIt-Anchor" href="#无dma和环形缓冲区的问题"></a> <strong># <mark>无DMA和环形缓冲区的问题</mark></strong></h2><blockquote><p><strong>当串口接收速率过快时，如视觉上位机频繁向单片机发送识别到的坐标数据，可能会导致单片机程序阻塞</strong></p><p><mark><strong>1. 串口阻塞的解决方案</strong></mark></p><img src="/posts/24028/image-20240919233036903.png" class="" title="image-20240919233036903"><p>DMA:数据转运</p><p>RingBuffer:环形缓存区</p><p><mark><strong>2. # 环形缓冲区的概念：</strong></mark></p><ul><li>头指针</li><li>尾指针</li></ul></blockquote><h2 id="现象"><a class="markdownIt-Anchor" href="#现象"></a> # 现象：</h2><h3 id="1-串口无解析发送上位机"><a class="markdownIt-Anchor" href="#1-串口无解析发送上位机"></a> 1. 串口无解析发送上位机</h3><p>CubeMX未定义串口引脚，未注意STM32外设引脚可复用问题</p><img src="/posts/24028/image-20240920234311280.png" class="" title="image-20240920234311280"><h3 id="2-回调函数名称错误"><a class="markdownIt-Anchor" href="#2-回调函数名称错误"></a> 2. 回调函数名称错误</h3><img src="/posts/24028/image-20240920231957317.png" class="" title="image-20240920231957317"><h1 id="二-dma空闲中断"><a class="markdownIt-Anchor" href="#二-dma空闲中断"></a> 二、DMA+空闲中断</h1><h2 id="dma的作用"><a class="markdownIt-Anchor" href="#dma的作用"></a> # DMA的作用</h2><blockquote><p>无DMA：数据-&gt;Uart寄存器-&gt;CPU访问Uart寄存器-&gt;执行其他程序部分</p><p>​-------如果串口通信速率过快------&gt;CPU频繁访问Uart寄存器--------&gt;程序阻塞</p><p>有DMA：数据-&gt;Uart-&gt;DMA访问Uart数据-&gt;存放到单片机内存地址</p><p>​CPU与DMA并行工作</p></blockquote><p>在上述配置的基础上对程序文件进行进一步修改。</p><h2 id="空闲中断"><a class="markdownIt-Anchor" href="#空闲中断"></a> # 空闲中断</h2><blockquote><h3 id="1-什么是空闲中断"><a class="markdownIt-Anchor" href="#1-什么是空闲中断"></a> 1. 什么是空闲中断？</h3><p>空闲中断（Idle Line Interrupt）是串口通信（UART）中常用的一种硬件中断机制。它用于检测串口接收线路在一段时间内没有接收到数据时触发。<strong>空闲中断的核心原理是检测 UART 外设的接收线路在数据传输结束后变为“空闲”状态</strong>（即，停止接收数据，线路上没有任何活动）。</p><p>当串口在接收数据时，硬件会自动维护一个“忙状态”标志。所有数据帧（包括起始位、数据位和停止位）都被接收完成后，接收线路进入空闲状态，此时 UART 硬件会触发“空闲中断”。这个中断标志仅在接收数据后首次空闲时触发，而不是每次线路空闲都会触发。因此，空闲中断能够用于判断数据帧的结束或检测数据包的传输完成。(比如，一个数据帧的长度为8个字节，在串口通信时每帧间隔一个字节来发送，在间隔的这个字节，触发空闲中断，进而可以在中断程序中处理数据帧)</p><h3 id="2-空闲中断在串口通信中的作用"><a class="markdownIt-Anchor" href="#2-空闲中断在串口通信中的作用"></a> 2. 空闲中断在串口通信中的作用</h3><p>空闲中断主要用于处理非固定长度的串口数据帧和高效的 DMA（Direct Memory Access，直接内存访问）数据传输。其作用和优势如下：</p><h4 id="21-非固定长度数据包接收"><a class="markdownIt-Anchor" href="#21-非固定长度数据包接收"></a> 2.1 <strong>非固定长度数据包接收</strong></h4><ul><li>当接收的数据是非固定长度时，很难在接收时预先设定要接收的数据长度。这时，可以利用空闲中断判断数据的结束。</li><li>当串口在 DMA 模式下接收数据时，无法使用常规的中断方式逐字节进行处理。使用空闲中断可以更高效地处理数据流，从而判断整个数据包的接收是否完成。</li></ul><h4 id="22-提高串口通信的效率"><a class="markdownIt-Anchor" href="#22-提高串口通信的效率"></a> 2.2 <strong>提高串口通信的效率</strong></h4><ul><li>使用空闲中断能够在 DMA 模式下提高串口通信的效率。当 DMA 缓冲区被填满或者数据接收超时时，空闲中断可以用于自动触发数据处理，避免了使用传统的定时器轮询方式。</li><li>通过判断空闲中断触发时间，可以精确判断数据包的传输完成，不必每次都等待接收缓冲区被填满才进行处理，从而提高系统响应速度。</li></ul><h4 id="23-降低-cpu-占用"><a class="markdownIt-Anchor" href="#23-降低-cpu-占用"></a> 2.3 <strong>降低 CPU 占用</strong></h4><ul><li>使用空闲中断配合 DMA 接收，可以降低 CPU 的使用率。在 DMA 接收过程中，数据自动从串口移入缓冲区，不需要 CPU 的参与，只有在接收结束或空闲中断触发时才进行数据处理。</li><li>对于接收频繁但数量不定的数据流（如传感器数据、通信协议数据包），使用空闲中断能极大地减少 CPU 的负担。</li></ul><h3 id="3-空闲中断在串口通信中的典型应用场景"><a class="markdownIt-Anchor" href="#3-空闲中断在串口通信中的典型应用场景"></a> 3. 空闲中断在串口通信中的典型应用场景</h3><h4 id="31-接收数据包的完整性判断"><a class="markdownIt-Anchor" href="#31-接收数据包的完整性判断"></a> 3.1 <strong>接收数据包的完整性判断</strong></h4><p>对于 UART 接收非固定长度的数据包（如 Modbus、串口通信协议），可以使用空闲中断来判断数据帧的结束。</p><p><strong>典型场景：</strong><br>假设通过 UART 接收的数据包长度不定，当接收到一个完整的数据帧时，串口线路会进入空闲状态，此时触发空闲中断，可以认为本次数据接收结束。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c复制代码// 空闲中断回调函数示例</span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {</span><br><span class="line">    if (__HAL_UART_GET_FLAG(huart, UART_FLAG_</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="1-变量声明"><a class="markdownIt-Anchor" href="#1-变量声明"></a> 1. 变量声明</h2><p><strong>声明 uart_rx_dma_buffer变量，用于数据转运</strong></p><img src="/posts/24028/image-20240919233721950.png" class="" title="image-20240919233721950"><h2 id="2-中断初始化"><a class="markdownIt-Anchor" href="#2-中断初始化"></a> 2. <strong>中断初始化</strong></h2><p>启用DMA相关中断</p><p>关闭DMA<mark>半中断</mark></p><img src="/posts/24028/image-20240919233901381.png" class="" title="image-20240919233901381"><p><strong>PS: 不再适用串口回调，改用DMA的方法</strong></p><img src="/posts/24028/image-20240919234047785.png" class="" title="image-20240919234047785"><h2 id="3-串口中断函数"><a class="markdownIt-Anchor" href="#3-串口中断函数"></a> 3. <strong>串口中断函数</strong></h2><p>每次触发串口中断，触发DMA中断</p><img src="/posts/24028/image-20240920200100912.png" class="" title="image-20240920200100912"><p><strong>取消使用串口中断回调函数</strong></p><img src="/posts/24028/image-20240920200332492.png" class="" title="image-20240920200332492"><p><strong>改用空闲中断回调函数</strong></p><p>PS: 不再需要串口超时解析</p><img src="/posts/24028/image-20240920200417955.png" class="" title="image-20240920200417955"><img src="/posts/24028/image-20240920200913934.png" class="" title="image-20240920200913934"><h2 id="现象-2"><a class="markdownIt-Anchor" href="#现象-2"></a> # 现象：</h2><img src="/posts/24028/image-20240921001109060.png" class="" title="image-20240921001109060"><h2 id="补充中断函数与回调函数的区别"><a class="markdownIt-Anchor" href="#补充中断函数与回调函数的区别"></a> # <mark>补充——中断函数与回调函数的区别</mark></h2><blockquote><p>在嵌入式编程中，HAL（硬件抽象层）库的中断函数和回调函数是常见的机制，尤其是在处理外设操作时。这两者的作用有时容易混淆，但它们的概念和使用场景有所不同。下面详细解释它们的区别：</p><h3 id="1-中断函数interrupt-service-routine-isr"><a class="markdownIt-Anchor" href="#1-中断函数interrupt-service-routine-isr"></a> 1. 中断函数（Interrupt Service Routine, ISR）</h3><p>中断函数是一段处理硬件中断的代码。当外设或处理器触发中断时，处理器会暂停当前的代码执行，转而执行与该中断对应的ISR。一旦中断被处理完毕，程序会恢复到原来的执行状态。</p><ul><li><strong>执行方式</strong>：硬件触发，直接由处理器执行，通常是高优先级。</li><li><strong>响应时间</strong>：要求短小精悍，不能执行耗时的任务，因为会阻塞其他中断。</li><li><strong>位置</strong>：ISR通常定义在HAL库或用户代码中，是一个固定的函数（如<code>TIM_IRQHandler</code>等）。</li><li><strong>调用方式</strong>：自动触发，由硬件中断控制器（NVIC）决定何时调用中断处理函数。</li></ul><h3 id="2-回调函数callback-function"><a class="markdownIt-Anchor" href="#2-回调函数callback-function"></a> 2. 回调函数（Callback Function）</h3><p>回调函数是一个函数指针，通过预先注册到某个模块或API中，等到某个事件发生时，由该模块或API负责调用。HAL库中的回调函数通常是在中断处理完毕后，由ISR或HAL库内部调用，用来进一步处理用户逻辑。</p><ul><li><strong>执行方式</strong>：由程序代码（比如ISR或定时器事件）调用，响应某个事件。</li><li><strong>响应时间</strong>：回调函数不要求像中断处理函数那样必须快速完成，往往用于处理稍复杂的业务逻辑。</li><li><strong>位置</strong>：回调函数通常由用户实现，并由HAL库的中断处理函数或其他机制调用（如<code>HAL_TIM_PeriodElapsedCallback</code>）。</li><li><strong>调用方式</strong>：回调函数不是直接由硬件触发，而是由软件触发，即当中断函数处理完硬件中断后，再调用用户注册的回调函数。</li></ul><h3 id="简单总结区别"><a class="markdownIt-Anchor" href="#简单总结区别"></a> 简单总结区别：</h3><ul><li><strong>触发机制</strong>：中断函数是由硬件事件（如定时器溢出、外部信号等）直接触发，而回调函数是由软件（如ISR）触发。</li><li><strong>职责范围</strong>：中断函数负责处理硬件中断，通常需要快速执行；回调函数则处理用户定义的业务逻辑，通常可以有更多的处理空间和时间。</li><li><strong>优先级</strong>：中断函数的优先级较高，回调函数的执行时间不受硬件中断控制，通常在中断函数结束之后才执行。</li></ul><h3 id="典型应用场景"><a class="markdownIt-Anchor" href="#典型应用场景"></a> 典型应用场景</h3><p>以定时器为例：</p><ul><li>当定时器溢出时，触发一个中断，执行定时器的中断函数<code>TIM_IRQHandler</code>。</li><li>在中断函数内部，可能会调用HAL库的定时器回调函数<code>HAL_TIM_PeriodElapsedCallback</code>，用于用户自定义的定时器周期性任务处理。</li></ul><p>这就是中断函数和回调函数的核心区别。</p></blockquote><h1 id="三-环形缓冲区"><a class="markdownIt-Anchor" href="#三-环形缓冲区"></a> 三、环形缓冲区</h1><h2 id="环形缓冲区的简介"><a class="markdownIt-Anchor" href="#环形缓冲区的简介"></a> # 环形缓冲区的简介</h2><blockquote><p>环形缓存区，也叫环形缓冲区（Ring Buffer）或循环缓冲区，是一种数据结构。它的特点 是缓存区的头和尾是连接在一起的，形成一个环。当数据写入缓冲区时，指针会不断前进，当到达缓冲区的末尾时，会重新回到开头，这样就实现了一个循环。</p><p><strong>环形缓冲区的组成</strong>：</p><ul><li>缓冲区数组：存放数据</li><li>头指针（读指针）</li><li>尾指针（写指针）</li></ul><p>环形缓冲区满足“先进先出的原则”</p><p><strong>环形缓冲区的优势</strong>：</p><ul><li>在普通串口接收中，数据是线性接收的，通常是通过中断或者轮询的方式处理数据。</li><li>而环形缓冲区适用于需要持续接收和处理数据的应用，如串口通信</li><li>环形缓冲区效率和可靠性高，但是需要复杂的管理逻辑</li></ul><p><strong>环形缓冲区的原理及实现</strong>：</p><p><a href="https://blog.csdn.net/2401_86353562/article/details/141830232">环形缓冲区(ring buffer)原理与实现详解-CSDN博客</a></p><img src="/posts/24028/9af5be294e82d063ae8d1eb1d642ed7a.png" class="" title="img"><p><strong>简单代码实现：</strong></p><p>缓冲区结构体定义</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFFER_SIZE (30) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">uint32_t</span> w;</span><br><span class="line">    <span class="type">uint32_t</span> r;</span><br><span class="line">    <span class="type">uint8_t</span> buffer[RINGBUFFER_SIZE];</span><br><span class="line">    <span class="type">uint32_t</span> itemCount;</span><br><span class="line">}<span class="type">ringbuffer_t</span>;</span><br></pre></td></tr></tbody></table></figure><p>初始化环形缓冲区</p><p>置零环形缓冲区中的元素</p><p>这里用到<code>memset</code>函数</p><ul><li>解释：复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</li><li>作用：是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法</li><li>头文件：C中<code>#include&lt;string.h&gt;</code>，C++中<code>#include&lt;cstring&gt;</code></li></ul><p>这里指向的是环形缓冲区内容buffer，为uint8_t类型的数组变量，数组大小为<code>RINGBUFFER_SIZE</code>，使用这段语句将buffer中的内存块内容置零。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ringbuffer_init</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 设置读指针和写指针初始值为0</span></span><br><span class="line">    rb-&gt;r = <span class="number">0</span>;</span><br><span class="line">    rb-&gt;w = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将缓冲区内存清零</span></span><br><span class="line">    <span class="built_in">memset</span>(rb-&gt;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * RINGBUFFER_SIZE);</span><br><span class="line">    <span class="comment">// 初始化项目计数为0</span></span><br><span class="line">    rb-&gt;itemCount = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>检查缓冲区是否已满</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查环形缓冲区是否已满</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">ringbuffer_is_full</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果项目计数等于缓冲区大小，返回1（已满），否则返回0（未满）</span></span><br><span class="line">    <span class="keyword">return</span> (rb-&gt;itemCount == RINGBUFFER_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>检查缓冲区是否为空</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查环形缓冲区是否为空</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">ringbuffer_is_empty</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果项目计数为0，返回1（为空），否则返回0（非空）</span></span><br><span class="line">    <span class="keyword">return</span> (rb-&gt;itemCount == <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>向环形缓冲区写入数据</p><p>这里限制了向环形缓冲区写入数据的个数：即限定在环形缓冲区数组索引大小内</p><p>数据根据写指针当前指向的位置，进行写入。数据完成写入后，写指针递增。如果写指针当前到达缓冲区索引尾部，那么返回索引头部，即指向0</p><p>此段代码管理逻辑中，如果当前的环形缓冲区已经写满，需要经过将缓冲区的数据取出后，才能继续对缓冲区进行写入操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向环形缓冲区写入数据</span></span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">ringbuffer_write</span><span class="params">(<span class="type">ringbuffer_t</span> *rb, <span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果缓冲区已满，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_full(rb))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 将数据写入缓冲区</span></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        rb-&gt;buffer[rb-&gt;w] = *data++;  <span class="comment">// 写入数据并移动写指针</span></span><br><span class="line">        rb-&gt;w = (rb-&gt;w + <span class="number">1</span>) % RINGBUFFER_SIZE;  <span class="comment">// 写指针循环递增</span></span><br><span class="line">        rb-&gt;itemCount++;  <span class="comment">// 增加项目计数</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 写入成功返回0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从缓冲区读取数据</p><p>缓冲区有数据，操作才有效</p><p>数据根据读指针当前指向的位置，进行读取。数据完成读取后，读指针递增。如果读指针当前到达缓冲区索引尾部，那么返回索引头部，即指向0。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从环形缓冲区读取数据</span></span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">ringbuffer_read</span><span class="params">(<span class="type">ringbuffer_t</span> *rb, <span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果缓冲区为空，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_empty(rb))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓冲区读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        *data++ = rb-&gt;buffer[rb-&gt;r];  <span class="comment">// 读取数据并移动读指针</span></span><br><span class="line">        rb-&gt;r = (rb-&gt;r + <span class="number">1</span>) % RINGBUFFER_SIZE;  <span class="comment">// 读指针循环递增</span></span><br><span class="line">        rb-&gt;itemCount--;  <span class="comment">// 减少项目计数</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 读取成功返回0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="1-移植环形缓冲区驱动文件"><a class="markdownIt-Anchor" href="#1-移植环形缓冲区驱动文件"></a> 1. <strong>移植环形缓冲区驱动文件</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ringbuffer_t</span> usart_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> usart_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br></pre></td></tr></tbody></table></figure><ul><li>判断ringbuffer是否满</li><li>写入数据</li><li>清空结构体</li></ul><h2 id="2-空闲中断回调函数"><a class="markdownIt-Anchor" href="#2-空闲中断回调函数"></a> 2. <strong>空闲中断回调函数</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief UART DMA接收完成回调函数 </span></span><br><span class="line"><span class="comment">将接收到的数据写入环形缓冲区，并清空DMA缓冲区</span></span><br><span class="line"><span class="comment">  * @param huart UART句柄 </span></span><br><span class="line"><span class="comment">  * @param Size 接收到的数据大小 </span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//空闲中断回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (huart-&gt;Instance == USART1)  <span class="comment">// 判断是 USART1 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//引入环形缓存区</span></span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line">ringbuffer_write(&amp;usart_rb,uart_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-修改串口解析"><a class="markdownIt-Anchor" href="#2-修改串口解析"></a> 2. <strong>修改串口解析</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb))<span class="keyword">return</span>;</span><br><span class="line">    ringbuffer_read(&amp;usart_rb,usart_read_buffer,usart_rb.itemCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ringbuffer data:%s\n"</span>,usart_read_buffer);</span><br><span class="line">    meset(usart_read_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>)*<span class="number">128</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><mark><strong>STM32串口通信方法总结:</strong></mark></p><ul><li><p>超时解析</p></li><li><p>DMA空闲中断</p></li><li><p>环形缓存区</p></li></ul><h1 id="四-adc和dma"><a class="markdownIt-Anchor" href="#四-adc和dma"></a> 四、ADC和DMA</h1><blockquote><p>STM32的ADC（模数转换器）通道IN11指的是STM32微控制器上一个特定的ADC输入通道。每个STM32芯片的ADC都有多个模拟输入引脚，这些引脚标记为<code>INx</code>（例如IN0、IN1、IN2等），对应不同的GPIO引脚。</p><p>具体到<strong>IN11</strong>，它是ADC的第11个输入通道，通常与一个特定的GPIO引脚连接。该引脚用于将模拟信号输入到ADC进行模数转换。</p><p>CT117E原理图：</p><img src="/posts/24028/image-20240921165117470.png" class="" title="image-20240921165117470"></blockquote><h2 id="1-cubemx配置-2"><a class="markdownIt-Anchor" href="#1-cubemx配置-2"></a> 1. CubeMX配置</h2><h3 id="11-adc通道分配"><a class="markdownIt-Anchor" href="#11-adc通道分配"></a> 1.1 <strong>ADC通道分配：</strong></h3><ul><li>ADC1: IN11</li><li>ADC2: IN15</li></ul><img src="/posts/24028/image-20240920205816075.png" class="" title="image-20240920205816075"><h3 id="12-配置dma"><a class="markdownIt-Anchor" href="#12-配置dma"></a> 1.2 配置DMA</h3><h4 id="121-配置dma通道"><a class="markdownIt-Anchor" href="#121-配置dma通道"></a> 1.2.1 配置DMA通道</h4><img src="/posts/24028/image-20240920205900067.png" class="" title="image-20240920205900067"><h4 id="122-配置为循环模式"><a class="markdownIt-Anchor" href="#122-配置为循环模式"></a> 1.2.2 配置为循环模式</h4><img src="/posts/24028/image-20240921004004318.png" class="" title="image-20240921004004318"><h4 id="123-配置dma速度"><a class="markdownIt-Anchor" href="#123-配置dma速度"></a> 1.2.3 配置DMA速度</h4><p>设置为中、高均可</p><img src="/posts/24028/image-20240920210046359.png" class="" title="image-20240920210046359"><h3 id="13-配置adc属性"><a class="markdownIt-Anchor" href="#13-配置adc属性"></a> 1.3 <strong>配置ADC属性</strong></h3><ul><li>四分频</li><li>DMA使能</li><li>循环使能</li></ul><img src="/posts/24028/image-20240920210259713.png" class="" title="image-20240920210259713"><h3 id="14-配置adc中断"><a class="markdownIt-Anchor" href="#14-配置adc中断"></a> 1.4  <strong>配置ADC中断</strong></h3><p>优先级为2即可</p><img src="/posts/24028/image-20240920210416469.png" class="" title="image-20240920210416469"><h2 id="2-驱动程序编写-2"><a class="markdownIt-Anchor" href="#2-驱动程序编写-2"></a> 2. 驱动程序编写</h2><h3 id="21-创建adc_appc"><a class="markdownIt-Anchor" href="#21-创建adc_appc"></a> 2.1 <strong>创建adc_app.c</strong></h3><p><strong>变量声明</strong></p><img src="/posts/24028/image-20240920211129892.png" class="" title="image-20240920211129892"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//双通道DMA</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure><p><strong>在主程序初始化启用DMA 转运 ADC 数据</strong></p><img src="/posts/24028/image-20240920211606752.png" class="" title="image-20240920211606752"><h3 id="22-定义adc进程"><a class="markdownIt-Anchor" href="#22-定义adc进程"></a> 2.2 <strong>定义ADC进程</strong></h3><img src="/posts/24028/image-20240920211903715.png" class="" title="image-20240920211903715"><ul><li>读取电压dma储存数据</li><li>转换为模拟电压值</li></ul><p>同样的，记得在任务调度器中添加proc</p><h3 id="23-lcd显示"><a class="markdownIt-Anchor" href="#23-lcd显示"></a> 2.3 <strong>lcd显示</strong></h3><img src="/posts/24028/image-20240920212245141.png" class="" title="image-20240920212245141"><h2 id="动态窗口"><a class="markdownIt-Anchor" href="#动态窗口"></a> # <strong><mark>动态窗口</mark></strong></h2><ul><li>使用环形缓存区</li><li>定义结构体</li></ul><img src="/posts/24028/image-20240920214629559.png" class="" title="image-20240920214629559"><img src="/posts/24028/image-20240920214552510.png" class="" title="image-20240920214552510"><h1 id="多串口通信"><a class="markdownIt-Anchor" href="#多串口通信"></a> 多串口通信</h1><h2 id="示例一"><a class="markdownIt-Anchor" href="#示例一"></a> 示例一</h2><p>使用DMA+环形缓冲区+空闲中断回调的方法，使用串口通信，在解析函数中每次解析对象为串口一次性连续接收到的数据。</p><p>所以，在解析函数<code>uart_proc</code>中一次完成对串口数据内容的解析即可，不需要再用状态机的判断逻辑。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"usart_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> uart_rx_index = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> uart_rx_ticks = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_dma_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">ringbuffer_t</span> usart_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"><span class="type">uint8_t</span> usart_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> uart2_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">uint8_t</span> uart2_rx_dma_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">ringbuffer_t</span> usart2_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"><span class="type">uint8_t</span> usart2_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br><span class="line"></span><br><span class="line">DataPacket context; <span class="comment">// 初始化上下文</span></span><br><span class="line"><span class="comment">//串口中断回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//    if(huart-&gt;Instance == USART1)</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        uart_rx_ticks = uwTick;</span></span><br><span class="line"><span class="comment">//        uart_rx_index++;//索引自增</span></span><br><span class="line"><span class="comment">//        //每次触发回调，都要重新初始化接收中断，定义接收的位置</span></span><br><span class="line"><span class="comment">//        HAL_UART_Receive_IT(&amp;huart1,&amp;uart_rx_buffer[uart_rx_index],1);</span></span><br><span class="line"><span class="comment">////printf("test");//排错</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//空闲中断回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"dma data:%s\n"</span>,uart2_rx_dma_buffer);<span class="comment">//发送串口接收内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (huart-&gt;Instance == USART1)  <span class="comment">// 判断是 USART1 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//引入环形缓存区</span></span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line">ringbuffer_write(&amp;usart_rb,uart_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(huart-&gt;Instance == USART2)  <span class="comment">// 判断是 USART2 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart2_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">ringbuffer_write(&amp;usart2_rb,uart2_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart2_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart2_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//    if(uart_rx_index == 0) return;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    if(uwTick - uart_rx_ticks &gt; 100)//时间超过100</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        printf("uart data:%s\n",uart_rx_buffer);//发送串口接收内容</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//        memset (uart_rx_buffer,0,uart_rx_index);//清空</span></span><br><span class="line"><span class="comment">//        uart_rx_index = 0;//指针指令</span></span><br><span class="line"><span class="comment">//        huart1.pRxBuffPtr = uart_rx_buffer;//uart1缓存区指针指向buffer</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">// 如果环形缓冲区为空，直接返回 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb) &amp;&amp; ringbuffer_is_empty(&amp;usart2_rb)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从环形缓冲区读取数据到读取缓冲区 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ringbuffer_read(&amp;usart_rb, usart_read_buffer, usart_rb.itemCount);</span></span><br><span class="line">ringbuffer_read(&amp;usart2_rb, usart2_read_buffer, usart2_rb.itemCount);</span><br><span class="line"><span class="comment">// 打印读取缓冲区中的数据 </span></span><br><span class="line"><span class="comment">//printf("ringbuffer data: %s\n", usart_read_buffer);</span></span><br><span class="line"><span class="comment">// 上位机&lt;test协议&gt;</span></span><br><span class="line"><span class="comment">//printf("{plotter}%s\r\n", usart_read_buffer);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//问题1：用状态机写，会导致无法一次性解码；</span></span><br><span class="line"><span class="comment">//使用串口上位机，发现每次发送串口数据，状态机才会+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(usart_read_buffer[0] == 0xFF &amp;&amp; usart_read_buffer[3] == 0xFB)//帧头帧尾检测</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(usart_read_buffer[1] == 0x2A){</span></span><br><span class="line"><span class="comment">context.data_type = 1;//正数</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else if(usart_read_buffer[1] == 0x2B){</span></span><br><span class="line"><span class="comment">context.data_type = 2;//负数</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">context.data = usart_read_buffer[2];</span></span><br><span class="line"><span class="comment">number_detect = context.data;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parse_buffer(usart_read_buffer,sizeof(usart_read_buffer),&amp;context);</span></span><br><span class="line">parse_buffer(usart2_read_buffer,<span class="keyword">sizeof</span>(usart2_read_buffer),&amp;context);</span><br><span class="line"><span class="comment">//问题2：无memset会怎么样？</span></span><br><span class="line"><span class="comment">//memset(usart_read_buffer, 0, sizeof(uint8_t) * BUUFER_SIZE);</span></span><br><span class="line"><span class="built_in">memset</span>(usart2_read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * BUUFER_SIZE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据帧解析函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_buffer</span><span class="params">(<span class="type">uint8_t</span> *buffer,<span class="type">size_t</span> size,DataPacket* data)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(size &lt; <span class="number">4</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//数据帧长度小于4，返回 0 表示解析失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; buffer[<span class="number">3</span>] == <span class="number">0xFB</span>)<span class="comment">//帧头帧尾检测</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer[<span class="number">1</span>] == <span class="number">0x2A</span>){</span><br><span class="line">data -&gt; data_type = <span class="number">1</span>;<span class="comment">//正数</span></span><br><span class="line">data -&gt; data = buffer[<span class="number">2</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(buffer[<span class="number">1</span>] == <span class="number">0x2B</span>){</span><br><span class="line">data -&gt; data_type = <span class="number">2</span>;<span class="comment">//负数</span></span><br><span class="line">data -&gt; data = buffer[<span class="number">2</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//非正确类型，解析失败</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//解析成功</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//帧头帧尾错误，解析失败</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("%c%c\n", context.state,usart_read_buffer[2]);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-串口中断超时解析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-串口中断超时解析&quot;&gt;&lt;/a&gt; 一、串口中断+超时解析&lt;/h1&gt;
&lt;h2 id=&quot;1-cubemx配置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][1]嵌入式工程模板与“任务调度器”</title>
    <link href="https://szturin.github.io/posts/56683/"/>
    <id>https://szturin.github.io/posts/56683/</id>
    <published>2024-09-09T14:35:16.000Z</published>
    <updated>2024-10-29T08:05:48.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-任务调度器"><a class="markdownIt-Anchor" href="#一-任务调度器"></a> 一、任务调度器</h1><h2 id="1-调度器结构体"><a class="markdownIt-Anchor" href="#1-调度器结构体"></a> 1. 调度器结构体</h2><p><strong>函数指针和指针函数:</strong><a href="https://blog.csdn.net/baidu_37973494/article/details/83150266">C语言基础知识：函数指针&amp;指针函数（定义格式、作用及用法说明）_指针函数的定义-CSDN博客</a></p><p>PS: 函数指针本身上还是一个指针，和一般指针没有区别，指向函数的执行地址</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调度器类型的结构体类型声明</span></span><br><span class="line"><span class="comment">//任务结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">void</span> (*task_func)(<span class="type">void</span>);<span class="comment">//函数指针</span></span><br><span class="line">    <span class="type">uint32_t</span> rate_ms;<span class="comment">//任务运行周期</span></span><br><span class="line">    <span class="type">uint32_t</span> last_run;<span class="comment">//上次运行时间</span></span><br><span class="line">} <span class="type">scheduler_task_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><code>typedef struct {} scheduler_task_t;</code>是⼀种定义新结构体类型的⽅式，这⾥定义 了⼀个名为  scheduler_task_t 的结构体类型。这个结构体类型包含三个成员。</p><ul><li><p><code>void *task_func(void);</code>定义了一个函数指针，用于储存任务函数的地址，便于进行任务调度</p></li><li><p><code>rate_ms</code>表示任务具体的执行周期</p></li><li><p><code>last_run</code>⽤于存储任务上次运⾏的时间戳（以毫秒为单位）。该成员⽤于 记录任务上⼀次被调度执⾏的时间点，以便计算任务是否需要再次执⾏</p></li></ul><p>静态任务数组，每个任务包括任务函数，执行周期，和上次执行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Led_task</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义调度器类型的变量 任务</span></span><br><span class="line"><span class="comment">//任务数组</span></span><br><span class="line"><span class="comment">//给scheduler_task_t类型变量tasks赋初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">scheduler_task_t</span> tasks[] ={</span><br><span class="line">    {Led_task,<span class="number">1000</span>,<span class="number">0</span>}<span class="comment">//定义一个任务，任务函数为Led_Proc,执行周期为1000毫秒，初始上次运行时间为0</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="2-调度器初始化"><a class="markdownIt-Anchor" href="#2-调度器初始化"></a> 2. 调度器初始化</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">//计算任务数组中任务函数的个数，结果储存在tasks_num中</span></span><br><span class="line">    tasks_num = <span class="keyword">sizeof</span>(tasks)/<span class="keyword">sizeof</span>(<span class="type">scheduler_task_t</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-调度器函数"><a class="markdownIt-Anchor" href="#3-调度器函数"></a> 3. 调度器函数</h2><p>遍历任务数组，检查是否有任务需要进行，如果系统当前时间超过任务的执行周期，那么执行任务变更，并且更新上次运行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_run</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">/*任务轮询*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>; i&lt; tasks_num; i++){</span><br><span class="line">        <span class="comment">//获取当前时间（毫秒）</span></span><br><span class="line">        <span class="type">uint8_t</span> time_now = HAL_GetTick();</span><br><span class="line">        <span class="comment">//检查任务是否到达当前时间点</span></span><br><span class="line">        <span class="keyword">if</span>(time_now &gt;= tasks[i].rate_ms + tasks[i].last_run){</span><br><span class="line">            <span class="comment">//更新任务的上次运行时间，保存时间戳</span></span><br><span class="line">            tasks[i].last_run = time_now;<span class="comment">//保存当前时间</span></span><br><span class="line">            tasks[i].task_func();<span class="comment">//执行对应指向的任务</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-任务调度器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-任务调度器&quot;&gt;&lt;/a&gt; 一、任务调度器&lt;/h1&gt;
&lt;h2 id=&quot;1-调度器结构体&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-调度器结</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【深度学习】[1]神经网络的基本概念</title>
    <link href="https://szturin.github.io/posts/23492/"/>
    <id>https://szturin.github.io/posts/23492/</id>
    <published>2024-08-16T17:36:58.000Z</published>
    <updated>2024-09-07T17:16:24.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-神经网络的基本概念"><a class="markdownIt-Anchor" href="#一-神经网络的基本概念"></a> 一、神经网络的基本概念</h1><h2 id="1-神经元感知器"><a class="markdownIt-Anchor" href="#1-神经元感知器"></a> 1. 神经元（感知器）</h2><p>一种被称为感知器的人工神经元在20世纪五六十年代被科学家Frank提出。通过数学模型，可以认识到<strong>感知器</strong>是一个根据输入与权重来做出决定的设备，随着<strong>权重</strong>和<strong>阈值</strong>的变化，可以得到不同的<strong>决策模型</strong>。当一个感知器计算后得到的值大于阈值时，从神经学的角度来讲这个感知器被激活，反之为0。感知器可以一定程度上模仿人脑做出决策，但是感知器的决策过程全部是线性的，在处理图像处理、语音识别等复杂问题时，难以仅靠线性模型达到良好的识别效果，因此需要在感知器模型种引入非线性部分。</p><h2 id="2-非线性神经元"><a class="markdownIt-Anchor" href="#2-非线性神经元"></a> 2. 非线性神经元</h2><p>为解决复杂的数学模型，引入<strong>激活函数</strong>，激活函数给神经元带来了非线性因素，使得神经网络可以任意逼近任何非线性函数。</p><p>通常将激活函数与线性神经元合并使之成为<strong>非线性神经元</strong></p><p>如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的<a href="https://baike.baidu.com/item/%E6%84%9F%E7%9F%A5%E6%9C%BA/12723581">感知机</a>（Perceptron）。</p><img src="/posts/23492/34d6b14bf4b79175276eac52abacdf94.png" class="" title="img"><p>激活函数可以分为<strong>两大类：</strong></p><img src="/posts/23492/e41598583c8b35dcbb907f9fd66d8351.png" class="" title="img"><ul><li><strong>饱和激活函数：</strong> sigmoid、 tanh…</li><li><strong>非饱和激活函数:</strong> ReLU 、Leaky Relu  、ELU、PReLU、RReLU…</li></ul><p><a href="https://blog.csdn.net/qq_42691298/article/details/126590726">深度学习中常见的10种激活函数（Activation Function）总结_激活函数有哪些-CSDN博客</a></p><h2 id="3常见的激活函数"><a class="markdownIt-Anchor" href="#3常见的激活函数"></a> 3.常见的激活函数</h2><h3 id="31-sigmoid函数"><a class="markdownIt-Anchor" href="#31-sigmoid函数"></a> 3.1 Sigmoid函数</h3><img src="/posts/23492/6c9269a456ee0497c9bb0d1383e51cc8.png" class="" title="img"><img src="/posts/23492/af5f15ef44f1b276c78bec5e140e7082.png" class="" title="img"><h3 id="32-tanh函数"><a class="markdownIt-Anchor" href="#32-tanh函数"></a> 3.2 tanh函数</h3><p><strong>tanh</strong>激活函数的数学表达式为：</p><img src="/posts/23492/70ad61d6f8c019d3dee98ad6ef45cb1a.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/e58d7204fef7f7410e92b4bf82e91938.png" class="" title="img"><h3 id="33-relu函数"><a class="markdownIt-Anchor" href="#33-relu函数"></a> 3.3 ReLU函数</h3><p><strong>ReLU</strong>激活函数的数学表达式为：</p><img src="/posts/23492/ae65877d14768ad1b6789c6ccdcd6e31.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/a2f4f9f3c522518908e20d7865beb48c.png" class="" title="img"><p>什么情况下适合使用ReLU？</p><ul><li><p>ReLU解决了梯度消失的问题，当输入值为正时，神经元不会饱和</p></li><li><p>由于ReLU线性、非饱和的性质，在SGD中能够快速收敛</p></li><li><p>计算复杂度低，不需要进行指数运算</p></li></ul><p>ReLU有哪些缺点？</p><ul><li><p>与Sigmoid一样，其输出不是以0为中心的</p></li><li><p>Dead ReLU 问题。当输入为负时，梯度为0。这个神经元及之后的神经元梯度永远为0，不再对任何数据有所响应，导致相应参数永远不会被更新</p></li><li><p>训练神经网络的时候，一旦学习率没有设置好，第一次更新权重的时候，输入是负值，那么这个含有ReLU的神经节点就会死亡，再也不会被激活。所以，要设置一个合适的较小的学习率，来降低这种情况的发生</p></li></ul><h2 id="4-神经网络的基本架构"><a class="markdownIt-Anchor" href="#4-神经网络的基本架构"></a> 4. 神经网络的基本架构</h2><img src="/posts/23492/bf32fef369b3823adc20dcdf9af603e3.jpg" class="" title="bf32fef369b3823adc20dcdf9af603e3"><ul><li><p>神经网络最左边的称为<strong>输入层</strong>，其中的神经元称为<strong>输入神经元</strong>，原始数据经由该层输入到神经网络进行后续处理。</p></li><li><p>最右边的称为<strong>输出层</strong>，包含输出神经元，该层的输出是神经网络对样本处理后的最终结果，如分类结果。</p></li><li><p>在输入层和输出层之间的是中间层，也称为 <strong>隐藏层</strong>，即既非输入也非输出的神经网络层，一个神经网络可以有一个或者多个隐藏层，隐藏层的主要作用是处理从上一层神经元传递来的信号。</p></li></ul><p>一般的，<strong>输入层</strong>和 <strong>输出层</strong>在整体神经网络的外部，称为可见层。设计神经网络的输入输出通常比较简单，直接，例如，假设我们知道了一朵花的4个明显特征（如花瓣的长度，宽度），可以利用这4个特征确定它是哪一种类的花，由于我们已经知道这朵花的4个特征，那么就需要4个输入神经元，每个数值代表花朵的一种特征的具体数值。<strong>输出层</strong>可以包含一个或者多个神经元，这由我们想要设定的具体花朵类别决定，可以根据输出的数字，确定花朵的类型。我们可以使用每一个<strong>输出神经元</strong>代表一种类型的花，这种方法称为One-Hot，One-Hot是一种常见的输出层编码方法。</p><h2 id="5-梯度下降"><a class="markdownIt-Anchor" href="#5-梯度下降"></a> 5. 梯度下降</h2><p><a href="https://blog.csdn.net/iqdutao/article/details/107174240">机器学习-梯度下降算法原理及公式推导_梯度下降计算公式-CSDN博客</a></p><h2 id="6-反向传播"><a class="markdownIt-Anchor" href="#6-反向传播"></a> 6. 反向传播</h2><p><a href="https://blog.csdn.net/ft_sunshine/article/details/90221691">“反向传播算法”过程及公式推导（超直观好懂的Backpropagation）_反向传播算法(过程及公式推导)-CSDN博客</a></p><p><strong>“正向传播”求损失，“反向传播”回传误差</strong>。同时，神经网络每层的每个神经元都可以<strong>根据误差信号修正每层的权重</strong></p><h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h1><h2 id="一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"><a class="markdownIt-Anchor" href="#一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"></a> 一、输入x是 784长度的向量，什么机制使得输出y变成的长度为10的向量？</h2><p>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的。具体操作通过 <strong>权重矩阵</strong> 和 <strong>偏置向量</strong> 来完成。</p><h3 id="1-全连接层的基本机制"><a class="markdownIt-Anchor" href="#1-全连接层的基本机制"></a> 1. <strong>全连接层的基本机制：</strong></h3><p>全连接层的工作机制可以用矩阵乘法来描述。给定输入向量 x<em>x</em>（长度为784），要转换为长度为10的输出向量，通常通过如下步骤：</p><h4 id="2-步骤"><a class="markdownIt-Anchor" href="#2-步骤"></a> 2. <strong>步骤：</strong></h4><ol><li><p><strong>输入向量 <img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"></strong>：这是一个长度为784的向量，表示神经网络的输入。</p><img src="/posts/23492/image-20240907224042533.png" class="" title="image-20240907224042533"></li><li><p><strong>权重矩阵 <img src="/posts/23492/image-20240907224200098.png" class="" title="image-20240907224200098"></strong>：全连接层会有一个权重矩阵 W<em>W</em>，其维度是 10×78410×784，表示从输入784维向量到输出10维向量的权重连接。每一行表示一个输出神经元与所有输入神经元的权重连接。</p></li><li><p><strong>偏置向量 <img src="/posts/23492/image-20240907224226570.png" class="" title="image-20240907224226570"></strong>：偏置向量 b<em>b</em> 是一个长度为10的向量，表示每个输出神经元的偏置。</p></li><li><p><strong>计算输出向量 <img src="/posts/23492/image-20240907224234671.png" class="" title="image-20240907224234671"></strong>：通过矩阵乘法计算输出向量。输出向量 o<em>o</em> 的维度是10。具体计算方式如下：</p><img src="/posts/23492/image-20240907224051327.png" class="" title="image-20240907224051327"><ul><li>W \cdot x )：矩阵 ( W ) 乘以向量 ( x )，将784维的输入向量映射为10维的输出向量。</li></ul></li></ol><h3 id="3-矩阵乘法具体步骤"><a class="markdownIt-Anchor" href="#3-矩阵乘法具体步骤"></a> 3. <strong>矩阵乘法具体步骤：</strong></h3><ul><li><p>假设输入向量<img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"> 是长度为784的向量：</p><img src="/posts/23492/image-20240907224100515.png" class="" title="image-20240907224100515"></li><li><p>权重矩阵 W<em>W</em> 是一个 10×78410×784 的矩阵：</p><img src="/posts/23492/image-20240907224116095.png" class="" title="image-20240907224116095"></li><li><p>偏置向量 b<em>b</em> 是一个长度为10的向量：</p><img src="/posts/23492/image-20240907224125174.png" class="" title="image-20240907223954313"></li><li><p>输出向量 o<em>o</em> 通过矩阵乘法和加法得到，维度为10：</p><img src="/posts/23492/image-20240907224134345.png" class="" title="image-20240907224134345"></li></ul><p>每一行表示一个输出神经元的结果，最终得到一个长度为10的向量。</p><h3 id="4-激活函数"><a class="markdownIt-Anchor" href="#4-激活函数"></a> 4. <strong>激活函数：</strong></h3><p>在得到长度为10的向量后，通常会将其通过激活函数进行处理。在分类任务中，输出层通常使用 <strong>Softmax</strong> 函数，将每个输出值转换为概率值。Softmax 函数公式为：</p><img src="/posts/23492/image-20240907224012315.png" class="" title="image-20240907224012315"><p>这会将输出向量 o<em>o</em> 转换为一个概率分布，表示输入属于不同类别的概率。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>将784长度的输入向量变为10长度的输出向量的关键步骤是通过 <strong>全连接层的矩阵乘法</strong> 和 <strong>偏置项</strong>，最终计算出长度为10的向量，并通过 <strong>Softmax</strong> 函数将其转换为概率分布，从而实现分类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-神经网络的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-神经网络的基本概念&quot;&gt;&lt;/a&gt; 一、神经网络的基本概念&lt;/h1&gt;
&lt;h2 id=&quot;1-神经元感知器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    
    <category term="学习笔记,深度学习" scheme="https://szturin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][2]stm32时钟树</title>
    <link href="https://szturin.github.io/posts/9067/"/>
    <id>https://szturin.github.io/posts/9067/</id>
    <published>2024-08-14T13:47:44.000Z</published>
    <updated>2024-10-29T08:06:04.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-锁相环的原理与应用"><a class="markdownIt-Anchor" href="#一-锁相环的原理与应用"></a> 一、锁相环的原理与应用</h1><p>参考文章：<a href="https://blog.csdn.net/weixin_46274168/article/details/130437627">【STM32】知识补充 锁相环原理与应用解析_stm32数字锁相-CSDN博客</a></p><h2 id="什么是锁相环-ppl"><a class="markdownIt-Anchor" href="#什么是锁相环-ppl"></a> 什么是锁相环 (PPL)</h2><p>锁相环是一种闭环反馈控制系统. 用于生成与输入信号同步且<a href="https://so.csdn.net/so/search?q=%E7%9B%B8%E4%BD%8D&amp;spm=1001.2101.3001.7020">相位</a>相同的输出信号. 它的核心功能是在输入信号的相位变化时, 自动调整输出信号以保持同步. 这使得锁相环成为了一种理想的频率和相位控制技术.</p><img src="/posts/9067/f9cb0a753bddf1fb37003ddd1310111b.png" class="" title="锁相环原理图"><h2 id="锁相环的基本组成"><a class="markdownIt-Anchor" href="#锁相环的基本组成"></a> 锁相环的基本组成</h2><p>锁相环主要由以下几个部分组成:</p><ul><li>相位比较器 (Phase Detector): 相位比较器负责比较输入信号和反馈信号的相位差, 并将其转换为电压信号</li><li>低通滤波器 (Low-Pass Filter): 低通滤波器对相位比较器的输出信号进行滤波, 以消除高频噪声和相位抖动</li><li>电压控制振荡器 (Voltage-Controlled Oscillator): 根据低通过滤波器的输出电压调整输出信号的频率和相位</li><li>反馈分频器 (Feedback Divider): 反馈分频器对 VCO 的输出信号进行分频处理, 并将其反馈给相位比较器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-锁相环的原理与应用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-锁相环的原理与应用&quot;&gt;&lt;/a&gt; 一、锁相环的原理与应用&lt;/h1&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://blog.csdn.net/weixin_46</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
  </entry>
  
  <entry>
    <title>【Opencv】[1]图像处理基本概念</title>
    <link href="https://szturin.github.io/posts/51713/"/>
    <id>https://szturin.github.io/posts/51713/</id>
    <published>2024-07-07T16:42:28.000Z</published>
    <updated>2024-10-03T11:24:34.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="opencv中文文档"><a class="markdownIt-Anchor" href="#opencv中文文档"></a> # OpenCV中文文档</h1><p><a href="https://woshicver.com/">https://woshicver.com/</a></p><h1 id="一-图像处理常见基本概念"><a class="markdownIt-Anchor" href="#一-图像处理常见基本概念"></a> 一、图像处理常见基本概念</h1><h2 id="1bgr和rgb格式"><a class="markdownIt-Anchor" href="#1bgr和rgb格式"></a> 1.BGR和RGB格式</h2><blockquote><ul><li><p>BGR和RGB是两种常见的颜色编码格式，它们在像素颜色排列的顺序上有所不同：</p><ol><li><strong>RGB格式</strong>：<ul><li>RGB指的是红色（R）、绿色（G）、蓝色（B）三个颜色通道的顺序。</li><li>在RGB格式中，像素的颜色值按照红、绿、蓝的顺序排列，即最开始的三个字节依次表示红色、绿色和蓝色分量。</li></ul></li><li><strong>BGR格式</strong>：<ul><li>BGR则是蓝色（B）、绿色（G）、红色（R）的顺序。</li><li>在BGR格式中，像素的颜色值按照蓝、绿、红的顺序排列，即最开始的三个字节依次表示蓝色、绿色和红色分量。</li></ul></li></ol><p>这两种格式主要在图像处理中有所区别。例如，<mark>在OpenCV中，默认情况下读取的图像格式是BGR而非RGB</mark>，这意味着你在处理图像数据时需要注意颜色通道的顺序。如果需要与其他软件或标准的RGB格式进行交互，通常需要进行颜色通道的重新排列。</p><p>总结：</p><ul><li><strong>RGB</strong>：红色、绿色、蓝色，像素颜色排列顺序是RGB。</li><li><strong>BGR</strong>：蓝色、绿色、红色，像素颜色排列顺序是BGR。</li></ul></li></ul><p>RGB格式的缺陷：自然条件下截取的图像，容易受到光线的影响，即对亮度比较敏感，RGB的三个分量都会受亮度的影响。</p></blockquote><h2 id="2-hsv格式"><a class="markdownIt-Anchor" href="#2-hsv格式"></a> 2. HSV格式</h2><blockquote><p>在图像处理中使用较多的是 HSV 颜色空间，它比 RGB 更接近人们对彩色的感知经验。非常直观地表达颜色的色调、鲜艳程度和明暗程度，方便进行颜色的对比。</p><p>​    在 HSV 颜色空间下，比 RGB 更容易跟踪某种颜色的物体，常用于分割指定颜色的物体。</p><p>​    HSV 表达彩色图像的方式由三个部分组成：</p><ul><li>Hue（色调、色相），相当于基调，是下图的俯视图得到的圆，圆上不同位置的颜色基调不同，把颜色分成了360°，每个位置有不同的颜色基调；</li><li>Saturation（饱和度、色彩纯净度）：纯度，沿着俯视图得到的圆的半径看，因为圆弧上的点代表该处的颜色的基调，那么半径上就是从纯白色到该基调颜色过渡过程中不同位置的纯度，在圆心处纯度为0，在圆弧上（该色调）纯度为100；</li><li>Value（明度）：亮度，沿着圆柱的高来看，圆柱表面上平行于圆柱轴上的点的颜色基调相同，纯度也相同，但是明暗程度不同。同时，该圆柱的半径也不同，相当于磁盘的柱面。</li></ul><p>​    用下面这个圆柱体来表示 HSV 颜色空间，圆柱体的横截面可以看做是一个极坐标系 ，H 用极坐标的极角表示，S 用极坐标的极轴长度表示，V 用圆柱中轴的高度表示。</p><img src="/posts/51713/a8d376f7eceb5a45001650bde730f019.png" class="" title="img"></blockquote><h2 id="3-分辨率和像素"><a class="markdownIt-Anchor" href="#3-分辨率和像素"></a> 3. 分辨率和像素</h2><p>1、像素是指照片的点数(表示照片是由多少点构成的)，分辨率是指照片像素点的密度(是用单位尺寸内的像素点，一般用每英寸多少点表示–dpi)。照片实际大小是像素决定的。一个像素很大的照片，如果将分辨率设置很大的话，打印出来的照片可能并不大(但是很清晰)。反之，一个像素并不很大的照片，如果将分辨率设置得很小，那么打印出来的照片可能很大(但是不清晰)。</p><p>2、 分辨率指单位长度上的像素值，与打印质量有关，一般使用的量纲为PPI; 总像素指图片的样本精度，与可打印尺寸有关，通常使用“长×宽”的方式表示，乘积就是通常所说的总像素。由于图片的宽高比不同，所以，同一总像素可以有多种规格。</p><h2 id="4-roi区域"><a class="markdownIt-Anchor" href="#4-roi区域"></a> 4. ROI区域</h2><blockquote><p>在计算机视觉和图像处理中，感兴趣区域（Region of Interest, ROI）是指图像中特别关注的部分。ROI 通常用于提取图像中的特定区域进行进一步的处理和分析，比如特征提取、对象识别、图像分割等。</p><h3 id="roi-的主要作用"><a class="markdownIt-Anchor" href="#roi-的主要作用"></a> ROI 的主要作用：</h3><ol><li><strong>减少处理时间</strong>：通过只处理图像中的特定区域，可以显著减少处理时间，提高效率。</li><li><strong>集中处理目标</strong>：可以将处理的焦点集中在图像中最相关的部分，忽略背景或其他不相关的区域。</li><li><strong>提高精度</strong>：在某些情况下，ROI 的提取可以提高图像处理的精度，尤其是在目标对象占据图像较小区域时。</li></ol><h3 id="如何定义和提取-roi"><a class="markdownIt-Anchor" href="#如何定义和提取-roi"></a> 如何定义和提取 ROI：</h3><p>通常，ROI 是一个矩形区域，可以通过指定其左上角和右下角的坐标来定义。在 OpenCV 中，可以通过数组切片的方式来提取 ROI。</p><h4 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码：</h4><p>以下是一个使用 OpenCV 提取 ROI 的简单示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># 读取图像</span><br><span class="line">image = cv2.imread('image.jpg')</span><br><span class="line"></span><br><span class="line"># 定义ROI的坐标（左上角和右下角）</span><br><span class="line">x1, y1 = 100, 100  # 左上角坐标</span><br><span class="line">x2, y2 = 300, 300  # 右下角坐标</span><br><span class="line"></span><br><span class="line"># 提取ROI区域</span><br><span class="line">roi = image[y1:y2, x1:x2]</span><br><span class="line"></span><br><span class="line"># 显示原图和ROI区域</span><br><span class="line">cv2.imshow('Original Image', image)</span><br><span class="line">cv2.imshow('ROI', roi)</span><br><span class="line"></span><br><span class="line"># 等待按键</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明：</h3><ol><li><strong>读取图像</strong>：使用 <code>cv2.imread()</code> 读取图像文件。</li><li><strong>定义 ROI</strong>：通过指定矩形的左上角 <code>(x1, y1)</code> 和右下角 <code>(x2, y2)</code> 坐标来定义感兴趣区域。</li><li><strong>提取 ROI</strong>：使用切片操作 <code>image[y1:y2, x1:x2]</code> 提取 ROI 区域。</li><li><strong>显示图像</strong>：使用 <code>cv2.imshow()</code> 显示原图和提取的 ROI。</li></ol><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><ul><li><strong>坐标有效性</strong>：确保 ROI 的坐标在图像的范围内，否则会导致错误。</li><li><strong>矩形定义</strong>：左上角坐标 <code>(x1, y1)</code> 应小于右下角坐标 <code>(x2, y2)</code>。</li></ul><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h3><ul><li><strong>目标检测</strong>：提取图像中检测到的目标区域进行进一步分析。</li><li><strong>图像分割</strong>：提取图像中特定的分割区域进行处理。</li><li><strong>特征提取</strong>：只对感兴趣的区域进行特征提取，减少计算量。</li></ul><p>通过合理定义和提取 ROI，可以有效地提高图像处理的效率和精度。</p></blockquote><h1 id="二-opencv介绍"><a class="markdownIt-Anchor" href="#二-opencv介绍"></a> 二、OpenCV介绍</h1><blockquote><p>OpenCV（open source computer vision library）是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。<br>它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。<br>OpenCV用C<ins>语言编写，它的主要接口也是C</ins>语言，但是依然保留了大量的C语言接口。</p></blockquote><p>安装opencv</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></tbody></table></figure><h1 id="三-opencv常用接口"><a class="markdownIt-Anchor" href="#三-opencv常用接口"></a> 三、OpenCV常用接口</h1><h2 id="一-图像入门"><a class="markdownIt-Anchor" href="#一-图像入门"></a> 一、图像入门</h2><p>Opencv常见相关功能库：</p><ul><li>numpy</li><li>Matplotlib</li></ul><h3 id="1-读取图像"><a class="markdownIt-Anchor" href="#1-读取图像"></a> 1. 读取图像</h3><p><code>cv2.imread()</code></p><ul><li>cv.IMREAD_COLOR： 加载彩色图像。任何图像的透明度都会被忽视。它是默认标志。</li><li>cv.IMREAD_GRAYSCALE：以灰度模式加载图像</li><li>cv.IMREAD_UNCHANGED：加载图像，包括alpha通道</li></ul><p><strong>注意</strong>： 除了这三个标志，你可以分别简单地传递整数1、0或-1。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以灰度格式加载图像</span></span><br><span class="line">img_file = cv.imread(<span class="string">"123.jpg"</span>,<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="2-显示图像与用户交互"><a class="markdownIt-Anchor" href="#2-显示图像与用户交互"></a> 2. 显示图像与用户交互</h3><p><code>cv2.imshow()</code></p><p>使用函数**cv2.imshow()**在窗口中显示图像。窗口自动适合图像尺寸。</p><p>第一个参数是窗口名称，它是一个字符串。第二个参数是我们的对象。可以根据需要创建任意多个窗口，可以使用不同的窗口名称</p><p><code>cv.waitKey()</code>是一个键盘绑定函数。其参数是以毫秒为单位的时间。该函数等待任何键盘事件指定的毫秒。如果您在这段时间内按下任何键，程序将继续运行。如果<strong>0</strong>被传递，它将无限期地等待一次敲击键。</p><p><code>cv.destroyAllWindows()</code>破坏创建的所有窗口。</p><p><code>cv.destroyWindow()</code>在其中传递确切的窗口名称作为参数。</p><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv.imshow(<span class="string">"img"</span>,img_file)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><p>PS: <code>cv.namedWindow()</code>可以创建一个空窗口</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv.namedWindow(<span class="string">'image'</span>,cv.WINDOW_NORMAL)</span><br><span class="line">cv.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h3 id="3-写入图像"><a class="markdownIt-Anchor" href="#3-写入图像"></a> 3. 写入图像</h3><p><code>cv2.imwrite()</code></p><p>第一个参数是文件名，第二个参数是要保存的图像。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.imwrite(<span class="string">'messigray.png'</span>,img)</span><br></pre></td></tr></tbody></table></figure><p>这会将图像以PNG格式保存在工作目录中。</p><h3 id="示例总结"><a class="markdownIt-Anchor" href="#示例总结"></a> # 示例总结</h3><p><strong>加载灰度图像，显示图像，按s保存图像，按Esc退出</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">img_file = cv.imread(<span class="string">'img.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">'img'</span>,img_file)</span><br><span class="line">key = cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> key == <span class="number">27</span> : <span class="comment"># 按Esc退出</span></span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line"><span class="keyword">elif</span> key == <span class="built_in">ord</span>(<span class="string">'s'</span>): <span class="comment"># 按s保存图像并退出</span></span><br><span class="line">    cv.imwrite(<span class="string">'img_file_save.png'</span>,img_file)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h3 id="matplotlib"><a class="markdownIt-Anchor" href="#matplotlib"></a> # Matplotlib</h3><p>Matplotlib 是 Python 2D-绘图领域使用最广泛的套件。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用matplotlib库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img =  cv.imread(<span class="string">'img.png'</span>,<span class="number">0</span>)</span><br><span class="line">plt.imshow(img, cmap = <span class="string">'gray'</span>, interpolation = <span class="string">'bicubic'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])  <span class="comment"># 隐藏 x 轴和 y 轴上的刻度值</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><h2 id="二-视频入门"><a class="markdownIt-Anchor" href="#二-视频入门"></a> 二、视频入门</h2><h3 id="1-驱动相机读取视频"><a class="markdownIt-Anchor" href="#1-驱动相机读取视频"></a> 1. 驱动相机读取视频</h3><p>可以通过<code>cap.isOpened()</code>方法检查它是否已初始化。如果是<code>True</code>，那么确定。否则，使用<code>cap.open()</code>打开它</p><p><code>cap.read()</code>返回布尔值(<code>True</code>/ <code>False</code>)。如果正确读取了帧，它将为<code>True</code>。因此，你可以通过检查此返回值来检查视频的结尾</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"can't not open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'can not recevie frame'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">'video'</span>,gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) ==  <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">cap.release() <span class="comment"># 释放视频捕获</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><p>注意：waitKey() 传入参数’0’会导致视频显示卡在一帧中</p><blockquote><p>正确使用方法：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) ==  <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure><p>waitKey()相当于一个阻塞式的函数,如<code>delay()</code></p></blockquote><h3 id="2-获取视频格式"><a class="markdownIt-Anchor" href="#2-获取视频格式"></a> 2. 获取视频格式</h3><p>可以使用<code>cap.get(propId)</code>方法访问该视频的某些功能，其中propId是0到18之间的一个数字。每个数字表示视频的属性（如果适用于该视频），并且可以显示完整的详细信息在这里看到：<strong>cv::VideoCapture::get()</strong></p><p>例如，我可以通过<code>cap.get(cv.CAP_PROP_FRAME_WIDTH)</code>和<code>cap.get(cv.CAP_PROP_FRAME_HEIGHT)</code>检查框架的宽度和高度</p><h3 id="3-设置视频格式"><a class="markdownIt-Anchor" href="#3-设置视频格式"></a> 3. 设置视频格式</h3><p>默认情况下，视频的分辨率为640x480，使用<code>cap.set()</code>设置即可</p><ul><li><code>cap.set(cv.CAP_PROP_FOURCC, codec)</code></li><li><code>cap.set(cv.CAP_PROP_FPS, 30)</code> #帧数</li><li><code>cap.set(cv.CAP_PROP_FRAME_WIDTH, 1920)</code>#列 宽度</li><li><code>cap.set(cv.CAP_PROP_FRAME_HEIGHT, 1080)</code> # 行 高度</li></ul><p>PS :  <code>codec = cv.VideoWriter_fourcc('M', 'J', 'P', 'G')</code></p><blockquote><p>**一、简介 **<br><code>cv2.VideoWriter_fourcc</code>是 OpenCV 中用于定义视频编解码器的函数，它将四个字符的编码（FourCC）转换为一个用于视频编码器的整数。FourCC 是一种四字符编码，用于指定视频文件中使用的压缩方式。</p><p><strong>二、语法和参数</strong></p><ol><li>语法<br><code>cv2.VideoWriter_fourcc(c1, c2, c3, c4)</code><br>2.参数<br>c1, c2, c3, c4：表示四个字符的编码，每个字符是一个字符，代表不同的视频编码器。常用的编码器包括：</li></ol><ul><li>‘XVID’：常用于 .avi 格式的视频文件。</li><li>‘MP4V’：常用于 .mp4 格式的视频文件。</li><li>‘MJPG’：适用于使用 Motion JPEG 编码的视频。</li></ul><p>3.返回值</p><p>返回一个整数，该整数用于创建 cv2.VideoWriter 对象时指定视频编码格式。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line">codec = cv.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FOURCC, codec)</span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FPS, <span class="number">30</span>) <span class="comment">#帧数</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_WIDTH, <span class="number">1920</span>) <span class="comment">#列 宽度</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_HEIGHT, <span class="number">1080</span>) <span class="comment"># 行 高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"can't not open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'can not recevie frame'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">'video'</span>,gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) ==  <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">cap.release() <span class="comment"># 释放视频捕获</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h2 id="4-保存视频"><a class="markdownIt-Anchor" href="#4-保存视频"></a> 4. 保存视频</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line">fourcc = cv.VideoWriter_fourcc(*<span class="string">'XVID'</span>)</span><br><span class="line">out = cv.VideoWriter(<span class="string">'output.avi'</span>,fourcc,<span class="number">20.0</span>,(<span class="number">1920</span>,<span class="number">1080</span>))</span><br><span class="line"></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FPS, <span class="number">30</span>) <span class="comment">#帧数</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_WIDTH, <span class="number">1920</span>) <span class="comment">#列 宽度</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv.CAP_PROP_FRAME_HEIGHT, <span class="number">1080</span>) <span class="comment"># 行 高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"can't open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'not get'</span>)</span><br><span class="line">    </span><br><span class="line">    frame = cv.flip(frame, <span class="number">0</span>)</span><br><span class="line">    out.write(frame)</span><br><span class="line">    cv.imshow(<span class="string">"video"</span>,frame)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h2 id="5-播放视频"><a class="markdownIt-Anchor" href="#5-播放视频"></a> 5. 播放视频</h2><p>跟捕获摄像头一致，只需要修改捕获的对象即可</p><p>如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="string">'vtest.avi'</span>)</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># 如果正确读取帧，ret为True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Can't receive frame (stream end?). Exiting ..."</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">'frame'</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h2 id="三-绘图功能"><a class="markdownIt-Anchor" href="#三-绘图功能"></a> 三、绘图功能</h2><h2 id="四-鼠标事件"><a class="markdownIt-Anchor" href="#四-鼠标事件"></a> 四、鼠标事件</h2><h2 id="五-滑块调参"><a class="markdownIt-Anchor" href="#五-滑块调参"></a> 五、滑块调参</h2><p><code>cv.createTrackbar()</code>：</p><ul><li><p>第一个参数是轨迹栏名称</p></li><li><p>第二个参数是它附加到的窗口名称</p></li><li><p>第三个参数是默认值</p></li><li><p>第四个参数是最大值</p></li><li><p>第五个是执行的回调函数每次跟踪栏值更改</p></li></ul><p>Opencv本身没有提供按钮相关的api，可以利用滑块函数，设定参数值为0/1，达到按钮的效果。</p><p><code>cv.getTrackbarPos()</code></p><ul><li><p>第一个参数是轨迹栏名称</p></li><li><p>第二个参数是窗口名称</p><p>使用<code>cv.getTrackbarPos()</code>函数，在主循环中可以实时响应滑块调节的对应轨道参数值</p></li></ul><p><strong>示例程序</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个黑色的图像，一个窗口</span></span><br><span class="line">img = np.zeros((<span class="number">300</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">'image'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建RGB调整滑块栏</span></span><br><span class="line">cv.createTrackbar(<span class="string">'R'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">'G'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">'B'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 ON/OFF 功能创建开关</span></span><br><span class="line">switch = <span class="string">'0 : OFF \n1 : ON'</span></span><br><span class="line">cv.createTrackbar(switch, <span class="string">'image'</span>,<span class="number">0</span>,<span class="number">1</span>,nothing)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">'image'</span>,img)</span><br><span class="line"></span><br><span class="line">    r = cv.getTrackbarPos(<span class="string">'R'</span>,<span class="string">'image'</span>)</span><br><span class="line">    g = cv.getTrackbarPos(<span class="string">'G'</span>,<span class="string">'image'</span>)</span><br><span class="line">    b = cv.getTrackbarPos(<span class="string">'B'</span>,<span class="string">'image'</span>)</span><br><span class="line">    s = cv.getTrackbarPos(switch,<span class="string">'image'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">        img[:] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img[:] = [b,g,r]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h1 id="四-opencv核心操作"><a class="markdownIt-Anchor" href="#四-opencv核心操作"></a> 四、OpenCV核心操作</h1><h2 id="一-图像的基本操作"><a class="markdownIt-Anchor" href="#一-图像的基本操作"></a> 一、图像的基本操作</h2><h2 id="二-图像的位运算"><a class="markdownIt-Anchor" href="#二-图像的位运算"></a> 二、图像的位运算</h2><h2 id="三-性能优化"><a class="markdownIt-Anchor" href="#三-性能优化"></a> 三、性能优化</h2><h3 id="1-衡量代码性能的方式"><a class="markdownIt-Anchor" href="#1-衡量代码性能的方式"></a> 1. 衡量代码性能的方式</h3><p><code>cv.getTickCount</code>函数返回从参考事件（如打开机器的那一刻）到调用此函数那一刻之间的时钟周期数。因此，如果在函数执行之前和之后调用它，则会获得用于执行函数的时钟周期数。</p><p><code>cv.getTickFrequency</code>函数返回时钟周期的频率或每秒的时钟周期数。因此，要找到执行时间（以秒为单位），你可以执行以下操作：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1 = cv.getTickCount()</span><br><span class="line"><span class="comment"># 你的执行代码</span></span><br><span class="line">e2 = cv.getTickCount()</span><br><span class="line">time = (e2 - e1)/ cv.getTickFrequency()</span><br></pre></td></tr></tbody></table></figure><p>除了OpenCV，Python还提供了一个模块<strong>time</strong>，这有助于衡量执行时间。另一个模块<strong>profile</strong>有助于获取有关代码的详细报告，例如代码中每个函数花费了多少时间，调用了函数的次数等。</p><h3 id="2-opencv默认的性能优化"><a class="markdownIt-Anchor" href="#2-opencv默认的性能优化"></a> 2. OpenCV默认的性能优化</h3><p>许多 OpenCV 函数都是使用 SSE2、 AVX 等进行优化的。 它还包含未优化的代码。因此，如果我们的系统支持这些特性，我们就应该利用它们(几乎所有现代的处理器都支持它们)。在编译时默认启用它。因此，如果启用了 OpenCV，它将运行优化的代码，否则它将运行未优化的代码。可以使用 <strong>cvUseoptimized</strong> 检查是否启用 / 禁用和 <strong>cvSetuseoptimized</strong> 以启用 / 禁用它。让我们看一个简单的例子。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查是否启用了优化</span></span><br><span class="line">In [<span class="number">5</span>]: cv.useOptimized()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="literal">True</span></span><br><span class="line">In [<span class="number">6</span>]: %timeit res = cv.medianBlur(img,<span class="number">49</span>)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">34.9</span> ms per loop</span><br><span class="line"><span class="comment"># 关闭它</span></span><br><span class="line">In [<span class="number">7</span>]: cv.setUseOptimized(<span class="literal">False</span>)</span><br><span class="line">In [<span class="number">8</span>]: cv.useOptimized()</span><br><span class="line">Out[<span class="number">8</span>]: <span class="literal">False</span></span><br><span class="line">In [<span class="number">9</span>]: %timeit res = cv.medianBlur(img,<span class="number">49</span>)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">64.1</span> ms per loop</span><br></pre></td></tr></tbody></table></figure><p>优化的中值滤波比未优化的版本快2倍。如果你检查其来源，可以看到中值滤波是 SIMD 优化。因此，可以使用它在代码顶部启用优化(默认启用的)</p><h3 id="3-性能优化方式"><a class="markdownIt-Anchor" href="#3-性能优化方式"></a> 3. 性能优化方式</h3><blockquote><p>在Python和NumPy中优化性能的技术和编码方法的关键技术：</p><h3 id="1-避免显式循环"><a class="markdownIt-Anchor" href="#1-避免显式循环"></a> 1. <strong>避免显式循环</strong></h3><ul><li><strong>描述</strong>：尽量避免使用<code>for</code>循环，尤其是双重或三重循环。使用NumPy的向量化操作。</li><li><strong>来源</strong>：NumPy User Guide - Array Programming</li></ul><h3 id="2-向量化操作"><a class="markdownIt-Anchor" href="#2-向量化操作"></a> 2. <strong>向量化操作</strong></h3><ul><li><strong>描述</strong>：利用NumPy的数组运算和广播功能来实现高效的向量化操作，避免逐元素计算。</li><li><strong>来源</strong>：NumPy Vectorization</li></ul><h3 id="3-缓存一致性"><a class="markdownIt-Anchor" href="#3-缓存一致性"></a> 3. <strong>缓存一致性</strong></h3><ul><li><strong>描述</strong>：确保数据在内存中的布局有利于CPU缓存，从而提高访问速度。例如，使用行优先的存储方式。</li><li><strong>来源</strong>：Understanding Cache and Memory</li></ul><h3 id="4-避免不必要的数组复制"><a class="markdownIt-Anchor" href="#4-避免不必要的数组复制"></a> 4. <strong>避免不必要的数组复制</strong></h3><ul><li><strong>描述</strong>：尽量使用数组视图而非副本，这样可以减少内存开销。使用<code>np.view()</code>或切片来创建视图。</li><li><strong>来源</strong>：NumPy Views</li></ul><h3 id="5-使用cython和numba"><a class="markdownIt-Anchor" href="#5-使用cython和numba"></a> 5. <strong>使用Cython和Numba</strong></h3><ul><li><p>描述</p><p>：如果在使用NumPy和向量化后代码仍然很慢，可以考虑使用Cython或Numba对性能关键部分进行加速。</p><ul><li><strong>Cython</strong>：允许将Python代码转换为C，以提高性能。</li><li><strong>Numba</strong>：通过JIT编译加速NumPy代码，特别是循环。</li></ul></li><li><p>来源：</p><ul><li><a href="https://cython.readthedocs.io/en/latest/">Cython Documentation</a></li><li>Numba Documentation</li></ul></li></ul><h3 id="6-使用并行计算"><a class="markdownIt-Anchor" href="#6-使用并行计算"></a> 6. <strong>使用并行计算</strong></h3><ul><li><strong>描述</strong>：对于大规模计算任务，可以利用并行处理库（如<code>multiprocessing</code>或<code>joblib</code>）来加速计算。</li><li><strong>来源</strong>：<a href="https://docs.python.org/3/library/multiprocessing.html">Python Multiprocessing</a></li></ul><h3 id="7-profiling和性能分析"><a class="markdownIt-Anchor" href="#7-profiling和性能分析"></a> 7. <strong>Profiling和性能分析</strong></h3><ul><li><strong>描述</strong>：使用性能分析工具（如<code>cProfile</code>和<code>line_profiler</code>）找出性能瓶颈，针对性优化。</li><li>来源：<ul><li><a href="https://docs.python.org/3/library/profile.html">cProfile Documentation</a></li><li><a href="https://github.com/pyutils/line_profiler">line_profiler</a></li></ul></li></ul><h3 id="8-利用科学计算库"><a class="markdownIt-Anchor" href="#8-利用科学计算库"></a> 8. <strong>利用科学计算库</strong></h3><ul><li><strong>描述</strong>：对于特定任务，利用专门的科学计算库（如SciPy、Pandas）进行更高效的数据处理和分析。</li><li><strong>来源</strong>：SciPy Documentation</li></ul></blockquote><h1 id="向量化"><a class="markdownIt-Anchor" href="#向量化"></a> # 向量化</h1><blockquote><p>在Python中，向量化主要是指使用NumPy和其他库（如Pandas和TensorFlow）来处理数组和矩阵数据的能力，从而提高计算效率。以下是一些在Python中向量化的常见用法：</p><h3 id="1-使用numpy进行向量化"><a class="markdownIt-Anchor" href="#1-使用numpy进行向量化"></a> 1. 使用NumPy进行向量化</h3><p>NumPy是Python中用于数值计算的库，它提供了高效的数组操作。通过向量化，你可以避免使用显式的循环，从而提高代码的性能。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个NumPy数组</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素加2</span></span><br><span class="line">b = a + <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出: [3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素平方</span></span><br><span class="line">c = a ** <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出: [ 1  4  9 16 25]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-使用pandas进行向量化"><a class="markdownIt-Anchor" href="#2-使用pandas进行向量化"></a> 2. 使用Pandas进行向量化</h3><p>Pandas是用于数据分析的库，它提供了类似于NumPy的向量化操作，适用于处理DataFrame和Series对象。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Pandas Series</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素乘以3</span></span><br><span class="line">s2 = s * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(s2)  <span class="comment"># 输出: 0    3, 1    6, 2    9, 3   12, 4   15</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-使用tensorflow进行向量化"><a class="markdownIt-Anchor" href="#3-使用tensorflow进行向量化"></a> 3. 使用TensorFlow进行向量化</h3><p>在深度学习中，TensorFlow也广泛使用向量化来进行大规模的矩阵运算。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python复制代码<span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TensorFlow张量</span></span><br><span class="line">x = tf.constant([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化操作：所有元素加5</span></span><br><span class="line">y = x + <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(y.numpy())  <span class="comment"># 输出: [ 6  7  8  9 10]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>向量化通过批量处理数据，减少了循环的使用，从而提高了代码的性能和可读性。在进行数值计算时，推荐尽量使用向量化的方法。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;opencv中文文档&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#opencv中文文档&quot;&gt;&lt;/a&gt; # OpenCV中文文档&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://woshicver.com/&quot;&gt;https://woshi</summary>
      
    
    
    
    
    <category term="学习笔记,计算机视觉" scheme="https://szturin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】PID平衡小车项目实战</title>
    <link href="https://szturin.github.io/posts/25248/"/>
    <id>https://szturin.github.io/posts/25248/</id>
    <published>2024-06-09T08:22:17.000Z</published>
    <updated>2024-10-29T08:05:20.478Z</updated>
    
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[11]IIC通信(mpu6050)</title>
    <link href="https://szturin.github.io/posts/5621/"/>
    <id>https://szturin.github.io/posts/5621/</id>
    <published>2024-05-24T12:55:20.000Z</published>
    <updated>2024-11-08T12:29:23.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iic通信协议"><a class="markdownIt-Anchor" href="#iic通信协议"></a> IIC通信协议</h1><h2 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h2><ul><li><p>同步时序的稳定性比异步时序更高</p></li><li><p>半双工</p></li><li><p>SCL、SDA两根通信线</p></li><li><p>支持总线挂载（一主多从，多主多从）</p></li></ul><h2 id="硬件电路"><a class="markdownIt-Anchor" href="#硬件电路"></a> 硬件电路</h2><ul><li>所有I2C设备的SCL连接在一起，SDA连接在一起</li><li>设备的SCL和SDA均要配置成开漏输出模式(防止形成短路电流，SDA要么<mark>被上拉</mark>，要么<mark>输出低电平</mark>)，会有“线与”的现象。在多主机的模式下，可以利用线与的特性，实现总线仲裁和时钟同步。</li><li>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</li></ul><img src="/posts/5621/image-20240524211453559.png" class="" title="image-20240524211453559"><hr><img src="/posts/5621/image-20240524212810776.png" class="" title="image-20240524212810776"><p><strong>PS：IIC时序是高位先行，串口是低位先行</strong></p><hr><img src="/posts/5621/image-20240524212934134.png" class="" title="image-20240524212934134"><p><strong>PS：主机接收时，需要释放SDA，即输入模式</strong></p><hr><img src="/posts/5621/image-20240524213709342.png" class="" title="image-20240524213709342"><p><strong>PS:从机的地址可以通过电路改变</strong></p><hr><img src="/posts/5621/image-20240524214219090.png" class="" title="image-20240524214219090"><p><strong><mark>红线处，此时需要从机应答，这里如果但看主机的SDA，应该会释放SDA，即高电平，由于从机要发送应答，根据线与的特性，这里拉低了SDA，所以最后SDA呈现图中所示。</mark></strong></p><hr><img src="/posts/5621/image-20240524214908190.png" class="" title="image-20240524214908190"><p><strong>IIC通信的设备中会有单独一个字节空间存储地址指针，当给IIC设备指定地址写时，地址指针会加一，这时如果使用当前地址读，就是读取指针地址指向的内存。此时序较为少用、</strong></p><hr><img src="/posts/5621/image-20240524215204768.png" class="" title="image-20240524215204768"><p><strong><mark>指定地址读的实现原理：先调用指定地址写，但是不写数据。再次调用当前地址读，这样复合的时序就能完成指定地址读的功能了</mark></strong></p><h1 id="mpu6050"><a class="markdownIt-Anchor" href="#mpu6050"></a> MPU6050</h1><img src="/posts/5621/image-20240524220155605.png" class="" title="image-20240524220155605"><h2 id="姿态角欧拉角"><a class="markdownIt-Anchor" href="#姿态角欧拉角"></a> 姿态角（欧拉角）</h2><img src="/posts/5621/image-20240524220352017.png" class="" title="image-20240524220352017"><p><strong>飞机相对于初始三个轴的夹角：</strong></p><ul><li>俯仰角：Pitch</li><li>滚转：Roll</li><li>偏航：Yaw</li></ul><p>要想获得稳定的欧拉角，就需要进行数据融合，进一步得到姿态角。</p><p><strong>常见的数据融合算法：</strong></p><ul><li>互补滤波</li><li>卡尔曼滤波</li></ul><p>ps:惯性导航领域里，姿态解算</p><h2 id="加速度计结构"><a class="markdownIt-Anchor" href="#加速度计结构"></a> 加速度计结构</h2><img src="/posts/5621/image-20240524220855509.png" class="" title="image-20240524220855509"><p><strong>F=ma(测力计)</strong></p><img src="/posts/5621/image-20240524221000525.png" class="" title="image-20240524221000525"><p><strong><mark>加速度计测得的是静态加速度，只能在物体静止的时候使用</mark></strong></p><h2 id="陀螺仪传感器"><a class="markdownIt-Anchor" href="#陀螺仪传感器"></a> 陀螺仪传感器</h2><img src="/posts/5621/image-20240524221506605.png" class="" title="image-20240524221506605"><p><strong>测得的是角速度，要想得到角度，可以进行求积分</strong></p><p><strong><mark>陀螺仪具有动态稳定性，不具有静态稳定性</mark></strong></p><p><strong><mark>对两种传感器进行互补滤波，就可以得到稳定的姿态角了</mark></strong></p><h2 id="mpu6050的参数"><a class="markdownIt-Anchor" href="#mpu6050的参数"></a> MPU6050的参数</h2><img src="/posts/5621/image-20240524221944683.png" class="" title="image-20240524221944683"><p>eg: mpu6050的从机地址：0x68 ，IIC时序中发送的第一个字节，高七位为从机地址，第八位为读写位。有时候把0XD0当作MPU6050的地址</p><h2 id="硬件结构"><a class="markdownIt-Anchor" href="#硬件结构"></a> 硬件结构</h2><img src="/posts/5621/image-20240525205511856.png" class="" title="image-20240525205511856"><blockquote><p><strong>六轴传感器的缺点：没有稳定的参考方向</strong></p><p>XCL，XDA：挂载磁力计，气压计</p><p>INT引脚：可以配置MPU6050内部一些事件，产生电平跳变</p><p>PS：MPU6050内部包含DMP单元：进行姿态融合和数据结算</p><p>包含稳压电路</p></blockquote><p><mark><strong>传感器内部含有自测单元</strong></mark></p><img src="/posts/5621/image-20240525210718105.png" class="" title="image-20240525210718105"><p>使能自测-&gt;读取数据1-&gt;失能自测-&gt;读取数据2，两个数据相减，得到的数据称作自测响应，自测响应如果在<mark>规定的范围内</mark>，说明芯片性能没问题。</p><hr><p><strong>电荷泵</strong></p><img src="/posts/5621/image-20240525210953979.png" class="" title="image-20240525210953979"><p>是一种<mark>升压电路</mark></p><p>原理：电源和电容串并联的切换（充电-&gt;串联-&gt;相当于电压升高（放电）-&gt;快速切换到并联-&gt;充电-&gt;循环）+ 电容滤波 = 平稳升压</p><img src="/posts/5621/image-20240525211051107.png" class="" title="image-20240525211051107"><hr><p><strong>DMP</strong>（数字运动处理器）</p><img src="/posts/5621/image-20240525211323304.png" class="" title="image-20240525211323304"><p>配合MPU6050官方的DMP库，进行姿态解算。</p><p><mark>引脚说明</mark></p><blockquote><p>FSYNC：帧同步</p></blockquote><blockquote><p>通信接口：用于和STM32通信</p><img src="/posts/5621/image-20240525211535797.png" class="" title="image-20240525211535797"></blockquote><blockquote><p>xxxxxxxxxx&nbsp;python script_name.py --train_data_dir “path/to/train_data” --test_data_dir “path/to/test_data” --img_height 128 --img_width 128 --batch_size 64 --epochs 15python</p><p>​可以拓展连接磁力计</p><img src="/posts/5621/image-20240525211622949.png" class="" title="image-20240525211622949"></blockquote><hr><h2 id="软件iic读写mpu6050"><a class="markdownIt-Anchor" href="#软件iic读写mpu6050"></a> 软件IIC读写MPU6050</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MyIIC.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主机寻址MPU6050*/</span></span><br><span class="line">MyIIC_Init();</span><br><span class="line">MyIIC_Start();</span><br><span class="line">MyIIC_SendByte(<span class="number">0xD0</span>);<span class="comment">//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="type">uint8_t</span> Ack = MyIIC_ReceiveAck();</span><br><span class="line">MyIIC_Stop();</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Ack,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> <img src="/posts/5621/image-20240525224436566.png" class="" title="image-20240525224436566"><hr><p><strong>修改MPU6050地址</strong></p><p>可见，寻址无应答</p><img src="/posts/5621/image-20240526152458852.png" class="" title="image-20240526152458852"><hr><p><strong>读取MPU6050 ID号</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="comment">/*//主机寻址MPU6050</span></span><br><span class="line"><span class="comment">MyIIC_Init();</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(0xD2);//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="comment">uint8_t Ack = MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">OLED_ShowNum(1,1,Ack,3);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//读取MPU6050ID号</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154358599.png" class="" title="image-20240526154358599"><hr><p><strong>写MPU6050</strong>，需要关闭MPU6050的睡眠模式</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//在电源管理器1，写入0x00，接触睡眠模式</span></span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//更改采样频率</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x19</span>);<span class="comment">//读取MPU6050采样频率</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154723015.png" class="" title="image-20240526154723015"><p><strong>PS:某种程度上来说，对寄存器的读写操作可以看作读写一个存储器，但是寄存器能反应硬件电路的状态，对硬件电路进行操作</strong></p><hr><h2 id="mpu6050读取六轴姿态值"><a class="markdownIt-Anchor" href="#mpu6050读取六轴姿态值"></a> MPU6050读取六轴姿态值</h2><p><strong>函数定义</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用指针，实现函数多返回值的操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params"><span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> DataH ,DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">*AccX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">*AccY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">*AccZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">*GyroX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">*GyroY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">*GyroZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int16_t</span> Ax,Ay,Az,Gx,Gy,Gz;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">MPU6050_GetData(&amp;Ax,&amp;Ay,&amp;Az,&amp;Gx,&amp;Gy,&amp;Gz);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">1</span>,Ax,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">1</span>,Ay,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">1</span>,Az,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">8</span>,Gx,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">8</span>,Gy,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">8</span>,Gz,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>加速度计最大量程为16g</strong></p><img src="/posts/5621/image-20240526162104183.png" class="" title="image-20240526162104183"><p>左侧为加速度计，右侧为角速度测量值</p><hr><h2 id="硬件iic读写mpu6050"><a class="markdownIt-Anchor" href="#硬件iic读写mpu6050"></a> 硬件IIC读写MPU6050</h2><p>CR：控制寄存器</p><p>DR：数据寄存器</p><p>SR：状态寄存器</p><p><strong>STM32IIC外设</strong></p><img src="/posts/5621/image-20240526162959527.png" class="" title="image-20240526162959527"><h3 id="多主机模型"><a class="markdownIt-Anchor" href="#多主机模型"></a> 多主机模型</h3><p><strong>一主多从</strong></p><img src="/posts/5621/image-20240526163123491.png" class="" title="image-20240526163123491"><p><strong>多主多从</strong></p><p>固定多主机：</p><img src="/posts/5621/image-20240526163142347.png" class="" title="image-20240526163142347"><p>可变多主机：</p><img src="/posts/5621/image-20240526163226138.png" class="" title="image-20240526163226138"><p><strong>GPIO复用输入和复用输出</strong></p><img src="/posts/5621/image-20240526164412282.png" class="" title="image-20240526164412282"><p><strong>IIC主机发送流程图</strong></p><img src="/posts/5621/image-20240526165109626.png" class="" title="image-20240526165109626"><p><strong>IIC主机接收流程图</strong></p><img src="/posts/5621/image-20240526165718823.png" class="" title="image-20240526165718823"><h3 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h3><blockquote><p><strong>产生起始条件</strong></p><p>void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>生成终止条件</strong></p><p>void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>配置在收到一个字节后，是否给从机应答</strong></p><p>void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>写数据到数据寄存器DR</strong></p><p>void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);</p><p><strong>读取DR的数据，作为返回值</strong></p><p>uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);</p><p><strong>发送7位地址</strong></p><p>void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);</p></blockquote><p><strong>状态监控函数的官方说明</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> ****************************************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                         I2C State Monitoring Functions</span></span><br><span class="line"><span class="comment"> *                       </span></span><br><span class="line"><span class="comment"> ****************************************************************************************   </span></span><br><span class="line"><span class="comment"> * This I2C driver provides three different ways for I2C state monitoring</span></span><br><span class="line"><span class="comment"> *  depending on the application requirements and constraints:</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 1) Basic state monitoring:</span></span><br><span class="line"><span class="comment"> *    Using I2C_CheckEvent() function:</span></span><br><span class="line"><span class="comment"> *    It compares the status registers (SR1 and SR2) content to a given event</span></span><br><span class="line"><span class="comment"> *    (can be the combination of one or more flags).</span></span><br><span class="line"><span class="comment"> *    It returns SUCCESS if the current status includes the given flags </span></span><br><span class="line"><span class="comment"> *    and returns ERROR if one or more flags are missing in the current status.</span></span><br><span class="line"><span class="comment"> *    - When to use:</span></span><br><span class="line"><span class="comment"> *      - This function is suitable for most applications as well as for startup </span></span><br><span class="line"><span class="comment"> *      activity since the events are fully described in the product reference manual </span></span><br><span class="line"><span class="comment"> *      (RM0008).</span></span><br><span class="line"><span class="comment"> *      - It is also suitable for users who need to define their own events.</span></span><br><span class="line"><span class="comment"> *    - Limitations:</span></span><br><span class="line"><span class="comment"> *      - If an error occurs (ie. error flags are set besides to the monitored flags),</span></span><br><span class="line"><span class="comment"> *        the I2C_CheckEvent() function may return SUCCESS despite the communication</span></span><br><span class="line"><span class="comment"> *        hold or corrupted real state. </span></span><br><span class="line"><span class="comment"> *        In this case, it is advised to use error interrupts to monitor the error</span></span><br><span class="line"><span class="comment"> *        events and handle them in the interrupt IRQ handler.</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *        @note </span></span><br><span class="line"><span class="comment"> *        For error management, it is advised to use the following functions:</span></span><br><span class="line"><span class="comment"> *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).</span></span><br><span class="line"><span class="comment"> *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.</span></span><br><span class="line"><span class="comment"> *            Where x is the peripheral instance (I2C1, I2C2 ...)</span></span><br><span class="line"><span class="comment"> *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()</span></span><br><span class="line"><span class="comment"> *            in order to determine which error occurred.</span></span><br><span class="line"><span class="comment"> *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()</span></span><br><span class="line"><span class="comment"> *            and/or I2C_GenerateStop() in order to clear the error flag and source,</span></span><br><span class="line"><span class="comment"> *            and return to correct communication status.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  2) Advanced state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetLastEvent() which returns the image of both status </span></span><br><span class="line"><span class="comment"> *     registers in a single word (uint32_t) (Status Register 2 value is shifted left </span></span><br><span class="line"><span class="comment"> *     by 16 bits and concatenated to Status Register 1).</span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *       - This function is suitable for the same applications above but it allows to</span></span><br><span class="line"><span class="comment"> *         overcome the limitations of I2C_GetFlagStatus() function (see below).</span></span><br><span class="line"><span class="comment"> *         The returned value could be compared to events already defined in the </span></span><br><span class="line"><span class="comment"> *         library (stm32f10x_i2c.h) or to custom values defined by user.</span></span><br><span class="line"><span class="comment"> *       - This function is suitable when multiple flags are monitored at the same time.</span></span><br><span class="line"><span class="comment"> *       - At the opposite of I2C_CheckEvent() function, this function allows user to</span></span><br><span class="line"><span class="comment"> *         choose when an event is accepted (when all events flags are set and no </span></span><br><span class="line"><span class="comment"> *         other flags are set or just when the needed flags are set like </span></span><br><span class="line"><span class="comment"> *         I2C_CheckEvent() function).</span></span><br><span class="line"><span class="comment"> *     - Limitations:</span></span><br><span class="line"><span class="comment"> *       - User may need to define his own events.</span></span><br><span class="line"><span class="comment"> *       - Same remark concerning the error management is applicable for this </span></span><br><span class="line"><span class="comment"> *         function if user decides to check only regular communication flags (and </span></span><br><span class="line"><span class="comment"> *         ignores error flags).</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3) Flag-based state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetFlagStatus() which simply returns the status of </span></span><br><span class="line"><span class="comment"> *     one single flag (ie. I2C_FLAG_RXNE ...). </span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *        - This function could be used for specific applications or in debug phase.</span></span><br><span class="line"><span class="comment"> *        - It is suitable when only one flag checking is needed (most I2C events </span></span><br><span class="line"><span class="comment"> *          are monitored through multiple flags).</span></span><br><span class="line"><span class="comment"> *     - Limitations: </span></span><br><span class="line"><span class="comment"> *        - When calling this function, the Status register is accessed. Some flags are</span></span><br><span class="line"><span class="comment"> *          cleared when the status register is accessed. So checking the status</span></span><br><span class="line"><span class="comment"> *          of one Flag, may clear other ones.</span></span><br><span class="line"><span class="comment"> *        - Function may need to be called twice or more in order to monitor one </span></span><br><span class="line"><span class="comment"> *          single event.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="iic配置占空比的缘由"><a class="markdownIt-Anchor" href="#iic配置占空比的缘由"></a> #IIC配置占空比的缘由</h3><p><strong>上升沿变化较慢，下降沿比较迅速，标准速度下，时钟占空比接近1：1，快速状态，占空比接近2：1</strong></p><img src="/posts/5621/image-20240526174725131.png" class="" title="image-20240526174725131"><p>100KHZ</p><img src="/posts/5621/image-20240526174831972.png" class="" title="image-20240526174831972"><p>400KHZ</p><img src="/posts/5621/image-20240526174841651.png" class="" title="image-20240526174841651"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> *  <span class="number">1</span>) Basic state monitoring</span><br><span class="line"> *******************************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Checks whether the last I2Cx Event is equal to the one passed</span></span><br><span class="line"><span class="comment">  *   as parameter.</span></span><br><span class="line"><span class="comment">  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.</span></span><br><span class="line"><span class="comment">  * @param  I2C_EVENT: specifies the event to be checked. </span></span><br><span class="line"><span class="comment">  *   This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     </span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9</span></span><br><span class="line"><span class="comment">  *     </span></span><br><span class="line"><span class="comment">  * @note: For detailed description of Events, please refer to section </span></span><br><span class="line"><span class="comment">  *    I2C_Events in stm32f10x_i2c.h file.</span></span><br><span class="line"><span class="comment">  *    </span></span><br><span class="line"><span class="comment">  * @retval An ErrorStatus enumeration value:</span></span><br><span class="line"><span class="comment">  * - SUCCESS: Last event is equal to the I2C_EVENT</span></span><br><span class="line"><span class="comment">  * - ERROR: Last event is different from the I2C_EVENT</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解决while死循环等待的问题"><a class="markdownIt-Anchor" href="#解决while死循环等待的问题"></a> 解决WHILE死循环等待的问题</h3><p><strong>多个while,比较危险，一旦通信出现问题，程序直接卡死</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*软件I2C，阻塞式程序</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();//可以加判断，确保时序的正确</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(RegAddress);//指定要写入的寄存器</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(Data);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//硬件IIC，非阻塞式程序</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT ) !=SUCCESS);<span class="comment">//事件监测</span></span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//选择I2C外设，从机地址，从机地址最低位。此函数自带接收应答的功能</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,RegAddress);<span class="comment">//写入DR，需要等待EV8事件</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,Data);</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) !=SUCCESS);<span class="comment">//发送完最后一个字节，需要监测EB8_1事件</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTOP(I2C2,ENABLE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>保护程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Timeout;</span><br><span class="line">Timeout= <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2Cx,I2C_EVENT) != SUCCESS)</span><br><span class="line">{</span><br><span class="line">Timeout--;</span><br><span class="line"><span class="keyword">if</span>(Timeout==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="dmp库"><a class="markdownIt-Anchor" href="#dmp库"></a> DMP库</h1><p>digital motion processor数字运动处理器，mpu6050自带的一个硬件，可以直接输出用于姿态结算的四元数</p><h1 id="卡尔曼滤波"><a class="markdownIt-Anchor" href="#卡尔曼滤波"></a> 卡尔曼滤波</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iic通信协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#iic通信协议&quot;&gt;&lt;/a&gt; IIC通信协议&lt;/h1&gt;
&lt;h2 id=&quot;基本功能&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本功能&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="IIC" scheme="https://szturin.github.io/tags/IIC/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[9]DMA数据转运</title>
    <link href="https://szturin.github.io/posts/10712/"/>
    <id>https://szturin.github.io/posts/10712/</id>
    <published>2024-05-22T03:44:18.000Z</published>
    <updated>2024-10-29T08:05:07.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h1><blockquote><p><strong>恢复缺省配置</strong></p><p>void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>初始化DMA</strong></p><p>void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>DMA使能</strong></p><p>void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);</p><p><strong>中断输出使能</strong></p><p>void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);</p><p><strong>DMA设置当前数据寄存器</strong></p><p>void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);</p><p><strong>DMA获取当前数据寄存器</strong></p><p>uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>获取DMA标志位状态</strong></p><p>FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);</p><p><strong>清除DMA标志位</strong></p><p>void DMA_ClearFlag(uint32_t DMAy_FLAG);</p><p><strong>获取DMA中断标志位状态</strong></p><p>ITStatus DMA_GetITStatus(uint32_t DMAy_IT);</p><p><strong>清除DMA中断标志位</strong></p><p>void DMA_ClearITPendingBit(uint32_t DMAy_IT);</p><p><strong>开启ADC DMA触发信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p></blockquote><ul><li><p><strong><mark>DMA是AHB总线的设备</mark></strong></p></li><li><p><strong><mark>DMA软件触发和硬件触发不能同时使用，如果同时使用DMA就会连续触发</mark></strong></p></li><li><p>DMA转运有三个条件：1.传输计数器大于0 2.触发源有触发信号 3.DMA使能</p></li></ul><h1 id="一-dma数据转运"><a class="markdownIt-Anchor" href="#一-dma数据转运"></a> 一、DMA数据转运</h1><h2 id="1stm32单片机ram和rom"><a class="markdownIt-Anchor" href="#1stm32单片机ram和rom"></a> 1.stm32单片机RAM和ROM</h2><h3 id="不加const修饰"><a class="markdownIt-Anchor" href="#不加const修饰"></a> 不加const修饰</h3><img src="/posts/10712/image-20240522115326572.png" class="" title="image-20240522115326572"><h3 id="加上const修饰"><a class="markdownIt-Anchor" href="#加上const修饰"></a> 加上const修饰</h3><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> aa =<span class="number">0x66</span>;<span class="comment">//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,aa,<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;aa,<span class="number">8</span>);<span class="comment">//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>现象</strong></p><p>flash里面编译的代码部分，地址位于flah最前面，所以这里变量的显示在靠后的地址</p><img src="/posts/10712/image-20240522115450140.png" class="" title="image-20240522115450140"><h2 id="const关键字节省sram空间"><a class="markdownIt-Anchor" href="#const关键字节省sram空间"></a> const关键字节省SRAM空间</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED字模库，宽8像素，高16像素*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> OLED_F8x16[][<span class="number">16</span>]=</span><br><span class="line">{</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//  0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="结构体访问寄存器ram地址"><a class="markdownIt-Anchor" href="#结构体访问寄存器ram地址"></a> 结构体访问寄存器RAM地址</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR,<span class="number">8</span>);</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522115913765.png" class="" title="image-20240522115913765"><p><strong><mark>外设的起始地址+寄存器的偏移地址=指定寄存器的地址</mark></strong></p><p><strong><mark>使用结构体访问，指定地址对应寄存器，这样，结构体访问就是寄存器的地址</mark></strong></p><h2 id="2dma转运数组"><a class="markdownIt-Anchor" href="#2dma转运数组"></a> 2.DMA转运数组</h2><p><strong>软件触发代码部分</strong></p> <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522143322783.png" class="" title="image-20240522143322783"><h2 id="3dma软件触发"><a class="markdownIt-Anchor" href="#3dma软件触发"></a> 3.DMA软件触发</h2><img src="/posts/10712/image-20240522144732279.png" class="" title="image-20240522144732279"><p><strong>DMA传输计数器软件重装</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyDMA_Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数DMA初始化配置</span></span><br><span class="line"><span class="comment">  * @参数要转运数据的首地址，存储器站点的起始地址，传输次数</span></span><br><span class="line"><span class="comment">  * @返回值</span></span><br><span class="line"><span class="comment">  * @特殊说明</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line">MyDMA_Size=Size;</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=Size;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Enable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=AddrB;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;<span class="comment">//以字节传输</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;</span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=AddrA;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte;<span class="comment">//转运数据宽度为一个字节</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，所以通道可以任意选择</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,MyDMA_Size);</span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"DataA"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">"DataB"</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataA,<span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataB,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">DataA[<span class="number">0</span>]++;</span><br><span class="line">DataA[<span class="number">1</span>]++;</span><br><span class="line">DataA[<span class="number">2</span>]++;</span><br><span class="line">DataA[<span class="number">3</span>]++;</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">MyDMA_Transfer();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522145131191.png" class="" title="image-20240522145131191"><p><strong>将DataA用const修饰</strong></p><p>DataA此时为flash里面的变量，所以地址为08开头</p><img src="/posts/10712/image-20240522145359406.png" class="" title="image-20240522145359406"><h1 id="adc-dma转运"><a class="markdownIt-Anchor" href="#adc-dma转运"></a> ADC+ DMA转运</h1><p><strong>ADC单次扫描，DMA单次转运+软件触发</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD_Value[<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=DISABLE;<span class="comment">//单次模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,<span class="number">4</span>);<span class="comment">//传输次数给4</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里选择了ADC触发DMA，标志位自动清零，所以不需要软件清零</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);//等待转换完成标志位置1</span></span><br><span class="line"><span class="comment">return ADC_GetConversionValue(ADC1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA转运完成总是在ADC完成之后的，所以这里等待DMA状态标志位即可*/</span></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>ADC连续扫描+DMA循环转运模式</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=ENABLE;<span class="comment">//连续模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Circular;<span class="comment">//传输模式，是否使用自动重装,DMA循环模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line"></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思考：</strong></p><ul><li>定时器触发ADC单词转换后通过DMA转运？</li><li>串口发送的数据使用DMA进行存储器到外设的转运</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;相关库函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#相关库函数&quot;&gt;&lt;/a&gt; 相关库函数&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;恢复缺省配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void DMA_DeInit(DMA</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="DMA数据转运" scheme="https://szturin.github.io/tags/DMA%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[10]串口通信</title>
    <link href="https://szturin.github.io/posts/19202/"/>
    <id>https://szturin.github.io/posts/19202/</id>
    <published>2024-05-20T03:50:54.000Z</published>
    <updated>2024-10-29T08:05:11.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p><strong>结构体初始化配置</strong></p><p>void USART_DeInit(USART_TypeDef* USARTx);<br>void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);<br>void USART_StructInit(USART_InitTypeDef* USART_InitStruct);</p><p><strong>同步时钟配置</strong></p><p>void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);<br>void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);</p><p><strong>发送数据</strong></p><p>void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);</p><ul><li>写DR寄存器</li></ul><p><strong>接收数据</strong></p><p>uint16_t USART_ReceiveData(USART_TypeDef* USARTx);</p><ul><li>读DR寄存器</li></ul></blockquote><h1 id="microlib"><a class="markdownIt-Anchor" href="#microlib"></a> MicroLIB</h1><p><strong>MicroLIB是Keil为嵌入式平台优化的一个精简库</strong></p><img src="/posts/19202/image-20240520133336274.png" class="" title="image-20240520133336274"><h1 id="多个串口同时使用printf"><a class="markdownIt-Anchor" href="#多个串口同时使用printf"></a> 多个串口同时使用printf</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(String,<span class="string">"Num=%d\r\n"</span>,<span class="number">666</span>);<span class="comment">//sprintf.可以将指定的数据复制到数组中</span></span><br><span class="line">Serial_SendString(String);<span class="comment">//打印字符串</span></span><br></pre></td></tr></tbody></table></figure><h1 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_Prinf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="汉字编码发送"><a class="markdownIt-Anchor" href="#汉字编码发送"></a> 汉字编码发送</h1><img src="/posts/19202/image-20240520135012811.png" class="" title="image-20240520135012811"><p><strong>统一选定为UTF-8编码</strong></p><h1 id="串口接收"><a class="markdownIt-Anchor" href="#串口接收"></a> 串口接收</h1><h2 id="1查询方法"><a class="markdownIt-Anchor" href="#1查询方法"></a> 1.查询方法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">RXData=USART_ReceiveData(USART1);<span class="comment">//读DR可以自动清除标志位</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2中断方法"><a class="markdownIt-Anchor" href="#2中断方法"></a> 2.中断方法</h2><h3 id="子程序"><a class="markdownIt-Anchor" href="#子程序"></a> 子程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxData;</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GerRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> Serial_RxData;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2主程序"><a class="markdownIt-Anchor" href="#2主程序"></a> 2.主程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"RxData:"</span>);</span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_GerRxFlag()==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RXData = Serial_GetRxData();</span><br><span class="line">Serial_SendByte(RXData);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">RXData=USART_ReceiveData(USART1);//读DR可以自动清除标志位</span></span><br><span class="line"><span class="comment">OLED_ShowHexNum(1,1,RXData,2);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="串口数据包"><a class="markdownIt-Anchor" href="#串口数据包"></a> 串口数据包</h1><p><strong>打包多字节为一个数据包，方便发送多字节的数据。将同一批的数据进行打包和分割</strong></p><p><strong>包头、包尾：简易通信协议</strong></p><ul><li>文本数据包</li><li>Hex数据包</li></ul><h2 id="状态机的方法来接收数据包"><a class="markdownIt-Anchor" href="#状态机的方法来接收数据包"></a> 状态机的方法来接收数据包</h2><img src="/posts/19202/image-20240520150733732.png" class="" title="image-20240520150733732"><h2 id="1发送数据包"><a class="markdownIt-Anchor" href="#1发送数据包"></a> 1.发送数据包</h2><img src="/posts/19202/image-20240520152533465.png" class="" title="image-20240520152533465"><h2 id="2接收数据包"><a class="markdownIt-Anchor" href="#2接收数据包"></a> 2.接收数据包</h2><p><strong>串口中断子程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_TxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送数据包*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(<span class="number">0xFF</span>);</span><br><span class="line">Serial_SendArray(Serial_TxPacket,<span class="number">4</span>);</span><br><span class="line">Serial_SendByte(<span class="number">0xFE</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line"><span class="keyword">if</span>(++pRxState&gt;=<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">pRxState=<span class="number">0</span>;</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="number">0xFE</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Serial.h</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_TxPacket[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_RxPacket[];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="小操作"><a class="markdownIt-Anchor" href="#小操作"></a> 小操作</h2><p><strong>按住alt选择一列进行修改</strong></p><img src="/posts/19202/image-20240520154534025.png" class="" title="image-20240520154534025"><h2 id="3文本收发数据包"><a class="markdownIt-Anchor" href="#3文本收发数据包"></a> 3.文本收发数据包</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">100</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'@'</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'\r'</span>)<span class="comment">//第一个包尾</span></span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line">pRxState++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)<span class="comment">//第二个包尾</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="string">'\n'</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">Serial_RxPacket[pRxState]=<span class="string">'\0'</span>;<span class="comment">//字符串结束时加上\0,表示字符串的结束</span></span><br><span class="line">pRxState=<span class="number">0</span>;<span class="comment">//MARK:忘记清零</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="串口下载"><a class="markdownIt-Anchor" href="#串口下载"></a> #串口下载</h1><h2 id="boot引脚"><a class="markdownIt-Anchor" href="#boot引脚"></a> Boot引脚</h2><p>BootLoder的作用相当于刷机</p><h2 id="调试使用"><a class="markdownIt-Anchor" href="#调试使用"></a> 调试使用</h2><img src="/posts/19202/image-20240520163851412.png" class="" title="image-20240520163851412"><p>可以保持跳线帽置1，但是复位后程序丢失，所以仅用来调试</p><h2 id="读flash生成bin文件"><a class="markdownIt-Anchor" href="#读flash生成bin文件"></a> 读FLASH生成bin文件</h2><img src="/posts/19202/image-20240520164112095.png" class="" title="image-20240520164112095"><h2 id="读保护写保护"><a class="markdownIt-Anchor" href="#读保护写保护"></a> 读保护/写保护</h2><img src="/posts/19202/image-20240520164217951.png" class="" title="image-20240520164217951"><h1 id="蓝牙串口通信"><a class="markdownIt-Anchor" href="#蓝牙串口通信"></a> 蓝牙串口通信</h1><p><a href="https://blog.csdn.net/struggle_success/article/details/130440579">电赛|项目|课设：蓝牙模块HC05主从配置与连接_蓝牙 master和 slave 服务-CSDN博客</a></p><p><strong>AT指令集</strong></p><p>AT+NAME = xlg 设置蓝牙名称为xlg</p><p>AT+ROLE=0 蓝牙模式为从模式 AT+ROLE=1 蓝牙模式为主模式<br>AT+CMODE=0 蓝牙连接模式为任意地址连接模式<br>AT+PSWD=1234 蓝牙配对密码为1234<br>AT+UART=9600，0，0 蓝牙通信串口波特率为9600，停止位1位，无校验位<br>AT+RMAAD 清空配对列表</p><p>一、更改波特率<br>AT+UART=a,b,c<br>蓝牙通信串口波特率为a，<br>b:停止位1位，无校验位<br>返回响应为OK</p><p>二、修改蓝牙模块密码</p><p>修改密码的AT指令格式如下：（以修改后的密码为1314为例）</p><pre><code>        AT+PSWD=1314（这里加回车）</code></pre><p>1<br>三、修改蓝牙模块名字</p><p>修改模块名字的AT指令如下：</p><pre><code>            AT+NAME =</code></pre><p>1<br>1， AT+ROLE设置主从模式：<br>AT+ROLE=1是设成主，AT+ROLE=0是设成从，AT+ROLE=2设成回环模式Slave-Loop：被动连接，接收远程蓝 牙主设备数据并将数据原样返回给远程蓝牙<br>AT+ROLE?：查询主从状态<br>2， AT+RESET:HC-05复位</p><p>3， AT+VERSION?：获取HC-05的软件版本号，只能获取，不能修改。</p><p>4， AT+ORGL:恢复出厂默认设置，当把模块设置乱了，使用此命令进行恢复默认值。</p><p>5， AT+ADDR?：获取HC-05的蓝牙地址码，只能获取，不能修改。</p><p>6， AT+NAME？:获取HC-05的名字,AT+NAME=xlg，修改模块的名字为xlg，具体名字自行修改。</p><p>7， AT+CLASS?：设置查询设备的类型，尽量不要去修改此参数。默认是1F00。</p><p>8， AT+IAC?：查询设置查询访问码，默认是9E8B33，尽量不要去修改此参数。</p><p>9， AT+PSWD？:查询设置配对密码,AT+PSWD=”0000”,密码要有双引号,密码是四位数字.</p><p>10， AT+UART：AT+UART？是查询当前模块的波特率，AT+UART=波特率,0,0。</p><p>11， AT+CMODE：AT+CMODE？是查询当前连接模式。AT+CMODE=0，1，2(0——指定蓝牙地址连接模式（指定蓝牙地址由绑定指令设置）1——任意蓝牙地址连接模式（不受绑定指令设置地址的约束）2——回环角色（Slave-Loop）默认连接模式：0)。</p><p>12， AT+BIND:AT+BIND?查询当前绑定地址,AT+BIND=NAP，UAP，LAP(用逗号隔开)。</p><p>13， AT+RMADD:从蓝牙配对列表中删除所有认证设备.</p><p>14， AT+STATE？:获取蓝牙模块工作状态.</p><p>15， AT+LINK=NAP,UAP,LAP：与远程设备建立连接。</p><p>16， AT+DISC:断开连接.</p><p>17， AT+RNAME？NAP，UAP，LAP:获取远程蓝牙设备名称.</p><p>18， AT+ADCN?：获取蓝牙配对列表中认证设备数。</p><p>19， AT+MRAD？获取最近使用过的蓝牙认证设备地址。</p><p>20， AT+INQM:设置查询模式,AT+INQM=1，9，48(1-带RSSI信号强度指示,9-超过9个蓝牙设备响应则终止查询,48-设定超时为48*1.28=61.44秒)</p><p><strong>ps: HC05模块的AT指令，蓝牙命名AT+NAME= 以及密码设置AT+PSWD= 需要加双引号！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;库函数解释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#库函数解释&quot;&gt;&lt;/a&gt; 库函数解释&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;结构体初始化配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void USART_DeInit</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="串口" scheme="https://szturin.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="蓝牙" scheme="https://szturin.github.io/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】红外通信系统</title>
    <link href="https://szturin.github.io/posts/29338/"/>
    <id>https://szturin.github.io/posts/29338/</id>
    <published>2024-05-11T06:32:46.000Z</published>
    <updated>2024-09-03T08:44:38.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> # 前言</h1><h2 id="一-红外通信系统"><a class="markdownIt-Anchor" href="#一-红外通信系统"></a> 一、红外通信系统</h2><h3 id="二-红外调制解调的原理"><a class="markdownIt-Anchor" href="#二-红外调制解调的原理"></a> 二、红外调制解调的原理</h3><ul><li>空闲状态：红外LED不亮，接收头输出高电平</li><li>发送低电平：红外LED以38KHz频率闪烁发光，接收头输出低电平</li><li>发送高电平：红外LED不亮，接收头输出高电平<br>总而言之，只有红外LED发送38KHZ的闪烁信号时，红外接收头OUT引脚才会对外输出低电平信号<br>红外发送–红外接收的本质是<mark>调制</mark>和<mark>解调</mark>，在这种条件下，可以过滤掉自然界中的“噪声信号”，只有38KHZ附近的红外信号才能被红外接收头识别转换为对应的低电平。</li></ul><p><strong>转换示意图：</strong><br>1.红外LED发出的信号</p><img src="/posts/29338/c97d453d8866482a8bc0a2191a565288.png" class="" title="在这里插入图片描述"><p>2.红外接收头发出的信号</p><img src="/posts/29338/3d972def937345fdb73a96eb875114b8.png" class="" title="在这里插入图片描述"><p>其中，红外接收头发出的低电平信号的宽度等价于红外LED发送的38KHz信号的时间。</p><h1 id="一-基于ccp1输入捕获模式的解调电路"><a class="markdownIt-Anchor" href="#一-基于ccp1输入捕获模式的解调电路"></a> 一、基于CCP1输入捕获模式的解调电路</h1><h2 id="1-proteus生成基带信号"><a class="markdownIt-Anchor" href="#1-proteus生成基带信号"></a> 1. Proteus生成基带信号</h2><img src="/posts/29338/image-20240511143825355.png" class="" title="image-20240511143825355"><h3 id="11脉冲最小单位"><a class="markdownIt-Anchor" href="#11脉冲最小单位"></a> 1.1脉冲最小单位</h3><img src="/posts/29338/image-20240511143912266.png" class="" title="image-20240511143912266"><h3 id="12特定脉冲序列"><a class="markdownIt-Anchor" href="#12特定脉冲序列"></a> 1.2特定脉冲序列</h3><img src="/posts/29338/image-20240511143937021.png" class="" title="image-20240511143937021"><img src="/posts/29338/image-20240519153450824.png" class="" title="image-20240519153450824"><p><strong>从左往右表示数据从高位到低位，如图所示为01001101</strong></p><h3 id="13仿真结果"><a class="markdownIt-Anchor" href="#13仿真结果"></a> 1.3仿真结果</h3><img src="/posts/29338/image-20240519153542254.png" class="" title="image-20240519153542254"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;<span class="comment">//接收数据储存变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获模式接收信号跳变*/</span></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次接收信号为下跳变</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;</span><br><span class="line">CCP1CON=<span class="number">0X05</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//本次接收信号为上跳变</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0</span> &amp;&amp; CCPR1H == <span class="number">0X00</span>){B=B&lt;&lt;<span class="number">1</span>;}<span class="comment">//'0'</span></span><br><span class="line"><span class="keyword">if</span>(CCPR1L &lt; <span class="number">0X50</span> &amp;&amp; CCPR1H == <span class="number">0X01</span>){B=B&lt;&lt;<span class="number">1</span>;B=B+<span class="number">1</span>;}  <span class="comment">//'1'</span></span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0XA0</span> &amp;&amp; CCPR1H == <span class="number">0X01</span>){PORTB = B;}  <span class="comment">//结束信号，电平宽度匹配时表示完整接收到1Byte数据</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;<span class="comment">//清空寄存器</span></span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;<span class="comment">//中断相关寄存器配置</span></span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line">B=<span class="number">0</span>;TRISB=<span class="number">0</span>; PORTB=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//开启定时器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二-基于ccp1输出比较模式的基带信号生成电路"><a class="markdownIt-Anchor" href="#二-基于ccp1输出比较模式的基带信号生成电路"></a> 二、基于CCP1输出比较模式的基带信号生成电路</h1><h2 id="1mpalb波形显示窗口显示rc2产生的基带信号"><a class="markdownIt-Anchor" href="#1mpalb波形显示窗口显示rc2产生的基带信号"></a> 1.MPALB波形显示窗口，显示RC2产生的基带信号</h2><img src="/posts/29338/image-20240519155221573.png" class="" title="image-20240519155221573"><h2 id="2代码解释"><a class="markdownIt-Anchor" href="#2代码解释"></a> 2.代码解释</h2><p><strong>CCP1模块每次发送1位二进制的负脉冲宽度，每次循环从data左移一位。PIC单片机C语言循环移位语句用汇编语句asm(“rlf _data,f”)，每次将最高位移入CARRY寄存器中，以最高的程序执行效率进行数据移位并生成基带信号的操作，并且每次发送1位二进制负脉冲宽度之后，会发送1位同步头的正脉冲宽度。发送完所有二进制数据之后，发送1位结束头低电平宽度</strong></p><img src="/posts/29338/image-20240519155522173.png" class="" title="image-20240519155522173"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data,data_cnt;<span class="comment">//发送的二进制代码，代码长度</span></span><br><span class="line"><span class="type">char</span> IR_SendSelect;</span><br><span class="line">bit a;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a=!a;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RC7=<span class="number">0</span>;</span><br><span class="line">data_cnt--;<span class="comment">//低电平。二进制代码位数减1</span></span><br><span class="line"><span class="keyword">if</span>(data_cnt == <span class="number">0</span>) <span class="keyword">goto</span> period_delty;<span class="comment">//位数为0，全部发送完，转624us延时</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"rlf _data,f"</span>);<span class="comment">//未发送完，取下一位待发送数据（数据移入CARRY中）</span></span><br><span class="line"><span class="keyword">if</span>(CARRY == <span class="number">1</span>) <span class="keyword">goto</span> data_5eh;<span class="comment">//待发送数据=1</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//待发送数据=0,叠加低电平时长68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;</span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">data_5eh:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X38</span>;<span class="comment">//待发送数据=1,叠加低电平时长138H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">1</span>;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">period_delty:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X70</span>;<span class="comment">//叠加624us的延时参数270H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">2</span>;<span class="comment">//高位字节加2及低位叠加时的进位和</span></span><br><span class="line">data=<span class="number">0B</span>01001101;<span class="comment">//=PORTB //从PORTB取数据</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;</span><br><span class="line">ret_fie:</span><br><span class="line">CCP1M0=<span class="number">0</span>;<span class="comment">//下次匹配时输出高电平</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//叠加同步头的延时参数68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line">CCP1M0=<span class="number">1</span>;<span class="comment">//下次匹配时输出低电平</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">nRBPU=<span class="number">0</span>;<span class="comment">//启用RB弱上拉</span></span><br><span class="line">TRISB=<span class="number">0xFF</span>;<span class="comment">//作输入口</span></span><br><span class="line">TRISC2=<span class="number">0</span>;<span class="comment">//C口定义为输入口，只定义RC2作为输出</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;<span class="comment">//设置预分频比为 = 1:1,开中断</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;<span class="comment">//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line">CCP1CON = <span class="number">0X08</span>;<span class="comment">//CCP1设为匹配时令CCP1/RC2引脚输出高电平</span></span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//启动TMR1</span></span><br><span class="line">data = <span class="number">0B</span>01001101;<span class="comment">//=PORTB;从PORTB取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三-将基带电路与调制电路配合组成简易的红外通信系统"><a class="markdownIt-Anchor" href="#三-将基带电路与调制电路配合组成简易的红外通信系统"></a> 三、将基带电路与调制电路配合，组成简易的红外通信系统</h1><p><strong>如图所示，因为RC2输出的红外基带信号带有毛刺，所以这里改为RC7引脚输出基带信号，这样，就能组成一个完整的红外发送-接收系统，运行仿真，此时红外接收端的LED同与发送端PORTB的逻辑</strong></p><img src="/posts/29338/image-20240519161843951.png" class="" title="image-20240519161843951"><h1 id="四-配合ccp1输出比较和ccp2-pwm输出模式构成载波-调制信号"><a class="markdownIt-Anchor" href="#四-配合ccp1输出比较和ccp2-pwm输出模式构成载波-调制信号"></a> 四、配合CCP1输出比较和CCP2 PWM输出模式，构成载波-调制信号</h1><p><strong>MPLAB仿真观测调制信号，与原基带信号进行对比，验证代码现象</strong></p><p><strong>调制信号在图像上有些地方在同步头结束后为高电平，但在经过红外发送管之后，发送的信号依然对应者基带信号的波形，所以实际上并没有影响</strong></p><img src="/posts/29338/image-20240514130203460.png" class="" title="image-20240514130203460"><h1 id="五-实物测试部分"><a class="markdownIt-Anchor" href="#五-实物测试部分"></a> 五、实物测试部分</h1><h2 id="1红外二极管收发"><a class="markdownIt-Anchor" href="#1红外二极管收发"></a> 1.红外二极管收发</h2><h3 id="使用电压表测试红外接收管压降"><a class="markdownIt-Anchor" href="#使用电压表测试红外接收管压降"></a> <mark>使用电压表测试红外接收管压降</mark></h3><img src="/posts/29338/b8287e8289bf096bd5da1196ff211612.jpg" class="" title="b8287e8289bf096bd5da1196ff211612"><h2 id="2测试红外接收模块是否能被触发"><a class="markdownIt-Anchor" href="#2测试红外接收模块是否能被触发"></a> 2.测试红外接收模块是否能被触发</h2><ul><li><mark><strong>首先测试能否顺利进入中断，用PIC板载LED进行观测，每次进入中断，代表接收到一次38KHZ的红外信号，同时PIC板的八位LED进行取反闪烁</strong></mark></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;</span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line">PORTD^=<span class="number">0xFF</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">if(CCPR1L &gt; 0 &amp;&amp; CCPR1H == 0X00){B=B&lt;&lt;1;}//'0'==0x685</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X01){B=B&lt;&lt;1;B=B+1;}  //'1'==0x12C</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X02){PORTD = B;}  //结束信号==0x270</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;</span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;</span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line">B=<span class="number">0</span>;TRISD=<span class="number">0</span>; PORTD=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3仿真软件测量接收信号时选定捕捉每个bit数据的范围"><a class="markdownIt-Anchor" href="#3仿真软件测量接收信号时选定捕捉每个bit数据的范围"></a> 3.仿真软件测量接收信号时，选定捕捉每个bit数据的范围</h2><h3 id="31-程序调试使得红外传输系统更加精确稳定"><a class="markdownIt-Anchor" href="#31-程序调试使得红外传输系统更加精确稳定"></a> 3.1 程序调试，使得红外传输系统更加精确稳定</h3><p><mark><strong>虽然在红外调制电路代码中，我们指定了每个二进制数据，停止位，起始位的电平长度，但是，因为程序设计以及单片机响应速度的原因，我们并不知道它最终生成信号各个部分的电平宽度具体值，如果将编写好的程序直接拿来用，可能得不到任何想要的现象。因此，要通过测量红外解调电路实际获取到的各个二进制电平的长度（通过LCD1602显示），然后再修改程序，使得红外接收单片机能够稳定接收红外发送单片机发送的信号。</strong></mark></p><p><strong>下面为用于测试接收端接收到各个bit数据电平宽度的代码，如：控制发送端发送的数据为0x00，然后接收端这边进行对’0’的电平宽度测量，显示在LCD1602上，其他任意宽度的bit位也是同理</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;</span><br><span class="line"><span class="type">int</span> Time_Data;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//PORTD^=0xFF;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次捕捉下降沿</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;</span><br><span class="line">CCP1CON=<span class="number">0X05</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>; Time_Data = CCPR1H &lt;&lt; <span class="number">8</span> | CCPR1L;</span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0</span> &amp;&amp; CCPR1H == <span class="number">0X00</span>){LCD1602_WriteNum(<span class="number">1</span>,<span class="number">0</span>,Time_Data,<span class="number">5</span>);CCP1IE=<span class="number">0</span>;}<span class="comment">//55</span></span><br><span class="line"><span class="comment">//if(CCPR1H == 0X01){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//263</span></span><br><span class="line"><span class="comment">//if(CCPR1H == 0X02){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)//本次捕捉下降沿</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;//清零TMR1寄存器值</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//下一次捕捉上升沿</span></span><br><span class="line"><span class="comment">CCP1IF=0;//清除输入捕捉标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;//下一次捕捉下降沿</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">if(CCPR1L &gt; 0 &amp;&amp; CCPR1H == 0X00){B=B&lt;&lt;1;}//0'068</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X01){B=B&lt;&lt;1;B=B+1;}  //'1'==0x12C</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X02){PORTD = B;}  //结束信号==0x270</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISD=<span class="number">0X00</span>;<span class="comment">//数据口</span></span><br><span class="line">    TRISA=<span class="number">0x00</span>;<span class="comment">//RA0配置为输出模式</span></span><br><span class="line">ADCON1=<span class="number">0X07</span>;<span class="comment">//RA端口与AD转换有关！！！，不然无法正常显示LCD1602</span></span><br><span class="line">LCD1602_Init();</span><br><span class="line">LCD1602_WriteString(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"OK"</span>);</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;</span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;</span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line"></span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line"></span><br><span class="line">B=<span class="number">0</span>;TRISD=<span class="number">0</span>; PORTD=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/29338/image-20240514001540423.png" class="" title="image-20240514001540423"><h2 id="发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据"><a class="markdownIt-Anchor" href="#发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据"></a> 发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据</h2><p><strong>如图所示，发送连续三个Byte的一帧数据</strong></p><img src="/posts/29338/image-20240514015916078.png" class="" title="image-20240514015916078"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data,data_cnt;<span class="comment">//发送的二进制代码，代码长度</span></span><br><span class="line"><span class="type">char</span> IR_SendSelect;</span><br><span class="line"><span class="type">char</span> measure_Flag;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1_HighByte;<span class="comment">//CCP1高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1_LowByte;<span class="comment">//CCP1低字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Over_Counter=<span class="number">0</span>;<span class="comment">//溢出计数值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Over_Counter_temp;<span class="comment">//溢出计数暂存值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1IF_TriggerFlag;<span class="comment">//CCP1中断触发标志位</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> TABLE[<span class="number">16</span>]={<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>,<span class="number">0x46</span>};</span><br><span class="line"><span class="type">char</span> Send_Counter;<span class="comment">//发送字节次数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Cycle;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data_new;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Cycle;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data_M;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稳定数据滤波器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">data_filter</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">T_data_new.Data[<span class="number">0</span>]=Over_Counter;</span><br><span class="line">T_data_new.Data[<span class="number">1</span>]=CCP1_HighByte;</span><br><span class="line">T_data_new.Data[<span class="number">2</span>]=CCP1_LowByte;</span><br><span class="line"></span><br><span class="line">T_data_M.Data[i++]= T_data_new.Cycle;</span><br><span class="line">i%=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T_data_M.Data[<span class="number">0</span>]==T_data_M.Data[<span class="number">1</span>] &amp;&amp; T_data_M.Data[<span class="number">1</span>] == T_data_M.Data[<span class="number">2</span>])<span class="comment">//当三次取值相等时，才为有效值</span></span><br><span class="line">{</span><br><span class="line">T_data.Cycle=T_data_new.Cycle;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(measure_Flag == 0)//为周期测量模式</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(TMR1IF==1)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">Over_Counter_temp++;//累加TMR1的溢出次数</span></span><br><span class="line"><span class="comment">TMR1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else if(CCP1IF==1)//判断是不是由CCP1引起的中断</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1IF_TriggerFlag^=1;//标志位取反</span></span><br><span class="line"><span class="comment">if(CCP1IF_TriggerFlag==1)//第一次捕捉到跳变</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;//清除定时器0计数寄存器值</span></span><br><span class="line"><span class="comment">TMR1L=0;</span></span><br><span class="line"><span class="comment">TMR1ON=1;//定时器1开始计时</span></span><br><span class="line"><span class="comment">CCP1IF=0;//清除中断标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else//第二次捕捉到跳变</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CCP1_LowByte=CCPR1L+31;//校准值</span></span><br><span class="line"><span class="comment">CCP1_HighByte=CCPR1H+CARRY;//加上进位标志位</span></span><br><span class="line"><span class="comment">Over_Counter=Over_Counter_temp;//将计数溢出暂存值赋值给显示值</span></span><br><span class="line"><span class="comment">data_filter();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Over_Counter_temp=0;//清除计数溢出暂存值</span></span><br><span class="line"><span class="comment">TMR1H=0;//清除定时器0计数寄存器值</span></span><br><span class="line"><span class="comment">TMR1L=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">LCD1602_WriteCommand(0x80);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[0]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[0]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[1]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[1]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[2]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[2]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData('H');</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TMR1ON=0;//定时器1停止计时</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*PWM,输出比较配置</span></span><br><span class="line"><span class="comment">T2CON=0;PR2=25;TMR2=0;//TMR2初始化，周期26us</span></span><br><span class="line"><span class="comment">CCP2CON=0X0C;</span></span><br><span class="line"><span class="comment">CCPR2L=13;//CCP2初始化，脉宽13us</span></span><br><span class="line"><span class="comment">T1CON=0;//设置预分频比为 = 1:1,开中断</span></span><br><span class="line"><span class="comment">data_cnt = 0x09;//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line"><span class="comment">CCP1CON = 0X08;//CCP1设为匹配时令CCP1/RC2引脚输出电平不变</span></span><br><span class="line"><span class="comment">TMR1ON=1;//启动TMR1</span></span><br><span class="line"><span class="comment">measure_Flag=1;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(measure_Flag == <span class="number">0</span>)<span class="comment">//将测量值发送(PWM(CCP2),输出比较(CCP1))</span></span><br><span class="line">{</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCP1M0==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RC7=<span class="number">0</span>;</span><br><span class="line">CCP2CON=<span class="number">0x00</span>;</span><br><span class="line">data_cnt--;<span class="comment">//低电平。二进制代码位数减1</span></span><br><span class="line"><span class="keyword">if</span>(data_cnt == <span class="number">0</span>){<span class="keyword">goto</span> period_delty;} <span class="comment">//位数为0，全部发送完，转624us延时</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"rlf _data,f"</span>);<span class="comment">//未发送完，取下一位待发送数据（数据移入CARRY中）</span></span><br><span class="line"><span class="keyword">if</span>(CARRY == <span class="number">1</span>) <span class="keyword">goto</span> data_5eh;<span class="comment">//待发送数据=1</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X04</span>;<span class="comment">//待发送数据=0,叠加低电平时长68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">data_5eh:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X18</span>;<span class="comment">//待发送数据=1,叠加低电平时长138H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">4</span>;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">period_delty:</span><br><span class="line">Send_Counter++;</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0XC0</span>;<span class="comment">//叠加624us的延时参数270H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">9</span>;<span class="comment">//高位字节加2及低位叠加时的进位和</span></span><br><span class="line">data=<span class="number">0B</span>10101001;<span class="comment">//=PORTB //从PORTB取数据</span></span><br><span class="line">data_cnt = <span class="number">9</span>;</span><br><span class="line">ret_fie:</span><br><span class="line">CCP1M0=<span class="number">0</span>;<span class="comment">//下次匹配时输出高电平</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCP2CON=<span class="number">0X0C</span>;</span><br><span class="line">RC7=<span class="number">1</span>;TMR2ON=<span class="number">1</span>;<span class="comment">//同步头时间，启动PWM信号输出</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//叠加同步头的延时参数68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line">CCP1M0=<span class="number">1</span>;<span class="comment">//下次匹配时输出低电平</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Send_Counter &gt;= <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">Send_Counter=<span class="number">0</span>;</span><br><span class="line">measure_Flag = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CCP1IF=0;//CCP标志位清零</span></span><br><span class="line"><span class="comment">TMR1IE=1;//定时器1中断使能</span></span><br><span class="line"><span class="comment">TMR1IF=0;//定时器1中断标志位清零</span></span><br><span class="line"><span class="comment">T1CON=0B00000000;//TMR1为定时器，预分频比1:1,不启动定时器1</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//使能CCP1捕捉每一个输入信号的上升沿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">TMR1ON=<span class="number">0</span>;<span class="comment">//关闭定时器1</span></span><br><span class="line">CCP2CON=<span class="number">0X00</span>;<span class="comment">//关闭PWM</span></span><br><span class="line">CCP1CON=<span class="number">0X00</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Send_Counter=<span class="number">0</span>;</span><br><span class="line">nRBPU=<span class="number">0</span>;<span class="comment">//启用RB弱上拉</span></span><br><span class="line">TRISB=<span class="number">0xFF</span>;<span class="comment">//作输入口</span></span><br><span class="line">TRISC7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;<span class="comment">//PWM信号（载波）输出引脚</span></span><br><span class="line">TRISC2=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">TRISD=<span class="number">0X00</span>;<span class="comment">//数据口</span></span><br><span class="line">    TRISA=<span class="number">0x00</span>;<span class="comment">//RA0配置为输出模式</span></span><br><span class="line">ADCON1=<span class="number">0X07</span>;<span class="comment">//RA端口与AD转换有关！！！，不然无法正常显示LCD1602 </span></span><br><span class="line">LCD1602_Init();</span><br><span class="line">LCD1602_WriteString(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CCP中断配置*/</span></span><br><span class="line">GIE=<span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">PEIE=<span class="number">1</span>;<span class="comment">//第二梯队中断打开</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;<span class="comment">//CCP中断打开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*周期测量</span></span><br><span class="line"><span class="comment">CCP1IF=0;//CCP标志位清零</span></span><br><span class="line"><span class="comment">TMR1IE=1;//定时器1中断使能</span></span><br><span class="line"><span class="comment">TMR1IF=0;//定时器1中断标志位清零</span></span><br><span class="line"><span class="comment">T1CON=0B00000000;//TMR1为定时器，预分频比1:1,不启动定时器1</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//使能CCP1捕捉每一个输入信号的上升沿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">T2CON=<span class="number">0</span>;PR2=<span class="number">25</span>;TMR2=<span class="number">0</span>;<span class="comment">//TMR2初始化，周期26us</span></span><br><span class="line">CCP2CON=<span class="number">0X0C</span>;</span><br><span class="line">CCPR2L=<span class="number">13</span>;<span class="comment">//CCP2初始化，脉宽13us</span></span><br><span class="line">T1CON=<span class="number">0</span>;<span class="comment">//设置预分频比为 = 1:1,开中断</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;<span class="comment">//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line">CCP1CON = <span class="number">0X08</span>;<span class="comment">//CCP1设为匹配时令CCP1/RC2引脚输出电平不变</span></span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//启动TMR1</span></span><br><span class="line"></span><br><span class="line">data = PORTB;<span class="comment">//=PORTB;从PORTB取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="猜测同步头的宽窄导致信号处理出现错误数据"><a class="markdownIt-Anchor" href="#猜测同步头的宽窄导致信号处理出现错误数据"></a> 猜测：同步头的宽窄，导致信号处理出现错误数据</h2><img src="/posts/29338/image-20240514130203460.png" class="" title="image-20240514130203460"><p><strong>解决方案：<mark>调整同步头宽度。每Byte数据需要等待一定的时间</mark></strong></p><h2 id="仿真测试结果没有完整移入数据实际上只接收到了7位"><a class="markdownIt-Anchor" href="#仿真测试结果没有完整移入数据实际上只接收到了7位"></a> 仿真测试结果：没有完整移入数据，实际上只接收到了7位</h2><img src="/posts/29338/image-20240514160814051.png" class="" title="image-20240514160814051"><p><strong>更改输入捕获中断内对各个二进制捕获的电平时间范围，使得红外解调的容允值更大，修改后，代码如下</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data_RecByte;</span><br><span class="line"><span class="type">int</span> Time_Data;</span><br><span class="line">bit Data_RecFlag;</span><br><span class="line"><span class="type">char</span> i;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> TABLE[<span class="number">16</span>]={<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>,<span class="number">0x46</span>};</span><br><span class="line">bit Start_Flag;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">5</span>];</span><br><span class="line">}T_Data_Rec;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//PORTD^=0xFF;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)//本次捕捉下降沿</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;</span></span><br><span class="line"><span class="comment">CCP1IF=0; Time_Data = CCPR1H &lt;&lt; 8 | CCPR1L;</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 400  &amp;&amp; Time_Data&lt; 500){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//55</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 800  &amp;&amp; Time_Data&lt; 1000){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//263</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 2300  &amp;&amp; Time_Data&lt; 2600){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line"><span class="comment">if(Time_Data &gt; 2900 ){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次捕捉下降沿</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;<span class="comment">//清零TMR1寄存器值</span></span><br><span class="line">CCP1CON=<span class="number">0X05</span>;<span class="comment">//下一次捕捉上升沿</span></span><br><span class="line">CCP1IF=<span class="number">0</span>;<span class="comment">//清除输入捕捉标志位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//本次捕捉上升沿</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//下一次捕捉下降沿</span></span><br><span class="line">CCP1IF=<span class="number">0</span>;Time_Data = CCPR1H &lt;&lt; <span class="number">8</span> | CCPR1L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;<span class="number">3200</span>){Start_Flag=<span class="number">1</span>;}  <span class="comment">//开始信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Flag)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">400</span>  &amp;&amp; Time_Data &lt;= <span class="number">500</span>){Data_RecByte=Data_RecByte&lt;&lt;<span class="number">1</span>;}<span class="comment">//0'068</span></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">800</span>  &amp;&amp; Time_Data&lt;= <span class="number">1200</span>){Data_RecByte=Data_RecByte&lt;&lt;<span class="number">1</span>;Data_RecByte=Data_RecByte+<span class="number">1</span>;} <span class="comment">//'1'</span></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">2200</span>  &amp;&amp; Time_Data&lt;= <span class="number">2500</span>){T_Data_Rec.Data[i++] = Data_RecByte;Start_Flag=<span class="number">0</span>;}  <span class="comment">//结束信号</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">{</span><br><span class="line">LCD1602_WriteNum(<span class="number">2</span>,<span class="number">0</span>,Time_Data,<span class="number">5</span>);</span><br><span class="line">LCD1602_WriteCommand(<span class="number">0x80</span>);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">0</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">0</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">1</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">1</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">2</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">2</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">3</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">3</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">4</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">4</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(<span class="string">'H'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>最终结果：实现了连续5Byte数据的接收</strong></p><img src="/posts/29338/image-20240514160944486.png" class="" title="image-20240514160944486"><h1 id="自定义通信协议"><a class="markdownIt-Anchor" href="#自定义通信协议"></a> 自定义通信协议</h1><p><strong><mark>在完整的红外传输系统工作在稳定可靠的状态后，我们可以拓展一些功能，如自己定义一个红外传输协议，使得单片机之间的红外通信能够实现更加复杂的功能，一次性能够传输更多的数据。</mark></strong></p><ul><li><p>添加一个起始位，长度位结束位的两倍</p></li><li><p>xxxxxxxxxx&nbsp;#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#include&lt;math.h&gt;​//写一个代码,打印100~200之间的素数//素数-质数//只能被1和他本身整除​//代码优化1：//m=a<em>b;//a和b中一定至少有一个数字是 &lt;=开平方m的//16 = 2</em>8 = 4*4//所以，大于开平方m的就不需要判断是否为m的因子，减少循环执行次数​//sqrt用于计算开平方的函数 -需要用到库函数 math.h//减少了循环的执行次数​//代码优化2：//偶数不可能是素数//修改for (i = 100; i &lt;= 200; i <ins>)为for (i = 101; i &lt;= 200; i += 2)​int main(){    int i, j = 0;​    //判断i是不是质数    for (i = 101; i &lt;= 200; i += 2)    {        int flag = 1;//定义一个参数，检测i是否能被 除了1和它本身的数 整除​        for (j = 2; j &lt;= sqrt(i); j</ins>)        {            if (i % j == 0)            {                flag = 0;//如果能被2到i-1之间的整除，记录flag=0;                //break;            }        }​        if (flag == 1)//不能被2到i-1之间的数整除        {            printf("%d是质数\n", i);//那么i就是质数        }    }    return 0;}c</p><ul><li>起始位：0xC30</li><li>‘0’: 0x204</li><li>‘1’:0x418</li><li>结束位:0x9C0</li></ul></li><li><p>修改同步头宽度，因为在实际使用红外通信时，单片机产生的红外信号可能没有那么理想，红外发射头发送出去的信号会衰减，因此我们可以适当增加同步头宽度，提高红外调制信号的“功率”，使得红外接收头能够正常接收到红外信号</p></li></ul><h1 id="周期信号测量红外收发系统"><a class="markdownIt-Anchor" href="#周期信号测量红外收发系统"></a> 周期信号测量+红外收发系统</h1><img src="/posts/29338/image-20240519165157774.png" class="" title="image-20240519165157774"><h1 id="红外双发双收双工系统"><a class="markdownIt-Anchor" href="#红外双发双收双工系统"></a> 红外双发双收（双工系统）</h1><img src="/posts/29338/image-20240519170223726.png" class="" title="image-20240519170223726"><h1 id="红外双工中继基站系统"><a class="markdownIt-Anchor" href="#红外双工中继基站系统"></a> 红外双工+中继基站系统</h1><p><strong><mark>如图所示，红外收发装置通过中继系统进行数据通信</mark></strong></p><img src="/posts/29338/image-20240519173118590.png" class="" title="image-20240519173118590"><h1 id="心得体会"><a class="markdownIt-Anchor" href="#心得体会"></a> 心得体会</h1><p>我在本次小组任务中，首先学习了红外通信系统的基本组成结构，了解了通信系统中调制/解调的原理以及实现方法。基于对第九章各个例子以及习题的学习以及编写相关代码，我熟悉了CCP模块的输入捕获、输出比较、PWM模式的工作原理。通过将这些模块组合，协同工作，在代码中利用定义的各个“标志位"，配置好了这些CCP各个功能模块协同工作的代码结构。</p><p>在准备进行本次小组任务的工作前，我们首先大概预览了一下本次小组任务需要用到的知识点，因为整个红外通信系统的构成需要多个单片机协同工作，所以必须要循循渐进地进行代码的编写、调试、验证。为了设计出最终包含红外双工通信+中继器的复杂系统，我们首先编写完成了一个简易的红外通信系统，不过这个系统的信号发送端发送的是基带信号，没有经过红外管，直接送给接收端单片机进行信号的解调。虽然我们在发送端设置好了各个不同数据位的电平宽度，比如’0‘，’1‘，’停止位‘的电平宽度有按照一定的比例用于区分，但课本上一开始给的例子，各个数据位电平宽度仅仅在微妙级，不管是仿真还是实物验证接收端都有可能无法解调出正确的信号，因为这些数据位的电平宽度太短，没有明显的区分度，一旦程序运行效率不行或者单片机电路上的微小延迟都有可能造成数据读取的错误。因此，我们等比例放大了每个数据位的电平宽度，以及同步头的宽度（保证调制信号的功率）。这样的话，不同bit的区分度就大大提高了。然后，我们自己再编写一段调试代码，即接收到任意的上边沿+下边沿的输入捕获，输出端改为固定指定的数据位发送，然后在接收端那边通过LCD1602显示实际上捕获到的电平宽度，这样就能知道红外接收端实际容允的电平宽度范围，确保整个红外通信系统的稳定性。</p><p>本次小组任务，更像一个小课程设计，我们设计出了一个功能完备的红外通信系统，在每个阶段的调试过程中，我们遇到了很多的问题，这些问题大多数是由于寄存器的配置引起的（因为单片机中CCP各个模块要协同工作，这就涉及到大量寄存器的状态切换），一旦寄存器配置冲突，而我们又不熟悉寄存器，就无法认识到代码的问题所在。我们通过MPLAB强大轻量化的Debug窗口，以及Proteus的调试功能，反复验证，循序渐进，最终设计出来了一个具备双工通信+中继器（基站）的完备通信系统，并且我们的通信系统可以通过修改代码中的参数实现连续任意位Byte的收发。</p><p>本次小组任务是有挑战性的，但是这也为我们后续学习更多复杂的通信系统打下基础。我们学会了化繁为简，分模块和层次，熟练配置单片机上所有相关功能寄存器的技巧，这不仅是我们单片机编程、电路系统设计技术上的显著提升，也是对理论基础是否扎实的考验。我想，通过本次小组任务，我们可以设计出各种功能强大，效率高的通信系统，利用自身专业编写出完备的通信协议等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; # 前言&lt;/h1&gt;
&lt;h2 id=&quot;一-红外通信系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-红外通信系统&quot;&gt;&lt;/a&gt; 一、红外</summary>
      
    
    
    
    
    <category term="课程设计" scheme="https://szturin.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【HEXO】[2] 多线程部署常见问题</title>
    <link href="https://szturin.github.io/posts/45608/"/>
    <id>https://szturin.github.io/posts/45608/</id>
    <published>2024-05-03T05:10:37.000Z</published>
    <updated>2024-11-08T12:30:46.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo更新日志"><a class="markdownIt-Anchor" href="#hexo更新日志"></a> HEXO更新日志</h1><p><strong>2024.5.3</strong></p><ul><li>重要更新：将HEXO博客部署到腾讯云轻量化服务器，极大提升国内访问速度，访问ip地址：<a href="http://122.51.23.7/">Turin’s Blog - 数理照亮世界</a></li><li>优化主页文章卡片界面，参考文章：<a href="https://butterfly.zhheo.com/home.html">首页 | Butterfly主题美化教程 (zhheo.com)</a></li><li>优化网站页面显示效果：透明度。<a href="https://qianchenggit.github.io/2021/10/06/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E4%BD%BF%E7%94%A8%E4%B8%80%E5%9B%BE%E6%B5%81/">博客背景使用一图流 | QianChengGit の小森林</a></li></ul><hr><p>xxxxxxxxxx&nbsp;git remote add [alias] [url]//参数[alias]为别名， [url]为远程仓库的地址bash</p><h1 id="一-hexo部署到云服务器ubuntu系统"><a class="markdownIt-Anchor" href="#一-hexo部署到云服务器ubuntu系统"></a> 一、HEXO部署到云服务器(Ubuntu系统)</h1><p><strong><a href="https://cloud.tencent.com/developer/article/1945550">Hexo部署至服务器（Ubuntu 20.04）-腾讯云开发者社区-腾讯云 (tencent.com)</a></strong></p><p><strong><a href="https://blog.cpen.top/posts/38874.html">04_Hexo-多平台部署-云服务器-GitHub-Gitee | Mycpen</a></strong></p><h1 id="二-ubuntu允许root连接服务器"><a class="markdownIt-Anchor" href="#二-ubuntu允许root连接服务器"></a> 二、Ubuntu允许root连接服务器</h1><p><a href="https://blog.csdn.net/crayon0/article/details/122272001">Linux开启ssh并允许root登录（ubuntu、centos、kalilinux）_ssh允许root远程登录-CSDN博客</a></p><blockquote><p>报错信息 “E45: ‘readonly’ option is set (add ! to override)” 是在使用 Vim 或 Neovim 文本编辑器时可能遇到的一个错误信息。当您尝试将更改写入以只读模式打开的文件时，就会出现这条信息。这种情况可能由几个原因引起，例如，您正在编辑的文件在文件系统级别启用了写保护，或者 Vim 打开了一个它认为不应该修改的文件（例如，系统配置文件或标记为“只读”的文件）。</p><p>要解决这个问题并强制 Vim 或 Neovim 尽管文件处于只读状态也要写入更改，您可以使用 <code>:w!</code> 命令，其中 <code>w</code> 代表“写入”，<code>!</code> 实际上意味着“强制”或“覆盖”。</p><p>下面是如何处理这种情况：</p><h3 id="如果您打算修改文件"><a class="markdownIt-Anchor" href="#如果您打算修改文件"></a> 如果您打算修改文件</h3><ol><li><p><strong>强制保存更改</strong>：如果您知道文件是安全可编辑的，且打算保存更改，可以使用 <code>:w!</code> 命令强制保存更改。这告诉 Vim 覆盖只读限制。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w!</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>更改文件权限</strong>：如果文件是只读的是因为文件系统权限，您可能需要在 Vim 外部更改其权限。例如，在类 Unix 系统（Linux、macOS）上，您可以使用 <code>chmod</code> 命令使文件可写。假设文件名为 <code>example.txt</code>；您可以使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +w example.txt</span><br></pre></td></tr></tbody></table></figure><p>然后，在 Vim 内尝试再次保存文件。</p></li></ol><h3 id="如果文件应保持不变"><a class="markdownIt-Anchor" href="#如果文件应保持不变"></a> 如果文件应保持不变</h3><p>如果文件应该是只读的，且您不小心做了更改或重新考虑了您的编辑，有几个操作您可以执行：</p><ol><li><p><strong>撤销更改</strong>：通过使用 Vim 中的撤销命令 <code>u</code> 手动撤销更改，直到您恢复到文件的原始状态。</p></li><li><p><strong>不保存并退出</strong>：如果您想退出 Vim 而不保存任何更改，可以使用 <code>:q!</code> 命令，它退出 Vim 且不保存。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="理解只读文件"><a class="markdownIt-Anchor" href="#理解只读文件"></a> 理解只读文件</h3><p>在决定覆盖其只读状态之前，了解文件为什么可能处于只读模式是很重要的。文件可以因各种原因而被设置为只读：</p><ul><li>文件可能在文件系统级别被标记为只读，以防止意外更改。</li><li>文件可能属于另一个用户或需要管理员权限才能修改。</li><li>Vim 可能会在检测到文件正在被另一个进程使用时，以只读模式打开文件。</li><li>某些配置或命令（如使用 <code>vim -R &lt;filename&gt;</code> 打开文件）可以指示 Vim 以只读模式打开文件。</li></ul><p>在尝试覆盖文件的只读状态之前，始终确保修改文件是恰当的。</p></blockquote><p><strong>root终端连接效果</strong></p><img src="/posts/45608/image-20240503134748284.png" class="" title="image-20240503134748284"><h2 id="公网ip访问blog网站"><a class="markdownIt-Anchor" href="#公网ip访问blog网站"></a> 公网ip访问Blog网站</h2><img src="/posts/45608/image-20240503135033425.png" class="" title="image-20240503135033425"><p><strong>总结：使用腾讯云服务器（Unbuntu系统）部署Hexo博客，踩雷无数。此次部署博主理解了Linux服务器的详细配置流程，blog网站的访问速度得到了大幅度的提升，免受”科学上网“之苦</strong></p><h1 id="三-问题待解决"><a class="markdownIt-Anchor" href="#三-问题待解决"></a> 三、问题（待解决）</h1><h2 id="一-每次deploy需要输入服务器root密码"><a class="markdownIt-Anchor" href="#一-每次deploy需要输入服务器root密码"></a> 一、每次deploy需要输入服务器root密码</h2><ul><li><p><strong>解决方案：配置SSH公钥</strong></p></li><li><p><strong>参考文章：</strong><a href="https://zhuanlan.zhihu.com/p/549151974">Hexo历险记之八SSH远程链接服务器 - 知乎 (zhihu.com)</a></p></li></ul><p><strong>将git环境下的ssh公钥配置到服务器中的authorized_keys，并且修改sshd_config文件，配置好ssh各项权限</strong></p><img src="/posts/45608/image-20240503153851704.png" class="" title="image-20240503153851704"><p>**最终效果：**免密连接</p><img src="/posts/45608/image-20240503154119191.png" class="" title="image-20240503154119191"><p><strong>PS: 允许不同环境的终端配对的公钥可能不一样，这里使用git bash，要连接的服务器那边就需要使用git bash生成的公钥，才能实现免密登录，这样每次deploy时无需输入密码</strong></p><h2 id="二-blog域名"><a class="markdownIt-Anchor" href="#二-blog域名"></a> 二、Blog域名</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo更新日志&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hexo更新日志&quot;&gt;&lt;/a&gt; HEXO更新日志&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;2024.5.3&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重要更新：将HEXO博客部署到</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="博客搭建" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/categories/Linux/Ubuntu/"/>
    
    
    <category term="HEXO" scheme="https://szturin.github.io/tags/HEXO/"/>
    
    <category term="博客" scheme="https://szturin.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="github" scheme="https://szturin.github.io/tags/github/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/tags/Ubuntu/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【ROS2】“人在回路”---与生成式人工智能交互的视觉医疗机器人</title>
    <link href="https://szturin.github.io/posts/17498/"/>
    <id>https://szturin.github.io/posts/17498/</id>
    <published>2024-04-27T16:39:25.000Z</published>
    <updated>2024-11-08T12:01:37.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人在回路与生成式人工智能交互的视觉服务机器人"><a class="markdownIt-Anchor" href="#人在回路与生成式人工智能交互的视觉服务机器人"></a> “人在回路”—与生成式人工智能交互的视觉服务机器人</h1><p><strong>第一次更新：2024.4.28</strong></p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><ul><li>人在回路（Human-in-the-loop）是一种模式，类似于人机闭环系统或人机互助系统。这种模式被认为是机器学习、人工智能和机器智能的一种可行发展模式，需要人与机器之间的相互作用。在这种模式下，人类始终是模型的一部分，影响着模型的结果，并且需要人类的智能来帮助机器更加智能化。</li><li>ChatGPT是一款强大的基于深度学习的自然语言处理模型，能够生成高质量的自然语言文本。使用ChatGPT+TogetheROS，即ChatRobot将文字描述转化为小车控制指令，根据描述生成特定功能的代码，使机器人按照描述执行相应的任务。–转自NodeHube社区。–转自NobeHube</li></ul><h2 id="项目信息"><a class="markdownIt-Anchor" href="#项目信息"></a> 项目信息：</h2><p><strong>我们的机器人定位为医疗看护机器人（无人车），使用RDK X3 嵌入式AI开发板作为主控，通过Opencv等进行视觉识别，基于类似激光雷达测距的方法实现自主导航运动，满足不同场景下的控制需求。通过ROS2系统使小车与计算机进行通信。</strong></p><p><strong>我们计划使用OpenAI提供的API接口写入小车系统，实现初步的语音交互到控制的过程。基于搭载ROS2系统的RDK X3开发板，使用"人在回路"的模型训练方法，完善机器人行为模型的逻辑，提升机器学习的算法和模型的zhi在后续对GPT接口的开发中，我们设想可以与Chatgpt进行“人在回路”的系统训练，基本实现我们的设想目标。</strong></p><p>基于"人在回路"的模型训练：</p><p><strong>传统的机器人设计，往往是按照设定好的行为逻辑，这种设计过于机械化。而在医疗领域，传统的机器人显然不足以应对以人为核心的服务化需要。所以我们设想，利用“人在回路“的人机闭环互助系统对机器人进行训练，是否可以使得机器人简单地接近于人类的思维模式。应用在医疗服务等领域</strong></p><p><strong>人类能够根据实际情况灵活调整策略和方法，这种能力是当前机器人或人工智能难以完全实现的。通过人在回路，机器人在执行任务时可以依据人类的指示灵活调整其行为和策略，更好地适应复杂多变的环境，这就是我们设计的初步思想，虽然从技术的角度出发还有非常遥远的距离，但是我们可以通过这种方法和思想，逐步完善机器人的基本功能。</strong></p><p><mark><strong>我们将搭载地平线公司的RDK X3作为主控， 配合32位单片机与各类传感器模块进行数据交互，制作一个能够应用于医疗、后勤等领域的复杂多场景的无人车型机器人，能够先实现以下的基本功能：</strong></mark></p><ul><li><p>送药：前期阶段实现小车的所有控制部分，通过Opencv，Openmv组成双摄系统。Opencv负责深度学习相关的视觉识别，Openmv通过SPI协议与单片机进行通信，搭建基础的路径检测控制功能。==实现房号识别，自动药物配送。==中期阶段部署利用Simulink或者Gazebo进行小车的运动仿真。</p></li><li><p>自主导航：通过激光雷达进行SLAM建图，使得机器人具备在不同地环境下进行路径规划避障的功能。</p></li><li><p>语言交互：通过API接口与ChatGPT初步实现计算机的文字交互-&gt;控制小车基本运动-&gt;搭载语音模块控制ChatGPT-&gt;完成更复杂的人机交互系统（图像识别+传感器+语音模块）。</p></li><li><p>环境检测：实现小车上述的基本功能后，进行深度学习相关的视觉开发，使用时下热门的YOLO目标检测算法。能够实现对病人如：跌倒检测（识别人体关节点）等视觉应用。</p></li></ul><h2 id="队伍信息"><a class="markdownIt-Anchor" href="#队伍信息"></a> 队伍信息</h2><p><strong>我们队伍命名为FFT队，FFT即为快速傅立叶变换（Fast Fourier Transform），它是一种算法，在信号处理、图像处理、音频处理等领域广泛使用的技术，在如今5G大规模普及的时代，5G具有mMTC(超大规模机器连接)，eMBB(超低延时)的特点，”物联网“，“边缘计算”，“自动驾驶”等技术得到显著的发展。队伍成员基本为为通信系学生。FFT意为我们队伍追求高效、灵活、准确的开发学习，秉持创新思维、以赛促学的思想，能够将创意与专业知识运用在前沿领域。我们希望基于RDK X3 实现一些基于AI与物联网的idea，利用自身的专业知识，能够在本次项目中通信部分进行着重地设计，提高云平台与机器人的通信效率与可靠性。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人在回路与生成式人工智能交互的视觉服务机器人&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#人在回路与生成式人工智能交互的视觉服务机器人&quot;&gt;&lt;/a&gt; “人在回路”—与生成式人工智能交互的视觉服务机器人&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;第</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="ROS2" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ROS2/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/categories/Linux/"/>
    
    <category term="RDK X3" scheme="https://szturin.github.io/categories/RDK-X3/"/>
    
    <category term="人工智能" scheme="https://szturin.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/categories/Linux/Ubuntu/"/>
    
    <category term="ROS2" scheme="https://szturin.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/ROS2/"/>
    
    
    <category term="ROS2" scheme="https://szturin.github.io/tags/ROS2/"/>
    
    <category term="linux" scheme="https://szturin.github.io/tags/linux/"/>
    
    <category term="操作系统" scheme="https://szturin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="RDK X3" scheme="https://szturin.github.io/tags/RDK-X3/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[软件操作]仿真调试</title>
    <link href="https://szturin.github.io/posts/45531/"/>
    <id>https://szturin.github.io/posts/45531/</id>
    <published>2024-04-27T07:26:45.000Z</published>
    <updated>2024-09-03T04:42:23.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软键盘"><a class="markdownIt-Anchor" href="#软键盘"></a> 软键盘</h1><img src="/posts/45531/image-20240427152809497.png" class="" title="image-20240427152809497"><h1 id="选择使用按键的属性"><a class="markdownIt-Anchor" href="#选择使用按键的属性"></a> 选择使用按键的属性</h1><img src="/posts/45531/image-20240427152840915.png" class="" title="image-20240427152840915">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软键盘&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软键盘&quot;&gt;&lt;/a&gt; 软键盘&lt;/h1&gt;
&lt;img src=&quot;/posts/45531/image-20240427152809497.png&quot; class=&quot;&quot; title=&quot;imag</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MPLAB" scheme="https://szturin.github.io/tags/MPLAB/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[8]AD/DA转换</title>
    <link href="https://szturin.github.io/posts/56223/"/>
    <id>https://szturin.github.io/posts/56223/</id>
    <published>2024-04-23T13:49:05.000Z</published>
    <updated>2024-09-03T08:43:36.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p>void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);</p><p><strong>恢复缺省配置</strong></p><p>void ADC_DeInit(ADC_TypeDef* ADCx);</p><p><strong>ADC初始化</strong></p><p>void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>ADC上电</strong></p><p>void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>开启DMA输出信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>中断输出控制</strong></p><p>void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);</p><ul><li>用于控制某个中断能否通往NVIC</li></ul><p><strong>复位校准</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取复位校准状态</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>开始校准</strong></p><p>void ADC_StartCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取开始校准状态</strong></p><p>FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);</p><p><strong>ADC软件触发的函数</strong></p><p>void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>ADC获取软件转换状态</strong></p><p>FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);</p><ul><li><p>实际上是获取CR2的SWSTART这一位,但是SWSTART在开始ADC转换后直接清除，所以并不能通过这个函数获得是否开始转换的信息</p><img src="/posts/56223/image-20240423220300035.png" class="" title="image-20240423220300035"></li></ul><p><strong><mark>如何获取ADC是否开启的状态？</mark></strong></p><p><strong>获取标志位状态</strong></p><p>FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);</p><ul><li>可以调用这个函数,ADC_FLAG选择EOC,判断EOC标志位是否置1</li></ul><p><strong>每隔几个通道间断一次</strong></p><p>void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);</p><p><strong>是否启动间断模式</strong></p><p>void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC规则组通道配置</strong></mark></p><p>void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);</p><ul><li>ADCx</li><li>ADC_Channel：指定的通道</li><li>Rank：序列的位置</li><li>ADC_SampleTime：指定通道的采样时间</li></ul><p><strong>ADC外部触发转换控制（是否允许外部触发转换）</strong></p><p>void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC获取转换值</strong></mark></p><p>uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);</p><ul><li>获取AD转换的数据寄存器，读取转换结果</li></ul><p><strong>ADC获取双模式转换值</strong></p><p>uint32_t ADC_GetDualModeConversionValue(void);</p><p><strong>是否启动模拟看门狗</strong></p><p>void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);</p><p><strong>配置高低阈值</strong></p><p>void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);</p><p><strong>配置看门的通道</strong></p><p>void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);</p><p><strong>ADC温度传感器、内部参考电压控制</strong></p><p>void ADC_TempSensorVrefintCmd(FunctionalState NewState);</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;库函数解释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#库函数解释&quot;&gt;&lt;/a&gt; 库函数解释&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="AD/DA转换" scheme="https://szturin.github.io/tags/AD-DA%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[7]编码器接口测速</title>
    <link href="https://szturin.github.io/posts/37664/"/>
    <id>https://szturin.github.io/posts/37664/</id>
    <published>2024-04-20T14:16:11.000Z</published>
    <updated>2024-09-03T04:23:22.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h2><blockquote><p><strong>定时器编码器配置</strong></p><p>void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,<br>uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);</p><ul><li>TIMx:选择定时器</li><li>TIM_EncoderMode: 选择编码器模式，T1单独计数，T2单独计数，T1/T2同时计数</li></ul><img src="/posts/37664/image-20240420235549817.png" class="" title="image-20240420235549817"><ul><li>TIM_IC1Polarity：电平极性</li><li>TIM_IC2Polarity：电平极性  可以通过配置这两个参数，设置正相和反相</li></ul><img src="/posts/37664/image-20240420235814820.png" class="" title="image-20240420235814820"></blockquote><h2 id="编码器测计数"><a class="markdownIt-Anchor" href="#编码器测计数"></a> 编码器测计数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM3);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">1</span><span class="number">-1</span>;<span class="comment">//PSC 不分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">65536</span> - <span class="number">1</span>;<span class="comment">//ARR </span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line">TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获单元配置*/</span></span><br><span class="line"><span class="comment">/**通道1配置**/</span></span><br><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">    TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="comment">//给结构体赋初始值，防止出现不确定的状态</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发  TIM_EncoderInterfaceConfig重复配置了相同的寄存器</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line">    <span class="comment">/**通道2配置**/</span> <span class="comment">//注意：这里不需要再定义新的结构体。因为上一次的值已经写入硬件寄存器</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_2;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置编码器接口*/</span></span><br><span class="line">    TIM_EncoderInterfaceConfig(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//定时器3 ，T1T2同时使用，极性相同(上升沿/下降沿两个都是有效的)，即为正相</span></span><br><span class="line">    <span class="comment">//若要反相，那么一个配置位上升沿，一个配置为下降沿有效</span></span><br><span class="line">TIM_Cmd(TIM3,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//int16_t 表示有符号数，能把unint16_相比最高位变为了符号位,这里利用到了补码的特性</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> TIM_GetCounter(TIM3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="编码器测速"><a class="markdownIt-Anchor" href="#编码器测速"></a> 编码器测速</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关库函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#相关库函数&quot;&gt;&lt;/a&gt; 相关库函数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定时器编码器配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void TIM_EncoderI</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="输入捕获" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/"/>
    
    <category term="输出比较" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83/"/>
    
  </entry>
  
</feed>
