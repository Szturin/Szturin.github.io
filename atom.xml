<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Turin&#39;s Blog</title>
  
  <subtitle>数理照亮世界</subtitle>
  <link href="https://szturin.github.io/atom.xml" rel="self"/>
  
  <link href="https://szturin.github.io/"/>
  <updated>2024-10-16T14:53:36.811Z</updated>
  <id>https://szturin.github.io/</id>
  
  <author>
    <name>Szturin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【stm32单片机】[操作系统][RT-Thread][1]内核与线程</title>
    <link href="https://szturin.github.io/posts/64776/"/>
    <id>https://szturin.github.io/posts/64776/</id>
    <published>2024-10-16T14:17:26.000Z</published>
    <updated>2024-10-16T14:53:36.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="裸机开发与操作系统的区别"><a class="markdownIt-Anchor" href="#裸机开发与操作系统的区别"></a> 裸机开发与操作系统的区别</h1><h2 id="裸机开发"><a class="markdownIt-Anchor" href="#裸机开发"></a> 裸机开发</h2><ul><li>单一任务（阻塞式）</li><li>手动分配资源</li><li>缺乏抽象层</li><li>灵活性、实时性较高</li></ul><h2 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h2><ul><li>多任务调度</li><li>自动资源管理</li><li>硬件抽象层</li></ul><h1 id="线程的概念"><a class="markdownIt-Anchor" href="#线程的概念"></a> 线程的概念</h1><p>在RT-thread中，线程是最小的工作单元。每个线程负责一个任务。RT-Thread根据线程的优先级决定哪个任务先完成.。</p><p>RT-Thread 支持多达 256 个优先级。0是最高的优先级。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;裸机开发与操作系统的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#裸机开发与操作系统的区别&quot;&gt;&lt;/a&gt; 裸机开发与操作系统的区别&lt;/h1&gt;
&lt;h2 id=&quot;裸机开发&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【嵌入式】[Keil5使用技巧][1]Debug使用</title>
    <link href="https://szturin.github.io/posts/10027/"/>
    <id>https://szturin.github.io/posts/10027/</id>
    <published>2024-10-16T12:03:24.000Z</published>
    <updated>2024-10-16T12:26:11.044Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2024.10.16：本博客将长期维护优化</p></blockquote><h1 id="一-参考文章"><a class="markdownIt-Anchor" href="#一-参考文章"></a> 一、参考文章</h1><p><a href="https://blog.csdn.net/yli001/article/details/130505875">Keil5软件使用-进阶调试篇_keil调试教程-CSDN博客</a></p><p><a href="https://blog.csdn.net/ylzmm/article/details/78902443">keil5软件仿真波形以及出现unknown signal的解决方法_unknown signal.-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2024.10.16：本博客将长期维护优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一-参考文章&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-参考文章&quot;&gt;&lt;/a&gt; 一、参考文章&lt;/h1&gt;
&lt;p&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】-Hal库-嵌入式-6-PWM、输入捕获</title>
    <link href="https://szturin.github.io/posts/12030/"/>
    <id>https://szturin.github.io/posts/12030/</id>
    <published>2024-10-15T13:54:15.000Z</published>
    <updated>2024-10-16T12:04:24.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="按键状态机与回调函数的封装思想"><a class="markdownIt-Anchor" href="#按键状态机与回调函数的封装思想"></a> # 按键状态机与回调函数的封装思想</h1><h1 id="一-pwm配置"><a class="markdownIt-Anchor" href="#一-pwm配置"></a> 一、PWM配置</h1><blockquote><p>生成频率为1000HZ的PWM信号，占空比可调</p></blockquote><h2 id="1-cubemx配置"><a class="markdownIt-Anchor" href="#1-cubemx配置"></a> 1. CubeMX配置</h2><ul><li>选择Internal(内部时钟)</li></ul><img src="/posts/undefined/image-20241015222342274.png" class="" title="image-20241015222342274"><p>根据CubeMX的芯片引脚图，选中引脚后的相关外设提示，可以便捷的配置定时器的作用通道</p><img src="/posts/undefined/image-20241015222740979.png" class="" title="image-20241015222216707"><p>定时器PWM相关配置项</p><p>这里50有误，应该改为500——&gt;对应50%的占空比</p><img src="/posts/undefined/image-20241015223259551.png" class="" title="image-20241015223259551"><h1 id="二-输入捕获"><a class="markdownIt-Anchor" href="#二-输入捕获"></a> 二、输入捕获</h1><h2 id="1-cubemx配置-2"><a class="markdownIt-Anchor" href="#1-cubemx配置-2"></a> 1. CubeMX配置</h2><img src="/posts/undefined/image-20241015230019438.png" class="" title="image-20241015230019438"><p><strong>Slave Mode</strong>: Reset Mode</p><ul><li><p><strong>从模式 (Slave Mode)</strong>：在定时器中，“Slave Mode” 是指定时器可以被外部信号触发或由另一个定时器控制。定时器可以通过外部输入或其他定时器的输出信号来复位、启动或停止。</p></li><li><p><strong>Reset Mode</strong>：在从模式的复位模式下，每当触发事件发生时，定时器的计数器（CNT寄存器）会被重置。这对于需要周期性重置定时器的应用很有用。</p></li></ul><p><strong>Trigger Source</strong>: TI1FP1</p><ul><li><strong>触发源 (Trigger Source)</strong>：TI1FP1 通常表示 “Timer Input 1 Filtered Pin 1”，即定时器通道1的输入引脚（TI1）的滤波信号。这个触发源指示定时器使用来自外部引脚的输入信号作为触发源。</li><li>TI1FP1 作为触发源意味着定时器的操作（如复位）将根据 TI1 引脚接收到的信号进行控制。</li></ul><p><strong>Clock Source</strong>: Internal Clock</p><ul><li><p><strong>时钟源 (Clock Source)</strong>：内部时钟意味着定时器使用微控制器内部的时钟源作为定时器的时间基准。通常，内部时钟是处理器的时钟或系统时钟（如 <code>HCLK</code> 或 <code>PCLK</code>）。</p></li><li><p>使用内部时钟意味着定时器的计数将基于微控制器的时钟频率进行递增，直到外部触发信号（例如 TI1FP1）复位它。</p></li></ul><p><strong>Channel1</strong>: Input Capture direct mode</p><ul><li><p><strong>通道1 (Channel 1)</strong>：配置为输入捕获模式意味着定时器的通道1正在监视一个外部信号（通过 TI1 引脚），并在检测到信号变化（如上升沿或下降沿）时捕获当前计数器值。</p></li><li><p><strong>Direct mode</strong>：直通模式表示信号直接进入输入捕获模块，而<mark>没有通过滤波器或其他复杂处理</mark>。这通常用于<mark>快速响应</mark>的<mark>输入捕获</mark>操作。</p></li></ul><img src="/posts/undefined/image-20241015230241742.png" class="" title="image-20241015230241742"><img src="/posts/undefined/image-20241016190503917.png" class="" title="image-20241016190503917"><p>DMA转运TIM通道1数据</p><img src="/posts/undefined/image-20241015230459480.png" class="" title="image-20241015230459480"><p>继续配置PA15</p><img src="/posts/undefined/image-20241015230709867.png" class="" title="image-20241015230709867">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;按键状态机与回调函数的封装思想&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#按键状态机与回调函数的封装思想&quot;&gt;&lt;/a&gt; # 按键状态机与回调函数的封装思想&lt;/h1&gt;
&lt;h1 id=&quot;一-pwm配置&quot;&gt;&lt;a class=&quot;markdow</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][5]IIC,RTC</title>
    <link href="https://szturin.github.io/posts/27956/"/>
    <id>https://szturin.github.io/posts/27956/</id>
    <published>2024-10-07T15:40:59.000Z</published>
    <updated>2024-10-15T03:28:55.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iic模块"><a class="markdownIt-Anchor" href="#iic模块"></a> IIC模块</h1><h2 id="一-mcp4017"><a class="markdownIt-Anchor" href="#一-mcp4017"></a> 一、MCP4017</h2><p>MCP4017 是一款由 Microchip Technology 公司生产的数字电位器。它是一种电子元件，通常用于调整电压、增益或信号强度，类似于传统的机械电位器，但可以通过数字控制来调节。</p><p>以下是 MCP4017 的一些主要特点：</p><ol><li><strong>数字电位器</strong>：MCP4017 是一个单通道的 7 位数字电位器，分辨率为 128 个不同的电阻值（2^7 = 128 步）。</li><li><strong>I²C 接口</strong>：它使用 I²C 通信协议进行控制，通过两个引脚（SCL 和 SDA）与主设备通信。I²C 是一种广泛使用的双线通信协议，适合用于低速设备。</li><li><strong>低功耗</strong>：MCP4017 设计为低功耗设备，适合需要节能的应用场景。</li><li><strong>电阻范围</strong>：MCP4017 提供了不同的电阻范围，常见的型号包括 5kΩ、10kΩ、50kΩ 和 100kΩ 等。用户可以通过 I²C 指令在这些范围内调节电阻值。</li><li><strong>非易失性存储器</strong>：该器件不带非易失性存储器（EEPROM），因此每次上电后，电位器的默认设置是中间值（即 64/128 的位置）。</li><li><strong>应用场景</strong>：MCP4017 常用于音频调节、信号处理、传感器校准等需要精确调节电阻的场合。</li></ol><h2 id="二-阅读芯片手册"><a class="markdownIt-Anchor" href="#二-阅读芯片手册"></a> 二、阅读芯片手册</h2><p>I2C地址：0101111</p><img src="/posts/27956/image-20241007234812331.png" class="" title="image-20241007234812331"><h2 id="三-hal库api"><a class="markdownIt-Anchor" href="#三-hal库api"></a> 三、Hal库API</h2><h2 id="四-cubemx配置"><a class="markdownIt-Anchor" href="#四-cubemx配置"></a> 四、CubeMX配置</h2><blockquote><h2 id="rtc"><a class="markdownIt-Anchor" href="#rtc"></a> RTC :</h2><p>STM32 的 <strong>RTC</strong>（实时时钟）是集成在 STM32 微控制器中的一个外设，用于保持时间和日期信息，即使在主系统电源断电时也能继续工作。STM32 的 RTC 是独立的、低功耗的，可以通过外部备用电源（如纽扣电池）或内置备用电源来运行。</p><h3 id="stm32-rtc-的主要功能"><a class="markdownIt-Anchor" href="#stm32-rtc-的主要功能"></a> STM32 RTC 的主要功能：</h3><ol><li><strong>实时时钟</strong>：提供年、月、日、星期、小时、分钟、秒的时间和日期计时功能。</li><li><strong>闹钟功能</strong>：STM32 的 RTC 可以设置定时闹钟，在指定时间触发事件，常用于定时唤醒或触发任务。</li><li><strong>时间戳</strong>：能够记录事件发生时的精确时间，例如在外部中断或特定事件发生时。</li><li><strong>周期性唤醒</strong>：RTC 支持通过定时唤醒系统进入低功耗模式，如待机模式或休眠模式，帮助实现低功耗设计。</li><li><strong>低功耗</strong>：RTC 在超低功耗模式下运行，可以使用独立的低速时钟源（如 LSE，外部 32.768 kHz 晶振）或内部低速时钟（LSI）。</li></ol><h3 id="rtc-的时钟源"><a class="markdownIt-Anchor" href="#rtc-的时钟源"></a> RTC 的时钟源</h3><p>STM32 的 RTC 通常依赖于一个低速的时钟源来保持准确的时间。常见的时钟源有：</p><ul><li><strong>LSE (Low-Speed External)</strong>：外部 32.768 kHz 晶振，精度高，适合精确计时。</li><li><strong>LSI (Low-Speed Internal)</strong>：内部低速 RC 振荡器，功耗低，但精度较差。</li></ul><h3 id="常见应用场景"><a class="markdownIt-Anchor" href="#常见应用场景"></a> 常见应用场景：</h3><ul><li><strong>电子钟表、日历</strong>：嵌入式系统中经常需要长时间保持准确时间的设备。</li><li><strong>低功耗设计</strong>：通过 RTC 实现系统定时唤醒和进入低功耗模式，节省电池能量。</li><li><strong>时间戳记录</strong>：在数据记录系统或日志系统中，RTC 用于标记数据生成的时间。</li></ul></blockquote><h3 id="配置rtc"><a class="markdownIt-Anchor" href="#配置rtc"></a> 配置RTC</h3><img src="/posts/27956/image-20241008003141122.png" class="" title="image-20241008003141122"><ul><li>Activate Clock Source：激活时钟源</li><li>Activate Calendar：激活日历</li></ul><h3 id="配置时钟树"><a class="markdownIt-Anchor" href="#配置时钟树"></a> 配置时钟树</h3><img src="/posts/27956/image-20241008003433105.png" class="" title="image-20241008003433105"><img src="/posts/27956/image-20241008003518489.png" class="" title="image-20241008003518489"><p>Asynchronous Predivider和Synchronous Predivider是用来分频的两个寄存器，RTC的时钟源（LSE、LSI或HSE/32）需要经过这些分频器后，才能提供给RTC时钟</p><ul><li>Asynchronous Predivider value：异步预分器值，125，通常用于降低功耗，</li><li>Synchronous Predivider value：同步预分频器值，6000，用于精确调节RTC的计时</li></ul><p>6000 x 125 = 750KHz，速度最快，精度最高</p><img src="/posts/27956/image-20241008003736355.png" class="" title="image-20241008003736355"><ul><li>二进制</li><li>时、分、秒</li></ul><h2 id="五-编写底层驱动"><a class="markdownIt-Anchor" href="#五-编写底层驱动"></a> 五、编写底层驱动</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_app.h"</span></span></span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef time;<span class="comment">//定义时间结构体</span></span><br><span class="line">RTC_DataTypeDef date;<span class="comment">//定义日期结构体</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    HAL_RTC_GetTime(&amp;hrtc,&amp;time,RTC_FORMAT_BIN);</span><br><span class="line">    HAL_RTC_GetDate(&amp;hrtc,&amp;date,RTC_FORMAT_BIN);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"bsp_system.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_proc</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>HAL库源码</strong></p><p>1.RTC数据类型</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Time structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint8_t</span> Hours;            <span class="comment">/*!&lt; Specifies the RTC Time Hour.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the RTC_HourFormat_12 is selected.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the RTC_HourFormat_24 is selected */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Minutes;          <span class="comment">/*!&lt; Specifies the RTC Time Minutes.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Seconds;          <span class="comment">/*!&lt; Specifies the RTC Time Seconds.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> TimeFormat;       <span class="comment">/*!&lt; Specifies the RTC AM/PM Time.</span></span><br><span class="line"><span class="comment">                                 This parameter can be a value of @ref RTC_AM_PM_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> SubSeconds;     <span class="comment">/*!&lt; Specifies the RTC_SSR RTC Sub Second register content.</span></span><br><span class="line"><span class="comment">                                 This parameter corresponds to a time unit range between [0-1] Second</span></span><br><span class="line"><span class="comment">                                 with [1 Sec / SecondFraction +1] granularity */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> SecondFraction;  <span class="comment">/*!&lt; Specifies the range or granularity of Sub Second register content</span></span><br><span class="line"><span class="comment">                                 corresponding to Synchronous pre-scaler factor value (PREDIV_S)</span></span><br><span class="line"><span class="comment">                                 This parameter corresponds to a time unit range between [0-1] Second</span></span><br><span class="line"><span class="comment">                                 with [1 Sec / SecondFraction +1] granularity.</span></span><br><span class="line"><span class="comment">                                 This field will be used only by HAL_RTC_GetTime function */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DayLightSaving;  <span class="comment">/*!&lt; This interface is deprecated. To manage Daylight Saving Time,</span></span><br><span class="line"><span class="comment">                                 please use HAL_RTC_DST_xxx functions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> StoreOperation;  <span class="comment">/*!&lt; This interface is deprecated. To manage Daylight Saving Time,</span></span><br><span class="line"><span class="comment">                                 please use HAL_RTC_DST_xxx functions */</span></span><br><span class="line">} RTC_TimeTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Date structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint8_t</span> WeekDay;  <span class="comment">/*!&lt; Specifies the RTC Date WeekDay.</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_WeekDay_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Month;    <span class="comment">/*!&lt; Specifies the RTC Date Month (in BCD format).</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_Month_Date_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Date;     <span class="comment">/*!&lt; Specifies the RTC Date.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Year;     <span class="comment">/*!&lt; Specifies the RTC Date Year.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */</span></span><br><span class="line">} RTC_DateTypeDef;</span><br></pre></td></tr></tbody></table></figure><p>2.RTC函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, <span class="type">uint32_t</span> Format)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">uint32_t</span> tmpreg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_RTC_FORMAT(Format));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get subseconds structure field from the corresponding register*/</span></span><br><span class="line">  sTime-&gt;SubSeconds = READ_REG(hrtc-&gt;Instance-&gt;SSR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get SecondFraction structure field from the corresponding register field*/</span></span><br><span class="line">  sTime-&gt;SecondFraction = (<span class="type">uint32_t</span>)(READ_REG(hrtc-&gt;Instance-&gt;PRER) &amp; RTC_PRER_PREDIV_S);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TR register */</span></span><br><span class="line">  tmpreg = (<span class="type">uint32_t</span>)(READ_REG(hrtc-&gt;Instance-&gt;TR) &amp; RTC_TR_RESERVED_MASK);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fill the structure fields with the read parameters */</span></span><br><span class="line">  sTime-&gt;Hours = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_HT | RTC_TR_HU)) &gt;&gt; RTC_TR_HU_Pos);</span><br><span class="line">  sTime-&gt;Minutes = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_MNT | RTC_TR_MNU)) &gt;&gt; RTC_TR_MNU_Pos);</span><br><span class="line">  sTime-&gt;Seconds = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_ST | RTC_TR_SU)) &gt;&gt; RTC_TR_SU_Pos);</span><br><span class="line">  sTime-&gt;TimeFormat = (<span class="type">uint8_t</span>)((tmpreg &amp; (RTC_TR_PM)) &gt;&gt; RTC_TR_PM_Pos);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the input parameters format */</span></span><br><span class="line">  <span class="keyword">if</span> (Format == RTC_FORMAT_BIN)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">/* Convert the time structure parameters to Binary format */</span></span><br><span class="line">    sTime-&gt;Hours = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Hours);</span><br><span class="line">    sTime-&gt;Minutes = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Minutes);</span><br><span class="line">    sTime-&gt;Seconds = (<span class="type">uint8_t</span>)RTC_Bcd2ToByte(sTime-&gt;Seconds);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HAL_OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>枚举类型：HAL_StatusTypeDef</strong></p><blockquote><p>typedef enum<br>{<br>HAL_OK       = 0x00U,<br>HAL_ERROR    = 0x01U,<br>HAL_BUSY     = 0x02U,<br>HAL_TIMEOUT  = 0x03U<br>} HAL_StatusTypeDef;</p></blockquote><p>Hal库封装的一个典型思想</p></blockquote><h2 id="多串口重定向-适合项目复用"><a class="markdownIt-Anchor" href="#多串口重定向-适合项目复用"></a> 多串口重定向-适合项目复用</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> {</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">512</span>];<span class="comment">//创建字符缓冲区</span></span><br><span class="line">    va_list arg;<span class="comment">//创建可变参数列表</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    va_start(arg, format);<span class="comment">// 初始化可变参数列表，获取my_printf传入的可变参数</span></span><br><span class="line">    len = vsnprintf(buffer, <span class="keyword">sizeof</span>(buffer), format, arg);<span class="comment">// 将格式化后的可变参数传入缓存区</span></span><br><span class="line">    va_end(arg);<span class="comment">// 结束可变参数列表</span></span><br><span class="line">    HAL_UART_Transmit(huart, (<span class="type">uint8_t</span> *)buffer, (<span class="type">uint16_t</span>)len, <span class="number">0xFF</span>); <span class="comment">// 将字符缓存数组发送出去</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iic模块&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#iic模块&quot;&gt;&lt;/a&gt; IIC模块&lt;/h1&gt;
&lt;h2 id=&quot;一-mcp4017&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-mcp4017&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【嵌入式系统】[RDK X3][1]RDK X3派基础入门</title>
    <link href="https://szturin.github.io/posts/44396/"/>
    <id>https://szturin.github.io/posts/44396/</id>
    <published>2024-10-01T15:52:54.000Z</published>
    <updated>2024-10-01T18:13:10.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-常用接口和视觉处理方法"><a class="markdownIt-Anchor" href="#一-常用接口和视觉处理方法"></a> 一、常用接口和视觉处理方法</h1><h3 id="摄像头的开启"><a class="markdownIt-Anchor" href="#摄像头的开启"></a> 摄像头的开启</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#摄像头类创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pi_Camera</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 图像初始化配置</span></span><br><span class="line">        self.Video = cv2.VideoCapture(<span class="number">8</span>, cv2.CAP_V4L2) <span class="comment"># 使能摄像头8的驱动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查摄像头是否打开</span></span><br><span class="line">        ret = self.Video.isOpened()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The video is opened."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"No video."</span>)</span><br><span class="line">    </span><br><span class="line">        codec = cv2.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>)</span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FOURCC, codec)</span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FPS, <span class="number">60</span>)  <span class="comment"># 帧数</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">640</span>)  <span class="comment"># 列 宽度</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>)  <span class="comment"># 行 高度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GuideLine</span>(<span class="params">self, c1, c2</span>):</span><br><span class="line">        ret, image = self.Video.read()<span class="comment">#注意：read返回一个bull值和图像数据list！，需要用两个变量获取</span></span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">360</span>), (<span class="number">640</span>, <span class="number">360</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)  <span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">240</span>), (<span class="number">640</span>, <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)  <span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="built_in">int</span>(c1), <span class="number">360</span>), (<span class="built_in">int</span>(c2), <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">2</span>)  <span class="comment"># 绘出倾角线</span></span><br><span class="line">            cv2.imshow(<span class="string">"GuideLine"</span>, image)</span><br></pre></td></tr></tbody></table></figure><p><strong>异常的处理：</strong><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017598873256736">错误处理 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p><strong>ret的作用：</strong></p><p>​通常是一个函数返回值的缩写，在opencv中经常用来读取函数的布尔值，判断摄像是否打开、头图像是否读取成功等，防止后续处理空值报错</p><p><strong>摄像头的驱动：</strong></p><ul><li><pre class="highlight"><code class="python">self.Video = cv2.VideoCapture(<span class="hljs-number">8</span>, cv2.CAP_V4L2)&lt;!--code￼<span class="hljs-number">1</span>--&gt;</code></pre></li></ul><h1 id="三-opencv实现色块识别"><a class="markdownIt-Anchor" href="#三-opencv实现色块识别"></a> 三、Opencv实现色块识别</h1><h1 id="rdk-x3-开发体验"><a class="markdownIt-Anchor" href="#rdk-x3-开发体验"></a> #RDK X3 开发体验</h1><p>题主目前初学Python,OpenCV,Ros2, 且对深度学习，图像处理等知识存在相当大的欠缺，基本参考RDK X3的官方手册学习，不得不说，RDK X3的官方镜像，社区生态支持做的都相当便捷，嵌入式边缘计算设备方面领域能做到对初学者如此友好的仅此一家。</p><blockquote><p>sudo bash -c ‘echo 1 &gt; /sys/devices/system/cpu/cpufreq/boost’</p></blockquote><blockquote><p>可通过<code>sudo hrut_somstatus</code>命令查看当前芯片工作频率、温度等状态：</p></blockquote><blockquote><p>供电不稳定导致X3无法正常启动，或者程序执行过程中摄像头无法正常驱动</p></blockquote><blockquote><p>驱动USB摄像头时应该确定设备号，使用<code>ls /dev/video*</code>命令查看当前的video设备</p></blockquote><blockquote><p>使用 rc.local 可以便捷配置开机自启动脚本</p></blockquote><blockquote><p>使用ros2或者tros命令应配置好环境变量</p></blockquote><blockquote><p>烧录镜像应选择稳定版本，比如 2.10 ，3.0.0beta存在一些小毛病（VNC无法正常使用）</p></blockquote><blockquote><p>vscode remote无法获得opencv imshow的图像，使用MobaXterm则正常显示X3的摄像头图像</p></blockquote><h1 id="rdk-x3多媒体"><a class="markdownIt-Anchor" href="#rdk-x3多媒体"></a> RDK X3多媒体</h1><h2 id="术语约定httpsdeveloperhorizonccdocuments_rdkmultimedia_developmentoverviewterminology"><a class="markdownIt-Anchor" href="#术语约定httpsdeveloperhorizonccdocuments_rdkmultimedia_developmentoverviewterminology"></a> 术语约定(<a href="https://developer.horizon.cc/documents_rdk/multimedia_development/overview#terminology">https://developer.horizon.cc/documents_rdk/multimedia_development/overview#terminology</a>)</h2><table><thead><tr><th>缩写</th><th>全称</th><th>解释</th></tr></thead><tbody><tr><td>VIN</td><td>Video IN</td><td>包含视频处理接入、图像信号处理器、畸变矫正和防抖处理，接收来自sensor的数据并处理，也可以直接接收内存中的图像数据</td></tr><tr><td>VPS</td><td>Video Process System</td><td>包含图像旋转、图像裁剪、缩放功能，可对同一种输入源输出不同分辨率的图像。输入源可以是VIN模块，也可以是内存中的图像数据</td></tr><tr><td>VENC</td><td>Video Encode</td><td>VENC编码模块支持H.264/H.265/JPEG/MJPEG编码，VPS模块处理后的数据可通过编码模块按不同协议编码做码流输出</td></tr><tr><td>VDEC</td><td>Video Decode</td><td>VDEC解码模块支持H.264/H.265/JPEG/MJPEG解码，可对已编码的码流进行解码，交给VPS模块做进一步处理，输出到VOT模块进行显示</td></tr><tr><td>VPU</td><td>Video Processing Unit</td><td>视频处理单元，完成视频的编解码功能</td></tr><tr><td>JPU</td><td>JPEG Processing Unit</td><td>JPEG 图片处理单元，完成JPEG、MJPEG的编解码功能</td></tr><tr><td>VOT</td><td>Video Output</td><td>视频输出模块接收VPS、VDEC的图像数据，可输出到显示设备</td></tr><tr><td>VIO</td><td>Video IN/OUT</td><td>视频输入、输出，包括VIN和VOT模块</td></tr><tr><td>MIPI</td><td>Mobile Industry Processor Interface</td><td>移动产业处理器接口</td></tr><tr><td>CSI</td><td>Camera Serial Interface</td><td>相机串行接口。CSI接口与DSI接口同属一门，都是MIPI（移动产业处理器接口联盟）制定的一种接口规范</td></tr><tr><td>DVP</td><td>Digital Video Port</td><td>数字视频端口</td></tr><tr><td>SIF</td><td>Sensor Interface</td><td>sensor接口，用来接收mipi、dvp或者内存的图像数据</td></tr><tr><td>ISP</td><td>Image Signal Processor</td><td>图像信号处理器，完成图像的效果调校</td></tr><tr><td>LDC</td><td>Lens Distortion Correction</td><td>镜头畸变校正</td></tr><tr><td>DIS</td><td>Digital Image Stabilizer</td><td>数字图像稳定</td></tr><tr><td>DWE</td><td>Dewarp Engine</td><td>畸变矫正引擎，主要是将LDC和DIS集成在一起，包括LDC的畸变矫正和DIS的统计结果</td></tr><tr><td>IPU</td><td>Image Process Unit</td><td>图像信号处理单元，支持图像的旋转、图像裁剪、缩放功能</td></tr><tr><td>GDC</td><td>Geometrical Distortion Correction</td><td>几何畸变矫正</td></tr><tr><td>PYM</td><td>Pyramid</td><td>图像金字塔</td></tr><tr><td>OSD</td><td>On Screen Display</td><td>视频图像叠层显示</td></tr><tr><td>BPU</td><td>Brain Process Unit</td><td>地平线机器人自主研发的可编程AI加速引擎</td></tr><tr><td>HAL</td><td>Hardware Abstraction Layer</td><td>硬件抽象层</td></tr><tr><td>FW</td><td>Firmware</td><td>固件</td></tr><tr><td>Sensor</td><td>Sensor</td><td>如不做特别说明，特指CMOS图像传感器</td></tr></tbody></table><h1 id="usb推理函数解释"><a class="markdownIt-Anchor" href="#usb推理函数解释"></a> USB推理函数解释</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> hobot_dnn <span class="keyword">import</span> pyeasy_dnn <span class="keyword">as</span> dnn</span><br><span class="line"><span class="keyword">from</span> hobot_vio <span class="keyword">import</span> libsrcampy <span class="keyword">as</span> srcampy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> json </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_handler</span>(<span class="params">signal, frame</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nExiting program"</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">output_tensors = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">fcos_postprocess_info = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbSysMem_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"phyAddr"</span>,ctypes.c_double),</span><br><span class="line">        (<span class="string">"virAddr"</span>,ctypes.c_void_p),</span><br><span class="line">        (<span class="string">"memSize"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNQuantiShift_yt</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"shiftLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"shiftData"</span>,ctypes.c_char_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNQuantiScale_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"scaleLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"scaleData"</span>,ctypes.POINTER(ctypes.c_float)),</span><br><span class="line">        (<span class="string">"zeroPointLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"zeroPointData"</span>,ctypes.c_char_p)</span><br><span class="line">    ]    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensorShape_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"dimensionSize"</span>,ctypes.c_int * <span class="number">8</span>),</span><br><span class="line">        (<span class="string">"numDimensions"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensorProperties_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"validShape"</span>,hbDNNTensorShape_t),</span><br><span class="line">        (<span class="string">"alignedShape"</span>,hbDNNTensorShape_t),</span><br><span class="line">        (<span class="string">"tensorLayout"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"tensorType"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"shift"</span>,hbDNNQuantiShift_yt),</span><br><span class="line">        (<span class="string">"scale"</span>,hbDNNQuantiScale_t),</span><br><span class="line">        (<span class="string">"quantiType"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"quantizeAxis"</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">"alignedByteSize"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"stride"</span>,ctypes.c_int * <span class="number">8</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensor_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"sysMem"</span>,hbSysMem_t * <span class="number">4</span>),</span><br><span class="line">        (<span class="string">"properties"</span>,hbDNNTensorProperties_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FcosPostProcessInfo_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"height"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"width"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"ori_height"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"ori_width"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"score_threshold"</span>,ctypes.c_float),</span><br><span class="line">        (<span class="string">"nms_threshold"</span>,ctypes.c_float),</span><br><span class="line">        (<span class="string">"nms_top_k"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"is_pad_resize"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libpostprocess = ctypes.CDLL(<span class="string">'/usr/lib/libpostprocess.so'</span>) </span><br><span class="line"></span><br><span class="line">get_Postprocess_result = libpostprocess.FcosPostProcess</span><br><span class="line">get_Postprocess_result.argtypes = [ctypes.POINTER(FcosPostProcessInfo_t)]  </span><br><span class="line">get_Postprocess_result.restype = ctypes.c_char_p  </span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_bboxs</span>(<span class="params">image, bboxes, classes=get_classes(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="string">"""draw the bboxes in the original image"""</span></span><br><span class="line">    <span class="comment"># 获取类别数量</span></span><br><span class="line">    num_classes = <span class="built_in">len</span>(classes)</span><br><span class="line">    <span class="comment"># 获取图像的高度、宽度和通道数</span></span><br><span class="line">    image_h, image_w, channel = image.shape</span><br><span class="line">    <span class="comment"># 生成颜色列表，每个类别一个颜色</span></span><br><span class="line">    hsv_tuples = [(<span class="number">1.0</span> * x / num_classes, <span class="number">1.</span>, <span class="number">1.</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(num_classes)]</span><br><span class="line">    colors = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: colorsys.hsv_to_rgb(*x), hsv_tuples))</span><br><span class="line">    <span class="comment"># 将颜色值转换为0-255范围内的RGB值</span></span><br><span class="line">    colors = <span class="built_in">list</span>(</span><br><span class="line">        <span class="built_in">map</span>(<span class="keyword">lambda</span> x: (<span class="built_in">int</span>(x[<span class="number">0</span>] * <span class="number">255</span>), <span class="built_in">int</span>(x[<span class="number">1</span>] * <span class="number">255</span>), <span class="built_in">int</span>(x[<span class="number">2</span>] * <span class="number">255</span>)),</span><br><span class="line">            colors))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置字体缩放比例</span></span><br><span class="line">    fontScale = <span class="number">0.5</span></span><br><span class="line">    <span class="comment"># 设置矩形框的厚度</span></span><br><span class="line">    bbox_thick = <span class="built_in">int</span>(<span class="number">0.6</span> * (image_h + image_w) / <span class="number">600</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每个检测结果</span></span><br><span class="line">    <span class="keyword">for</span> i, result <span class="keyword">in</span> <span class="built_in">enumerate</span>(bboxes):</span><br><span class="line">        <span class="comment"># 获取矩形框的位置信息</span></span><br><span class="line">        bbox = result[<span class="string">'bbox'</span>]</span><br><span class="line">        <span class="comment"># 获取检测分数</span></span><br><span class="line">        score = result[<span class="string">'score'</span>]</span><br><span class="line">        <span class="comment"># 获取类别ID</span></span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">int</span>(result[<span class="string">'id'</span>])</span><br><span class="line">        <span class="comment"># 获取类别名称</span></span><br><span class="line">        name = result[<span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将位置信息四舍五入为整数</span></span><br><span class="line">        coor = [<span class="built_in">round</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> bbox]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据类别ID获取对应的颜色</span></span><br><span class="line">        bbox_color = colors[<span class="built_in">id</span>]</span><br><span class="line">        <span class="comment"># 矩形框的两个顶点坐标</span></span><br><span class="line">        c1, c2 = (coor[<span class="number">0</span>], coor[<span class="number">1</span>]), (coor[<span class="number">2</span>], coor[<span class="number">3</span>])</span><br><span class="line">        <span class="comment"># 画矩形框</span></span><br><span class="line">        cv2.rectangle(image, c1, c2, bbox_color, bbox_thick)</span><br><span class="line">        <span class="comment"># 类别名称</span></span><br><span class="line">        classes_name = name</span><br><span class="line">        <span class="comment"># 矩形框内显示的文字</span></span><br><span class="line">        bbox_mess = <span class="string">'%s: %.2f'</span> % (classes_name, score)</span><br><span class="line">        <span class="comment"># 获取文字尺寸</span></span><br><span class="line">        t_size = cv2.getTextSize(bbox_mess,</span><br><span class="line">                                 <span class="number">0</span>,</span><br><span class="line">                                 fontScale,</span><br><span class="line">                                 thickness=bbox_thick // <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 画矩形框的填充部分，用于显示文字背景</span></span><br><span class="line">        cv2.rectangle(image, c1, (c1[<span class="number">0</span>] + t_size[<span class="number">0</span>], c1[<span class="number">1</span>] - t_size[<span class="number">1</span>] - <span class="number">3</span>),</span><br><span class="line">                      bbox_color, -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 在图像上显示文字</span></span><br><span class="line">        cv2.putText(image,</span><br><span class="line">                    bbox_mess, (c1[<span class="number">0</span>], c1[<span class="number">1</span>] - <span class="number">2</span>),</span><br><span class="line">                    cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">                    fontScale, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                    bbox_thick // <span class="number">2</span>,</span><br><span class="line">                    lineType=cv2.LINE_AA)</span><br><span class="line">        <span class="comment"># 打印检测结果</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"{} is in the picture with confidence:{:.4f}"</span>.<span class="built_in">format</span>(</span><br><span class="line">            classes_name, score))</span><br><span class="line">    <span class="comment"># 返回绘制了矩形框和文字的图像</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_display_res</span>():</span><br><span class="line">    <span class="comment"># 检查指定路径下的可执行文件是否存在，如果不存在则返回默认分辨率 1920x1080</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">"/usr/bin/get_hdmi_res"</span>) == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1920</span>, <span class="number">1080</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> subprocess</span><br><span class="line">    <span class="comment"># 使用子进程运行 get_hdmi_res 命令，获取输出</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"/usr/bin/get_hdmi_res"</span>], stdout=subprocess.PIPE)</span><br><span class="line">    result = p.communicate()</span><br><span class="line">    <span class="comment"># 将结果按逗号分割</span></span><br><span class="line">    res = result[<span class="number">0</span>].split(<span class="string">b','</span>)</span><br><span class="line">    <span class="comment"># 确保宽度和高度在合理范围内</span></span><br><span class="line">    res[<span class="number">1</span>] = <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(res[<span class="number">1</span>]), <span class="number">1920</span>), <span class="number">0</span>)</span><br><span class="line">    res[<span class="number">0</span>] = <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(res[<span class="number">0</span>]), <span class="number">1080</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(res[<span class="number">1</span>]), <span class="built_in">int</span>(res[<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get HDMI display object</span></span><br><span class="line">disp = srcampy.Display()</span><br><span class="line"><span class="comment"># For the meaning of parameters, please refer to the relevant documents of HDMI display</span></span><br><span class="line">disp_w, disp_h = get_display_res()</span><br><span class="line">disp.display(<span class="number">0</span>, disp_w, disp_h) <span class="comment"># 显示模块初始化，并配置显示参数</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 FcosPostProcessInfo_t 对象</span></span><br><span class="line">fcos_postprocess_info = FcosPostProcessInfo_t()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标图像的高度和宽度</span></span><br><span class="line">fcos_postprocess_info.height = <span class="number">512</span></span><br><span class="line">fcos_postprocess_info.width = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置原始图像的高度和宽度</span></span><br><span class="line">fcos_postprocess_info.ori_height = disp_h</span><br><span class="line">fcos_postprocess_info.ori_width = disp_w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置分数阈值，用于过滤低置信度的检测框</span></span><br><span class="line">fcos_postprocess_info.score_threshold = <span class="number">0.5</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置非极大值抑制（NMS）的阈值，用于合并重叠的检测框</span></span><br><span class="line">fcos_postprocess_info.nms_threshold = <span class="number">0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 NMS 阶段保留的检测框数量上限</span></span><br><span class="line">fcos_postprocess_info.nms_top_k = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定是否在图像调整大小时使用填充</span></span><br><span class="line">fcos_postprocess_info.is_pad_resize = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(models[<span class="number">0</span>].outputs)):</span><br><span class="line">    <span class="comment"># 设置每个输出张量的布局属性</span></span><br><span class="line">    output_tensors[i].properties.tensorLayout = get_TensorLayout(models[<span class="number">0</span>].outputs[i].properties.layout)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查输出张量的 scale_data 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(models[<span class="number">0</span>].outputs[i].properties.scale_data) == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 如果 scale_data 为空，设置量化类型为 0</span></span><br><span class="line">        output_tensors[i].properties.quantiType = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果 scale_data 不为空，设置量化类型为 2</span></span><br><span class="line">        output_tensors[i].properties.quantiType = <span class="number">2</span>  </span><br><span class="line">        <span class="comment"># 将 scale_data 重新调整形状</span></span><br><span class="line">        scale_data_tmp = models[<span class="number">0</span>].outputs[i].properties.scale_data.reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, models[<span class="number">0</span>].outputs[i].properties.shape[<span class="number">3</span>])  </span><br><span class="line">        <span class="comment"># 将 scale_data 转换为指向浮点数的指针</span></span><br><span class="line">        output_tensors[i].properties.scale.scaleData = scale_data_tmp.ctypes.data_as(ctypes.POINTER(ctypes.c_float))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置每个输出张量的有效形状和对齐形状</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(models[<span class="number">0</span>].outputs[i].properties.shape)):</span><br><span class="line">        output_tensors[i].properties.validShape.dimensionSize[j] = models[<span class="number">0</span>].outputs[i].properties.shape[j]</span><br><span class="line">        output_tensors[i].properties.alignedShape.dimensionSize[j] = models[<span class="number">0</span>].outputs[i].properties.shape[j]</span><br></pre></td></tr></tbody></table></figure><h2 id="主循环"><a class="markdownIt-Anchor" href="#主循环"></a> 主循环</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        _ ,frame = cap.read()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(frame.shape)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Failed to get image from usb camera"</span>)</span><br><span class="line">        <span class="comment"># 把图片缩放到模型的输入尺寸</span></span><br><span class="line">        <span class="comment"># 获取算法模型的输入tensor 的尺寸</span></span><br><span class="line">        h, w = models[<span class="number">0</span>].inputs[<span class="number">0</span>].properties.shape[<span class="number">2</span>], models[<span class="number">0</span>].inputs[<span class="number">0</span>].properties.shape[<span class="number">3</span>]</span><br><span class="line">        des_dim = (w, h)</span><br><span class="line">        resized_data = cv2.resize(frame, des_dim, interpolation=cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line">        nv12_data = bgr2nv12_opencv(resized_data)</span><br><span class="line"></span><br><span class="line">        t0 = time()</span><br><span class="line">        <span class="comment"># Forward</span></span><br><span class="line">        outputs = models[<span class="number">0</span>].forward(nv12_data)</span><br><span class="line">        t1 = time()</span><br><span class="line">        <span class="comment"># print("forward time is :", (t1 - t0))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Do post process</span></span><br><span class="line">        strides = [<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strides)):</span><br><span class="line">            <span class="keyword">if</span> (output_tensors[i].properties.quantiType == <span class="number">0</span>):</span><br><span class="line">                output_tensors[i].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">5</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">5</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">10</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">10</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">            <span class="keyword">else</span>:      </span><br><span class="line">                output_tensors[i].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">5</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">5</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">10</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">10</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line"></span><br><span class="line">            libpostprocess.FcosdoProcess(output_tensors[i], output_tensors[i + <span class="number">5</span>], output_tensors[i + <span class="number">10</span>], ctypes.pointer(fcos_postprocess_info), i)</span><br><span class="line"></span><br><span class="line">        result_str = get_Postprocess_result(ctypes.pointer(fcos_postprocess_info))  </span><br><span class="line">        result_str = result_str.decode(<span class="string">'utf-8'</span>)  </span><br><span class="line">        t2 = time()</span><br><span class="line">        <span class="comment"># print("FcosdoProcess time is :", (t2 - t1))</span></span><br><span class="line">        <span class="comment"># print(result_str)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># draw result</span></span><br><span class="line">        <span class="comment"># 解析JSON字符串  </span></span><br><span class="line">        data = json.loads(result_str[<span class="number">14</span>:])  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frame.shape[<span class="number">0</span>]!=disp_h <span class="keyword">or</span> frame.shape[<span class="number">1</span>]!=disp_w:</span><br><span class="line">            frame = cv2.resize(frame, (disp_w,disp_h), interpolation=cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Draw bboxs</span></span><br><span class="line">        box_bgr = draw_bboxs(frame, data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># cv2.imwrite("imf.jpg", box_bgr)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Convert to nv12 for HDMI display</span></span><br><span class="line">        box_nv12 = bgr2nv12_opencv(box_bgr)</span><br><span class="line">        disp.set_img(box_nv12.tobytes())</span><br><span class="line"></span><br><span class="line">        finish_time = time()</span><br><span class="line">        image_counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> finish_time - start_time &gt;  <span class="number">10</span>:</span><br><span class="line">            <span class="built_in">print</span>(start_time, finish_time, image_counter)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"FPS: {:.2f}"</span>.<span class="built_in">format</span>(image_counter / (finish_time - start_time)))</span><br><span class="line">            start_time = finish_time</span><br><span class="line">            image_counter = <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-常用接口和视觉处理方法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-常用接口和视觉处理方法&quot;&gt;&lt;/a&gt; 一、常用接口和视觉处理方法&lt;/h1&gt;
&lt;h3 id=&quot;摄像头的开启&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][4]ADC采集系统</title>
    <link href="https://szturin.github.io/posts/26676/"/>
    <id>https://szturin.github.io/posts/26676/</id>
    <published>2024-09-29T14:14:00.000Z</published>
    <updated>2024-10-01T18:13:10.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vscode配置stm32编译调试环境"><a class="markdownIt-Anchor" href="#vscode配置stm32编译调试环境"></a> <strong># <mark>VsCode配置STM32编译调试环境</mark></strong></h1><p><a href="https://www.bilibili.com/video/BV1BJeJehEkb/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7026df729530ac261e29b43864230918">【保姆】vscode配置单片机编译调试烧录环境（以STM32为例）_哔哩哔哩_bilibili</a></p><h1 id="一-adc采集系统"><a class="markdownIt-Anchor" href="#一-adc采集系统"></a> 一、ADC采集系统</h1><h2 id="1-adc通道外部电路"><a class="markdownIt-Anchor" href="#1-adc通道外部电路"></a> 1. ADC通道(外部电路)</h2><img src="/posts/26676/image-20241001005738016.png" class="" title="image-20241001005738016"><h2 id="2-功能要求"><a class="markdownIt-Anchor" href="#2-功能要求"></a> 2. 功能要求</h2><img src="/posts/26676/image-20241001005805205.png" class="" title="image-20241001005805205"><h2 id="3-动态窗口"><a class="markdownIt-Anchor" href="#3-动态窗口"></a> 3. <mark>动态窗口</mark></h2><img src="/posts/26676/image-20241001005817305.png" class="" title="image-20241001005817305"><p><strong>"动态"的含义：3秒的实时采集<mark>窗口</mark>随着时间自行移动，adc采集的值动态实时更新在3s的窗口数据内</strong></p><img src="/posts/26676/image-20241001010344145.png" class="" title="image-20241001010344145"><h1 id="二-功能实现"><a class="markdownIt-Anchor" href="#二-功能实现"></a> 二、功能实现</h1><h2 id="1-adc解算"><a class="markdownIt-Anchor" href="#1-adc解算"></a> 1. ADC解算</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//双通道DMA</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">adc_proc</span><span class="params">()</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) </span><br><span class="line">{</span><br><span class="line">adc_value[<span class="number">0</span>] += (<span class="type">float</span>)dma_buff[<span class="number">0</span>][i]; </span><br><span class="line">adc_value[<span class="number">1</span>] += (<span class="type">float</span>)dma_buff[<span class="number">1</span>][i];</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10进制模拟量电压</span></span><br><span class="line"><span class="comment">//adc_value[0] = adc_value[0] / 30 *3.3f / 4096; </span></span><br><span class="line"><span class="comment">//adc_value[1] = adc_value[1] / 30 *3.3f / 4096;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不对分辨率和参考电压进行解算</span></span><br><span class="line">    <span class="comment">//16进制数字量电压</span></span><br><span class="line">adc_value[<span class="number">0</span>] = adc_value[<span class="number">0</span>] / (<span class="number">30</span>+<span class="number">1</span>);</span><br><span class="line">adc_value[<span class="number">1</span>] = adc_value[<span class="number">1</span>] / (<span class="number">30</span>+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-lcd底层实现"><a class="markdownIt-Anchor" href="#2-lcd底层实现"></a> 2. LCD底层实现</h2><h3 id="21-变量定义"><a class="markdownIt-Anchor" href="#21-变量定义"></a> 2.1 <strong>变量定义</strong></h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> lcd_disp_mode;<span class="comment">//lcd显示模式</span></span><br><span class="line"><span class="type">uint16_t</span> ph_value;<span class="comment">//PH值</span></span><br><span class="line"><span class="type">uint16_t</span> pd_value;<span class="comment">//PD值</span></span><br></pre></td></tr></tbody></table></figure><p>参数界面</p><img src="/posts/26676/image-20240929225356591.png" class="" title="image-20240929225356591"><p>记录界面</p><img src="/posts/26676/image-20240929225307555.png" class="" title="image-20240929225307555"><h3 id="22-lcd进程"><a class="markdownIt-Anchor" href="#22-lcd进程"></a> 2.2 <strong>LCD进程</strong></h3><p>由于4T官方提供的LCD底层驱动，当显示的数据位数增加时，显示的位数会增加，但是当位数减小时，却不能对旧的数据进行清空。</p><p>所以这里用“空格”来覆盖刷新，达到位数减小显示缩减的效果。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span>(lcd_disp_mode){</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            LCD_Sprintf(Line1,<span class="string">"        DATA"</span>);</span><br><span class="line">            </span><br><span class="line">            LCD_Sprintf(Line3,<span class="string">"   R37:%d    "</span>,(<span class="type">int</span>)adc_value[<span class="number">0</span>]);</span><br><span class="line">            LCD_Sprintf(Line4,<span class="string">"   R38:%d    "</span>,(<span class="type">int</span>)adc_value[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="lcd背光-问题"><a class="markdownIt-Anchor" href="#lcd背光-问题"></a> #<mark>LCD背光 问题</mark></h3><p><strong>现象：如图所示，只有在对LCD写入的片段，LCD才有正常的背景</strong></p><img src="/posts/26676/3ee14bc0dc0d49a3647ae193e51b544.jpg" class="" title="3ee14bc0dc0d49a3647ae193e51b544"><p><strong>原因：未对LCD进行初始化清屏</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">system_init();</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_Clear(Black);</span><br><span class="line">LCD_SetTextColor(White);</span><br><span class="line">LCD_SetBackColor(Black);</span><br><span class="line">scheduler_init();</span><br></pre></td></tr></tbody></table></figure><p><strong>来源：lcd.c</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_Clear</span></span><br><span class="line"><span class="comment">* Description    : Clears the hole LCD.</span></span><br><span class="line"><span class="comment">* Input          : Color: the color of the background.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Clear</span><span class="params">(u16 Color)</span></span><br><span class="line">{</span><br><span class="line">    u32 index = <span class="number">0</span>;</span><br><span class="line">    LCD_SetCursor(<span class="number">0x00</span>, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; <span class="number">76800</span>; index++)</span><br><span class="line">    {</span><br><span class="line">        LCD_WR_DATA(Color);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="23-led功能和初始化状态"><a class="markdownIt-Anchor" href="#23-led功能和初始化状态"></a> 2.3 LED功能和初始化状态</h3><img src="/posts/26676/image-20241001001209075.png" class="" title="image-20241001001209075"><h3 id="24-lcd底层完整代码实现"><a class="markdownIt-Anchor" href="#24-lcd底层完整代码实现"></a> 2.4 LCD底层完整代码实现</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"bsp_system.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> lcd_disp_mode;    <span class="comment">// lcd显示模式</span></span><br><span class="line"><span class="type">uint16_t</span> ph_value = <span class="number">2000</span>; <span class="comment">// PH值</span></span><br><span class="line"><span class="type">uint16_t</span> pd_value = <span class="number">1000</span>; <span class="comment">// PD值</span></span><br><span class="line"><span class="type">uint16_t</span> vh_value;        <span class="comment">// PH值</span></span><br><span class="line"><span class="type">uint16_t</span> vd_value;        <span class="comment">// PD值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  格式化字符串并显示在指定的LCD行上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数接受一个行号和一个格式化字符串（类似于printf），</span></span><br><span class="line"><span class="comment"> * 格式化字符串后，将其显示在LCD的指定行上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  Line    要显示字符串的LCD行号。</span></span><br><span class="line"><span class="comment"> * @param  format  格式化字符串，后跟要格式化的参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数内部使用 `vsprintf` 来格式化字符串，然后</span></span><br><span class="line"><span class="comment"> * 调用 `LCD_DisplayStringLine` 在LCD上显示格式化后的字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例用法:</span></span><br><span class="line"><span class="comment"> * @code</span></span><br><span class="line"><span class="comment"> * LcdSprintf(0, "Temperature: %d C", temperature);</span></span><br><span class="line"><span class="comment"> * @endcode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdSprintf</span><span class="params">(<span class="type">uint8_t</span> Line, <span class="type">char</span> *format, ...)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> String[<span class="number">21</span>];                     <span class="comment">// 缓冲区用于存储格式化后的字符串</span></span><br><span class="line">    va_list arg;                         <span class="comment">// 参数列表用于存储可变参数</span></span><br><span class="line">    va_start(arg, format);               <span class="comment">// 使用格式化字符串初始化参数列表</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(String, format, arg);       <span class="comment">// 格式化字符串并存储在缓冲区中</span></span><br><span class="line">    va_end(arg);                         <span class="comment">// 清理参数列表</span></span><br><span class="line">    LCD_DisplayStringLine(Line, String); <span class="comment">// 在LCD的指定行显示格式化后的字符串</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (lcd_disp_mode)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//测量界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        DATA"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   R37:%d    "</span>, (<span class="type">int</span>)adc_value[<span class="number">0</span>]);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   R38:%d    "</span>, (<span class="type">int</span>)adc_value[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//参数界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        PARA"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   PH:%d    "</span>, ph_value);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   PD:%d    "</span>, pd_value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//参数界面</span></span><br><span class="line">        LcdSprintf(Line1, <span class="string">"        RECD"</span>);</span><br><span class="line">        LcdSprintf(Line3, <span class="string">"   VH:%d    "</span>, vh_value);</span><br><span class="line">        LcdSprintf(Line4, <span class="string">"   VD:%d    "</span>, vd_value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-按键底层"><a class="markdownIt-Anchor" href="#3-按键底层"></a> 3. 按键底层</h2><p>uwTick：在Systick（系统滴答定时器）中断中自增，可以用作单片机运行的时间戳</p><p><a href="https://cloud.tencent.com/developer/article/1861964">HAL库与Cubemx系列|Systick-系统滴答定时器详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h3 id="31-按键处理进程"><a class="markdownIt-Anchor" href="#31-按键处理进程"></a> 3.1 按键处理进程</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> ph_pd_flag; <span class="comment">//参数修改切换标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键处理函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数用于扫描按键的状态，并更新按键按下和释放的标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// 读取当前按键状态</span></span><br><span class="line">key_val = key_read();</span><br><span class="line"><span class="comment">// 计算按下的按键（当前按下状态与前一状态异或，并与当前状态相与）</span></span><br><span class="line">key_down = key_val &amp; (key_old ^ key_val);</span><br><span class="line"><span class="comment">// 计算释放的按键（当前未按下状态与前一状态异或，并与前一状态相与）</span></span><br><span class="line">key_up = ~key_val &amp; (key_old ^ key_val);</span><br><span class="line"><span class="comment">// 更新前一按键状态</span></span><br><span class="line">key_old = key_val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key_down == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">ph_pd_flag ^= <span class="number">1</span>;<span class="comment">//参数选择标志位取反</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lcd_disp_mode == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">key_tick = uwTick; <span class="comment">//记录按键按下时的时间</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(key_up == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(lcd_disp_mode == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(uwTick - key_tick &gt; <span class="number">2000</span>)</span><br><span class="line">{</span><br><span class="line">key_tick = <span class="number">0</span>;<span class="comment">//清理按键时间戳</span></span><br><span class="line">vd_value = vh_value = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (key_down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span> (++lcd_disp_mode == <span class="number">3</span>)<span class="comment">//模式切换</span></span><br><span class="line">{</span><br><span class="line">lcd_disp_mode = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)<span class="comment">//参数切换界面s</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//创建一个指针，根据参数选择标志位切换指向</span></span><br><span class="line"><span class="comment">//这样，使用逻辑语句和一个指针变量就可以实现对两个参数的地址指向-&gt;数据内容更改</span></span><br><span class="line"><span class="type">uint16_t</span> *p = (ph_pd_flag) ? &amp;ph_value : &amp;pd_value;</span><br><span class="line">*p += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*p &gt; <span class="number">4096</span>)</span><br><span class="line">{</span><br><span class="line">*p = <span class="number">4096</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span> (lcd_disp_mode == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> *p = (ph_pd_flag) ? &amp;ph_value : &amp;pd_value;</span><br><span class="line">*p -= <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="number">65536</span> - <span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-adc采集"><a class="markdownIt-Anchor" href="#4-adc采集"></a> 4. adc采集</h2><h3 id="41-变量定义"><a class="markdownIt-Anchor" href="#41-变量定义"></a> 4.1 变量定义</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//DMA接收缓存</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];<span class="comment">//ADC采样数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINDOWS_SIZE 3000 <span class="comment">//动态窗口的大小为3秒</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">adc_data_t</span> adc_buffer[BUFFER_SIZE];<span class="comment">//adc采集周期为100ms,动态窗口大小为3s</span></span><br><span class="line"><span class="type">int</span> buffer_start = <span class="number">0</span>;<span class="comment">//头指针</span></span><br><span class="line"><span class="type">int</span> buffer_end = <span class="number">0</span>;<span class="comment">//尾指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> vd_flag;<span class="comment">//标志位，表示当前窗口内是否检测到突变</span></span><br></pre></td></tr></tbody></table></figure><h3 id="42-添加数据到动态串口缓冲区"><a class="markdownIt-Anchor" href="#42-添加数据到动态串口缓冲区"></a> 4.2 添加数据到动态串口（缓冲区）</h3><p>本例中,ADC采样的环形缓冲区比较特殊，具备动态时间窗口的特性</p><ul><li>和一般的环形缓冲区一样，具备头指针和尾指针的概念，环形存取数据。</li><li>缓冲区具备“时间窗口”的概念，那么就要让缓冲区中最<mark>老</mark>的数据，存在时间不能超过三秒，超过则移除（实际上是写指针移位，相当于队这个无用的数据不再进行读取，环形缓冲区中读取数据，就相当于将这个数据移除缓存区，因为索引指针不会再指向这个数据。）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief添加adc采集数据，当前时间到adc缓冲区(环形)</span></span><br><span class="line"><span class="comment">  * @paramadc采集数据，当前时间，指定的buffer</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_adc_data</span><span class="params">(<span class="type">uint32_t</span> adc,<span class="type">uint32_t</span> current_time,<span class="type">adc_data_t</span> *buffer)</span></span><br><span class="line">{</span><br><span class="line">buffer[buffer_end].timestamp = current_time;<span class="comment">//记录当前时间到尾指针指向的缓冲区</span></span><br><span class="line">buffer[buffer_end].adc = adc;<span class="comment">//记录adc采集值到尾指针指向的缓冲区 </span></span><br><span class="line"></span><br><span class="line">buffer_end = (buffer_end + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//表示尾指针自加，0~30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer_end == buffer_start)<span class="comment">// 如果缓冲区满了，调整buffer_start，使得窗口始终保持在3秒内</span></span><br><span class="line">{</span><br><span class="line">buffer_start = (buffer_start + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//头指针移位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前时间是否超过窗口时间戳3秒，即操作时间超过3秒,// 移除超出3秒窗口的数据</span></span><br><span class="line"><span class="keyword">while</span>((current_time - buffer[buffer_start].timestamp &gt; WINDOWS_SIZE))</span><br><span class="line">{</span><br><span class="line">buffer_start = (buffer_start + <span class="number">1</span>) % BUFFER_SIZE;<span class="comment">//头指针移位</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="43-检查缓冲区的突变"><a class="markdownIt-Anchor" href="#43-检查缓冲区的突变"></a> 4.3 检查缓冲区的突变</h3><p>对当前窗口进行极大值，极小值的检测。</p><p>注意区分极大值，极小值和最大值最小值的区别。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief检测当前窗口是否发生ADC突变</span></span><br><span class="line"><span class="comment">  * @param突变计数，adc缓冲区</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_adc_sudden_change</span><span class="params">(<span class="type">uint16_t</span> *sudden_change_count,<span class="type">adc_data_t</span> *buffer)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> f_max = buffer[buffer_start].adc;</span><br><span class="line"><span class="comment">//uint16_t f_min = buffer[buffer_end].adc;</span></span><br><span class="line"><span class="type">uint16_t</span> f_min = buffer[buffer_start].adc;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = buffer_start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(index != buffer_end)<span class="comment">//读取完整个环形缓冲区</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//极大值</span></span><br><span class="line"><span class="keyword">if</span>(buffer[index].adc &gt; f_max)</span><br><span class="line">{</span><br><span class="line">f_max = buffer[index].adc;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//极小值</span></span><br><span class="line"><span class="keyword">if</span>(buffer[index].adc &lt; f_min)</span><br><span class="line">{</span><br><span class="line">f_min = buffer[index].adc;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//指针加1</span></span><br><span class="line">index = (index + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> diff = f_max - f_min;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测ADC突变</span></span><br><span class="line"><span class="keyword">if</span>(diff &lt; pd_value)</span><br><span class="line">{</span><br><span class="line">vd_flag = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vd_flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">vd_flag = <span class="number">0</span>;</span><br><span class="line">(*sudden_change_count) ++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ucLed[<span class="number">2</span>] = (diff &gt; pd_value)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="44-adc解析进程"><a class="markdownIt-Anchor" href="#44-adc解析进程"></a> 4.4 ADC解析进程</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_proc</span><span class="params">()</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Time_tick = HAL_GetTick();<span class="comment">//获取当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> vh_flag;<span class="comment">//超限标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对adc1,adc2两个adc通道进行数据采集</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) </span><br><span class="line">{</span><br><span class="line">adc_value[<span class="number">0</span>] += (<span class="type">float</span>)dma_buff[<span class="number">0</span>][i]; <span class="comment">//采集30次</span></span><br><span class="line">adc_value[<span class="number">1</span>] += (<span class="type">float</span>)dma_buff[<span class="number">1</span>][i]; <span class="comment">//采集30次</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">adc_value[<span class="number">0</span>] = adc_value[<span class="number">0</span>] / (<span class="number">30</span> + <span class="number">1</span>); <span class="comment">//采集30后，但是累加值是(30+1)次，因为采集30次之前本身adc_value[0]就有值</span></span><br><span class="line">adc_value[<span class="number">1</span>] = adc_value[<span class="number">1</span>] / (<span class="number">30</span> + <span class="number">1</span>); <span class="comment">//否则会出现如采集到的ADC值大于4096的现象</span></span><br><span class="line"></span><br><span class="line">add_adc_data(adc_value[<span class="number">0</span>],Time_tick,adc_buffer);<span class="comment">//将adc采集值写入缓冲区</span></span><br><span class="line">check_adc_sudden_change(&amp;vd_value,adc_buffer);<span class="comment">//判断是否发生值突变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(adc_value[<span class="number">1</span>] &lt; ph_value) </span><br><span class="line">{</span><br><span class="line">vh_flag = <span class="number">0</span>; <span class="comment">//当adc_value小于参数时，标志位才会置0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vh_flag == <span class="number">0</span>) <span class="comment">// adc_value大于参数且标志位为0</span></span><br><span class="line">{</span><br><span class="line">vh_flag = <span class="number">1</span>;<span class="comment">//标志位置1</span></span><br><span class="line">vh_value++;<span class="comment">//超限次数加1</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-led底层"><a class="markdownIt-Anchor" href="#5-led底层"></a> 5. LED底层</h2><h2 id="51-led显示进程"><a class="markdownIt-Anchor" href="#51-led显示进程"></a> 5.1 LED显示进程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief LED 显示处理函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每次调用该函数时，LED 灯根据 ucLed 数组中的值来决定是开启还是关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 显示当前 Led_Pos 位置的 LED 灯状态</span></span><br><span class="line">    ucLed[<span class="number">0</span>] = (lcd_disp_mode == <span class="number">0</span>);<span class="comment">//当前界面为数据采集时LED1点亮 </span></span><br><span class="line">    ucLed[<span class="number">1</span>] = adc_value[<span class="number">1</span>] &gt; ph_value ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ucLed[2] = (adc_value[0] &gt; pd_value);//放入窗口突变判断中</span></span><br><span class="line">    </span><br><span class="line">    led_disp(ucLed);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-串口通信"><a class="markdownIt-Anchor" href="#6-串口通信"></a> 6. 串口通信</h2><h3 id="61-串口通信进程"><a class="markdownIt-Anchor" href="#61-串口通信进程"></a> 6.1 串口通信进程</h3><p>sscanf：将stream内容取出，并根据入口参数的格式化过滤内容，取出数据</p><p>strcmp：比较两个字符串的内容</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb)) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 从环形缓冲区读取数据到读取缓冲区 </span></span><br><span class="line">ringbuffer_read(&amp;usart_rb, usart_read_buffer, usart_rb.itemCount);</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> value;</span><br><span class="line"><span class="type">uint16_t</span> *p = <span class="literal">NULL</span>;<span class="comment">//创建一个空指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sscanf</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"$PD(%hu)"</span>,&amp;value) == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">p = &amp;pd_value;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sscanf</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"$PH(%hu)"</span>,&amp;value) == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">p = &amp;ph_value;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"#VH"</span>) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VH:%d\n"</span>,vh_value);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)usart_read_buffer,<span class="string">"#VD"</span>) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VD:%d\n"</span>,vd_value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(value &lt; <span class="number">4096</span>)</span><br><span class="line">{</span><br><span class="line">*p = value; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(usart_read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * BUUFER_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vscode配置stm32编译调试环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vscode配置stm32编译调试环境&quot;&gt;&lt;/a&gt; &lt;strong&gt;# &lt;mark&gt;VsCode配置STM32编译调试环境&lt;/mark&gt;&lt;/stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【FPGA】[Quartus]补充[1]——工程创建和仿真设置</title>
    <link href="https://szturin.github.io/posts/30892/"/>
    <id>https://szturin.github.io/posts/30892/</id>
    <published>2024-09-21T15:16:04.000Z</published>
    <updated>2024-09-21T16:05:02.389Z</updated>
    
    <content type="html"><![CDATA[<p>author: sz_jmu</p><h1 id="一-新建工程"><a class="markdownIt-Anchor" href="#一-新建工程"></a> 一、新建工程</h1><img src="/posts/30892/image-20240921231843304.png" class="" title="image-20240921231843304"><hr><img src="/posts/30892/image-20240921232007449.png" class="" title="image-20240921232007449"><hr><img src="/posts/30892/image-20240921232158703.png" class="" title="image-20240921232158703"><hr><img src="/posts/30892/image-20240921232252862.png" class="" title="image-20240921232252862"><img src="/posts/30892/image-20240921232444167.png" class="" title="image-20240921232444167"><hr><img src="/posts/30892/image-20240921232539812.png" class="" title="image-20240921232539812"><hr><p>完成工程创建后，如果想要修改之前的EDA tools Settings，可以：</p><img src="/posts/30892/image-20240921232809899.png" class="" title="image-20240921232809899"><p>默认情况下没有仿真组件路径，需要手动添加</p><p>手动设置仿真软件的路径：Tools-&gt;Options</p><img src="/posts/30892/image-20240921233059815.png" class="" title="image-20240921233059815"><hr><p>创建元件</p><img src="/posts/30892/image-20240921234523862.png" class="" title="image-20240921234523862"><hr><p>新建原理图文件</p><img src="/posts/30892/image-20240921234842876.png" class="" title="image-20240921234842876"><hr><p><a href="https://www.bilibili.com/video/BV1Rc411J7FW?p=4&amp;vd_source=7026df729530ac261e29b43864230918">4.编写和编译代码 / 解决编译报错问题_哔哩哔哩_bilibili</a></p><img src="/posts/30892/image-20240921233524839.png" class="" title="image-20240921233524839"><p>将原理图设置为顶层设计实体，无需重复创建工程编译</p><p>以后在同一个工程对单个程序或者原理图进行编译时，选择为顶层设计实体即可</p><img src="/posts/30892/image-20240921235755270.png" class="" title="image-20240921235755270"><hr><img src="/posts/30892/image-20240921235550901.png" class="" title="image-20240921235550901"><h1 id="二-quartus-优化配置"><a class="markdownIt-Anchor" href="#二-quartus-优化配置"></a> 二、Quartus 优化配置</h1><h2 id="1-字体"><a class="markdownIt-Anchor" href="#1-字体"></a> 1. 字体</h2><img src="/posts/30892/image-20240921234417742.png" class="" title="image-20240921234417742"><h2 id="2-编译加速"><a class="markdownIt-Anchor" href="#2-编译加速"></a> 2. 编译加速</h2><img src="/posts/30892/image-20240922000307027.png" class="" title="image-20240922000307027">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;author: sz_jmu&lt;/p&gt;
&lt;h1 id=&quot;一-新建工程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-新建工程&quot;&gt;&lt;/a&gt; 一、新建工程&lt;/h1&gt;
&lt;img src=&quot;/posts/30892/image-202409212318</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[RM电控][1]开发板的使用与CAN总线控制3508电机</title>
    <link href="https://szturin.github.io/posts/31666/"/>
    <id>https://szturin.github.io/posts/31666/</id>
    <published>2024-09-18T15:03:22.000Z</published>
    <updated>2024-10-14T11:56:11.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-a板介绍"><a class="markdownIt-Anchor" href="#一-a板介绍"></a> 一、A板介绍*</h1><ul><li>A板外部晶振为12MHZ，最高主频为168MHZ</li></ul><h1 id="二-can总线通信原理"><a class="markdownIt-Anchor" href="#二-can总线通信原理"></a> 二、CAN总线通信原理</h1><h2 id="1-can总线是什么"><a class="markdownIt-Anchor" href="#1-can总线是什么"></a> 1. CAN总线是什么</h2><h3 id="11-can总线简介"><a class="markdownIt-Anchor" href="#11-can总线简介"></a> 1.1 CAN总线简介</h3><p>​CAN 是 Controller Area Network 的缩写，最初是汽车行业为了减少车身上的线束，而且还能进行大量数据的高速通信，由德国电气商博世公司在1986 年开发出的面向汽车的通信协议。现在，CAN 的高性能和可靠性已被认同，并被广泛地应用于工业自动化、船舶、医疗设备、工业设备等方面。RM的电机（3508、2006、6020）的控制也采用了CAN协议进行通信。<br>CAN 总线由 CAN_H 和 CAN_L 一对差分线构成，各个设备一起挂载在总线上。</p><p>参考文章：<a href="https://blog.csdn.net/weixin_54448108/article/details/125881138">【RoboMaster】从零开始控制RM电机（2）-CAN通信原理及电调通信协议_can通讯 同步触发控制电机-CSDN博客</a></p><h3 id="12-can通信的特点"><a class="markdownIt-Anchor" href="#12-can通信的特点"></a> 1.2 CAN通信的特点</h3><p><strong>1) 多主控制</strong><br>多个单元同时开始发送时，发送高优先级 ID 消息的单元可获得发送权。</p><p><strong>2) 消息的发送</strong></p><p>所有的消息由固定格式发送，标识符（Identifier 以下称为 ID）决定优先级。</p><p><strong>3) 通信速度</strong></p><p>同一CAN总线网络，所有单元必须同一通信速率。</p><h2 id="2-can通信协议"><a class="markdownIt-Anchor" href="#2-can通信协议"></a> 2. CAN通信协议</h2><h3 id="21-帧的种类"><a class="markdownIt-Anchor" href="#21-帧的种类"></a> 2.1 帧的种类</h3><p>CAN通信由五种帧类型</p><img src="/posts/31666/88d8d711fa24f37edff930d2be7b5e5d.png" class="" title="在这里插入图片描述"><p>其中数据帧和遥控帧有标准格式和扩展格式两种格式。</p><p>标准格式有 11 个位的标识符（Identifier: 以下称 ID），扩展格式有 29 个位的 ID。</p><p>控制RM电机使用标准帧。</p><h3 id="22-数据帧"><a class="markdownIt-Anchor" href="#22-数据帧"></a> 2.2 数据帧</h3><p>CAN总线数据帧的帧结构：</p><p>主要处理</p><img src="/posts/31666/7cec510a164a96bf6d346eee189c9cee.png" class="" title="在这里插入图片描述"><ol><li>帧起始<br>表示数据帧开始的段。</li><li>仲裁场<br>表示该帧优先级的段。</li><li>控制场<br>表示数据的字节数及保留位的段。</li><li>数据场<br>数据的内容，可发送 0～8 个字节的数据。</li><li>CRC 场<br>检查帧的传输错误的段。</li><li>应答场<br>表示确认正常接收的段。</li><li>帧结尾<br>表示数据帧结束的段。</li></ol><h5 id="1仲裁场"><a class="markdownIt-Anchor" href="#1仲裁场"></a> (1)仲裁场</h5><p>CAN 的 ID 分为标准 ID 和 拓展 ID 两类，每个设备都有自己独有的ID，CAN通信通过仲裁ID决定优先级。</p><h5 id="2控制场"><a class="markdownIt-Anchor" href="#2控制场"></a> (2)控制场</h5><p>控制场由 6 个位构成，表示数据段的字节数，C620电调的数据段长度为8</p><img src="/posts/31666/b63bd68d7d77e03f2e2bfed4439523e7.png" class="" title="在这里插入图片描述"><h5 id="3数据场"><a class="markdownIt-Anchor" href="#3数据场"></a> (3)数据场</h5><p>如果控制场的DLC表示为DRRR，CAN 总线的一个数据帧中所需要传输的有效数据实际上就是这 8Byte。这8字节的排列顺序为从高到低。</p><img src="/posts/31666/0519eb8c409db49546fc1b6b25fcd174.png" class="" title="在这里插入图片描述"><h1 id="三-电调通信"><a class="markdownIt-Anchor" href="#三-电调通信"></a> 三、电调通信</h1><h2 id="1-m3508m2006电机"><a class="markdownIt-Anchor" href="#1-m3508m2006电机"></a> 1. M3508&amp;M2006电机</h2><p>这两种电机代码通用</p><ul><li>M3508使用C620电调</li><li>M2006使用C610电调</li></ul><h3 id="11-单片机-数据帧-电调"><a class="markdownIt-Anchor" href="#11-单片机-数据帧-电调"></a> 1.1 单片机-&gt;数据帧-&gt;电调</h3><p>单片机向电调发送控制指令控制电调的<mark>电流输出</mark>。</p><p>一个数据帧只能给四个电机发送数据，</p><p>控制前四个电机时将ID设为 0x200</p><p>控制后四个电机时将ID设为 0x1FF</p><img src="/posts/31666/1af85c7b717809c098b68813f8100bb1.png" class="" title="img"><h3 id="12-电调-数据帧-单片机"><a class="markdownIt-Anchor" href="#12-电调-数据帧-单片机"></a> 1.2 电调-&gt;数据帧-&gt;单片机</h3><p>为了实现闭环控制，单片机需要接收电调的反馈报文得到电机的转速、机械转子角度、实时电流数据。</p><p>根据接收到的<mark>ID</mark>判断是哪一个电调的数据，电调反馈报文ID规定为 0x200+电调ID(1-8),如0x201(电调ID为1)。</p><img src="/posts/31666/89de834dbe0df93d0de87c331cc4970f.png" class="" title="在这里插入图片描述"><h2 id="2-gm6020电机"><a class="markdownIt-Anchor" href="#2-gm6020电机"></a> 2. GM6020电机</h2><h3 id="21-发送"><a class="markdownIt-Anchor" href="#21-发送"></a> 2.1 发送</h3><img src="/posts/31666/f5cec08ec56db6f2c90f9cd3b1b886b5.png" class="" title="在这里插入图片描述"><h3 id="22-接收"><a class="markdownIt-Anchor" href="#22-接收"></a> 2.2 接收</h3><img src="/posts/31666/d8dde436c117927177cdeeb6b356c8a7.png" class="" title="在这里插入图片描述"><h2 id="3-cubemx配置can总线协议"><a class="markdownIt-Anchor" href="#3-cubemx配置can总线协议"></a> 3. CubeMX配置CAN总线协议</h2><ul><li>波特率要设置成1M</li></ul><h2 id="4-程序实现"><a class="markdownIt-Anchor" href="#4-程序实现"></a> 4. 程序实现</h2><h3 id="41-can数据帧发送"><a class="markdownIt-Anchor" href="#41-can数据帧发送"></a> 4.1 CAN数据帧发送</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置并发送电机控制命令</span></span><br><span class="line"><span class="comment"> * @param hcan CAN句柄</span></span><br><span class="line"><span class="comment"> * @param STDID 标准ID</span></span><br><span class="line"><span class="comment"> * @param motor1 电机1控制值</span></span><br><span class="line"><span class="comment"> * @param motor2 电机2控制值</span></span><br><span class="line"><span class="comment"> * @param motor3 电机3控制值</span></span><br><span class="line"><span class="comment"> * @param motor4 电机4控制值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_motor_cmd</span><span class="params">(CAN_HandleTypeDef *hcan, <span class="type">uint32_t</span> STDID,</span></span><br><span class="line"><span class="params">                   <span class="type">int16_t</span> motor1, <span class="type">int16_t</span> motor2, <span class="type">int16_t</span> motor3, <span class="type">int16_t</span> motor4)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> send_mail_box;  <span class="comment">// 定义一个变量用于存储发送邮箱编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置发送消息的标识符</span></span><br><span class="line">    CANx_tx_message.StdId = STDID;</span><br><span class="line">    CANx_tx_message.IDE = CAN_ID_STD;  <span class="comment">// 标识符选择位，STD-标准帧</span></span><br><span class="line">    CANx_tx_message.RTR = CAN_RTR_DATA;  <span class="comment">// 定义帧类型</span></span><br><span class="line">    CANx_tx_message.DLC = <span class="number">0x08</span>;  <span class="comment">// 数据帧长度为8位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充要发送的数据</span></span><br><span class="line">    CANx_send_data[<span class="number">0</span>] = motor1 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">1</span>] = motor1;</span><br><span class="line">    CANx_send_data[<span class="number">2</span>] = motor2 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">3</span>] = motor2;</span><br><span class="line">    CANx_send_data[<span class="number">4</span>] = motor3 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">5</span>] = motor3;</span><br><span class="line">    CANx_send_data[<span class="number">6</span>] = motor4 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    CANx_send_data[<span class="number">7</span>] = motor4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送CAN数据</span></span><br><span class="line">    HAL_CAN_AddTxMessage(hcan, &amp;CANx_tx_message, CANx_send_data, &amp;send_mail_box);  <span class="comment">// hal库CAN发送函数：该函数用于向发送邮箱添加发送报文，并激活发送请求</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="42-can数据帧接收"><a class="markdownIt-Anchor" href="#42-can数据帧接收"></a> 4.2 CAN数据帧接收</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief CAN接收回调函数</span></span><br><span class="line"><span class="comment"> *        处理CAN接收到的数据帧</span></span><br><span class="line"><span class="comment"> * @param hcan CAN句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_CAN_RxFifo0MsgPendingCallback</span><span class="params">(CAN_HandleTypeDef *hcan)</span></span><br><span class="line">{</span><br><span class="line">    CAN_RxHeaderTypeDef RX_Header;  <span class="comment">// 定义数据帧的帧头</span></span><br><span class="line">    <span class="type">uint8_t</span> RX_BUFFER[<span class="number">8</span>];           <span class="comment">// 接收存放数据帧数据的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取CAN接收到的数据帧并存入局部变量</span></span><br><span class="line">    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &amp;RX_Header, RX_BUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断接收的是CAN1还是CAN2</span></span><br><span class="line">    <span class="keyword">if</span> (hcan == &amp;hcan1) {</span><br><span class="line">        <span class="comment">// CAN1：通过反馈数据的ID确定这一组数据存放的地址</span></span><br><span class="line">        i = RX_Header.StdId - Chassis_3508A;</span><br><span class="line">        Motor_measure_fun(&amp;Motor_measure[i], RX_BUFFER);  <span class="comment">// 调用函数把数据存入结构体数组</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (hcan == &amp;hcan2) {</span><br><span class="line">        <span class="comment">// CAN2：通过反馈数据的ID确定这一组数据存放的地址</span></span><br><span class="line">        i = RX_Header.StdId - CAN2_3508_ID1 + <span class="number">7</span>;</span><br><span class="line">        Motor_measure_fun(&amp;Motor_measure[i], RX_BUFFER);  <span class="comment">// 调用函数把数据存入结构体数组</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-a板介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-a板介绍&quot;&gt;&lt;/a&gt; 一、A板介绍*&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;A板外部晶振为12MHZ，最高主频为168MHZ&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;二-can总线通信</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【C语言进阶】[2]链表</title>
    <link href="https://szturin.github.io/posts/57564/"/>
    <id>https://szturin.github.io/posts/57564/</id>
    <published>2024-09-16T07:24:11.000Z</published>
    <updated>2024-09-16T16:00:43.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-可变数组"><a class="markdownIt-Anchor" href="#一-可变数组"></a> 一、可变数组</h1><p>编写可变数组函数库</p><ul><li>创建数组</li><li>回收数组</li><li>获取数组中单元个数</li><li>访问数组中的某个单元</li><li>增长数组长度</li></ul><img src="/posts/57564/image-20240916160733688.png" class="" title="image-20240916160733688"><p>定义Array结构体：</p><p>定义为指针类型的结构体，似乎可以简化某些函数的调用传递参数，节省内存空间？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">}*Array;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>但是，当我们在函数内部创建变量的时候，这个时候a指向的是已经存在的内存空间。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Array a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以，一般情况下，定义结构体变量不要加*，不要定义指针类型</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">}Array;</span><br><span class="line"></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span>;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a,<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a,<span class="type">int</span> more_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>函数实现：</p><p><strong>创建可变数组</strong></p><p>思考：为什么不返回指针？</p><ul><li>本地变量在函数使用后会销毁</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span></span><br><span class="line">{</span><br><span class="line">    Array a;<span class="comment">//创建本地变量</span></span><br><span class="line">    a.size = init_size;</span><br><span class="line">    a.<span class="built_in">array</span> = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*a.size);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>释放数组空间</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">a-&gt;<span class="built_in">array</span> = Null;<span class="comment">//防止重复调用，free(Null)是无害操作</span></span><br><span class="line">a-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>获取数组大小</strong></p><p>思考：为什么不直接a.size获取大小？</p><ul><li>目的：封装，保护了a的size，防止被修改，也利于后期维护</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span></span><br><span class="line">{</span><br><span class="line">   <span class="keyword">return</span> a-&gt;size; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>获取数组中对应元素的位置</strong></p><p>思考：为什么要返回int类型指针而不直接返回int</p><img src="/posts/57564/image-20240916163416339.png" class="" title="image-20240916163416339"><ul><li>使用<code>array_at(&amp;a,0)</code>取地址</li><li>使用<code>*array_at(&amp;a,0)=10;</code>可以直接进行赋值操作</li></ul><p>当然，也可以重新编写array_set，array_get两个函数，分别用于赋值和取值</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a,<span class="type">int</span> index)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> &amp;(a-&gt;<span class="built_in">array</span>[index]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>增长数组空间</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a,<span class="type">int</span> more_size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span>*p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>((<span class="type">int</span>)*(a-&gt;size+more_size));<span class="comment">//定义缓存指针，申请more_size个内存空间</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a-&gt;size;i++){</span><br><span class="line">        p[i]=a-&gt;<span class="built_in">array</span>[i];<span class="comment">//将array原本的内存空间中的值赋给p</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);<span class="comment">//释放内存空间</span></span><br><span class="line">    a-&gt;<span class="built_in">array</span> = p;<span class="comment">//将p值还原给a</span></span><br><span class="line">    a-&gt;size += more_size;<span class="comment">//增大a的size大小</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>不断写入数组内容</strong></p><img src="/posts/57564/image-20240916164843040.png" class="" title="image-20240916164843040"><p>一直循环下去，总会出现数组越界的情况。</p><p>于是，继续修改array_at</p><img src="/posts/57564/image-20240916165102244.png" class="" title="image-20240916165102244"><p>引入block概念</p><img src="/posts/57564/image-20240916165338660.png" class="" title="image-20240916165338660"><h1 id="二-可变数组的缺陷"><a class="markdownIt-Anchor" href="#二-可变数组的缺陷"></a> 二、 可变数组的缺陷</h1><ul><li>拷贝时间开销大</li><li>在内存受限的情况下，可能难以申请到更大的内存空间</li><li><img src="/posts/57564/image-20240916165754291.png" class="" title="image-20240916165754291"></li></ul><p>解决方案：<br>不去修改原来的内存空间，链接1个block即可拓展数组长度</p><img src="/posts/57564/image-20240916165911534.png" class="" title="image-20240916165911534"><h1 id="三-链表"><a class="markdownIt-Anchor" href="#三-链表"></a> 三、链表</h1><p>链表中的元素簇称为“节点”</p><p>每个节点仅包含两个部分:</p><ul><li>数据</li><li>指向下一个节点的指针</li></ul><img src="/posts/57564/image-20240916170101356.png" class="" title="image-20240916170101356"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span>{</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> <span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br></pre></td></tr></tbody></table></figure><p>思考：为什么不用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">next</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>因为在这一行还没有执行Node的类型重定义，编译器无法识别。</p><p>使用struct _node{</p><p>}定义了struct _node类型的结构体</p><p>使用typedef … Node重定义了struct _node类型</p><p>程序：循环输入数字，如果为-1则退出，</p><img src="/posts/57564/image-20240916170714369.png" class="" title="image-20240916170714369"><h2 id="1-定义head"><a class="markdownIt-Anchor" href="#1-定义head"></a> 1. 定义head</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node *head = Null;</span><br></pre></td></tr></tbody></table></figure><h2 id="2定义第一个节点"><a class="markdownIt-Anchor" href="#2定义第一个节点"></a> 2.定义第一个节点</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">p-&gt;value = number;</span><br><span class="line">p-&gt;next = Null;</span><br></pre></td></tr></tbody></table></figure><h2 id="3-定义last"><a class="markdownIt-Anchor" href="#3-定义last"></a> 3. 定义last</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node *last = head;</span><br><span class="line"><span class="keyword">while</span>(last -&gt; next)</span><br><span class="line">{</span><br><span class="line">    last = last -&gt; next;</span><br><span class="line">}</span><br><span class="line">last-&gt;next = p;</span><br></pre></td></tr></tbody></table></figure><img src="/posts/57564/image-20240916173028618.png" class="" title="image-20240916173028618"><h2 id="4-链表函数添加节点"><a class="markdownIt-Anchor" href="#4-链表函数添加节点"></a> 4. 链表函数——添加节点</h2><p>实现一个创建节点的函数：</p><p>缺点：函数内部对head进行改变，但是并不影响外部的head（PS:<mark>这里的head为指针</mark>）</p><p>tips：尽量少用全局变量</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(Node* head,<span class="type">int</span> number)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//add to linked-list</span></span><br><span class="line">    Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;value = number;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//find the last</span></span><br><span class="line">    Node *last = head;</span><br><span class="line">    <span class="keyword">if</span>(last){<span class="comment">//如果last指向非空</span></span><br><span class="line">        <span class="keyword">while</span>(last-&gt;next){<span class="comment">//last的nest指向非空</span></span><br><span class="line">            last = last-&gt;next;<span class="comment">//last等于last指向的next</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// attach</span></span><br><span class="line">        last-&gt;next = p;<span class="comment">//last指向的next等于p</span></span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        head = p;<span class="comment">//修改head</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>| |</p><p>| |</p><p>/</p><p>修改程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">add</span><span class="params">(Node* head,<span class="type">int</span> number)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//add to linked-list</span></span><br><span class="line">    Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;value = number;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//find the last</span></span><br><span class="line">    Node *last = head;</span><br><span class="line">    <span class="keyword">if</span>(last){<span class="comment">//如果last指向非空</span></span><br><span class="line">        <span class="keyword">while</span>(last-&gt;next){<span class="comment">//last的nest指向非空</span></span><br><span class="line">            last = last-&gt;next;<span class="comment">//last等于last指向的next</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// attach</span></span><br><span class="line">        last-&gt;next = p;<span class="comment">//last指向的next等于p</span></span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        head = p;<span class="comment">//修改head</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head; <span class="comment">// &lt;================= 将head返回出去</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在主程序中，即可实现改变head的操作，但是这也存在一个缺点，如果忘记调用head = …，程序会报错，封装还不够完美</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = add(...);</span><br></pre></td></tr></tbody></table></figure><p>| |</p><p>| |</p><p>/</p><p>第三种方案，传head改为传递head的指针（实际上是<mark>指针的指针</mark>）</p><p>tips：数据结构</p><p>实际上，现在这个函数，return返回值，以及主程序中的赋值都可以不进行，提高了程序的易用性，根本原因是因为pHead是head的指针，即<mark>指针的指针</mark></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">add</span><span class="params">(Node** pHead,<span class="type">int</span> number)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//add to linked-list</span></span><br><span class="line">    Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;value = number;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//find the last</span></span><br><span class="line">    Node *last = *pHead;</span><br><span class="line">    <span class="keyword">if</span>(last){<span class="comment">//如果last指向非空</span></span><br><span class="line">        <span class="keyword">while</span>(last-&gt;next){<span class="comment">//last的nest指向非空</span></span><br><span class="line">            last = last-&gt;next;<span class="comment">//last等于last指向的next</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// attach</span></span><br><span class="line">        last-&gt;next = p;<span class="comment">//last指向的next等于p</span></span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        *pHead = p;<span class="comment">//修改head</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *pHead; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>| |</p><p>| |</p><p>/</p><p>第四种方案 ，添加一个List类型结构体</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span>{</span></span><br><span class="line">    Node *head;</span><br><span class="line">}List;</span><br></pre></td></tr></tbody></table></figure><p>这样，函数可以改写为</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(List *plist,<span class="type">int</span> number)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//add to linked-list</span></span><br><span class="line">    Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;value = number;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//find the last</span></span><br><span class="line">    Node *last = plist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span>(last){<span class="comment">//如果last指向非空</span></span><br><span class="line">        <span class="keyword">while</span>(last-&gt;next){<span class="comment">//last的nest指向非空</span></span><br><span class="line">            last = last-&gt;next;<span class="comment">//last等于last指向的next</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// attach</span></span><br><span class="line">        last-&gt;next = p;<span class="comment">//last指向的next等于p</span></span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        plist-&gt;head = p;<span class="comment">//修改head</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>思考：调用这个函数，last每次都要从head开始指向，执行了没有必要的操作，如何让函数执行完之后，last指向保持上一次的指向？</p><p>| |</p><p>| |</p><p>/</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span>{</span></span><br><span class="line">    Node *head;</span><br><span class="line">    Node *tail;</span><br><span class="line">}List;</span><br></pre></td></tr></tbody></table></figure><img src="/posts/57564/image-20240916194131704.png" class="" title="image-20240916194131704"><p>实现：</p><p>在 <code>List</code> 结构体中添加一个指向链表尾节点的指针 <code>tail</code>，然后每次添加节点时，直接更新 <code>tail</code> 的指向。这样可以避免每次都从头开始遍历链表，优化了插入操作的效率。</p><h3 id="修改后的代码示例"><a class="markdownIt-Anchor" href="#修改后的代码示例"></a> 修改后的代码示例</h3><ol><li><strong>修改 <code>List</code> 结构体</strong>：添加一个 <code>tail</code> 指针，指向链表的最后一个节点。</li><li><strong>修改 <code>add</code> 函数</strong>：在每次添加新节点时，直接更新 <code>tail</code> 指针。</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(List *plist,<span class="type">int</span> number)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//add to linked-list</span></span><br><span class="line">    Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;value = number;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//find the last</span></span><br><span class="line">    <span class="keyword">if</span>(plist-&gt;tail){<span class="comment">//如果尾节点存在</span></span><br><span class="line">            plist-&gt;tail-&gt;next = p;<span class="comment">//尾节点的next指向新节点</span></span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        plist-&gt;head = p;<span class="comment">//头节点指向新节点</span></span><br><span class="line">    }</span><br><span class="line">    plist-&gt;tail = p;  <span class="comment">// 更新 tail 为新添加的节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种方式通过维护一个指向尾节点的指针，可以避免每次添加节点都从头遍历，优化了链表操作的效率。</p><h2 id="5-链表函数打印"><a class="markdownIt-Anchor" href="#5-链表函数打印"></a> 5. 链表函数——打印</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(List *<span class="built_in">list</span>)</span>{</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">for</span>(p=<span class="built_in">list</span>-&gt;head;p;p=p-&gt;next){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,p-&gt;value);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-链表函数删除"><a class="markdownIt-Anchor" href="#6-链表函数删除"></a> 6. 链表函数——删除</h2><img src="/posts/57564/image-20240916202900021.png" class="" title="image-20240916202900021"><h2 id="7-链表函数清除"><a class="markdownIt-Anchor" href="#7-链表函数清除"></a> 7. 链表函数——清除</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(List *plist)</span> {</span><br><span class="line">    Node *current = plist-&gt;head;</span><br><span class="line">    Node *nextNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) {</span><br><span class="line">        nextNode = current-&gt;next;  <span class="comment">// 保存下一个节点</span></span><br><span class="line">        <span class="built_in">free</span>(current);             <span class="comment">// 释放当前节点</span></span><br><span class="line">        current = nextNode;        <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    plist-&gt;head = <span class="literal">NULL</span>;  <span class="comment">// 清空头指针</span></span><br><span class="line">    plist-&gt;tail = <span class="literal">NULL</span>;  <span class="comment">// 清空尾指针</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-可变数组&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-可变数组&quot;&gt;&lt;/a&gt; 一、可变数组&lt;/h1&gt;
&lt;p&gt;编写可变数组函数库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建数组&lt;/li&gt;
&lt;li&gt;回收数组&lt;/li&gt;
&lt;li&gt;获取数组中单元个数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【C语言进阶】[1]指针和字符串函数</title>
    <link href="https://szturin.github.io/posts/23807/"/>
    <id>https://szturin.github.io/posts/23807/</id>
    <published>2024-09-16T07:22:33.000Z</published>
    <updated>2024-09-16T16:00:43.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-动态内存分配"><a class="markdownIt-Anchor" href="#一-动态内存分配"></a> 一、动态内存分配</h1><h2 id="1-malloc函数"><a class="markdownIt-Anchor" href="#1-malloc函数"></a> 1. malloc函数</h2><img src="/posts/23807/image-20240916153443169.png" class="" title="image-20240916153443169"><p><code>malloc</code>（memory allocation，内存分配）函数是C语言标准库中的一个函数，用于在程序运行时动态分配一块指定大小的内存区域。这块内存是在<strong>堆</strong>（heap）上分配的，与栈上的内存不同，它的生命周期由程序员控制，可以手动分配和释放。<code>malloc</code> 函数的声明在 <code>stdlib.h</code> 头文件中。</p><h3 id="malloc-的基本用法"><a class="markdownIt-Anchor" href="#malloc-的基本用法"></a> <code>malloc</code> 的基本用法</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void* malloc(size_t size);</span><br></pre></td></tr></tbody></table></figure><h4 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数：</h4><ul><li><code>size</code>: 要分配的内存大小，以字节为单位。</li></ul><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值：</h4><ul><li>成功时，返回一个指向分配内存块的指针，该指针的类型为 <code>void*</code>（可以强制转换为任何类型的指针）。</li><li>如果分配失败（比如系统内存不足），则返回 <code>NULL</code>。</li></ul><h3 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码：</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> *arr;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 malloc 动态分配一个大小为 n 的整型数组</span></span><br><span class="line">    arr = (<span class="type">int</span>*) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">// 如果 malloc 失败，arr 会返回 NULL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Memory allocation failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用分配的内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完毕后释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，<code>malloc</code> 分配了一个能容纳 5 个 <code>int</code> 类型元素的内存空间。注意，分配内存后应立即检查是否分配成功（返回值是否为 <code>NULL</code>），并且在使用完分配的内存后，应该使用 <code>free</code> 函数释放内存，以避免内存泄漏。</p><h3 id="malloc-的优点"><a class="markdownIt-Anchor" href="#malloc-的优点"></a> <code>malloc</code> 的优点</h3><ol><li><strong>灵活的内存管理</strong>：<code>malloc</code> 允许在运行时动态分配内存，尤其适用于数组大小在编译时不确定的情况。</li><li><strong>堆上的大内存</strong>：与栈不同，堆可以存储比栈更大的数据。使用 <code>malloc</code> 可以避免栈溢出，适合处理大数据或需要长期保留的数据。</li><li><strong>可移植性</strong>：<code>malloc</code> 是标准库函数，跨平台可用。</li></ol><h3 id="malloc-的缺点"><a class="markdownIt-Anchor" href="#malloc-的缺点"></a> <code>malloc</code> 的缺点</h3><ol><li><strong>手动管理内存</strong>：程序员必须手动释放内存（使用 <code>free</code> 函数）。未及时释放内存会导致内存泄漏，程序运行时间长了可能耗尽系统内存。</li><li><strong>分配失败风险</strong>：<code>malloc</code> 在分配失败时返回 <code>NULL</code>，程序员需要处理这种情况。忽略分配失败的检查可能导致程序崩溃。</li><li><strong>性能开销</strong>：动态内存分配在系统调用中有一定的性能开销，因此如果频繁分配和释放内存，性能可能受到影响。</li></ol><h3 id="常见的错误使用"><a class="markdownIt-Anchor" href="#常见的错误使用"></a> 常见的错误使用</h3><ol><li><strong>忘记释放内存</strong>：导致内存泄漏。</li><li><strong>二次释放内存</strong>：释放已经释放过的内存会导致程序运行错误。</li><li><strong>使用未初始化的内存</strong>：<code>malloc</code> 只分配内存但不初始化，需要手动初始化或使用 <code>calloc</code> 。</li></ol><p>总之，<code>malloc</code> 是C语言中用于动态内存管理的基础工具，但在使用时需要格外小心，以避免内存管理方面的错误。</p><h2 id="2-内存泄漏"><a class="markdownIt-Anchor" href="#2-内存泄漏"></a> 2. 内存泄漏</h2><img src="/posts/23807/image-20240916155054555.png" class="" title="image-20240916155054555"><p>程序作用：</p><ul><li>用malloc获取100MB内存空间，返回地址赋值给p</li><li>while循环可以分辨获取了几次空间</li></ul><h2 id="3-malloc申请的内存是否连续"><a class="markdownIt-Anchor" href="#3-malloc申请的内存是否连续"></a> 3. malloc申请的内存是否连续？</h2><p>是的，<code>malloc</code> 函数分配的内存是连续的。</p><p>在 C 语言中，<code>malloc</code> 函数用于动态分配一块指定大小的内存区域，并返回一个指向该内存块的指针。<code>malloc</code> 保证返回的内存块是连续的，即在物理内存中是相邻的一块区域。这对于许多需要内存连续性的操作非常重要，例如在处理数组、矩阵等数据结构时。</p><h2 id="4-0-null不是一个有效的地址"><a class="markdownIt-Anchor" href="#4-0-null不是一个有效的地址"></a> 4. 0 (Null)不是一个有效的地址</h2><p>free(Null)</p><p>free(0)均是不会报错的。</p><p>因此，可以在定义指针时，赋值为零。</p><h2 id="5-常见问题"><a class="markdownIt-Anchor" href="#5-常见问题"></a> 5. 常见问题</h2><img src="/posts/23807/image-20240916155832862.png" class="" title="image-20240916155832862"><ul><li>malloc没有free, 残留内存垃圾，申请内存不释放，会造成内存泄漏，比如大型程序（服务器程序）</li></ul><h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] ={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,}</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> *p= a </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *q = &amp;a[<span class="number">5</span>] </span><br><span class="line"></span><br><span class="line">q-p=?</span><br></pre></td></tr></tbody></table></figure><p>在 C 语言中，指针相减操作会返回两个指针之间的距离，单位是数组元素的个数。</p><p>假设你有如下的代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = {1, 2, 3, 4, 5};</span><br><span class="line">int *p = a;</span><br><span class="line">int *q = &amp;a[5];</span><br></pre></td></tr></tbody></table></figure><ul><li><code>p</code> 指向数组 <code>a</code> 的第一个元素，即 <code>a[0]</code>，地址为 <code>a</code>。</li><li><code>q</code> 指向 <code>a[5]</code>，也就是超出数组末尾的第一个地址（这个元素不存在，因为数组的有效下标是 0 到 4）。</li></ul><p>接下来执行 <code>q - p</code>：</p><ol><li><code>q</code> 指向 <code>&amp;a[5]</code>，即 <code>a</code> 数组末尾后面的地址。</li><li><code>p</code> 指向数组的第一个元素 <code>a[0]</code>。</li></ol><p><strong>计算</strong> <code>q - p</code> 时，它会计算两个指针之间相隔的元素个数。因此：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q - p = 5</span><br></pre></td></tr></tbody></table></figure><p>这是因为 <code>q</code> 指向的地址比 <code>p</code> 向后移动了 5 个整型元素的距离。</p><p>最终答案是：<code>q - p = 5</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-动态内存分配&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-动态内存分配&quot;&gt;&lt;/a&gt; 一、动态内存分配&lt;/h1&gt;
&lt;h2 id=&quot;1-malloc函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【Git学习】[4]远程仓库</title>
    <link href="https://szturin.github.io/posts/45839/"/>
    <id>https://szturin.github.io/posts/45839/</id>
    <published>2024-09-16T05:32:01.000Z</published>
    <updated>2024-09-16T06:47:34.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重命名远程仓库"><a class="markdownIt-Anchor" href="#重命名远程仓库"></a> 重命名远程仓库</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename origin github</span><br></pre></td></tr></tbody></table></figure><img src="/posts/45839/image-20240916133628463.png" class="" title="image-20240916133628463"><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> #问题</h1><h2 id="一-hexo推送源文件安全性报错"><a class="markdownIt-Anchor" href="#一-hexo推送源文件安全性报错"></a> 一、Hexo推送源文件，安全性报错</h2><img src="/posts/45839/image-20240916135838561.png" class="" title="image-20240916135838561"><p>解决方案：转到log中指向的链接，选择use for test,</p><img src="/posts/45839/image-20240916135827657.png" class="" title="image-20240916135827657"><p>可以看到，修改后，再次push，成功提交到github。</p><img src="/posts/45839/image-20240916140029571.png" class="" title="image-20240916140029571">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重命名远程仓库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重命名远程仓库&quot;&gt;&lt;/a&gt; 重命名远程仓库&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【电赛】2024年H题-自动行驶小车</title>
    <link href="https://szturin.github.io/posts/37775/"/>
    <id>https://szturin.github.io/posts/37775/</id>
    <published>2024-09-15T14:24:02.000Z</published>
    <updated>2024-10-11T14:46:26.608Z</updated>
    
    <content type="html"><![CDATA[<p>注意：CCS Theia编译可能无法找到报错位置，建议每次小幅修改后就立即编译</p><p>主要问题：</p><ul><li><p>如何进行调参？</p></li><li><p>如何设计一个完整的系统？</p></li><li><p>小车如何走直线？</p><ul><li>PID速度环</li><li>陀螺仪</li></ul></li><li><p>小车在循迹时如何保证沿中线行驶？</p></li><li><p>如何解决陀螺仪漂移的问题</p><ul><li>滤波算法</li></ul></li><li><p>如何避免/减少场地干扰？</p></li><li><p>如何提高速度的同时保证行驶稳定？</p></li></ul><h1 id="程序结构-底层驱动"><a class="markdownIt-Anchor" href="#程序结构-底层驱动"></a> 程序结构-底层驱动</h1><h2 id="一-基础电机控制"><a class="markdownIt-Anchor" href="#一-基础电机控制"></a> 一、基础电机控制</h2><p>源文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"motor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iso646.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief电机启动</span></span><br><span class="line"><span class="comment">  * @param    None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_On</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    DL_GPIO_setPins(GPIO_MOTOR_PIN_FSTBY_PORT, GPIO_MOTOR_PIN_FSTBY_PIN);<span class="comment">//置位对应端口-&gt;引脚电平,STBY</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief    电机关闭</span></span><br><span class="line"><span class="comment">  * @param    None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    DL_GPIO_clearPins(GPIO_MOTOR_PIN_FSTBY_PORT, GPIO_MOTOR_PIN_FSTBY_PIN);<span class="comment">//清除对应端口-&gt;引脚电平，STBY</span></span><br><span class="line">    <span class="comment">//逻辑口电平清除</span></span><br><span class="line">    DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN);</span><br><span class="line">    DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN);</span><br><span class="line">    DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN);</span><br><span class="line">    DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief速度设置</span></span><br><span class="line"><span class="comment">  * @param    左右轮占空比（百分值）</span></span><br><span class="line"><span class="comment">  * @retval     None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Speed</span><span class="params">(<span class="type">float</span> duty1,<span class="type">float</span> duty2)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> compareValue = <span class="number">0</span>;<span class="comment">//比较值最大为3199，最小值为0</span></span><br><span class="line">    <span class="keyword">if</span>(duty1 &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//PWM定时器向下计数，比较值计算</span></span><br><span class="line">        compareValue = <span class="number">3199</span> - <span class="number">3199</span> * (-duty1/<span class="number">100.0</span>);</span><br><span class="line">        <span class="comment">//比较值设置</span></span><br><span class="line">        DL_TimerA_setCaptureCompareValue(PWM_MOTOR_INST, compareValue, DL_TIMER_CC_0_INDEX); </span><br><span class="line">        <span class="comment">//电机逻辑引脚设置</span></span><br><span class="line">        DL_GPIO_setPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN);</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(duty1 &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        compareValue = <span class="number">3199</span> - <span class="number">3199</span> * (duty1/<span class="number">100.0</span>);</span><br><span class="line">        DL_TimerA_setCaptureCompareValue(PWM_MOTOR_INST, compareValue, DL_TIMER_CC_0_INDEX);</span><br><span class="line">        DL_GPIO_setPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(duty2 &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        compareValue = <span class="number">3199</span> - <span class="number">3199</span> * (-duty2/<span class="number">100.0</span>);</span><br><span class="line">        DL_TimerA_setCaptureCompareValue(PWM_MOTOR_INST, compareValue, DL_TIMER_CC_1_INDEX);  </span><br><span class="line">        DL_GPIO_setPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(duty2 &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        compareValue = <span class="number">3199</span> - <span class="number">3199</span> * (duty2/<span class="number">100.0</span>);</span><br><span class="line">        DL_TimerA_setCaptureCompareValue(PWM_MOTOR_INST, compareValue, DL_TIMER_CC_1_INDEX);</span><br><span class="line">        DL_GPIO_setPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN);</span><br><span class="line">        DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>头文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义简化写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AIN1(x)   x?DL_GPIO_setPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN):DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL1_PORT, GPIO_MOTOR_PIN_FL1_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AIN2(x)   x?DL_GPIO_setPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN):DL_GPIO_clearPins(GPIO_MOTOR_PIN_FL2_PORT, GPIO_MOTOR_PIN_FL2_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN1(x)   x?DL_GPIO_setPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN):DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN2(x)   x?DL_GPIO_setPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN):DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_On</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Off</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Speed</span><span class="params">(<span class="type">float</span> duty1,<span class="type">float</span> duty2)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="二-pid控制算法"><a class="markdownIt-Anchor" href="#二-pid控制算法"></a> 二、PID控制算法</h2><h3 id="参数定义"><a class="markdownIt-Anchor" href="#参数定义"></a> # 参数定义</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"PID.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Serial.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"main.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"math.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Trace_Byte;<span class="comment">//循迹总状态</span></span><br><span class="line"><span class="type">uint8_t</span> Angle_PID_Flag =<span class="number">0</span>;<span class="comment">//角度环开启标志位</span></span><br><span class="line"><span class="type">uint8_t</span> CV_flag=<span class="number">0</span>;<span class="comment">//视觉循迹开启标志位</span></span><br><span class="line"><span class="type">uint8_t</span> Test_pid_flag=<span class="number">0</span>;<span class="comment">//PID调试标志位</span></span><br><span class="line"><span class="type">float</span> K_trace = <span class="number">0.0615</span>;<span class="comment">//减速系数</span></span><br><span class="line"><span class="type">float</span> Speed_midset = <span class="number">30</span>;<span class="comment">//预设直线速度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*灰度GPIO口宏定义*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO1 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_0_PORT,GPIO_TRACE_PIN_TRACE_0_PIN) == GPIO_TRACE_PIN_TRACE_0_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO2 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_1_PORT,GPIO_TRACE_PIN_TRACE_1_PIN) == GPIO_TRACE_PIN_TRACE_1_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO3 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_2_PORT,GPIO_TRACE_PIN_TRACE_2_PIN) == GPIO_TRACE_PIN_TRACE_2_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO4 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_3_PORT,GPIO_TRACE_PIN_TRACE_3_PIN) == GPIO_TRACE_PIN_TRACE_3_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO5 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_4_PORT,GPIO_TRACE_PIN_TRACE_4_PIN) == GPIO_TRACE_PIN_TRACE_4_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO6 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_5_PORT,GPIO_TRACE_PIN_TRACE_5_PIN) == GPIO_TRACE_PIN_TRACE_5_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO7 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_6_PORT,GPIO_TRACE_PIN_TRACE_6_PIN) == GPIO_TRACE_PIN_TRACE_6_PIN)?1:0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_Huidu_IO8 ((DL_GPIO_readPins(GPIO_TRACE_PIN_TRACE_7_PORT,GPIO_TRACE_PIN_TRACE_7_PIN) == GPIO_TRACE_PIN_TRACE_7_PIN)?1:0)</span></span><br></pre></td></tr></tbody></table></figure><p><strong>结构体类型</strong></p><p>创建结构体类型的方法，方便进行同类型变量元素组的创建，减少代码重复度。</p><p>这里定义了PID类型结构体，在之后新建其他用于PID控制的变量组时，只要用PID类型定义变量即可、</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*结构体类型定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">float</span> Kp;</span><br><span class="line"><span class="type">float</span> Ki;</span><br><span class="line"><span class="type">float</span> Kd;</span><br><span class="line"><span class="type">float</span> error;</span><br><span class="line"><span class="type">float</span> last_error;</span><br><span class="line"><span class="type">float</span> error_sum;</span><br><span class="line"><span class="type">float</span> error_difference;</span><br><span class="line"><span class="type">float</span> velocity_sum;</span><br><span class="line">}PID;</span><br></pre></td></tr></tbody></table></figure><p><strong>PID初始化相关函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PID类型变量声明*/</span></span><br><span class="line">PID Velocity;</span><br><span class="line">PID Velocity_L;</span><br><span class="line">PID trace_hd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*速度环PID*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Velocity_PID_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Velocity.Kp = <span class="number">-1.33</span>;</span><br><span class="line">    Velocity.Kd = <span class="number">-0.22</span>;</span><br><span class="line">    Velocity.Ki = <span class="number">-0.012</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Velocity_L_PID_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Velocity_L.Kp = <span class="number">-1.34</span>;</span><br><span class="line">    Velocity_L.Kd = <span class="number">-0.22</span>;</span><br><span class="line">    Velocity_L.Ki = <span class="number">-0.012</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*循迹环PID*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trace_hd_PID_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    trace_hd.Kp = <span class="number">-1.75</span>;</span><br><span class="line">    trace_hd.Kd = <span class="number">-0.65</span>;</span><br><span class="line">    trace_hd.Ki = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*PID初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Velocity_PID_Init();</span><br><span class="line">    Velocity_L_PID_Init();</span><br><span class="line">    trace_hd_PID_Init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*限幅函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I_amplitude_limiting</span><span class="params">(<span class="type">float</span> number,<span class="type">float</span> *Error_sum)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(*Error_sum &gt; number)</span><br><span class="line">{</span><br><span class="line">*Error_sum = number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*Error_sum &lt;- number)</span><br><span class="line">{</span><br><span class="line">*Error_sum = -number;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>辅助函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*限幅函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I_amplitude_limiting</span><span class="params">(<span class="type">float</span> number,<span class="type">float</span> *Error_sum)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(*Error_sum &gt; number)</span><br><span class="line">{</span><br><span class="line">*Error_sum = number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*Error_sum &lt;- number)</span><br><span class="line">{</span><br><span class="line">*Error_sum = -number;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief获取灰度巡线路数</span></span><br><span class="line"><span class="comment">  * @param    无</span></span><br><span class="line"><span class="comment">  * @retval 识别路数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">Huidu_Counter</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> hd_sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)<span class="comment">//灰度循迹个数统计</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(((~Trace_Byte)&gt;&gt;i)&amp;<span class="number">0x01</span>) hd_sum++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hd_sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief灰度状态读取函数</span></span><br><span class="line"><span class="comment">  * @param    无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_TraceData</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Trace_Byte = (Read_Huidu_IO1&lt;&lt;<span class="number">7</span>) + (Read_Huidu_IO2 &lt;&lt; <span class="number">6</span>) + (Read_Huidu_IO3 &lt;&lt; <span class="number">5</span>) + (Read_Huidu_IO4 &lt;&lt;<span class="number">4</span>) </span><br><span class="line">                 + (Read_Huidu_IO5 &lt;&lt; <span class="number">3</span>) +(Read_Huidu_IO6 &lt;&lt;<span class="number">2</span>) +(Read_Huidu_IO7 &lt;&lt;<span class="number">1</span>) + Read_Huidu_IO8;<span class="comment">//8路灰度循迹状态</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1循迹控制pd控制自适应曲线减速"><a class="markdownIt-Anchor" href="#1循迹控制pd控制自适应曲线减速"></a> 1.循迹控制（PD控制+自适应曲线减速）</h3><p>此函数包含：</p><ul><li>循迹路数统计：可用于判断小车是否脱线、循线、特征值检测</li><li>适用于圆弧的循迹状态穷举</li><li>自适应的曲线减速函数，提高循迹的稳定性</li><li>PD环控制，提高循迹的抗干扰能力与拟合程度</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*八路循迹环PID控制器*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_hd_PID</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp_hd_sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    temp_hd_sum = Huidu_Counter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(temp_hd_sum &lt;=<span class="number">2</span>)<span class="comment">//差速循迹</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span>(Trace_Byte)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xE7</span>: <span class="comment">// 1110 0111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xC3</span>: <span class="comment">// 1100 0011</span></span><br><span class="line">                trace_hd.error = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x00</span>: <span class="comment">// 0000 0000</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0F</span>: <span class="comment">// 0000 1111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x07</span>: <span class="comment">// 0000 0111</span></span><br><span class="line">                trace_hd.error = <span class="number">-9</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF0</span>: <span class="comment">// 1111 0000</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xE0</span>: <span class="comment">// 1110 0000</span></span><br><span class="line">                trace_hd.error = <span class="number">9</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xE3</span>: <span class="comment">// 1110 0011</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF7</span>: <span class="comment">// 1111 0111</span></span><br><span class="line">                trace_hd.error = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xC1</span>: <span class="comment">// 1100 0001</span></span><br><span class="line">                trace_hd.error = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF3</span>: <span class="comment">// 1111 0011</span></span><br><span class="line">                trace_hd.error = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF1</span>: <span class="comment">// 1111 0001</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFB</span>: <span class="comment">// 1111 1011</span></span><br><span class="line">                trace_hd.error = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF9</span>: <span class="comment">// 1111 1001</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFD</span>: <span class="comment">// 1111 1101</span></span><br><span class="line">                trace_hd.error = <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xF8</span>: <span class="comment">// 1111 1000</span></span><br><span class="line">                trace_hd.error = <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFC</span>: <span class="comment">// 1111 1100</span></span><br><span class="line">                trace_hd.error = <span class="number">12</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFE</span>: <span class="comment">// 1111 1110</span></span><br><span class="line">                trace_hd.error = <span class="number">14</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x87</span>: <span class="comment">// 1000 0111</span></span><br><span class="line">                trace_hd.error = <span class="number">-2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xC7</span>: <span class="comment">// 1100 0111</span></span><br><span class="line">                trace_hd.error = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xEF</span>: <span class="comment">// 1110 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xCF</span>: <span class="comment">// 1100 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8F</span>: <span class="comment">// 1000 1111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xDF</span>: <span class="comment">// 1101 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-6</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x9F</span>: <span class="comment">// 1001 1111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xBF</span>: <span class="comment">// 1011 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1F</span>: <span class="comment">// 0001 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x3F</span>: <span class="comment">// 0011 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-12</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7F</span>: <span class="comment">// 0111 1111</span></span><br><span class="line">                trace_hd.error = <span class="number">-14</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xFF</span>: <span class="comment">// 1111 1111</span></span><br><span class="line">                trace_hd.error = trace_hd.last_error &gt; <span class="number">0</span> ? <span class="number">16</span> : <span class="number">-16</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                trace_hd.error = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp_hd_sum &gt;= <span class="number">6</span> &amp;&amp; temp_hd_sum &lt;= <span class="number">8</span>)<span class="comment">//掉头</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//Angle_PID_Flag = 1;</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//停车</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    trace_hd.error_difference = trace_hd.error - trace_hd.last_error;</span><br><span class="line">    trace_hd.error_sum += trace_hd.error;<span class="comment">//误差累加量</span></span><br><span class="line">    trace_hd.last_error = trace_hd.error;</span><br><span class="line">    I_amplitude_limiting(<span class="number">1000</span>,&amp;trace_hd.error_sum);<span class="comment">//误差累加量限幅</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    K_trace =  <span class="number">1</span>/<span class="number">16.0</span> * <span class="built_in">pow</span>((<span class="number">1</span>-(<span class="number">20</span>/Speed_midset)),<span class="number">0.5</span>);<span class="comment">//弯道减速系数</span></span><br><span class="line">    MID_Speed = Speed_midset * (<span class="number">1</span> - (<span class="type">uint8_t</span>)(trace_hd.error)*K_trace) * (<span class="number">1</span> + (<span class="type">uint8_t</span>)(trace_hd.error)*K_trace);<span class="comment">//基准速度变换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> trace_hd.error*trace_hd.Kp  + trace_hd.error_difference * trace_hd.Kd;<span class="comment">//PD环循迹，比例+积分</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2陀螺仪角度环小车姿态控制"><a class="markdownIt-Anchor" href="#2陀螺仪角度环小车姿态控制"></a> 2.陀螺仪角度环(小车姿态控制)</h3><p>此函数功能：</p><ul><li>输入陀螺仪传感器测量的姿态，进行PID解算</li><li>PD环控制，确保小车转向迅速并且稳定。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*转向环PID控制器*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_imu_PID</span><span class="params">(<span class="type">int</span> yaw, <span class="type">int</span> caclu_yaw)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">float</span> Kp = <span class="number">-1.35</span>;</span><br><span class="line">    <span class="type">float</span> Kd = <span class="number">-9.5</span>;</span><br><span class="line">    <span class="type">float</span> Ki = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> error ;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> last_error;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> error_diff;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> error_sum;</span><br><span class="line"></span><br><span class="line">    error = yaw -caclu_yaw;</span><br><span class="line">    error_sum += error;</span><br><span class="line"></span><br><span class="line">    I_amplitude_limiting(<span class="number">1000</span>,&amp;error_sum);<span class="comment">//误差累加量限幅</span></span><br><span class="line"></span><br><span class="line">    error_diff = error-last_error;</span><br><span class="line">    last_error = error;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error &gt; <span class="number">180</span>) <span class="comment">// 防止小车转到180度时一直旋转的问题</span></span><br><span class="line">        error = error - <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">-180</span>)</span><br><span class="line">        error = error + <span class="number">360</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Kp * error + Kd * error_diff + Ki*error_sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>PID头文件</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Trace_Byte;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Angle_PID_Flag;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Test_pid_flag;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> Speed_midset;<span class="comment">//预设直线速度</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_cv_PID</span><span class="params">(<span class="type">int</span> measure, <span class="type">int</span> caclu)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_hd_PID</span><span class="params">()</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_hd_PID_Seven</span><span class="params">()</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Velocity_PID_L</span><span class="params">(<span class="type">float</span> velocity,<span class="type">float</span> velocity_calcu)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Velocity_PID_R</span><span class="params">(<span class="type">float</span> velocity,<span class="type">float</span> velocity_calcu)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_TraceData</span><span class="params">()</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Turn_imu_PID</span><span class="params">(<span class="type">int</span> yaw, <span class="type">int</span> caclu_yaw)</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">Huidu_Counter</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="三-陀螺仪串口通信"><a class="markdownIt-Anchor" href="#三-陀螺仪串口通信"></a> 三、陀螺仪串口通信</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接收变量</span></span><br><span class="line"><span class="type">uint8_t</span> RollL, RollH, PitchL, PitchH, YawL, YawH, VL, VH, SUM;</span><br><span class="line"><span class="type">float</span> Pitch,Roll,Yaw;</span><br><span class="line"><span class="comment">// 串口接收状态标识</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_HEADER1 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_HEADER2 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECEIVE_DATA 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxState_JY = WAIT_HEADER1;</span><br><span class="line"><span class="type">uint8_t</span> receivedData[<span class="number">9</span>];</span><br><span class="line"><span class="type">uint8_t</span> dataIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送置偏航角置零命令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_JY61P_Zero_Yaw</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X69</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X88</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XB5</span>);</span><br><span class="line">delay_ms(<span class="number">100</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X01</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X04</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line">delay_ms(<span class="number">100</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>头文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __JY61P_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __JY61P_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_JY61P_Zero_Yaw</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_JY61P_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> Pitch,Roll,Yaw;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="四-常规外设串口通信"><a class="markdownIt-Anchor" href="#四-常规外设串口通信"></a> 四、常规外设串口通信</h2><h3 id="1-变量声明"><a class="markdownIt-Anchor" href="#1-变量声明"></a> 1. 变量声明</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"main.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 256  <span class="comment">// 定义缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">100</span>];</span><br><span class="line"><span class="comment">/*PID调试*/</span></span><br><span class="line"><span class="type">float</span> Test_Kp;<span class="comment">//比例</span></span><br><span class="line"><span class="type">float</span> Test_Ki;<span class="comment">//积分</span></span><br><span class="line"><span class="type">float</span> Test_Kd;<span class="comment">//微分</span></span><br><span class="line"><span class="type">float</span> Test_Ks;<span class="comment">//目标速度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*系统调试串口变量*/</span></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"><span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> pRxState;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="type">uint8_t</span> RxData_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上位机串口变量*/</span></span><br><span class="line"><span class="type">uint8_t</span> Soc_RxFlag;</span><br><span class="line"><span class="type">uint8_t</span> RxState_SOC = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> SOC_RxData_type;</span><br><span class="line"><span class="type">uint8_t</span> SOC_pRxState;<span class="comment">//串口接收数据索引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口屏串口变量*/</span></span><br><span class="line"><span class="type">uint8_t</span> Screen_RxFlag;</span><br><span class="line"><span class="type">uint8_t</span> RxState_Screen;</span><br><span class="line"><span class="type">uint8_t</span> Screen_RxData_type;</span><br><span class="line"><span class="type">uint8_t</span> Screen_pRxState;<span class="comment">//串口接收数据索引号</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">100</span>];</span><br></pre></td></tr></tbody></table></figure><h2 id="2-辅助函数"><a class="markdownIt-Anchor" href="#2-辅助函数"></a> 2. 辅助函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统串口初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SYS_UART0_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">NVIC_ClearPendingIRQ(UART_0_INST_INT_IRQN);</span><br><span class="line">NVIC_EnableIRQ(UART_0_INST_INT_IRQN);</span><br><span class="line">    DL_UART_clearInterruptStatus(UART_0_INST,DL_UART_INTERRUPT_RX);<span class="comment">//清除中断标志位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//SOC通信串口初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SOC_UART1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">NVIC_ClearPendingIRQ(UART_SOC_INST_INT_IRQN);</span><br><span class="line">NVIC_EnableIRQ(UART_SOC_INST_INT_IRQN);</span><br><span class="line">    DL_UART_clearInterruptStatus(UART_SOC_INST,DL_UART_INTERRUPT_RX);<span class="comment">//清除中断标志位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符串给SOC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SOC_SendString</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">'\0'</span>)</span><br><span class="line">    {</span><br><span class="line">        DL_UART_Main_transmitDataBlocking(UART_SOC_INST, *str++);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口屏通信串口初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Screen_UART2_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">NVIC_ClearPendingIRQ(UART_Screen_INST_INT_IRQN);</span><br><span class="line">NVIC_EnableIRQ(UART_Screen_INST_INT_IRQN);</span><br><span class="line">    DL_UART_clearInterruptStatus(UART_Screen_INST,DL_UART_INTERRUPT_RX);<span class="comment">//清除中断标志位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符串给串口屏</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Screen_SendString</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">'\0'</span>)</span><br><span class="line">    {</span><br><span class="line">        DL_UART_Main_transmitDataBlocking(UART_Screen_INST, *str++);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int_to_binary_string</span><span class="params">(<span class="type">uint32_t</span> value, <span class="type">char</span> *binary_str, <span class="type">int</span> max_bits)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 生成二进制字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = max_bits - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    {</span><br><span class="line">        binary_str[i] = (value &amp; (<span class="number">1U</span> &lt;&lt; i)) ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">    }</span><br><span class="line">    binary_str[max_bits] = <span class="string">'\0'</span>; <span class="comment">// 确保字符串以 null 结尾</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将浮点数转换为字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">float_to_string</span><span class="params">(<span class="type">float</span> value, <span class="type">char</span> *str, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">snprintf</span>(str, size, <span class="string">"%.2f"</span>, value); <span class="comment">// 格式化为两位小数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_send_string</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *showdata)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造要发送的字符串，确保缓冲区足够大</span></span><br><span class="line">    length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"%s=\"%s\"\xff\xff\xff"</span>, name, showdata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否发生了缓冲区溢出</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt;= <span class="keyword">sizeof</span>(buffer))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理，例如可以通过截断字符串或者增加缓冲区大小来解决</span></span><br><span class="line">        <span class="comment">// 这里只是简单地截断字符串以确保不会发送超出缓冲区的内容</span></span><br><span class="line">        buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>; <span class="comment">// 确保字符串以 null 结尾</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Screen_SendString 发送构造好的字符串</span></span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_send_number</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"%s=%d\xff\xff\xff"</span>, name, num);</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= BUFFER_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理</span></span><br><span class="line">    }</span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_send_float</span><span class="params">(<span class="type">char</span>* name, <span class="type">float</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> num_int = (<span class="type">int</span>)(num * <span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"%s=%d\xff\xff\xff"</span>, name, num_int);</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= BUFFER_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理</span></span><br><span class="line">    }</span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_Wave</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> ch, <span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"add %s,%d,%d\xff\xff\xff"</span>, name, ch, val);</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= BUFFER_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理</span></span><br><span class="line">    }</span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_Wave_Fast</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> ch, <span class="type">int</span> count, <span class="type">int</span>* show_data)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"addt %s,%d,%d\xff\xff\xff"</span>, name, ch, count);</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= BUFFER_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理</span></span><br><span class="line">    }</span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 发送每个字符</span></span><br><span class="line">        DL_UART_Main_transmitDataBlocking(UART_Screen_INST, (<span class="type">char</span>)show_data[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发送结束标志</span></span><br><span class="line">    Screen_SendString(<span class="string">"\xff\xff\xff"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_Wave_Clear</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> ch)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"cle %s,%d\xff\xff\xff"</span>, name, ch);</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= BUFFER_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 缓冲区溢出处理</span></span><br><span class="line">    }</span><br><span class="line">    Screen_SendString(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="程序结构-中断服务函数"><a class="markdownIt-Anchor" href="#程序结构-中断服务函数"></a> 程序结构-中断服务函数</h1><h2 id="1常规串口中断"><a class="markdownIt-Anchor" href="#1常规串口中断"></a> 1.常规串口中断</h2><ul><li>Uart0: 系统串口，用作与计算机通信调试</li><li>Uart_Screen：串口屏串口，用于和串口屏进行通信调试，串口屏可以直接控制小车，也可以显示小车实时参数</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_0_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (DL_UART_Main_getPendingInterrupt(UART_0_INST)) {<span class="comment">//判断中断的类型，DL_UART_Main_getPendingInterrupt(UART_0_INST)调用具有清空标志位的功能？</span></span><br><span class="line">        <span class="keyword">case</span> DL_UART_MAIN_IIDX_RX:<span class="comment">//如果触发串口接收事件</span></span><br><span class="line">       RxData = DL_UART_Main_receiveData(UART_0_INST);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)<span class="comment">//帧头检测</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'#'</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">1</span>)<span class="comment">//数据类型检测s</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">switch</span>(RxData)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="string">'P'</span>:<span class="comment">//x+</span></span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">RxData_type=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'I'</span>:<span class="comment">//x-</span></span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">RxData_type=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'D'</span>:<span class="comment">//x-</span></span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">RxData_type=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">RxData_type=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)<span class="comment">//数据，接收范围限制在单字节，足够完成任务要求</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'!'</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">RxState=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line">pRxState++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Screen_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (DL_UART_Main_getPendingInterrupt(UART_Screen_INST))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> DL_UART_MAIN_IIDX_RX:<span class="comment">//如果触发串口接收事件</span></span><br><span class="line">            RxData = DL_UART_Main_receiveData(UART_Screen_INST);</span><br><span class="line">            <span class="keyword">if</span>(RxState_Screen == <span class="number">0</span>)<span class="comment">//帧头检测</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(RxData == <span class="number">0xEF</span> &amp;&amp; Screen_RxFlag == <span class="number">0</span>)</span><br><span class="line">                {</span><br><span class="line">                    RxState_Screen = <span class="number">1</span>;<span class="comment">//串口屏的数据帧</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(RxState_Screen == <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                Serial_RxPacket[<span class="number">0</span>]=RxData;</span><br><span class="line">                RxState_Screen = <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(RxState_Screen == <span class="number">2</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(RxData == <span class="number">0xEE</span>)</span><br><span class="line">                {</span><br><span class="line">                    Screen_RxFlag=<span class="number">1</span>;</span><br><span class="line">                    RxState_Screen=<span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-陀螺仪串口中断函数"><a class="markdownIt-Anchor" href="#2-陀螺仪串口中断函数"></a> 2. 陀螺仪串口中断函数</h2><p>用于处理从陀螺仪传感器接收到的通信数据，其中主要的部分是Roll，Pitch，Yaw角</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串口中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_JY61P_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">uint8_t</span> uartdata = DL_UART_Main_receiveData(UART_JY61P_INST); <span class="comment">// 接收一个uint8_t数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (RxState_JY) {</span><br><span class="line">    <span class="keyword">case</span> WAIT_HEADER1:</span><br><span class="line">        <span class="keyword">if</span> (uartdata == <span class="number">0x55</span>) {</span><br><span class="line">            RxState_JY = WAIT_HEADER2;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WAIT_HEADER2:</span><br><span class="line">        <span class="keyword">if</span> (uartdata == <span class="number">0x53</span>) {</span><br><span class="line">            RxState_JY = RECEIVE_DATA;</span><br><span class="line">            dataIndex = <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            RxState_JY = WAIT_HEADER1; <span class="comment">// 如果不是期望的第二个头，重置状态</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RECEIVE_DATA:</span><br><span class="line">        receivedData[dataIndex++] = uartdata;</span><br><span class="line">        <span class="keyword">if</span> (dataIndex == <span class="number">9</span>) {</span><br><span class="line">            <span class="comment">// 数据接收完毕，分配给具体的变量</span></span><br><span class="line">            RollL = receivedData[<span class="number">0</span>];</span><br><span class="line">            RollH = receivedData[<span class="number">1</span>];</span><br><span class="line">            PitchL = receivedData[<span class="number">2</span>];</span><br><span class="line">            PitchH = receivedData[<span class="number">3</span>];</span><br><span class="line">            YawL = receivedData[<span class="number">4</span>];</span><br><span class="line">            YawH = receivedData[<span class="number">5</span>];</span><br><span class="line">            VL = receivedData[<span class="number">6</span>];</span><br><span class="line">            VH = receivedData[<span class="number">7</span>];</span><br><span class="line">            SUM = receivedData[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验SUM是否正确</span></span><br><span class="line">            <span class="type">uint8_t</span> calculatedSum = <span class="number">0x55</span> + <span class="number">0x53</span> + RollH + RollL + PitchH + PitchL + YawH + YawL + VH + VL;</span><br><span class="line">            <span class="keyword">if</span> (calculatedSum == SUM) {</span><br><span class="line">                <span class="comment">// 校验成功，可以进行后续处理</span></span><br><span class="line">                <span class="keyword">if</span>((<span class="type">float</span>)(((<span class="type">uint16_t</span>)RollH &lt;&lt; <span class="number">8</span>) | RollL)/<span class="number">32768</span>*<span class="number">180</span>&gt;<span class="number">180</span>){</span><br><span class="line">                    Roll = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)RollH &lt;&lt; <span class="number">8</span>) | RollL)/<span class="number">32768</span>*<span class="number">180</span> - <span class="number">360</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    Roll = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)RollH &lt;&lt; <span class="number">8</span>) | RollL)/<span class="number">32768</span>*<span class="number">180</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>((<span class="type">float</span>)(((<span class="type">uint16_t</span>)PitchH &lt;&lt; <span class="number">8</span>) | PitchL)/<span class="number">32768</span>*<span class="number">180</span>&gt;<span class="number">180</span>){</span><br><span class="line">                    Pitch = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)PitchH &lt;&lt; <span class="number">8</span>) | PitchL)/<span class="number">32768</span>*<span class="number">180</span> - <span class="number">360</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    Pitch = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)PitchH &lt;&lt; <span class="number">8</span>) | PitchL)/<span class="number">32768</span>*<span class="number">180</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>((<span class="type">float</span>)(((<span class="type">uint16_t</span>)YawH &lt;&lt; <span class="number">8</span>) | YawL)/<span class="number">32768</span>*<span class="number">180</span> &gt;<span class="number">180</span>){</span><br><span class="line">                    Yaw = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)YawH &lt;&lt; <span class="number">8</span>) | YawL)/<span class="number">32768</span>*<span class="number">180</span> - <span class="number">360</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    Yaw = (<span class="type">float</span>)(((<span class="type">uint16_t</span>)YawH &lt;&lt; <span class="number">8</span>) | YawL)/<span class="number">32768</span>*<span class="number">180</span>;</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 校验失败，处理错误</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            RxState_JY = WAIT_HEADER1; <span class="comment">// 重置状态以等待下一个数据包</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//DL_UART_Main_transmitData(UART_JY61P_INST, uartdata); // 可选：回传接收到的数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="程序结构-任务进程"><a class="markdownIt-Anchor" href="#程序结构-任务进程"></a> 程序结构-任务进程</h1><p>在此文件中，定义各种不同的任务</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Process.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************串口进程*********************************/</span></span><br><span class="line"><span class="comment">/*系统串口(UART1)解码进程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SYS_RxPro</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*PID调试*/</span></span><br><span class="line">    <span class="keyword">if</span>(Serial_RxFlag)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span>(RxData_type)<span class="comment">//判断数据帧的数据类型</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span>(pRxState == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Kp = Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">2</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Kp = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Kp = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">100</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">2</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span>(pRxState == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ki = Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">2</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ki = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ki = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">100</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">2</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span>(pRxState == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Kd = Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">2</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Kd = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line"></span><br><span class="line">                    Test_Kd = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">100</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">2</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span>(pRxState == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ks = Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">2</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ks = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pRxState == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line">                    Test_Ks = (Serial_RxPacket[<span class="number">0</span>]<span class="number">-0x30</span>)*<span class="number">100</span> + (Serial_RxPacket[<span class="number">1</span>]<span class="number">-0x30</span>)*<span class="number">10</span> + (Serial_RxPacket[<span class="number">2</span>]<span class="number">-0x30</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        Serial_RxFlag=<span class="number">0</span>;</span><br><span class="line">        pRxState=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口屏通信解码进程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Screen_RxPro</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(Screen_RxFlag == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span>(Serial_RxPacket[<span class="number">0</span>])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Motor_On();</span><br><span class="line">                Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(System_Mode == <span class="number">0</span> | System_Mode == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    yaw_detect = yaw_val;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    yaw_detect = yaw_val - LX_3_IMU_ANGEL_1;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                Motor_flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                Serial_JY61P_Zero_Yaw();</span><br><span class="line">                Motor_Off();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//PID参数模式切换：调试模式&lt;-&gt;固定模式</span></span><br><span class="line">                Test_pid_flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                Test_pid_flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        DL_UART_Main_transmitData(UART_Screen_INST,Serial_RxPacket[<span class="number">0</span>]);</span><br><span class="line">        Screen_RxFlag=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************特殊功能进程**********************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Beep_Proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(beep_flag == <span class="number">1</span> || beep_key_flag == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        DL_GPIO_setPins(GPIO_BEEP_PORT,GPIO_BEEP_PIN_1_PIN);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        DL_GPIO_clearPins(GPIO_BEEP_PORT,GPIO_BEEP_PIN_1_PIN);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*OlED进程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Oled_Proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    OLED_ShowString(<span class="number">0</span>, <span class="number">8</span>,<span class="string">"Mode:"</span>,<span class="number">8</span>);</span><br><span class="line">    OLED_ShowNum(<span class="number">42</span>, <span class="number">8</span>, System_Mode+<span class="number">1</span>, <span class="number">1</span> ,<span class="number">8</span>);</span><br><span class="line">    OLED_ShowBinNum(<span class="number">0</span>, <span class="number">28</span>, Trace_Byte, <span class="number">8</span> ,<span class="number">8</span>);</span><br><span class="line">    OLED_ShowSignedNum(<span class="number">0</span>, <span class="number">45</span>,Yaw,<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line">    OLED_Update();    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口屏进程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HMI_Proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    int_to_binary_string(Trace_Byte, data_HMI, <span class="number">8</span>);</span><br><span class="line">    HMI_send_string(hmi_trace, data_HMI);<span class="comment">//串口屏打印循迹状态</span></span><br><span class="line"></span><br><span class="line">    float_to_string(Yaw,data_HMI,<span class="number">8</span>);</span><br><span class="line">    HMI_send_string(hmi_yaw, data_HMI);<span class="comment">//串口屏打印陀螺仪实际的Yaw角度</span></span><br><span class="line"></span><br><span class="line">    float_to_string(M_Speed_L,data_HMI,<span class="number">8</span>);</span><br><span class="line">    HMI_send_string(hmi_speed, data_HMI);<span class="comment">//串口屏打印速度</span></span><br><span class="line"></span><br><span class="line">    float_to_string(System_Mode,data_HMI,<span class="number">8</span>);</span><br><span class="line">    HMI_send_string(hmi_imu, data_HMI);<span class="comment">//串口屏打印单片机记忆的Yaw角度</span></span><br><span class="line"></span><br><span class="line">    float_to_string(NEncoder.right_motor_total_cnt,data_HMI,<span class="number">8</span>);</span><br><span class="line">    HMI_send_string(hmi_totol, data_HMI);<span class="comment">//串口屏打印总的脉冲数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(Key_Down)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            beep_key_flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(++System_Mode == <span class="number">4</span>)</span><br><span class="line">            {</span><br><span class="line">                System_Mode = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            Motor_On();</span><br><span class="line">            Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line">            Speed_midset = Speed_ZX;</span><br><span class="line">            <span class="keyword">if</span>(System_Mode == <span class="number">0</span> | System_Mode == <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                yaw_detect = yaw_val;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            {</span><br><span class="line">                yaw_detect = yaw_val - LX_3_IMU_ANGEL_1;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Motor_flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            Motor_flag = <span class="number">0</span>;</span><br><span class="line">            Serial_JY61P_Zero_Yaw();</span><br><span class="line">            Motor_Off();            </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="程序结构-路径规划"><a class="markdownIt-Anchor" href="#程序结构-路径规划"></a> 程序结构-路径规划</h1><h2 id="1-路径1"><a class="markdownIt-Anchor" href="#1-路径1"></a> 1. 路径1</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************路线进程***********************************/</span></span><br><span class="line"><span class="comment">//要求1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LX_Proc_1</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp_hd_sum;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> LX_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    temp_hd_sum =  Huidu_Counter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(LX_state ==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        Speed_midset = <span class="number">30</span> - NEncoder.right_motor_total_cnt/<span class="number">8000</span> * <span class="number">15.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp_hd_sum &gt;=<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            beep_flag = <span class="number">1</span>;</span><br><span class="line">            LX_state = <span class="number">1</span>;</span><br><span class="line">            Motor_Off();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-路径2"><a class="markdownIt-Anchor" href="#2-路径2"></a> 2. 路径2</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LX_Proc_2</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp_hd_sum;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> LX_state = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> LuChen_Counter;</span><br><span class="line">    </span><br><span class="line">    temp_hd_sum =  Huidu_Counter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LuChen_Counter = (NEncoder.left_motor_total_cnt + NEncoder.right_motor_total_cnt)/2;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(LX_state ==<span class="number">0</span>)<span class="comment">//从A触发</span></span><br><span class="line">    {</span><br><span class="line">        Speed_midset = <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp_hd_sum &gt;=<span class="number">1</span>)<span class="comment">//碰到B</span></span><br><span class="line">        {</span><br><span class="line">            Speed_midset = <span class="number">35</span>;</span><br><span class="line">            LX_state = <span class="number">1</span>;</span><br><span class="line">            Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">            beep_flag = <span class="number">1</span>;</span><br><span class="line">            motor_total_cnt_reset();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">1</span>)<span class="comment">//从B出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt;= <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到C</span></span><br><span class="line">            {</span><br><span class="line">                Speed_midset = <span class="number">40</span>;</span><br><span class="line">                yaw_detect -= LX_2_IMU_ANGEL;</span><br><span class="line">                Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">2</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">            }                   </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">2</span>)<span class="comment">//从C出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(temp_hd_sum &gt;= <span class="number">1</span>)<span class="comment">//碰到D</span></span><br><span class="line">        {</span><br><span class="line">            motor_total_cnt_reset();</span><br><span class="line">            Speed_midset = <span class="number">35</span>;</span><br><span class="line">            Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">            LX_state = <span class="number">3</span>;</span><br><span class="line">            beep_flag = <span class="number">1</span>;     </span><br><span class="line">        }    </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">3</span>)<span class="comment">//从D出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt;= <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到A</span></span><br><span class="line">            {</span><br><span class="line">                LX_state = <span class="number">4</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                Motor_Off();</span><br><span class="line">            }                 </span><br><span class="line">        }</span><br><span class="line">                   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-路径3"><a class="markdownIt-Anchor" href="#3-路径3"></a> 3. 路径3</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求3</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LX_Proc_3</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp_hd_sum;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> LX_state = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    temp_hd_sum =  Huidu_Counter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(LX_state ==<span class="number">0</span>)<span class="comment">//从A触发</span></span><br><span class="line">    {</span><br><span class="line">        Speed_midset=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(Angle_PID_Flag)</span><br><span class="line">        {</span><br><span class="line">            Timer_Angel_Sleep_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fabsf(Yaw - yaw_detect) &lt;= <span class="number">1.5</span>)</span><br><span class="line">            {</span><br><span class="line">                Speed_midset=Speed_ZX<span class="number">-15</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">11</span>;</span><br><span class="line">            }            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">11</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp_hd_sum &gt;=<span class="number">1</span>)<span class="comment">//碰到C</span></span><br><span class="line">        {</span><br><span class="line">            Speed_midset=Speed_WD<span class="number">-10</span>;</span><br><span class="line">            LX_state = <span class="number">1</span>;</span><br><span class="line">            Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">            beep_flag = <span class="number">1</span>;</span><br><span class="line">            motor_total_cnt_reset();</span><br><span class="line">        }        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">1</span>)<span class="comment">//从C出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到B</span></span><br><span class="line">            {</span><br><span class="line">                Speed_midset=Speed_ZX<span class="number">-15</span>;</span><br><span class="line">                yaw_detect = yaw_val + LX_4_IMU_ANGEL_1 + <span class="number">0.5</span>;</span><br><span class="line">                Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">2</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">            }                    </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">2</span>)<span class="comment">//从B出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(temp_hd_sum &gt;= <span class="number">1</span>)<span class="comment">//碰到D</span></span><br><span class="line">        {</span><br><span class="line">            Speed_midset=Speed_WD<span class="number">-10</span>;</span><br><span class="line">            Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">            LX_state = <span class="number">3</span>;</span><br><span class="line">            beep_flag = <span class="number">1</span>;     </span><br><span class="line">            motor_total_cnt_reset();</span><br><span class="line">        }    </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">3</span>)<span class="comment">//从D出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到A</span></span><br><span class="line">            {</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">4</span>;</span><br><span class="line">                Motor_Off();</span><br><span class="line">            }              </span><br><span class="line">        }             </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-路径4"><a class="markdownIt-Anchor" href="#4-路径4"></a> 4. 路径4</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求4</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LX_Proc_4</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp_hd_sum;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> LX_state = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line">    temp_hd_sum =  Huidu_Counter();</span><br><span class="line">    K_ZX = <span class="number">1</span>-(<span class="number">20</span>/Speed_ZX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(LX_state ==<span class="number">0</span>)<span class="comment">//从A触发</span></span><br><span class="line">    {</span><br><span class="line">        Speed_midset=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Angle_PID_Flag)</span><br><span class="line">        {</span><br><span class="line">            Timer_Angel_Sleep_flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(fabsf(Yaw - yaw_detect) &lt;= <span class="number">1.5</span>)</span><br><span class="line">            {</span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line"></span><br><span class="line">                Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX * K_ZX);</span><br><span class="line"></span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">11</span>;</span><br><span class="line">            }            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">11</span>)</span><br><span class="line">    {</span><br><span class="line">        Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX *K_ZX);</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">4000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum &gt;=<span class="number">1</span>)<span class="comment">//碰到C</span></span><br><span class="line">            {</span><br><span class="line">                Speed_midset=Speed_WD;</span><br><span class="line">                LX_state = <span class="number">1</span>;</span><br><span class="line">                Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line">     </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">1</span>)<span class="comment">//从C出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到B</span></span><br><span class="line">            {</span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line">                Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX * K_ZX);</span><br><span class="line">                yaw_detect = yaw_val + LX_4_IMU_ANGEL_1 + <span class="number">0.65</span>;</span><br><span class="line">                Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line">                LX_state = <span class="number">2</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">            }                    </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">2</span>)<span class="comment">//从B出发</span></span><br><span class="line">    {</span><br><span class="line">        Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX * K_ZX);</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">4000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum &gt;= <span class="number">1</span>)<span class="comment">//碰到D</span></span><br><span class="line">            {</span><br><span class="line">                Speed_midset=Speed_WD;</span><br><span class="line">                Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">                LX_state = <span class="number">3</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;     </span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line">                    Speed_midset = Speed_WD - <span class="number">5</span>;</span><br><span class="line">                }</span><br><span class="line">            }              </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">3</span>)<span class="comment">//从D出发</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">5000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum == <span class="number">0</span>)<span class="comment">//碰到A</span></span><br><span class="line">            {</span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line">                Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX * K_ZX);</span><br><span class="line">                LX_state = <span class="number">12</span>;</span><br><span class="line">                Angle_PID_Flag = <span class="number">1</span>;</span><br><span class="line">                yaw_detect = yaw_val - LX_4_IMU_ANGEL_1 + <span class="number">1.0</span>;                </span><br><span class="line">                beep_flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(++i&gt;=<span class="number">4</span>)</span><br><span class="line">                {</span><br><span class="line">                    LX_state = <span class="number">4</span>;</span><br><span class="line">                    Motor_Off();</span><br><span class="line">                }</span><br><span class="line">            }              </span><br><span class="line">        }             </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LX_state == <span class="number">12</span>)<span class="comment">//从A出发</span></span><br><span class="line">    {</span><br><span class="line">        Speed_midset = Speed_ZX - (NEncoder.right_motor_total_cnt/<span class="number">12000</span> * Speed_ZX * K_ZX);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(NEncoder.right_motor_total_cnt &gt; <span class="number">4000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp_hd_sum &gt;= <span class="number">1</span>)<span class="comment">//碰到C</span></span><br><span class="line">            {</span><br><span class="line">                Speed_midset=Speed_WD;</span><br><span class="line">                Angle_PID_Flag = <span class="number">0</span>;</span><br><span class="line">                LX_state = <span class="number">1</span>;</span><br><span class="line">                beep_flag = <span class="number">1</span>;     </span><br><span class="line">                motor_total_cnt_reset();</span><br><span class="line">            }       </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="程序结构-主程序"><a class="markdownIt-Anchor" href="#程序结构-主程序"></a> 程序结构-主程序</h1><h2 id="1-参数声明"><a class="markdownIt-Anchor" href="#1-参数声明"></a> 1. 参数声明</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"main.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Serial.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"nqei.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti/driverlib/dl_gpio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ti_msp_dl_config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Path.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Key_Number;<span class="comment">//按键调试 </span></span><br><span class="line"><span class="type">uint8_t</span> Key_Val,Key_Down,Key_Up,Key_Old;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PS:PWM可调范围，0~100以内任意浮点数</span></span><br><span class="line"><span class="type">float</span> MT_L = <span class="number">20.0</span>;<span class="comment">//左轮速度初值</span></span><br><span class="line"><span class="type">float</span> MT_R = <span class="number">20.0</span>;<span class="comment">//右轮速度初值</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxData;<span class="comment">//串口接收寄存器存储变量</span></span><br><span class="line"><span class="type">uint8_t</span> MID_Speed;<span class="comment">//基准速度</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> yaw_val;<span class="comment">//记录Yaw角</span></span><br><span class="line"><span class="type">float</span> yaw_detect;<span class="comment">//预测yaw角</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> Velocity_IL,Velocity_IR;<span class="comment">//左右轮速度环PID输入</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> Dif_Out;<span class="comment">//差速环PID输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Motor_flag;<span class="comment">//电机使能标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> M_Speed_L;<span class="comment">//左轮测速</span></span><br><span class="line"><span class="type">float</span> M_Speed_R;<span class="comment">//右轮测速</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Timer_Angel_Sleep;</span><br><span class="line"><span class="type">uint8_t</span> Timer_Angel_Sleep_flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外设列表：</span></span><br><span class="line"><span class="comment">//1.GPIO        LED</span></span><br><span class="line"><span class="comment">//2.PWM         定时器G0,两路PWM</span></span><br><span class="line"><span class="comment">//3.定时器      定时器A0</span></span><br><span class="line"><span class="comment">//4.串口        USART0:调试串口</span></span><br><span class="line"><span class="comment">//5.按键      </span></span><br><span class="line"><span class="comment">//6.OLED      硬件IIC</span></span><br><span class="line"><span class="comment">//7.MPU6050   硬件IIC</span></span><br><span class="line"><span class="comment">//8.串口屏</span></span><br><span class="line"><span class="comment">//9.陀螺仪串口</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> beep_flag = <span class="number">0</span>;<span class="comment">//声光提示标志位</span></span><br><span class="line"><span class="type">uint8_t</span> beep_key_flag;<span class="comment">//按键提示音</span></span><br><span class="line"><span class="type">uint8_t</span> beep_timer = <span class="number">0</span>;<span class="comment">//声光提示持续时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> hmi_speed[]=<span class="string">"n1.txt"</span>;<span class="comment">//测速</span></span><br><span class="line"><span class="type">char</span> hmi_yaw[]=<span class="string">"n2.txt"</span>;<span class="comment">//测角度</span></span><br><span class="line"><span class="type">char</span> hmi_trace[]=<span class="string">"n3.txt"</span>;<span class="comment">//测循迹</span></span><br><span class="line"><span class="type">char</span> hmi_totol[]=<span class="string">"n4.txt"</span>;<span class="comment">//测里程</span></span><br><span class="line"><span class="type">char</span> hmi_imu[]=<span class="string">"n5.txt"</span>;<span class="comment">//测记忆角度</span></span><br><span class="line"><span class="type">char</span> data_HMI[]=<span class="string">""</span>;<span class="comment">//串口屏数据存储空间</span></span><br><span class="line"><span class="type">uint8_t</span> Key_Timer;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Timer_1ms_counter;</span><br><span class="line"><span class="type">uint8_t</span> System_Mode;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> WD_Protect_Flag;</span><br><span class="line"><span class="type">uint8_t</span> WD_Protect_time;</span><br><span class="line"><span class="type">uint8_t</span> WD_Protect_err;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> K_ZX = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*初始加速函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Speed_InitPro</span><span class="params">(<span class="type">uint8_t</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">    {</span><br><span class="line">        Set_Speed(i,i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-主循环"><a class="markdownIt-Anchor" href="#2-主循环"></a> 2. 主循环</h2><p>执行系统所需要的初始化部分，注意初始化的顺序。</p><p>用于显示的部分放在主循环中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始加速函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Speed_InitPro</span><span class="params">(<span class="type">uint8_t</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> temp;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">    {</span><br><span class="line">        Set_Speed(i,i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*开启系统时钟中断，会导致串口工作异常或者程序卡死*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    SYSCFG_DL_init();<span class="comment">//syscfg初始化</span></span><br><span class="line">    delay_ms(<span class="number">100</span>);<span class="comment">//等待初始化稳定</span></span><br><span class="line">    OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">    OLED_ShowString(<span class="number">16</span>,<span class="number">8</span>,<span class="string">"OK"</span>,<span class="number">8</span>);</span><br><span class="line">    delay_ms(<span class="number">100</span>);<span class="comment">//等待陀螺仪稳定</span></span><br><span class="line">    Motor_Off();<span class="comment">//初始电机关闭，等待按键控制</span></span><br><span class="line">    </span><br><span class="line">    SYS_UART0_Init();<span class="comment">//串口0初始化</span></span><br><span class="line">    Screen_UART2_Init();<span class="comment">//串口2初始化</span></span><br><span class="line"></span><br><span class="line">    BP_Encoder_Init();<span class="comment">//编码器初始化</span></span><br><span class="line">    PID_Init();</span><br><span class="line">    delay_ms(<span class="number">1000</span>);<span class="comment">//等待初始化稳定</span></span><br><span class="line">    <span class="comment">//Speed_InitPro(Speed_midset*0.8);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编码器中断使能</span></span><br><span class="line">    delay_ms(<span class="number">50</span>);<span class="comment">//等待初始化稳定</span></span><br><span class="line">    TIMER_1_Init();<span class="comment">//定时器1初始化</span></span><br><span class="line">    TIMER_2_Init();</span><br><span class="line"></span><br><span class="line">    NVIC_EnableIRQ(UART_JY61P_INST_INT_IRQN);  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    { </span><br><span class="line">        Oled_Proc();</span><br><span class="line">        HMI_Proc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="维特陀螺仪"><a class="markdownIt-Anchor" href="#维特陀螺仪"></a> 维特陀螺仪</h1><h2 id="一-通信协议"><a class="markdownIt-Anchor" href="#一-通信协议"></a> 一、通信协议</h2><img src="/posts/37775/image-20241011224055889.png" class="" title="image-20241011224055889"><h3 id="11-读格式"><a class="markdownIt-Anchor" href="#11-读格式"></a> 1.1 读格式</h3><img src="/posts/37775/image-20241011224134268.png" class="" title="image-20241011224134268"><p>代码实现（仅读取角度）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接收变量</span></span><br><span class="line"><span class="type">uint8_t</span> RollL, RollH, PitchL, PitchH, YawL, YawH, VL, VH, SUM;</span><br><span class="line"><span class="type">float</span> Pitch,Roll,Yaw;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 串口接收状态标识</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_HEADER1 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_HEADER2 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECEIVE_DATA 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxState_JY = WAIT_HEADER1;</span><br><span class="line"><span class="type">uint8_t</span> receivedData[<span class="number">9</span>];<span class="comment">//接收数据储存数组</span></span><br><span class="line"><span class="type">uint8_t</span> dataIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 串口中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_JY61P_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">uint8_t</span> uartdata = DL_UART_Main_receiveData(UART_JY61P_INST); <span class="comment">// 接收一个uint8_t数据</span></span><br><span class="line">    <span class="keyword">switch</span> (RxState_JY) {</span><br><span class="line">    <span class="keyword">case</span> WAIT_HEADER1:</span><br><span class="line">        <span class="keyword">if</span> (uartdata == <span class="number">0x55</span>) { <span class="comment">//协议头</span></span><br><span class="line">            RxState_JY = WAIT_HEADER2;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WAIT_HEADER2:</span><br><span class="line">        <span class="keyword">if</span> (uartdata == <span class="number">0x53</span>) { <span class="comment">//数据内容：角度</span></span><br><span class="line">            RxState_JY = RECEIVE_DATA;</span><br><span class="line">            dataIndex = <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            RxState_JY = WAIT_HEADER1; <span class="comment">// 如果不是期望的第二个头，重置状态</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RECEIVE_DATA:</span><br><span class="line">        receivedData[dataIndex++] = uartdata;</span><br><span class="line">        <span class="keyword">if</span> (dataIndex == <span class="number">9</span>) {</span><br><span class="line">            <span class="comment">// 数据接收完毕，分配给具体的变量</span></span><br><span class="line">            RollL = receivedData[<span class="number">0</span>];</span><br><span class="line">            RollH = receivedData[<span class="number">1</span>];</span><br><span class="line">            PitchL = receivedData[<span class="number">2</span>];</span><br><span class="line">            PitchH = receivedData[<span class="number">3</span>];</span><br><span class="line">            YawL = receivedData[<span class="number">4</span>];</span><br><span class="line">            YawH = receivedData[<span class="number">5</span>];</span><br><span class="line">            VL = receivedData[<span class="number">6</span>];</span><br><span class="line">            VH = receivedData[<span class="number">7</span>];</span><br><span class="line">            SUM = receivedData[<span class="number">8</span>];</span><br><span class="line">            <span class="comment">// 校验SUM是否正确</span></span><br><span class="line">            <span class="type">uint8_t</span> calculatedSum = <span class="number">0x55</span> + <span class="number">0x53</span> + RollH + RollL + PitchH + PitchL + YawH + YawL + VH + VL;</span><br><span class="line">            <span class="keyword">if</span> (calculatedSum == SUM) {</span><br><span class="line">                <span class="comment">// 校验成功，可以进行后续处理</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 校验失败，处理错误</span></span><br><span class="line">            }</span><br><span class="line">            RxState_JY = WAIT_HEADER1; <span class="comment">// 重置状态以等待下一个数据包</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//DL_UART_Main_transmitData(UART_JY61P_INST, uartdata); // 可选：回传接收到的数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="12-写格式"><a class="markdownIt-Anchor" href="#12-写格式"></a> 1.2 写格式</h3><img src="/posts/37775/image-20241011224231172.png" class="" title="image-20241011224231172"><p>代码实现（Z轴置零）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送置偏航角置零命令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_JY61P_Zero_Yaw</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*解锁指令*/</span></span><br><span class="line">    DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X69</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X88</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XB5</span>);</span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">200</span>);<span class="comment">//延迟200ms</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*修改指令（Z轴置零）*/</span></span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X01</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X04</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">3000</span>);<span class="comment">//延迟3秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*保存指令*/</span></span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XFF</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0XAA</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line">DL_UART_Main_transmitDataBlocking(UART_JY61P_INST,<span class="number">0X00</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注意：CCS Theia编译可能无法找到报错位置，建议每次小幅修改后就立即编译&lt;/p&gt;
&lt;p&gt;主要问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何进行调参？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何设计一个完整的系统？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小车如何走直线？&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][3]UART、DMA、ADC</title>
    <link href="https://szturin.github.io/posts/24028/"/>
    <id>https://szturin.github.io/posts/24028/</id>
    <published>2024-09-15T13:56:13.000Z</published>
    <updated>2024-10-10T16:07:45.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-串口中断超时解析"><a class="markdownIt-Anchor" href="#一-串口中断超时解析"></a> 一、串口中断+超时解析</h1><h2 id="1-cubemx配置"><a class="markdownIt-Anchor" href="#1-cubemx配置"></a> 1. CubeMX配置</h2><h2 id="11-属性配置"><a class="markdownIt-Anchor" href="#11-属性配置"></a> 1.1 <strong>属性配置</strong></h2><p>主要配置波特率，其余默认</p><style>.qobikssqwibc{}</style><img src="/posts/24028/image-20240919224239733.png" class="qobikssqwibc" alt="image-20240919224239733"><p><strong>中断配置</strong></p><p>Preemption Priority：抢占优先级</p><p>Sub Priority: 子优先级</p><img src="/posts/24028/image-20240919224306805.png" class="" title="image-20240919224306805"><p><strong>串口的DMA设置</strong></p><p>只开接收DMA即可</p><p>DMA的模式：</p><ul><li>Normol</li><li>Circual</li></ul><img src="/posts/24028/image-20240919224441445.png" class="" title="image-20240919224441445"><img src="/posts/24028/image-20240919224501610.png" class="" title="image-20240919224501610"><h2 id="2-驱动程序编写"><a class="markdownIt-Anchor" href="#2-驱动程序编写"></a> 2. 驱动程序编写</h2><h3 id="21-串口重定向"><a class="markdownIt-Anchor" href="#21-串口重定向"></a> 2.1 串口重定向</h3><p><strong>在uasrt.c中进行修改</strong></p><img src="/posts/24028/image-20240919225413251.png" class="" title="image-20240919225413251"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE * str)</span></span><br><span class="line">{</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,(<span class="type">uint8_t</span> *)&amp;ch,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="22-app_uartc-变量定义"><a class="markdownIt-Anchor" href="#22-app_uartc-变量定义"></a> 2.2 <strong>app_uart.c 变量定义</strong></h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> uart_rx_index = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> uart_tx_ticks = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br></pre></td></tr></tbody></table></figure><h3 id="23-中断初始化"><a class="markdownIt-Anchor" href="#23-中断初始化"></a> 2.3 <strong>中断初始化</strong></h3><p>放入Core-&gt;Src-&gt;usart.c中</p><p>在初始化中使能串口中断，往buffer中每次填充一个字节，触发中断回调</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart1,uart_rx_buffer,<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><img src="/posts/24028/image-20240920223856904.png" class="" title="image-20240920223856904"><blockquote><p><mark>Hal库——中断回调函数</mark></p><p>在 STM32 的 HAL（硬件抽象层）库中，<strong>中断回调函数</strong>用于处理各种外设的中断事件。这些回调函数由 HAL 库提供，用户只需实现这些函数以响应特定的中断。</p><h3 id="1-一般函数-vs-回调函数"><a class="markdownIt-Anchor" href="#1-一般函数-vs-回调函数"></a> 1. <strong>一般函数 vs. 回调函数</strong></h3><ul><li><p><strong>逻辑限定普通函数的调用</strong>：</p><ul><li>逻辑条件通常在调用函数之前进行检查，确保在满足特定条件时再执行该函数。</li><li>这种方式在函数内部或外部使用条件语句（如 <code>if</code>）来控制函数的执行。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">normalFunction</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (condition) {  <span class="comment">// 条件检查</span></span><br><span class="line">        normalFunction();  <span class="comment">// 仅在条件满足时调用</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>回调函数</strong>：</p><ul><li>回调函数通过传递函数指针来实现灵活的调用，调用发生在某个事件或特定条件下。</li><li>这种机制允许外部函数（如事件处理或异步操作）在需要时调用传递的回调，而不需要直接控制逻辑。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callbackFunction</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">}</span><br><span class="line">      </span><br><span class="line"><span class="type">void</span> <span class="title function_">eventHandler</span><span class="params">(<span class="type">void</span> (*callback)())</span> {</span><br><span class="line">    <span class="comment">// 某个事件发生后调用回调</span></span><br><span class="line">    callback();  <span class="comment">// 不需要在这里检查条件</span></span><br><span class="line">}</span><br><span class="line">      </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    eventHandler(callbackFunction);  <span class="comment">// 传递回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="2-中断函数-vs-回调函数"><a class="markdownIt-Anchor" href="#2-中断函数-vs-回调函数"></a> 2. <strong>中断函数 vs. 回调函数</strong></h3><ul><li><strong>中断函数</strong>：<ul><li>直接处理外设中断的代码，通常是在中断服务例程 (ISR) 中实现。</li><li>代码较为复杂，涉及中断向量、优先级、屏蔽等设置。</li><li>可能会引入较长的中断处理时间，不适合执行复杂的任务。</li></ul></li><li><strong>回调函数</strong>：<ul><li>是一个更高层次的抽象，允许用户在中断发生时执行特定的处理逻辑。</li><li>HAL 库提供的回调函数允许用户定义中断后要执行的操作，而不需要直接修改中断服务例程。</li><li>更易于维护和调试，因为用户只需关注回调函数的逻辑，而不需要管理中断相关的低层实现。</li></ul></li></ul></blockquote><h3 id="24-回调函数声明"><a class="markdownIt-Anchor" href="#24-回调函数声明"></a> 2.4 回调函数声明</h3><p><strong>弱定义</strong></p><img src="/posts/24028/image-20240915220013260.png" class="" title="image-20240915220013260"><img src="/posts/24028/image-20240920223951975.png" class="" title="image-20240920223951975"><p><strong>自定义回调函数</strong></p><p>可以自行声明与弱定义回调函数同名的函数，会优先执行自定义的函数</p><p>Hal库中各种弱定义都是用__weak修饰的</p><img src="/posts/24028/image-20240915220050996.png" class="" title="image-20240915220050996"><p>过程：串口接收-&gt;触发回调-&gt;进入回调函数</p><p>PS: void HAL_UART_RxCpliCallback(UART_HandleTypeDef *huart) 不要用成 void HAL_UART_TxCpliCallback(UART_HandleTypeDef *huart)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(huart-&gt;Instance == USART1)</span><br><span class="line">    {</span><br><span class="line">        uart_rx_ticks = uwTick;</span><br><span class="line">        uart_rx_index++;<span class="comment">//索引自增</span></span><br><span class="line">        <span class="comment">//每次触发回调，都要重新初始化接收中断，定义接收的位置</span></span><br><span class="line">        HAL_UART_Receive_IT(&amp;huart1,&amp;uart_r_buffer[uart_rx_index],<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="25-串口解析"><a class="markdownIt-Anchor" href="#25-串口解析"></a> 2.5 串口解析</h3><p><strong>超时解析</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(uart_rx_index == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(uwTick - uart_rx_ticks &gt; <span class="number">100</span>)<span class="comment">//时间超过100</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"uart data:%s\n"</span>,uart_rx_buffer);<span class="comment">//发送串口接收内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span> (uart_rx_buffer,<span class="number">0</span>,uart_rx_index);<span class="comment">//清空</span></span><br><span class="line">        uart_rx_index = <span class="number">0</span>;<span class="comment">//指针指令</span></span><br><span class="line">        huart1.pRxBuffPtr = uart_rx_buffer;<span class="comment">//uart1缓存区指针指向buffer</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="无dma和环形缓冲区的问题"><a class="markdownIt-Anchor" href="#无dma和环形缓冲区的问题"></a> <strong># <mark>无DMA和环形缓冲区的问题</mark></strong></h2><blockquote><p><strong>当串口接收速率过快时，如视觉上位机频繁向单片机发送识别到的坐标数据，可能会导致单片机程序阻塞</strong></p><p><mark><strong>1. 串口阻塞的解决方案</strong></mark></p><img src="/posts/24028/image-20240919233036903.png" class="" title="image-20240919233036903"><p>DMA:数据转运</p><p>RingBuffer:环形缓存区</p><p><mark><strong>2. # 环形缓冲区的概念：</strong></mark></p><ul><li>头指针</li><li>尾指针</li></ul></blockquote><h2 id="现象"><a class="markdownIt-Anchor" href="#现象"></a> # 现象：</h2><h3 id="1-串口无解析发送上位机"><a class="markdownIt-Anchor" href="#1-串口无解析发送上位机"></a> 1. 串口无解析发送上位机</h3><p>CubeMX未定义串口引脚，未注意STM32外设引脚可复用问题</p><img src="/posts/24028/image-20240920234311280.png" class="" title="image-20240920234311280"><h3 id="2-回调函数名称错误"><a class="markdownIt-Anchor" href="#2-回调函数名称错误"></a> 2. 回调函数名称错误</h3><img src="/posts/24028/image-20240920231957317.png" class="" title="image-20240920231957317"><h1 id="二-dma空闲中断"><a class="markdownIt-Anchor" href="#二-dma空闲中断"></a> 二、DMA+空闲中断</h1><h2 id="dma的作用"><a class="markdownIt-Anchor" href="#dma的作用"></a> # DMA的作用</h2><blockquote><p>无DMA：数据-&gt;Uart寄存器-&gt;CPU访问Uart寄存器-&gt;执行其他程序部分</p><p>​-------如果串口通信速率过快------&gt;CPU频繁访问Uart寄存器--------&gt;程序阻塞</p><p>有DMA：数据-&gt;Uart-&gt;DMA访问Uart数据-&gt;存放到单片机内存地址</p><p>​CPU与DMA并行工作</p></blockquote><p>在上述配置的基础上对程序文件进行进一步修改。</p><h2 id="空闲中断"><a class="markdownIt-Anchor" href="#空闲中断"></a> # 空闲中断</h2><blockquote><h3 id="1-什么是空闲中断"><a class="markdownIt-Anchor" href="#1-什么是空闲中断"></a> 1. 什么是空闲中断？</h3><p>空闲中断（Idle Line Interrupt）是串口通信（UART）中常用的一种硬件中断机制。它用于检测串口接收线路在一段时间内没有接收到数据时触发。<strong>空闲中断的核心原理是检测 UART 外设的接收线路在数据传输结束后变为“空闲”状态</strong>（即，停止接收数据，线路上没有任何活动）。</p><p>当串口在接收数据时，硬件会自动维护一个“忙状态”标志。所有数据帧（包括起始位、数据位和停止位）都被接收完成后，接收线路进入空闲状态，此时 UART 硬件会触发“空闲中断”。这个中断标志仅在接收数据后首次空闲时触发，而不是每次线路空闲都会触发。因此，空闲中断能够用于判断数据帧的结束或检测数据包的传输完成。(比如，一个数据帧的长度为8个字节，在串口通信时每帧间隔一个字节来发送，在间隔的这个字节，触发空闲中断，进而可以在中断程序中处理数据帧)</p><h3 id="2-空闲中断在串口通信中的作用"><a class="markdownIt-Anchor" href="#2-空闲中断在串口通信中的作用"></a> 2. 空闲中断在串口通信中的作用</h3><p>空闲中断主要用于处理非固定长度的串口数据帧和高效的 DMA（Direct Memory Access，直接内存访问）数据传输。其作用和优势如下：</p><h4 id="21-非固定长度数据包接收"><a class="markdownIt-Anchor" href="#21-非固定长度数据包接收"></a> 2.1 <strong>非固定长度数据包接收</strong></h4><ul><li>当接收的数据是非固定长度时，很难在接收时预先设定要接收的数据长度。这时，可以利用空闲中断判断数据的结束。</li><li>当串口在 DMA 模式下接收数据时，无法使用常规的中断方式逐字节进行处理。使用空闲中断可以更高效地处理数据流，从而判断整个数据包的接收是否完成。</li></ul><h4 id="22-提高串口通信的效率"><a class="markdownIt-Anchor" href="#22-提高串口通信的效率"></a> 2.2 <strong>提高串口通信的效率</strong></h4><ul><li>使用空闲中断能够在 DMA 模式下提高串口通信的效率。当 DMA 缓冲区被填满或者数据接收超时时，空闲中断可以用于自动触发数据处理，避免了使用传统的定时器轮询方式。</li><li>通过判断空闲中断触发时间，可以精确判断数据包的传输完成，不必每次都等待接收缓冲区被填满才进行处理，从而提高系统响应速度。</li></ul><h4 id="23-降低-cpu-占用"><a class="markdownIt-Anchor" href="#23-降低-cpu-占用"></a> 2.3 <strong>降低 CPU 占用</strong></h4><ul><li>使用空闲中断配合 DMA 接收，可以降低 CPU 的使用率。在 DMA 接收过程中，数据自动从串口移入缓冲区，不需要 CPU 的参与，只有在接收结束或空闲中断触发时才进行数据处理。</li><li>对于接收频繁但数量不定的数据流（如传感器数据、通信协议数据包），使用空闲中断能极大地减少 CPU 的负担。</li></ul><h3 id="3-空闲中断在串口通信中的典型应用场景"><a class="markdownIt-Anchor" href="#3-空闲中断在串口通信中的典型应用场景"></a> 3. 空闲中断在串口通信中的典型应用场景</h3><h4 id="31-接收数据包的完整性判断"><a class="markdownIt-Anchor" href="#31-接收数据包的完整性判断"></a> 3.1 <strong>接收数据包的完整性判断</strong></h4><p>对于 UART 接收非固定长度的数据包（如 Modbus、串口通信协议），可以使用空闲中断来判断数据帧的结束。</p><p><strong>典型场景：</strong><br>假设通过 UART 接收的数据包长度不定，当接收到一个完整的数据帧时，串口线路会进入空闲状态，此时触发空闲中断，可以认为本次数据接收结束。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c复制代码// 空闲中断回调函数示例</span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {</span><br><span class="line">    if (__HAL_UART_GET_FLAG(huart, UART_FLAG_</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="1-变量声明"><a class="markdownIt-Anchor" href="#1-变量声明"></a> 1. 变量声明</h2><p><strong>声明 uart_rx_dma_buffer变量，用于数据转运</strong></p><img src="/posts/24028/image-20240919233721950.png" class="" title="image-20240919233721950"><h2 id="2-中断初始化"><a class="markdownIt-Anchor" href="#2-中断初始化"></a> 2. <strong>中断初始化</strong></h2><p>启用DMA相关中断</p><p>关闭DMA<mark>半中断</mark></p><img src="/posts/24028/image-20240919233901381.png" class="" title="image-20240919233901381"><p><strong>PS: 不再适用串口回调，改用DMA的方法</strong></p><img src="/posts/24028/image-20240919234047785.png" class="" title="image-20240919234047785"><h2 id="3-串口中断函数"><a class="markdownIt-Anchor" href="#3-串口中断函数"></a> 3. <strong>串口中断函数</strong></h2><p>每次触发串口中断，触发DMA中断</p><img src="/posts/24028/image-20240920200100912.png" class="" title="image-20240920200100912"><p><strong>取消使用串口中断回调函数</strong></p><img src="/posts/24028/image-20240920200332492.png" class="" title="image-20240920200332492"><p><strong>改用空闲中断回调函数</strong></p><p>PS: 不再需要串口超时解析</p><img src="/posts/24028/image-20240920200417955.png" class="" title="image-20240920200417955"><img src="/posts/24028/image-20240920200913934.png" class="" title="image-20240920200913934"><h2 id="现象-2"><a class="markdownIt-Anchor" href="#现象-2"></a> # 现象：</h2><img src="/posts/24028/image-20240921001109060.png" class="" title="image-20240921001109060"><h2 id="补充中断函数与回调函数的区别"><a class="markdownIt-Anchor" href="#补充中断函数与回调函数的区别"></a> # <mark>补充——中断函数与回调函数的区别</mark></h2><blockquote><p>在嵌入式编程中，HAL（硬件抽象层）库的中断函数和回调函数是常见的机制，尤其是在处理外设操作时。这两者的作用有时容易混淆，但它们的概念和使用场景有所不同。下面详细解释它们的区别：</p><h3 id="1-中断函数interrupt-service-routine-isr"><a class="markdownIt-Anchor" href="#1-中断函数interrupt-service-routine-isr"></a> 1. 中断函数（Interrupt Service Routine, ISR）</h3><p>中断函数是一段处理硬件中断的代码。当外设或处理器触发中断时，处理器会暂停当前的代码执行，转而执行与该中断对应的ISR。一旦中断被处理完毕，程序会恢复到原来的执行状态。</p><ul><li><strong>执行方式</strong>：硬件触发，直接由处理器执行，通常是高优先级。</li><li><strong>响应时间</strong>：要求短小精悍，不能执行耗时的任务，因为会阻塞其他中断。</li><li><strong>位置</strong>：ISR通常定义在HAL库或用户代码中，是一个固定的函数（如<code>TIM_IRQHandler</code>等）。</li><li><strong>调用方式</strong>：自动触发，由硬件中断控制器（NVIC）决定何时调用中断处理函数。</li></ul><h3 id="2-回调函数callback-function"><a class="markdownIt-Anchor" href="#2-回调函数callback-function"></a> 2. 回调函数（Callback Function）</h3><p>回调函数是一个函数指针，通过预先注册到某个模块或API中，等到某个事件发生时，由该模块或API负责调用。HAL库中的回调函数通常是在中断处理完毕后，由ISR或HAL库内部调用，用来进一步处理用户逻辑。</p><ul><li><strong>执行方式</strong>：由程序代码（比如ISR或定时器事件）调用，响应某个事件。</li><li><strong>响应时间</strong>：回调函数不要求像中断处理函数那样必须快速完成，往往用于处理稍复杂的业务逻辑。</li><li><strong>位置</strong>：回调函数通常由用户实现，并由HAL库的中断处理函数或其他机制调用（如<code>HAL_TIM_PeriodElapsedCallback</code>）。</li><li><strong>调用方式</strong>：回调函数不是直接由硬件触发，而是由软件触发，即当中断函数处理完硬件中断后，再调用用户注册的回调函数。</li></ul><h3 id="简单总结区别"><a class="markdownIt-Anchor" href="#简单总结区别"></a> 简单总结区别：</h3><ul><li><strong>触发机制</strong>：中断函数是由硬件事件（如定时器溢出、外部信号等）直接触发，而回调函数是由软件（如ISR）触发。</li><li><strong>职责范围</strong>：中断函数负责处理硬件中断，通常需要快速执行；回调函数则处理用户定义的业务逻辑，通常可以有更多的处理空间和时间。</li><li><strong>优先级</strong>：中断函数的优先级较高，回调函数的执行时间不受硬件中断控制，通常在中断函数结束之后才执行。</li></ul><h3 id="典型应用场景"><a class="markdownIt-Anchor" href="#典型应用场景"></a> 典型应用场景</h3><p>以定时器为例：</p><ul><li>当定时器溢出时，触发一个中断，执行定时器的中断函数<code>TIM_IRQHandler</code>。</li><li>在中断函数内部，可能会调用HAL库的定时器回调函数<code>HAL_TIM_PeriodElapsedCallback</code>，用于用户自定义的定时器周期性任务处理。</li></ul><p>这就是中断函数和回调函数的核心区别。</p></blockquote><h1 id="三-环形缓冲区"><a class="markdownIt-Anchor" href="#三-环形缓冲区"></a> 三、环形缓冲区</h1><h2 id="环形缓冲区的简介"><a class="markdownIt-Anchor" href="#环形缓冲区的简介"></a> # 环形缓冲区的简介</h2><blockquote><p>环形缓存区，也叫环形缓冲区（Ring Buffer）或循环缓冲区，是一种数据结构。它的特点 是缓存区的头和尾是连接在一起的，形成一个环。当数据写入缓冲区时，指针会不断前进，当到达缓冲区的末尾时，会重新回到开头，这样就实现了一个循环。</p><p><strong>环形缓冲区的组成</strong>：</p><ul><li>缓冲区数组：存放数据</li><li>头指针（读指针）</li><li>尾指针（写指针）</li></ul><p>环形缓冲区满足“先进先出的原则”</p><p><strong>环形缓冲区的优势</strong>：</p><ul><li>在普通串口接收中，数据是线性接收的，通常是通过中断或者轮询的方式处理数据。</li><li>而环形缓冲区适用于需要持续接收和处理数据的应用，如串口通信</li><li>环形缓冲区效率和可靠性高，但是需要复杂的管理逻辑</li></ul><p><strong>环形缓冲区的原理及实现</strong>：</p><p><a href="https://blog.csdn.net/2401_86353562/article/details/141830232">环形缓冲区(ring buffer)原理与实现详解-CSDN博客</a></p><img src="/posts/24028/9af5be294e82d063ae8d1eb1d642ed7a.png" class="" title="img"><p><strong>简单代码实现：</strong></p><p>缓冲区结构体定义</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFFER_SIZE (30) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">uint32_t</span> w;</span><br><span class="line">    <span class="type">uint32_t</span> r;</span><br><span class="line">    <span class="type">uint8_t</span> buffer[RINGBUFFER_SIZE];</span><br><span class="line">    <span class="type">uint32_t</span> itemCount;</span><br><span class="line">}<span class="type">ringbuffer_t</span>;</span><br></pre></td></tr></tbody></table></figure><p>初始化环形缓冲区</p><p>置零环形缓冲区中的元素</p><p>这里用到<code>memset</code>函数</p><ul><li>解释：复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</li><li>作用：是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法</li><li>头文件：C中<code>#include&lt;string.h&gt;</code>，C++中<code>#include&lt;cstring&gt;</code></li></ul><p>这里指向的是环形缓冲区内容buffer，为uint8_t类型的数组变量，数组大小为<code>RINGBUFFER_SIZE</code>，使用这段语句将buffer中的内存块内容置零。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ringbuffer_init</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 设置读指针和写指针初始值为0</span></span><br><span class="line">    rb-&gt;r = <span class="number">0</span>;</span><br><span class="line">    rb-&gt;w = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将缓冲区内存清零</span></span><br><span class="line">    <span class="built_in">memset</span>(rb-&gt;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * RINGBUFFER_SIZE);</span><br><span class="line">    <span class="comment">// 初始化项目计数为0</span></span><br><span class="line">    rb-&gt;itemCount = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>检查缓冲区是否已满</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查环形缓冲区是否已满</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">ringbuffer_is_full</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果项目计数等于缓冲区大小，返回1（已满），否则返回0（未满）</span></span><br><span class="line">    <span class="keyword">return</span> (rb-&gt;itemCount == RINGBUFFER_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>检查缓冲区是否为空</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查环形缓冲区是否为空</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">ringbuffer_is_empty</span><span class="params">(<span class="type">ringbuffer_t</span> *rb)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果项目计数为0，返回1（为空），否则返回0（非空）</span></span><br><span class="line">    <span class="keyword">return</span> (rb-&gt;itemCount == <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>向环形缓冲区写入数据</p><p>这里限制了向环形缓冲区写入数据的个数：即限定在环形缓冲区数组索引大小内</p><p>数据根据写指针当前指向的位置，进行写入。数据完成写入后，写指针递增。如果写指针当前到达缓冲区索引尾部，那么返回索引头部，即指向0</p><p>此段代码管理逻辑中，如果当前的环形缓冲区已经写满，需要经过将缓冲区的数据取出后，才能继续对缓冲区进行写入操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向环形缓冲区写入数据</span></span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">ringbuffer_write</span><span class="params">(<span class="type">ringbuffer_t</span> *rb, <span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果缓冲区已满，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_full(rb))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 将数据写入缓冲区</span></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        rb-&gt;buffer[rb-&gt;w] = *data++;  <span class="comment">// 写入数据并移动写指针</span></span><br><span class="line">        rb-&gt;w = (rb-&gt;w + <span class="number">1</span>) % RINGBUFFER_SIZE;  <span class="comment">// 写指针循环递增</span></span><br><span class="line">        rb-&gt;itemCount++;  <span class="comment">// 增加项目计数</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 写入成功返回0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从缓冲区读取数据</p><p>缓冲区有数据，操作才有效</p><p>数据根据读指针当前指向的位置，进行读取。数据完成读取后，读指针递增。如果读指针当前到达缓冲区索引尾部，那么返回索引头部，即指向0。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从环形缓冲区读取数据</span></span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">ringbuffer_read</span><span class="params">(<span class="type">ringbuffer_t</span> *rb, <span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果缓冲区为空，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_empty(rb))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓冲区读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    {</span><br><span class="line">        *data++ = rb-&gt;buffer[rb-&gt;r];  <span class="comment">// 读取数据并移动读指针</span></span><br><span class="line">        rb-&gt;r = (rb-&gt;r + <span class="number">1</span>) % RINGBUFFER_SIZE;  <span class="comment">// 读指针循环递增</span></span><br><span class="line">        rb-&gt;itemCount--;  <span class="comment">// 减少项目计数</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 读取成功返回0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="1-移植环形缓冲区驱动文件"><a class="markdownIt-Anchor" href="#1-移植环形缓冲区驱动文件"></a> 1. <strong>移植环形缓冲区驱动文件</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ringbuffer_t</span> usart_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> usart_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br></pre></td></tr></tbody></table></figure><ul><li>判断ringbuffer是否满</li><li>写入数据</li><li>清空结构体</li></ul><h2 id="2-空闲中断回调函数"><a class="markdownIt-Anchor" href="#2-空闲中断回调函数"></a> 2. <strong>空闲中断回调函数</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief UART DMA接收完成回调函数 </span></span><br><span class="line"><span class="comment">将接收到的数据写入环形缓冲区，并清空DMA缓冲区</span></span><br><span class="line"><span class="comment">  * @param huart UART句柄 </span></span><br><span class="line"><span class="comment">  * @param Size 接收到的数据大小 </span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//空闲中断回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (huart-&gt;Instance == USART1)  <span class="comment">// 判断是 USART1 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//引入环形缓存区</span></span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line">ringbuffer_write(&amp;usart_rb,uart_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-修改串口解析"><a class="markdownIt-Anchor" href="#2-修改串口解析"></a> 2. <strong>修改串口解析</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb))<span class="keyword">return</span>;</span><br><span class="line">    ringbuffer_read(&amp;usart_rb,usart_read_buffer,usart_rb.itemCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ringbuffer data:%s\n"</span>,usart_read_buffer);</span><br><span class="line">    meset(usart_read_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>)*<span class="number">128</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><mark><strong>STM32串口通信方法总结:</strong></mark></p><ul><li><p>超时解析</p></li><li><p>DMA空闲中断</p></li><li><p>环形缓存区</p></li></ul><h1 id="四-adc和dma"><a class="markdownIt-Anchor" href="#四-adc和dma"></a> 四、ADC和DMA</h1><blockquote><p>STM32的ADC（模数转换器）通道IN11指的是STM32微控制器上一个特定的ADC输入通道。每个STM32芯片的ADC都有多个模拟输入引脚，这些引脚标记为<code>INx</code>（例如IN0、IN1、IN2等），对应不同的GPIO引脚。</p><p>具体到<strong>IN11</strong>，它是ADC的第11个输入通道，通常与一个特定的GPIO引脚连接。该引脚用于将模拟信号输入到ADC进行模数转换。</p><p>CT117E原理图：</p><img src="/posts/24028/image-20240921165117470.png" class="" title="image-20240921165117470"></blockquote><h2 id="1-cubemx配置-2"><a class="markdownIt-Anchor" href="#1-cubemx配置-2"></a> 1. CubeMX配置</h2><h3 id="11-adc通道分配"><a class="markdownIt-Anchor" href="#11-adc通道分配"></a> 1.1 <strong>ADC通道分配：</strong></h3><ul><li>ADC1: IN11</li><li>ADC2: IN15</li></ul><img src="/posts/24028/image-20240920205816075.png" class="" title="image-20240920205816075"><h3 id="12-配置dma"><a class="markdownIt-Anchor" href="#12-配置dma"></a> 1.2 配置DMA</h3><h4 id="121-配置dma通道"><a class="markdownIt-Anchor" href="#121-配置dma通道"></a> 1.2.1 配置DMA通道</h4><img src="/posts/24028/image-20240920205900067.png" class="" title="image-20240920205900067"><h4 id="122-配置为循环模式"><a class="markdownIt-Anchor" href="#122-配置为循环模式"></a> 1.2.2 配置为循环模式</h4><img src="/posts/24028/image-20240921004004318.png" class="" title="image-20240921004004318"><h4 id="123-配置dma速度"><a class="markdownIt-Anchor" href="#123-配置dma速度"></a> 1.2.3 配置DMA速度</h4><p>设置为中、高均可</p><img src="/posts/24028/image-20240920210046359.png" class="" title="image-20240920210046359"><h3 id="13-配置adc属性"><a class="markdownIt-Anchor" href="#13-配置adc属性"></a> 1.3 <strong>配置ADC属性</strong></h3><ul><li>四分频</li><li>DMA使能</li><li>循环使能</li></ul><img src="/posts/24028/image-20240920210259713.png" class="" title="image-20240920210259713"><h3 id="14-配置adc中断"><a class="markdownIt-Anchor" href="#14-配置adc中断"></a> 1.4  <strong>配置ADC中断</strong></h3><p>优先级为2即可</p><img src="/posts/24028/image-20240920210416469.png" class="" title="image-20240920210416469"><h2 id="2-驱动程序编写-2"><a class="markdownIt-Anchor" href="#2-驱动程序编写-2"></a> 2. 驱动程序编写</h2><h3 id="21-创建adc_appc"><a class="markdownIt-Anchor" href="#21-创建adc_appc"></a> 2.1 <strong>创建adc_app.c</strong></h3><p><strong>变量声明</strong></p><img src="/posts/24028/image-20240920211129892.png" class="" title="image-20240920211129892"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> dma_buff[<span class="number">2</span>][<span class="number">30</span>];<span class="comment">//双通道DMA</span></span><br><span class="line"><span class="type">float</span> adc_value[<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure><p><strong>在主程序初始化启用DMA 转运 ADC 数据</strong></p><img src="/posts/24028/image-20240920211606752.png" class="" title="image-20240920211606752"><h3 id="22-定义adc进程"><a class="markdownIt-Anchor" href="#22-定义adc进程"></a> 2.2 <strong>定义ADC进程</strong></h3><img src="/posts/24028/image-20240920211903715.png" class="" title="image-20240920211903715"><ul><li>读取电压dma储存数据</li><li>转换为模拟电压值</li></ul><p>同样的，记得在任务调度器中添加proc</p><h3 id="23-lcd显示"><a class="markdownIt-Anchor" href="#23-lcd显示"></a> 2.3 <strong>lcd显示</strong></h3><img src="/posts/24028/image-20240920212245141.png" class="" title="image-20240920212245141"><h2 id="动态窗口"><a class="markdownIt-Anchor" href="#动态窗口"></a> # <strong><mark>动态窗口</mark></strong></h2><ul><li>使用环形缓存区</li><li>定义结构体</li></ul><img src="/posts/24028/image-20240920214629559.png" class="" title="image-20240920214629559"><img src="/posts/24028/image-20240920214552510.png" class="" title="image-20240920214552510"><h1 id="多串口通信"><a class="markdownIt-Anchor" href="#多串口通信"></a> 多串口通信</h1><h2 id="示例一"><a class="markdownIt-Anchor" href="#示例一"></a> 示例一</h2><p>使用DMA+环形缓冲区+空闲中断回调的方法，使用串口通信，在解析函数中每次解析对象为串口一次性连续接收到的数据。</p><p>所以，在解析函数<code>uart_proc</code>中一次完成对串口数据内容的解析即可，不需要再用状态机的判断逻辑。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"usart_app.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> uart_rx_index = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> uart_rx_ticks = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">uint8_t</span> uart_rx_dma_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">ringbuffer_t</span> usart_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"><span class="type">uint8_t</span> usart_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> uart2_rx_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">uint8_t</span> uart2_rx_dma_buffer[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="type">ringbuffer_t</span> usart2_rb; <span class="comment">//定义ringbuffer_t类型结构体变量</span></span><br><span class="line"><span class="type">uint8_t</span> usart2_read_buffer[<span class="number">128</span>];<span class="comment">//定义环形缓存区数组</span></span><br><span class="line"></span><br><span class="line">DataPacket context; <span class="comment">// 初始化上下文</span></span><br><span class="line"><span class="comment">//串口中断回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//    if(huart-&gt;Instance == USART1)</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        uart_rx_ticks = uwTick;</span></span><br><span class="line"><span class="comment">//        uart_rx_index++;//索引自增</span></span><br><span class="line"><span class="comment">//        //每次触发回调，都要重新初始化接收中断，定义接收的位置</span></span><br><span class="line"><span class="comment">//        HAL_UART_Receive_IT(&amp;huart1,&amp;uart_rx_buffer[uart_rx_index],1);</span></span><br><span class="line"><span class="comment">////printf("test");//排错</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//空闲中断回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"dma data:%s\n"</span>,uart2_rx_dma_buffer);<span class="comment">//发送串口接收内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (huart-&gt;Instance == USART1)  <span class="comment">// 判断是 USART1 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//引入环形缓存区</span></span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line">ringbuffer_write(&amp;usart_rb,uart_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(huart-&gt;Instance == USART2)  <span class="comment">// 判断是 USART2 触发的中断</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(!ringbuffer_is_full(&amp;usart2_rb))<span class="comment">//判断环形缓存区是否为空</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">ringbuffer_write(&amp;usart2_rb,uart2_rx_dma_buffer,Size);<span class="comment">//将DMA缓冲区中的数据写入环形缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(uart2_rx_dma_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(uart2_rx_dma_buffer));<span class="comment">//清空</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//    if(uart_rx_index == 0) return;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    if(uwTick - uart_rx_ticks &gt; 100)//时间超过100</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        printf("uart data:%s\n",uart_rx_buffer);//发送串口接收内容</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//        memset (uart_rx_buffer,0,uart_rx_index);//清空</span></span><br><span class="line"><span class="comment">//        uart_rx_index = 0;//指针指令</span></span><br><span class="line"><span class="comment">//        huart1.pRxBuffPtr = uart_rx_buffer;//uart1缓存区指针指向buffer</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">// 如果环形缓冲区为空，直接返回 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ringbuffer_is_empty(&amp;usart_rb) &amp;&amp; ringbuffer_is_empty(&amp;usart2_rb)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从环形缓冲区读取数据到读取缓冲区 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ringbuffer_read(&amp;usart_rb, usart_read_buffer, usart_rb.itemCount);</span></span><br><span class="line">ringbuffer_read(&amp;usart2_rb, usart2_read_buffer, usart2_rb.itemCount);</span><br><span class="line"><span class="comment">// 打印读取缓冲区中的数据 </span></span><br><span class="line"><span class="comment">//printf("ringbuffer data: %s\n", usart_read_buffer);</span></span><br><span class="line"><span class="comment">// 上位机&lt;test协议&gt;</span></span><br><span class="line"><span class="comment">//printf("{plotter}%s\r\n", usart_read_buffer);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//问题1：用状态机写，会导致无法一次性解码；</span></span><br><span class="line"><span class="comment">//使用串口上位机，发现每次发送串口数据，状态机才会+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(usart_read_buffer[0] == 0xFF &amp;&amp; usart_read_buffer[3] == 0xFB)//帧头帧尾检测</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(usart_read_buffer[1] == 0x2A){</span></span><br><span class="line"><span class="comment">context.data_type = 1;//正数</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else if(usart_read_buffer[1] == 0x2B){</span></span><br><span class="line"><span class="comment">context.data_type = 2;//负数</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">context.data = usart_read_buffer[2];</span></span><br><span class="line"><span class="comment">number_detect = context.data;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parse_buffer(usart_read_buffer,sizeof(usart_read_buffer),&amp;context);</span></span><br><span class="line">parse_buffer(usart2_read_buffer,<span class="keyword">sizeof</span>(usart2_read_buffer),&amp;context);</span><br><span class="line"><span class="comment">//问题2：无memset会怎么样？</span></span><br><span class="line"><span class="comment">//memset(usart_read_buffer, 0, sizeof(uint8_t) * BUUFER_SIZE);</span></span><br><span class="line"><span class="built_in">memset</span>(usart2_read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) * BUUFER_SIZE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据帧解析函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_buffer</span><span class="params">(<span class="type">uint8_t</span> *buffer,<span class="type">size_t</span> size,DataPacket* data)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(size &lt; <span class="number">4</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//数据帧长度小于4，返回 0 表示解析失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; buffer[<span class="number">3</span>] == <span class="number">0xFB</span>)<span class="comment">//帧头帧尾检测</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buffer[<span class="number">1</span>] == <span class="number">0x2A</span>){</span><br><span class="line">data -&gt; data_type = <span class="number">1</span>;<span class="comment">//正数</span></span><br><span class="line">data -&gt; data = buffer[<span class="number">2</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(buffer[<span class="number">1</span>] == <span class="number">0x2B</span>){</span><br><span class="line">data -&gt; data_type = <span class="number">2</span>;<span class="comment">//负数</span></span><br><span class="line">data -&gt; data = buffer[<span class="number">2</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//非正确类型，解析失败</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//解析成功</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//帧头帧尾错误，解析失败</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("%c%c\n", context.state,usart_read_buffer[2]);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-串口中断超时解析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-串口中断超时解析&quot;&gt;&lt;/a&gt; 一、串口中断+超时解析&lt;/h1&gt;
&lt;h2 id=&quot;1-cubemx配置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【嵌入式】[开发常见问题][1]</title>
    <link href="https://szturin.github.io/posts/33286/"/>
    <id>https://szturin.github.io/posts/33286/</id>
    <published>2024-09-13T14:00:07.000Z</published>
    <updated>2024-09-16T06:47:34.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="keil问题"><a class="markdownIt-Anchor" href="#keil问题"></a> Keil问题</h1><h2 id="编译报错问题1"><a class="markdownIt-Anchor" href="#编译报错问题1"></a> 编译报错问题1：</h2><blockquote><p>*** Using Compiler ‘V5.06 update 5 (build 528)’, folder: ‘D:\keil5\ARM\ARMCC\Bin’ Build target ‘Test_v2’ FCARM - Output Name not specified, please check ‘Options for Target - Utilities’ Target not created. Build Time Elapsed:  00:00:00</p></blockquote><p>原因：引入了错误的文件类型</p><p>解决方案：<a href="https://blog.csdn.net/Zhichao_Zhang/article/details/125893598">keil错误和解决办法(1):FCARM - Output Name not specified, please check ‘Options for Target - Utilities‘_fcarm - output name not specified, please check 'o-CSDN博客</a></p><p>注意：.c文件要配置为</p><img src="/posts/33286/image-20240913225206874.png" class="" title="image-20240913225206874"><p>.h文件要配置为</p><img src="/posts/33286/image-20240913225225217.png" class="" title="image-20240913225225217"><p>但是，只要导入的时候，选择All files，就不会出现文件类型引用错误。</p><img src="/posts/33286/image-20240913225300078.png" class="" title="image-20240913225300078">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;keil问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#keil问题&quot;&gt;&lt;/a&gt; Keil问题&lt;/h1&gt;
&lt;h2 id=&quot;编译报错问题1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#编译报错问题1&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][嵌入式][1]嵌入式工程模板与“任务调度器”</title>
    <link href="https://szturin.github.io/posts/56683/"/>
    <id>https://szturin.github.io/posts/56683/</id>
    <published>2024-09-09T14:35:16.000Z</published>
    <updated>2024-09-21T07:13:28.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-任务调度器"><a class="markdownIt-Anchor" href="#一-任务调度器"></a> 一、任务调度器</h1><h2 id="1-调度器结构体"><a class="markdownIt-Anchor" href="#1-调度器结构体"></a> 1. 调度器结构体</h2><p><strong>函数指针和指针函数:</strong><a href="https://blog.csdn.net/baidu_37973494/article/details/83150266">C语言基础知识：函数指针&amp;指针函数（定义格式、作用及用法说明）_指针函数的定义-CSDN博客</a></p><p>PS: 函数指针本身上还是一个指针，和一般指针没有区别，指向函数的执行地址</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调度器类型的结构体类型声明</span></span><br><span class="line"><span class="comment">//任务结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">void</span> (*task_func)(<span class="type">void</span>);<span class="comment">//函数指针</span></span><br><span class="line">    <span class="type">uint32_t</span> rate_ms;<span class="comment">//任务运行周期</span></span><br><span class="line">    <span class="type">uint32_t</span> last_run;<span class="comment">//上次运行时间</span></span><br><span class="line">} <span class="type">scheduler_task_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><code>typedef struct {} scheduler_task_t;</code>是⼀种定义新结构体类型的⽅式，这⾥定义 了⼀个名为  scheduler_task_t 的结构体类型。这个结构体类型包含三个成员。</p><ul><li><p><code>void *task_func(void);</code>定义了一个函数指针，用于储存任务函数的地址，便于进行任务调度</p></li><li><p><code>rate_ms</code>表示任务具体的执行周期</p></li><li><p><code>last_run</code>⽤于存储任务上次运⾏的时间戳（以毫秒为单位）。该成员⽤于 记录任务上⼀次被调度执⾏的时间点，以便计算任务是否需要再次执⾏</p></li></ul><p>静态任务数组，每个任务包括任务函数，执行周期，和上次执行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Led_task</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义调度器类型的变量 任务</span></span><br><span class="line"><span class="comment">//任务数组</span></span><br><span class="line"><span class="comment">//给scheduler_task_t类型变量tasks赋初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">scheduler_task_t</span> tasks[] ={</span><br><span class="line">    {Led_task,<span class="number">1000</span>,<span class="number">0</span>}<span class="comment">//定义一个任务，任务函数为Led_Proc,执行周期为1000毫秒，初始上次运行时间为0</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="2-调度器初始化"><a class="markdownIt-Anchor" href="#2-调度器初始化"></a> 2. 调度器初始化</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">//计算任务数组中任务函数的个数，结果储存在tasks_num中</span></span><br><span class="line">    tasks_num = <span class="keyword">sizeof</span>(tasks)/<span class="keyword">sizeof</span>(<span class="type">scheduler_task_t</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-调度器函数"><a class="markdownIt-Anchor" href="#3-调度器函数"></a> 3. 调度器函数</h2><p>遍历任务数组，检查是否有任务需要进行，如果系统当前时间超过任务的执行周期，那么执行任务变更，并且更新上次运行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_run</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">/*任务轮询*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>; i&lt; tasks_num; i++){</span><br><span class="line">        <span class="comment">//获取当前时间（毫秒）</span></span><br><span class="line">        <span class="type">uint8_t</span> time_now = HAL_GetTick();</span><br><span class="line">        <span class="comment">//检查任务是否到达当前时间点</span></span><br><span class="line">        <span class="keyword">if</span>(time_now &gt;= tasks[i].rate_ms + tasks[i].last_run){</span><br><span class="line">            <span class="comment">//更新任务的上次运行时间，保存时间戳</span></span><br><span class="line">            tasks[i].last_run = time_now;<span class="comment">//保存当前时间</span></span><br><span class="line">            tasks[i].task_func();<span class="comment">//执行对应指向的任务</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-任务调度器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-任务调度器&quot;&gt;&lt;/a&gt; 一、任务调度器&lt;/h1&gt;
&lt;h2 id=&quot;1-调度器结构体&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-调度器结</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【Tensorflow】[2] 神经网络搭建</title>
    <link href="https://szturin.github.io/posts/34487/"/>
    <id>https://szturin.github.io/posts/34487/</id>
    <published>2024-09-07T17:12:30.000Z</published>
    <updated>2024-10-16T12:26:46.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-独热编码"><a class="markdownIt-Anchor" href="#一-独热编码"></a> 一、独热编码</h1><p>独热编码使用N位代表N种状态，任意时候只有其中一位有效。采用独热编码的例程：</p><p>独热编码使用N位代表N种状态，任意时候只有其中一位有效。</p><p>采用独热编码的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">性别:  </span><br><span class="line">[0, 1]代表女，[1, 0]代表男</span><br><span class="line"></span><br><span class="line">数字0-9: </span><br><span class="line">[0,0,0,0,0,0,0,0,0,1]代表9，[0,1,0,0,0,0,0,0,0,0]代表1</span><br></pre></td></tr></tbody></table></figure><p>独热编码的优点在于</p><ul><li>能够处理非连续型数值特征</li><li>在一定程度上也扩充了特征。比如性别本身是一个特征，经过编码以后，就变成了男或女两个特征。</li><li>适合分类</li></ul><p>在神经网络中，独热编码其实具有很强的容错性，比如神经网络的输出结果是 [0,0.1,0.2,0.7,0,0,0,0,0, 0]转成独热编码后，表示数字3。即值最大的地方变为1，其余均为0。[0,0.1,0.4,0.5,0,0,0,0,0, 0]也能表示数字3。</p><blockquote><p>numpu中有一个函数，numpy.argmax()可以取得最大值的下标。</p></blockquote><h1 id="二-神经网络训练的重要概念"><a class="markdownIt-Anchor" href="#二-神经网络训练的重要概念"></a> 二、神经网络训练的重要概念</h1><h2 id="1-输入x输出y-标签label"><a class="markdownIt-Anchor" href="#1-输入x输出y-标签label"></a> 1. 输入（x）输出（y）、标签（label）</h2><ul><li>输入是指传入给网络处理的向量，相当于数学函数中的变量。</li><li>输出是指网络处理后返回的结果，相当于数据函数中的函数值。</li><li>标签是指我们期望网络返回的结果。</li></ul><p>对于识别mnist图片而言，输入是大小为784（28 * 28）的向量，输出是大小为10的概率向量（概率最大的位置，即预测的数字）,这部分操作由<mark>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的</mark>。</p><h2 id="2-损失函数loss-function"><a class="markdownIt-Anchor" href="#2-损失函数loss-function"></a> 2. 损失函数（loss function）</h2><p>损失函数评估网络模型的好坏，值越大，表示模型越差，值越小，表示模型越好。因为传入大量的训练集训练的目标，就是将损失函数的值降到最小。</p><h3 id="21-常见的损失函数定义"><a class="markdownIt-Anchor" href="#21-常见的损失函数定义"></a> 2.1 <strong>常见的损失函数定义：</strong></h3><p><strong>差的平方和 sum((y - label)^2)</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 1] 与 [0.1, 0.3, 0.6]的差的平方和为 0.01 + 0.09 + 0.16 = 0.26</span><br><span class="line">[0, 0, 1] 与 [0.2, 0.2, 0.6]的差的平方和为 0.04 + 0.04 + 0.16 = 0.24</span><br><span class="line">[0, 0, 1] 与 [0.1, 0, 0.9]的差的平方和为 0.01 + 0.01 = 0.02</span><br></pre></td></tr></tbody></table></figure><p><strong>交叉熵 -sum(label * log(y))</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 1] 与 [0.1, 0.3, 0.6]的交叉熵为 -log(0.6) = 0.51</span><br><span class="line">[0, 0, 1] 与 [0.2, 0.2, 0.6]的交叉熵为 -log(0.6) = 0.51</span><br><span class="line">[0, 0, 1] 与 [0.1, 0, 0.9]的交叉熵为 -log(0.9) = 0.10</span><br></pre></td></tr></tbody></table></figure><p>当label为0时，交叉熵为0，label为1时，交叉熵为-log(y)，交叉熵只关注独热编码中有效位的损失。这样屏蔽了无效位值的变化（无效位的值的变化并不会影响最终结果），并且通过取对数放大了有效位的损失。当有效位的值趋近于0时，交叉熵趋近于正无穷大。</p><h2 id="3-回归模型"><a class="markdownIt-Anchor" href="#3-回归模型"></a> 3. 回归模型</h2><p>我们可以将网络理解为一个函数，回归模型，其实是希望对这个函数进行拟合。<br>比如定义模型为 Y = X * w + b，对应的损失即</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss = (Y - labal)^2</span><br><span class="line">     = -(X * w - b - label)^2</span><br><span class="line">这里损失函数用方差计算，这个函数是关于w和b的二次函数，所以神经网络训练的目的是找到w和b，使得loss最小。</span><br></pre></td></tr></tbody></table></figure><p>可以通过不断地传入X和label的值，来修正w和b，使得最终得到的Y与label的loss最小。这个训练的过程，可以采用<strong>梯度下降</strong>的方法。通过梯度下降，找到最快的方向，调整w和b值，使得w * X + b的值越来越接近label。</p><p><a href="https://blog.csdn.net/iqdutao/article/details/107174240">机器学习-梯度下降算法原理及公式推导_梯度下降计算公式-CSDN博客</a></p><img src="/posts/34487/loss.png" class="" title="loss"><h2 id="4-学习速率"><a class="markdownIt-Anchor" href="#4-学习速率"></a> 4. 学习速率</h2><p>简单说，梯度即一个函数的斜率，找到函数的斜率，其实就知道了w和b的值往哪个方向调整，能够让函数值（loss）降低得最快。那么方向知道了，往这个方向调整多少呢？这个数，神经网络中称之为学习速率。学习速率调得太低，训练速度会很慢，学习速率调得过高，每次迭代波动会很大</p><h2 id="5-softmax激活函数"><a class="markdownIt-Anchor" href="#5-softmax激活函数"></a> 5. softmax激活函数</h2><p>作用：一是放大效果，二是梯度下降时需要一个可导的函数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def softmax(x):</span><br><span class="line">    import numpy as np</span><br><span class="line">    return np.exp(x) / np.sum(np.exp(x), axis=0)</span><br><span class="line"></span><br><span class="line">softmax([4, 5, 10])</span><br><span class="line"># [ 0.002,  0.007,  0.991]</span><br></pre></td></tr></tbody></table></figure><h1 id="三-tensorflow识别手写数字-实现简单的神经网络"><a class="markdownIt-Anchor" href="#三-tensorflow识别手写数字-实现简单的神经网络"></a> 三、tensorflow识别手写数字-实现简单的神经网络</h1><h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> # 思考</h1><h2 id="一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"><a class="markdownIt-Anchor" href="#一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"></a> 一、输入x是 784长度的向量，什么机制使得输出y变成的长度为10的向量？</h2><p>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的。具体操作通过 <strong>权重矩阵</strong> 和 <strong>偏置向量</strong> 来完成。</p><h3 id="1-全连接层的基本机制"><a class="markdownIt-Anchor" href="#1-全连接层的基本机制"></a> 1. <strong>全连接层的基本机制：</strong></h3><p>全连接层的工作机制可以用矩阵乘法来描述。给定输入向量 x<em>x</em>（长度为784），要转换为长度为10的输出向量，通常通过如下步骤：</p><h4 id="2-步骤"><a class="markdownIt-Anchor" href="#2-步骤"></a> 2. <strong>步骤：</strong></h4><ol><li><p><strong>输入向量 <img src="/posts/34487/image-20240907224214042.png" class="" title="image-20240907224214042"></strong>：这是一个长度为784的向量，表示神经网络的输入。</p><img src="/posts/34487/image-20240907224042533.png" class="" title="image-20240907224042533"></li><li><p><strong>权重矩阵 <img src="/posts/34487/image-20240907224200098.png" class="" title="image-20240907224200098"></strong>：全连接层会有一个权重矩阵 W<em>W</em>，其维度是 10×78410×784，表示从输入784维向量到输出10维向量的权重连接。每一行表示一个输出神经元与所有输入神经元的权重连接。</p></li><li><p><strong>偏置向量 <img src="/posts/34487/image-20240907224226570.png" class="" title="image-20240907224226570"></strong>：偏置向量 b<em>b</em> 是一个长度为10的向量，表示每个输出神经元的偏置。</p></li><li><p><strong>计算输出向量 <img src="/posts/34487/image-20240907224234671.png" class="" title="image-20240907224234671"></strong>：通过矩阵乘法计算输出向量。输出向量 o<em>o</em> 的维度是10。具体计算方式如下：</p><img src="/posts/34487/image-20240907224051327.png" class="" title="image-20240907224051327"><ul><li>W \cdot x )：矩阵 ( W ) 乘以向量 ( x )，将784维的输入向量映射为10维的输出向量。</li></ul></li></ol><ul><li><p>假设输入向量<img src="/posts/34487/image-20240907224214042.png" class="" title="image-20240907224214042"> 是长度为784的向量：</p><img src="/posts/34487/image-20240907224100515.png" class="" title="image-20240907224100515"></li><li><p>权重矩阵 <img src="/posts/34487/image-20240907224200098.png" class="" title="image-20240907224200098"> 是一个 10×78410×784 的矩阵：</p><img src="/posts/34487/image-20240907224116095.png" class="" title="image-20240907224116095"></li><li><p>偏置向量<img src="/posts/34487/image-20240907224226570.png" class="" title="image-20240907224226570"> 是一个长度为10的向量：</p><img src="/posts/34487/image-20240907224125174.png" class="" title="image-20240907223954313"></li><li><p>输出向量 <img src="/posts/34487/image-20240907224234671.png" class="" title="image-20240907224234671">通过矩阵乘法和加法得到，维度为10：</p><img src="/posts/34487/image-20240907224134345.png" class="" title="image-20240907224134345"></li></ul><p>每一行表示一个输出神经元的结果，最终得到一个长度为10的向量。</p><h3 id="4-激活函数"><a class="markdownIt-Anchor" href="#4-激活函数"></a> 4. <strong>激活函数：</strong></h3><p>在得到长度为10的向量后，通常会将其通过激活函数进行处理。在分类任务中，输出层通常使用 <strong>Softmax</strong> 函数，将每个输出值转换为概率值。Softmax 函数公式为：</p><img src="/posts/34487/image-20240907224012315.png" class="" title="image-20240907224012315"><p>这会将输出向量 o<em>o</em> 转换为一个概率分布，表示输入属于不同类别的概率。</p><p>作用：对输出结果进行非负化和归一化，保证了概论的和为1</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>将784长度的输入向量变为10长度的输出向量的关键步骤是通过 <strong>全连接层的矩阵乘法</strong> 和 <strong>偏置项</strong>，最终计算出长度为10的向量，并通过 <strong>Softmax</strong> 函数将其转换为概率分布，从而实现分类。</p><h2 id="二-softmax"><a class="markdownIt-Anchor" href="#二-softmax"></a> 二、Softmax</h2><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> # 参考文章</h1><p><a href="https://geektutu.com/post/tensorflow-mnist-simplest.html">TensorFlow入门(一) - mnist手写数字识别(网络搭建) | 极客兔兔 (geektutu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-独热编码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-独热编码&quot;&gt;&lt;/a&gt; 一、独热编码&lt;/h1&gt;
&lt;p&gt;独热编码使用N位代表N种状态，任意时候只有其中一位有效。采用独热编码的例程：&lt;/p&gt;
&lt;p&gt;独热编码使用N位代表N种状态</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【Python基础】[1]Python的基本语法</title>
    <link href="https://szturin.github.io/posts/46726/"/>
    <id>https://szturin.github.io/posts/46726/</id>
    <published>2024-09-05T04:58:08.000Z</published>
    <updated>2024-09-09T14:54:31.264Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>【Git学习】[3]标签管理</title>
    <link href="https://szturin.github.io/posts/7213/"/>
    <id>https://szturin.github.io/posts/7213/</id>
    <published>2024-09-03T11:02:08.000Z</published>
    <updated>2024-09-07T14:37:36.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针</p><p>使用<code>tag</code>命名指向历史版本号，能够更好的进行代码管理</p><h1 id="一-创建标签"><a class="markdownIt-Anchor" href="#一-创建标签"></a> 一、创建标签</h1><p>查看分支</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></tbody></table></figure><p>创建新的标签</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903190927707.png" class="" title="image-20240903190927707"><p>查看所有标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191014025.png" class="" title="image-20240903191014025"><p>查看历史提交</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline --abbrev-commit</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191100832.png" class="" title="image-20240903191100832"><p>比如要对-&gt;“博客备份”这次打标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.9 607328c</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191236366.png" class="" title="image-20240903191236366"><p>查看标签信息，注意：```tag``是按字母顺序排列的</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v0.9</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191323368.png" class="" title="image-20240903191323368"><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v0.1 -m "version 0.1 released" 1094adb</span><br></pre></td></tr></tbody></table></figure><h1 id="二-操作标签"><a class="markdownIt-Anchor" href="#二-操作标签"></a> 二、操作标签</h1><p>删除标签</p><p>注意：对标签的操作都在本地，不会影响远程</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v0.1</span><br></pre></td></tr></tbody></table></figure><p>如果要推送标签到远程仓库，使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.0</span><br></pre></td></tr></tbody></table></figure><p>一次性推送全部尚未推送到远程的标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></tbody></table></figure><p>如果标签已经推送到远程，需要：</p><p>1.删除本地标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v0.9</span><br></pre></td></tr></tbody></table></figure><p>2.从远程删除</p><p>格式：:refs/tags/<tagname></tagname></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v0.9</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。&lt;/p&gt;
&lt;p&gt;Git的标签虽然是版本库的快照，但</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Git" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/"/>
    
    <category term="分布式系统" scheme="https://szturin.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="github" scheme="https://szturin.github.io/categories/github/"/>
    
    
  </entry>
  
  <entry>
    <title>【Git学习】[2]分支管理</title>
    <link href="https://szturin.github.io/posts/21302/"/>
    <id>https://szturin.github.io/posts/21302/</id>
    <published>2024-09-03T10:38:38.000Z</published>
    <updated>2024-09-16T05:49:33.143Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://liaoxuefeng.com/books/git/branch/create/index.html">创建与合并分支 - Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h1 id="一-分支的创建"><a class="markdownIt-Anchor" href="#一-分支的创建"></a> 一、分支的创建</h1><h2 id="1-分支创建"><a class="markdownIt-Anchor" href="#1-分支创建"></a> 1. 分支创建</h2><p>我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch 'dev'</span><br></pre></td></tr></tbody></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch 'dev'</span><br></pre></td></tr></tbody></table></figure><p>然后提交：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m "branch test"</span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></tbody></table></figure><p><mark>dev 分支的任务完成，就可以切换分支了</mark></p><h2 id="二-分支的管理"><a class="markdownIt-Anchor" href="#二-分支的管理"></a> 二、分支的管理</h2><h2 id="1-查看分支"><a class="markdownIt-Anchor" href="#1-查看分支"></a> 1. 查看分支</h2><img src="/posts/21302/image-20240916131915181.png" class="" title="image-20240916131915181"><h2 id="2-切换分支"><a class="markdownIt-Anchor" href="#2-切换分支"></a> 2. 切换分支</h2><img src="/posts/21302/image-20240916132045724.png" class="" title="image-20240916132045724"><h2 id="3-合并分支"><a class="markdownIt-Anchor" href="#3-合并分支"></a> 3. 合并分支</h2><p>完成之后，master分支上的修改在main上也能看到了</p><img src="/posts/21302/image-20240916132125567.png" class="" title="image-20240916132125567"><h2 id="4-删除分支"><a class="markdownIt-Anchor" href="#4-删除分支"></a> 4. 删除分支</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://liaoxuefeng.com/books/git/branch/create/index.html&quot;&gt;创建与合并分支 - Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-分支的创建</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Git" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/"/>
    
    <category term="分布式系统" scheme="https://szturin.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="github" scheme="https://szturin.github.io/categories/github/"/>
    
    
  </entry>
  
  <entry>
    <title>【深度学习】[1]神经网络的基本概念</title>
    <link href="https://szturin.github.io/posts/23492/"/>
    <id>https://szturin.github.io/posts/23492/</id>
    <published>2024-08-16T17:36:58.000Z</published>
    <updated>2024-09-07T17:16:24.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-神经网络的基本概念"><a class="markdownIt-Anchor" href="#一-神经网络的基本概念"></a> 一、神经网络的基本概念</h1><h2 id="1-神经元感知器"><a class="markdownIt-Anchor" href="#1-神经元感知器"></a> 1. 神经元（感知器）</h2><p>一种被称为感知器的人工神经元在20世纪五六十年代被科学家Frank提出。通过数学模型，可以认识到<strong>感知器</strong>是一个根据输入与权重来做出决定的设备，随着<strong>权重</strong>和<strong>阈值</strong>的变化，可以得到不同的<strong>决策模型</strong>。当一个感知器计算后得到的值大于阈值时，从神经学的角度来讲这个感知器被激活，反之为0。感知器可以一定程度上模仿人脑做出决策，但是感知器的决策过程全部是线性的，在处理图像处理、语音识别等复杂问题时，难以仅靠线性模型达到良好的识别效果，因此需要在感知器模型种引入非线性部分。</p><h2 id="2-非线性神经元"><a class="markdownIt-Anchor" href="#2-非线性神经元"></a> 2. 非线性神经元</h2><p>为解决复杂的数学模型，引入<strong>激活函数</strong>，激活函数给神经元带来了非线性因素，使得神经网络可以任意逼近任何非线性函数。</p><p>通常将激活函数与线性神经元合并使之成为<strong>非线性神经元</strong></p><p>如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的<a href="https://baike.baidu.com/item/%E6%84%9F%E7%9F%A5%E6%9C%BA/12723581">感知机</a>（Perceptron）。</p><img src="/posts/23492/34d6b14bf4b79175276eac52abacdf94.png" class="" title="img"><p>激活函数可以分为<strong>两大类：</strong></p><img src="/posts/23492/e41598583c8b35dcbb907f9fd66d8351.png" class="" title="img"><ul><li><strong>饱和激活函数：</strong> sigmoid、 tanh…</li><li><strong>非饱和激活函数:</strong> ReLU 、Leaky Relu  、ELU、PReLU、RReLU…</li></ul><p><a href="https://blog.csdn.net/qq_42691298/article/details/126590726">深度学习中常见的10种激活函数（Activation Function）总结_激活函数有哪些-CSDN博客</a></p><h2 id="3常见的激活函数"><a class="markdownIt-Anchor" href="#3常见的激活函数"></a> 3.常见的激活函数</h2><h3 id="31-sigmoid函数"><a class="markdownIt-Anchor" href="#31-sigmoid函数"></a> 3.1 Sigmoid函数</h3><img src="/posts/23492/6c9269a456ee0497c9bb0d1383e51cc8.png" class="" title="img"><img src="/posts/23492/af5f15ef44f1b276c78bec5e140e7082.png" class="" title="img"><h3 id="32-tanh函数"><a class="markdownIt-Anchor" href="#32-tanh函数"></a> 3.2 tanh函数</h3><p><strong>tanh</strong>激活函数的数学表达式为：</p><img src="/posts/23492/70ad61d6f8c019d3dee98ad6ef45cb1a.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/e58d7204fef7f7410e92b4bf82e91938.png" class="" title="img"><h3 id="33-relu函数"><a class="markdownIt-Anchor" href="#33-relu函数"></a> 3.3 ReLU函数</h3><p><strong>ReLU</strong>激活函数的数学表达式为：</p><img src="/posts/23492/ae65877d14768ad1b6789c6ccdcd6e31.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/a2f4f9f3c522518908e20d7865beb48c.png" class="" title="img"><p>什么情况下适合使用ReLU？</p><ul><li><p>ReLU解决了梯度消失的问题，当输入值为正时，神经元不会饱和</p></li><li><p>由于ReLU线性、非饱和的性质，在SGD中能够快速收敛</p></li><li><p>计算复杂度低，不需要进行指数运算</p></li></ul><p>ReLU有哪些缺点？</p><ul><li><p>与Sigmoid一样，其输出不是以0为中心的</p></li><li><p>Dead ReLU 问题。当输入为负时，梯度为0。这个神经元及之后的神经元梯度永远为0，不再对任何数据有所响应，导致相应参数永远不会被更新</p></li><li><p>训练神经网络的时候，一旦学习率没有设置好，第一次更新权重的时候，输入是负值，那么这个含有ReLU的神经节点就会死亡，再也不会被激活。所以，要设置一个合适的较小的学习率，来降低这种情况的发生</p></li></ul><h2 id="4-神经网络的基本架构"><a class="markdownIt-Anchor" href="#4-神经网络的基本架构"></a> 4. 神经网络的基本架构</h2><img src="/posts/23492/bf32fef369b3823adc20dcdf9af603e3.jpg" class="" title="bf32fef369b3823adc20dcdf9af603e3"><ul><li><p>神经网络最左边的称为<strong>输入层</strong>，其中的神经元称为<strong>输入神经元</strong>，原始数据经由该层输入到神经网络进行后续处理。</p></li><li><p>最右边的称为<strong>输出层</strong>，包含输出神经元，该层的输出是神经网络对样本处理后的最终结果，如分类结果。</p></li><li><p>在输入层和输出层之间的是中间层，也称为 <strong>隐藏层</strong>，即既非输入也非输出的神经网络层，一个神经网络可以有一个或者多个隐藏层，隐藏层的主要作用是处理从上一层神经元传递来的信号。</p></li></ul><p>一般的，<strong>输入层</strong>和 <strong>输出层</strong>在整体神经网络的外部，称为可见层。设计神经网络的输入输出通常比较简单，直接，例如，假设我们知道了一朵花的4个明显特征（如花瓣的长度，宽度），可以利用这4个特征确定它是哪一种类的花，由于我们已经知道这朵花的4个特征，那么就需要4个输入神经元，每个数值代表花朵的一种特征的具体数值。<strong>输出层</strong>可以包含一个或者多个神经元，这由我们想要设定的具体花朵类别决定，可以根据输出的数字，确定花朵的类型。我们可以使用每一个<strong>输出神经元</strong>代表一种类型的花，这种方法称为One-Hot，One-Hot是一种常见的输出层编码方法。</p><h2 id="5-梯度下降"><a class="markdownIt-Anchor" href="#5-梯度下降"></a> 5. 梯度下降</h2><p><a href="https://blog.csdn.net/iqdutao/article/details/107174240">机器学习-梯度下降算法原理及公式推导_梯度下降计算公式-CSDN博客</a></p><h2 id="6-反向传播"><a class="markdownIt-Anchor" href="#6-反向传播"></a> 6. 反向传播</h2><p><a href="https://blog.csdn.net/ft_sunshine/article/details/90221691">“反向传播算法”过程及公式推导（超直观好懂的Backpropagation）_反向传播算法(过程及公式推导)-CSDN博客</a></p><p><strong>“正向传播”求损失，“反向传播”回传误差</strong>。同时，神经网络每层的每个神经元都可以<strong>根据误差信号修正每层的权重</strong></p><h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h1><h2 id="一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"><a class="markdownIt-Anchor" href="#一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"></a> 一、输入x是 784长度的向量，什么机制使得输出y变成的长度为10的向量？</h2><p>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的。具体操作通过 <strong>权重矩阵</strong> 和 <strong>偏置向量</strong> 来完成。</p><h3 id="1-全连接层的基本机制"><a class="markdownIt-Anchor" href="#1-全连接层的基本机制"></a> 1. <strong>全连接层的基本机制：</strong></h3><p>全连接层的工作机制可以用矩阵乘法来描述。给定输入向量 x<em>x</em>（长度为784），要转换为长度为10的输出向量，通常通过如下步骤：</p><h4 id="2-步骤"><a class="markdownIt-Anchor" href="#2-步骤"></a> 2. <strong>步骤：</strong></h4><ol><li><p><strong>输入向量 <img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"></strong>：这是一个长度为784的向量，表示神经网络的输入。</p><img src="/posts/23492/image-20240907224042533.png" class="" title="image-20240907224042533"></li><li><p><strong>权重矩阵 <img src="/posts/23492/image-20240907224200098.png" class="" title="image-20240907224200098"></strong>：全连接层会有一个权重矩阵 W<em>W</em>，其维度是 10×78410×784，表示从输入784维向量到输出10维向量的权重连接。每一行表示一个输出神经元与所有输入神经元的权重连接。</p></li><li><p><strong>偏置向量 <img src="/posts/23492/image-20240907224226570.png" class="" title="image-20240907224226570"></strong>：偏置向量 b<em>b</em> 是一个长度为10的向量，表示每个输出神经元的偏置。</p></li><li><p><strong>计算输出向量 <img src="/posts/23492/image-20240907224234671.png" class="" title="image-20240907224234671"></strong>：通过矩阵乘法计算输出向量。输出向量 o<em>o</em> 的维度是10。具体计算方式如下：</p><img src="/posts/23492/image-20240907224051327.png" class="" title="image-20240907224051327"><ul><li>W \cdot x )：矩阵 ( W ) 乘以向量 ( x )，将784维的输入向量映射为10维的输出向量。</li></ul></li></ol><h3 id="3-矩阵乘法具体步骤"><a class="markdownIt-Anchor" href="#3-矩阵乘法具体步骤"></a> 3. <strong>矩阵乘法具体步骤：</strong></h3><ul><li><p>假设输入向量<img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"> 是长度为784的向量：</p><img src="/posts/23492/image-20240907224100515.png" class="" title="image-20240907224100515"></li><li><p>权重矩阵 W<em>W</em> 是一个 10×78410×784 的矩阵：</p><img src="/posts/23492/image-20240907224116095.png" class="" title="image-20240907224116095"></li><li><p>偏置向量 b<em>b</em> 是一个长度为10的向量：</p><img src="/posts/23492/image-20240907224125174.png" class="" title="image-20240907223954313"></li><li><p>输出向量 o<em>o</em> 通过矩阵乘法和加法得到，维度为10：</p><img src="/posts/23492/image-20240907224134345.png" class="" title="image-20240907224134345"></li></ul><p>每一行表示一个输出神经元的结果，最终得到一个长度为10的向量。</p><h3 id="4-激活函数"><a class="markdownIt-Anchor" href="#4-激活函数"></a> 4. <strong>激活函数：</strong></h3><p>在得到长度为10的向量后，通常会将其通过激活函数进行处理。在分类任务中，输出层通常使用 <strong>Softmax</strong> 函数，将每个输出值转换为概率值。Softmax 函数公式为：</p><img src="/posts/23492/image-20240907224012315.png" class="" title="image-20240907224012315"><p>这会将输出向量 o<em>o</em> 转换为一个概率分布，表示输入属于不同类别的概率。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>将784长度的输入向量变为10长度的输出向量的关键步骤是通过 <strong>全连接层的矩阵乘法</strong> 和 <strong>偏置项</strong>，最终计算出长度为10的向量，并通过 <strong>Softmax</strong> 函数将其转换为概率分布，从而实现分类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-神经网络的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-神经网络的基本概念&quot;&gt;&lt;/a&gt; 一、神经网络的基本概念&lt;/h1&gt;
&lt;h2 id=&quot;1-神经元感知器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    
    <category term="学习笔记,深度学习" scheme="https://szturin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
