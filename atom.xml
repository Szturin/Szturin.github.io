<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Turin&#39;s Blog</title>
  
  <subtitle>数理照亮世界</subtitle>
  <link href="https://szturin.github.io/atom.xml" rel="self"/>
  
  <link href="https://szturin.github.io/"/>
  <updated>2024-09-09T14:54:31.261Z</updated>
  <id>https://szturin.github.io/</id>
  
  <author>
    <name>Szturin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【stm32单片机】[Hal库][3]嵌入式工程模板与“任务调度器”</title>
    <link href="https://szturin.github.io/posts/56683/"/>
    <id>https://szturin.github.io/posts/56683/</id>
    <published>2024-09-09T14:35:16.000Z</published>
    <updated>2024-09-09T14:54:31.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-任务调度器"><a class="markdownIt-Anchor" href="#一-任务调度器"></a> 一、任务调度器</h1><h2 id="1-调度器结构体"><a class="markdownIt-Anchor" href="#1-调度器结构体"></a> 1. 调度器结构体</h2><p><strong>指针函数:</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调度器类型的结构体类型声明</span></span><br><span class="line"><span class="comment">//任务结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">void</span> *<span class="title function_">task_func</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//指针函数</span></span><br><span class="line">    <span class="type">uint32_t</span> rate_ms;<span class="comment">//任务运行周期</span></span><br><span class="line">    <span class="type">uint32_t</span> last_run;<span class="comment">//上次运行时间</span></span><br><span class="line">} <span class="type">scheduler_task_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><code>typedef struct {} scheduler_task_t;</code>是⼀种定义新结构体类型的⽅式，这⾥定义 了⼀个名为  scheduler_task_t 的结构体类型。这个结构体类型包含三个成员。</p><ul><li><p><code>void *task_func(void);</code>定义了一个函数指针，用于储存任务函数的地址，便于进行任务调度</p></li><li><p><code>rate_ms</code>表示任务具体的执行周期</p></li><li><p><code>last_run</code>⽤于存储任务上次运⾏的时间戳（以毫秒为单位）。该成员⽤于 记录任务上⼀次被调度执⾏的时间点，以便计算任务是否需要再次执⾏</p></li></ul><p>静态任务数组，每个任务包括任务函数，执行周期，和上次执行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Led_task</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义调度器类型的变量 任务</span></span><br><span class="line"><span class="comment">//任务数组</span></span><br><span class="line"><span class="comment">//给scheduler_task_t类型变量tasks赋初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">scheduler_task_t</span> tasks[] ={</span><br><span class="line">    {Led_task,<span class="number">1000</span>,<span class="number">0</span>}<span class="comment">//定义一个任务，任务函数为Led_Proc,执行周期为1000毫秒，初始上次运行时间为0</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="2-调度器初始化"><a class="markdownIt-Anchor" href="#2-调度器初始化"></a> 2. 调度器初始化</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">//计算任务数组中任务函数的个数，结果储存在tasks_num中</span></span><br><span class="line">    tasks_num = <span class="keyword">sizeof</span>(tasks)/<span class="keyword">sizeof</span>(<span class="type">scheduler_task_t</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-调度器函数"><a class="markdownIt-Anchor" href="#3-调度器函数"></a> 3. 调度器函数</h2><p>遍历任务数组，检查是否有任务需要进行，如果系统当前时间超过任务的执行周期，那么执行任务变更，并且更新上次运行时间</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_run</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="comment">/*任务轮询*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>; i&lt; tasks_num; i++){</span><br><span class="line">        <span class="comment">//获取当前时间（毫秒）</span></span><br><span class="line">        <span class="type">uint8_t</span> time_now = HAL_GetTick();</span><br><span class="line">        <span class="comment">//检查任务是否到达当前时间点</span></span><br><span class="line">        <span class="keyword">if</span>(time_now &gt;= tasks[i].rate_ms + tasks[i].last_run){</span><br><span class="line">            <span class="comment">//更新任务的上次运行时间，保存时间戳</span></span><br><span class="line">            tasks[i].last_run = time_now;<span class="comment">//保存当前时间</span></span><br><span class="line">            tasks[i].task_func();<span class="comment">//执行对应指向的任务</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-任务调度器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-任务调度器&quot;&gt;&lt;/a&gt; 一、任务调度器&lt;/h1&gt;
&lt;h2 id=&quot;1-调度器结构体&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-调度器结</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【Tensorflow】[2] 神经网络搭建</title>
    <link href="https://szturin.github.io/posts/34487/"/>
    <id>https://szturin.github.io/posts/34487/</id>
    <published>2024-09-07T17:12:30.000Z</published>
    <updated>2024-09-10T13:34:44.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-独热编码"><a class="markdownIt-Anchor" href="#一-独热编码"></a> 一、独热编码</h1><p>独热编码使用N位代表N种状态，任意时候只有其中一位有效。采用独热编码的例程：</p><p>独热编码使用N位代表N种状态，任意时候只有其中一位有效。</p><p>采用独热编码的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">性别:  </span><br><span class="line">[0, 1]代表女，[1, 0]代表男</span><br><span class="line"></span><br><span class="line">数字0-9: </span><br><span class="line">[0,0,0,0,0,0,0,0,0,1]代表9，[0,1,0,0,0,0,0,0,0,0]代表1</span><br></pre></td></tr></tbody></table></figure><p>独热编码的优点在于</p><ul><li>能够处理非连续型数值特征</li><li>在一定程度上也扩充了特征。比如性别本身是一个特征，经过编码以后，就变成了男或女两个特征。</li><li>适合分类</li></ul><p>在神经网络中，独热编码其实具有很强的容错性，比如神经网络的输出结果是 [0,0.1,0.2,0.7,0,0,0,0,0, 0]转成独热编码后，表示数字3。即值最大的地方变为1，其余均为0。[0,0.1,0.4,0.5,0,0,0,0,0, 0]也能表示数字3。</p><blockquote><p>numpu中有一个函数，numpy.argmax()可以取得最大值的下标。</p></blockquote><h1 id="二-神经网络训练的重要概念"><a class="markdownIt-Anchor" href="#二-神经网络训练的重要概念"></a> 二、神经网络训练的重要概念</h1><h2 id="1-输入x输出y-标签label"><a class="markdownIt-Anchor" href="#1-输入x输出y-标签label"></a> 1. 输入（x）输出（y）、标签（label）</h2><ul><li>输入是指传入给网络处理的向量，相当于数学函数中的变量。</li><li>输出是指网络处理后返回的结果，相当于数据函数中的函数值。</li><li>标签是指我们期望网络返回的结果。</li></ul><p>对于识别mnist图片而言，输入是大小为784（28 * 28）的向量，输出是大小为10的概率向量（概率最大的位置，即预测的数字）,这部分操作由<mark>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的</mark>。</p><h2 id="2-损失函数loss-function"><a class="markdownIt-Anchor" href="#2-损失函数loss-function"></a> 2. 损失函数（loss function）</h2><p>损失函数评估网络模型的好坏，值越大，表示模型越差，值越小，表示模型越好。因为传入大量的训练集训练的目标，就是将损失函数的值降到最小。</p><h3 id="21-常见的损失函数定义"><a class="markdownIt-Anchor" href="#21-常见的损失函数定义"></a> 2.1 <strong>常见的损失函数定义：</strong></h3><p><strong>差的平方和 sum((y - label)^2)</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 1] 与 [0.1, 0.3, 0.6]的差的平方和为 0.01 + 0.09 + 0.16 = 0.26</span><br><span class="line">[0, 0, 1] 与 [0.2, 0.2, 0.6]的差的平方和为 0.04 + 0.04 + 0.16 = 0.24</span><br><span class="line">[0, 0, 1] 与 [0.1, 0, 0.9]的差的平方和为 0.01 + 0.01 = 0.02</span><br></pre></td></tr></tbody></table></figure><p><strong>交叉熵 -sum(label * log(y))</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 1] 与 [0.1, 0.3, 0.6]的交叉熵为 -log(0.6) = 0.51</span><br><span class="line">[0, 0, 1] 与 [0.2, 0.2, 0.6]的交叉熵为 -log(0.6) = 0.51</span><br><span class="line">[0, 0, 1] 与 [0.1, 0, 0.9]的交叉熵为 -log(0.9) = 0.10</span><br></pre></td></tr></tbody></table></figure><p>当label为0时，交叉熵为0，label为1时，交叉熵为-log(y)，交叉熵只关注独热编码中有效位的损失。这样屏蔽了无效位值的变化（无效位的值的变化并不会影响最终结果），并且通过取对数放大了有效位的损失。当有效位的值趋近于0时，交叉熵趋近于正无穷大。</p><h2 id="3-回归模型"><a class="markdownIt-Anchor" href="#3-回归模型"></a> 3. 回归模型</h2><p>我们可以将网络理解为一个函数，回归模型，其实是希望对这个函数进行拟合。<br>比如定义模型为 Y = X * w + b，对应的损失即</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss = (Y - labal)^2</span><br><span class="line">     = -(X * w - b - label)^2</span><br><span class="line">这里损失函数用方差计算，这个函数是关于w和b的二次函数，所以神经网络训练的目的是找到w和b，使得loss最小。</span><br></pre></td></tr></tbody></table></figure><p>可以通过不断地传入X和label的值，来修正w和b，使得最终得到的Y与label的loss最小。这个训练的过程，可以采用<strong>梯度下降</strong>的方法。通过梯度下降，找到最快的方向，调整w和b值，使得w * X + b的值越来越接近label。</p><p><a href="https://blog.csdn.net/iqdutao/article/details/107174240">机器学习-梯度下降算法原理及公式推导_梯度下降计算公式-CSDN博客</a></p><img src="/posts/34487/loss.png" class="" title="loss"><h2 id="4-学习速率"><a class="markdownIt-Anchor" href="#4-学习速率"></a> 4. 学习速率</h2><p>简单说，梯度即一个函数的斜率，找到函数的斜率，其实就知道了w和b的值往哪个方向调整，能够让函数值（loss）降低得最快。那么方向知道了，往这个方向调整多少呢？这个数，神经网络中称之为学习速率。学习速率调得太低，训练速度会很慢，学习速率调得过高，每次迭代波动会很大</p><h2 id="5-softmax激活函数"><a class="markdownIt-Anchor" href="#5-softmax激活函数"></a> 5. softmax激活函数</h2><p>作用：一是放大效果，二是梯度下降时需要一个可导的函数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def softmax(x):</span><br><span class="line">    import numpy as np</span><br><span class="line">    return np.exp(x) / np.sum(np.exp(x), axis=0)</span><br><span class="line"></span><br><span class="line">softmax([4, 5, 10])</span><br><span class="line"># [ 0.002,  0.007,  0.991]</span><br></pre></td></tr></tbody></table></figure><h1 id="三-tensorflow识别手写数字-实现简单的神经网络"><a class="markdownIt-Anchor" href="#三-tensorflow识别手写数字-实现简单的神经网络"></a> 三、tensorflow识别手写数字-实现简单的神经网络</h1><h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> # 思考</h1><h2 id="一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"><a class="markdownIt-Anchor" href="#一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"></a> 一、输入x是 784长度的向量，什么机制使得输出y变成的长度为10的向量？</h2><p>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的。具体操作通过 <strong>权重矩阵</strong> 和 <strong>偏置向量</strong> 来完成。</p><h3 id="1-全连接层的基本机制"><a class="markdownIt-Anchor" href="#1-全连接层的基本机制"></a> 1. <strong>全连接层的基本机制：</strong></h3><p>全连接层的工作机制可以用矩阵乘法来描述。给定输入向量 x<em>x</em>（长度为784），要转换为长度为10的输出向量，通常通过如下步骤：</p><h4 id="2-步骤"><a class="markdownIt-Anchor" href="#2-步骤"></a> 2. <strong>步骤：</strong></h4><ol><li><p><strong>输入向量 <img src="/posts/34487/image-20240907224214042.png" class="" title="image-20240907224214042"></strong>：这是一个长度为784的向量，表示神经网络的输入。</p><img src="/posts/34487/image-20240907224042533.png" class="" title="image-20240907224042533"></li><li><p><strong>权重矩阵 <img src="/posts/34487/image-20240907224200098.png" class="" title="image-20240907224200098"></strong>：全连接层会有一个权重矩阵 W<em>W</em>，其维度是 10×78410×784，表示从输入784维向量到输出10维向量的权重连接。每一行表示一个输出神经元与所有输入神经元的权重连接。</p></li><li><p><strong>偏置向量 <img src="/posts/34487/image-20240907224226570.png" class="" title="image-20240907224226570"></strong>：偏置向量 b<em>b</em> 是一个长度为10的向量，表示每个输出神经元的偏置。</p></li><li><p><strong>计算输出向量 <img src="/posts/34487/image-20240907224234671.png" class="" title="image-20240907224234671"></strong>：通过矩阵乘法计算输出向量。输出向量 o<em>o</em> 的维度是10。具体计算方式如下：</p><img src="/posts/34487/image-20240907224051327.png" class="" title="image-20240907224051327"><ul><li>W \cdot x )：矩阵 ( W ) 乘以向量 ( x )，将784维的输入向量映射为10维的输出向量。</li></ul></li></ol><h3 id="3-矩阵乘法具体步骤"><a class="markdownIt-Anchor" href="#3-矩阵乘法具体步骤"></a> 3. <strong>矩阵乘法具体步骤：</strong></h3><ul><li><p>假设输入向量<img src="/posts/34487/image-20240907224214042.png" class="" title="image-20240907224214042"> 是长度为784的向量：</p><img src="/posts/34487/image-20240907224100515.png" class="" title="image-20240907224100515"></li><li><p>权重矩阵 <img src="/posts/34487/image-20240907224200098.png" class="" title="image-20240907224200098"> 是一个 10×78410×784 的矩阵：</p><img src="/posts/34487/image-20240907224116095.png" class="" title="image-20240907224116095"></li><li><p>偏置向量<img src="/posts/34487/image-20240907224226570.png" class="" title="image-20240907224226570"> 是一个长度为10的向量：</p><img src="/posts/34487/image-20240907224125174.png" class="" title="image-20240907223954313"></li><li><p>输出向量 <img src="/posts/34487/image-20240907224234671.png" class="" title="image-20240907224234671">通过矩阵乘法和加法得到，维度为10：</p><img src="/posts/34487/image-20240907224134345.png" class="" title="image-20240907224134345"></li></ul><p>每一行表示一个输出神经元的结果，最终得到一个长度为10的向量。</p><h3 id="4-激活函数"><a class="markdownIt-Anchor" href="#4-激活函数"></a> 4. <strong>激活函数：</strong></h3><p>在得到长度为10的向量后，通常会将其通过激活函数进行处理。在分类任务中，输出层通常使用 <strong>Softmax</strong> 函数，将每个输出值转换为概率值。Softmax 函数公式为：</p><img src="/posts/34487/image-20240907224012315.png" class="" title="image-20240907224012315"><p>这会将输出向量 o<em>o</em> 转换为一个概率分布，表示输入属于不同类别的概率。</p><p>作用：对输出结果进行非负化和归一化，保证了概论的和为1</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>将784长度的输入向量变为10长度的输出向量的关键步骤是通过 <strong>全连接层的矩阵乘法</strong> 和 <strong>偏置项</strong>，最终计算出长度为10的向量，并通过 <strong>Softmax</strong> 函数将其转换为概率分布，从而实现分类。</p><h2 id="二-softmax"><a class="markdownIt-Anchor" href="#二-softmax"></a> 二、Softmax</h2><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> # 参考文章</h1><p><a href="https://geektutu.com/post/tensorflow-mnist-simplest.html">TensorFlow入门(一) - mnist手写数字识别(网络搭建) | 极客兔兔 (geektutu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-独热编码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-独热编码&quot;&gt;&lt;/a&gt; 一、独热编码&lt;/h1&gt;
&lt;p&gt;独热编码使用N位代表N种状态，任意时候只有其中一位有效。采用独热编码的例程：&lt;/p&gt;
&lt;p&gt;独热编码使用N位代表N种状态</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【Python基础】[1]Python的基本语法</title>
    <link href="https://szturin.github.io/posts/46726/"/>
    <id>https://szturin.github.io/posts/46726/</id>
    <published>2024-09-05T04:58:08.000Z</published>
    <updated>2024-09-09T14:54:31.264Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>【Git学习】[3]标签管理</title>
    <link href="https://szturin.github.io/posts/7213/"/>
    <id>https://szturin.github.io/posts/7213/</id>
    <published>2024-09-03T11:02:08.000Z</published>
    <updated>2024-09-07T14:37:36.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针</p><p>使用<code>tag</code>命名指向历史版本号，能够更好的进行代码管理</p><h1 id="一-创建标签"><a class="markdownIt-Anchor" href="#一-创建标签"></a> 一、创建标签</h1><p>查看分支</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></tbody></table></figure><p>创建新的标签</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903190927707.png" class="" title="image-20240903190927707"><p>查看所有标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191014025.png" class="" title="image-20240903191014025"><p>查看历史提交</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline --abbrev-commit</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191100832.png" class="" title="image-20240903191100832"><p>比如要对-&gt;“博客备份”这次打标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.9 607328c</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191236366.png" class="" title="image-20240903191236366"><p>查看标签信息，注意：```tag``是按字母顺序排列的</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v0.9</span><br></pre></td></tr></tbody></table></figure><img src="/posts/7213/image-20240903191323368.png" class="" title="image-20240903191323368"><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v0.1 -m "version 0.1 released" 1094adb</span><br></pre></td></tr></tbody></table></figure><h1 id="二-操作标签"><a class="markdownIt-Anchor" href="#二-操作标签"></a> 二、操作标签</h1><p>删除标签</p><p>注意：对标签的操作都在本地，不会影响远程</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v0.1</span><br></pre></td></tr></tbody></table></figure><p>如果要推送标签到远程仓库，使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.0</span><br></pre></td></tr></tbody></table></figure><p>一次性推送全部尚未推送到远程的标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></tbody></table></figure><p>如果标签已经推送到远程，需要：</p><p>1.删除本地标签</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v0.9</span><br></pre></td></tr></tbody></table></figure><p>2.从远程删除</p><p>格式：:refs/tags/<tagname></tagname></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v0.9</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。&lt;/p&gt;
&lt;p&gt;Git的标签虽然是版本库的快照，但</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Git" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/"/>
    
    <category term="分布式系统" scheme="https://szturin.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="github" scheme="https://szturin.github.io/categories/github/"/>
    
    
  </entry>
  
  <entry>
    <title>【Git学习】[2]分支管理</title>
    <link href="https://szturin.github.io/posts/21302/"/>
    <id>https://szturin.github.io/posts/21302/</id>
    <published>2024-09-03T10:38:38.000Z</published>
    <updated>2024-09-03T11:23:06.891Z</updated>
    
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Git" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/"/>
    
    <category term="分布式系统" scheme="https://szturin.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="github" scheme="https://szturin.github.io/categories/github/"/>
    
    
  </entry>
  
  <entry>
    <title>【深度学习】[1]神经网络的基本概念</title>
    <link href="https://szturin.github.io/posts/23492/"/>
    <id>https://szturin.github.io/posts/23492/</id>
    <published>2024-08-16T17:36:58.000Z</published>
    <updated>2024-09-07T17:16:24.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-神经网络的基本概念"><a class="markdownIt-Anchor" href="#一-神经网络的基本概念"></a> 一、神经网络的基本概念</h1><h2 id="1-神经元感知器"><a class="markdownIt-Anchor" href="#1-神经元感知器"></a> 1. 神经元（感知器）</h2><p>一种被称为感知器的人工神经元在20世纪五六十年代被科学家Frank提出。通过数学模型，可以认识到<strong>感知器</strong>是一个根据输入与权重来做出决定的设备，随着<strong>权重</strong>和<strong>阈值</strong>的变化，可以得到不同的<strong>决策模型</strong>。当一个感知器计算后得到的值大于阈值时，从神经学的角度来讲这个感知器被激活，反之为0。感知器可以一定程度上模仿人脑做出决策，但是感知器的决策过程全部是线性的，在处理图像处理、语音识别等复杂问题时，难以仅靠线性模型达到良好的识别效果，因此需要在感知器模型种引入非线性部分。</p><h2 id="2-非线性神经元"><a class="markdownIt-Anchor" href="#2-非线性神经元"></a> 2. 非线性神经元</h2><p>为解决复杂的数学模型，引入<strong>激活函数</strong>，激活函数给神经元带来了非线性因素，使得神经网络可以任意逼近任何非线性函数。</p><p>通常将激活函数与线性神经元合并使之成为<strong>非线性神经元</strong></p><p>如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的<a href="https://baike.baidu.com/item/%E6%84%9F%E7%9F%A5%E6%9C%BA/12723581">感知机</a>（Perceptron）。</p><img src="/posts/23492/34d6b14bf4b79175276eac52abacdf94.png" class="" title="img"><p>激活函数可以分为<strong>两大类：</strong></p><img src="/posts/23492/e41598583c8b35dcbb907f9fd66d8351.png" class="" title="img"><ul><li><strong>饱和激活函数：</strong> sigmoid、 tanh…</li><li><strong>非饱和激活函数:</strong> ReLU 、Leaky Relu  、ELU、PReLU、RReLU…</li></ul><p><a href="https://blog.csdn.net/qq_42691298/article/details/126590726">深度学习中常见的10种激活函数（Activation Function）总结_激活函数有哪些-CSDN博客</a></p><h2 id="3常见的激活函数"><a class="markdownIt-Anchor" href="#3常见的激活函数"></a> 3.常见的激活函数</h2><h3 id="31-sigmoid函数"><a class="markdownIt-Anchor" href="#31-sigmoid函数"></a> 3.1 Sigmoid函数</h3><img src="/posts/23492/6c9269a456ee0497c9bb0d1383e51cc8.png" class="" title="img"><img src="/posts/23492/af5f15ef44f1b276c78bec5e140e7082.png" class="" title="img"><h3 id="32-tanh函数"><a class="markdownIt-Anchor" href="#32-tanh函数"></a> 3.2 tanh函数</h3><p><strong>tanh</strong>激活函数的数学表达式为：</p><img src="/posts/23492/70ad61d6f8c019d3dee98ad6ef45cb1a.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/e58d7204fef7f7410e92b4bf82e91938.png" class="" title="img"><h3 id="33-relu函数"><a class="markdownIt-Anchor" href="#33-relu函数"></a> 3.3 ReLU函数</h3><p><strong>ReLU</strong>激活函数的数学表达式为：</p><img src="/posts/23492/ae65877d14768ad1b6789c6ccdcd6e31.png" class="" title="img"><p>函数图像如下：</p><img src="/posts/23492/a2f4f9f3c522518908e20d7865beb48c.png" class="" title="img"><p>什么情况下适合使用ReLU？</p><ul><li><p>ReLU解决了梯度消失的问题，当输入值为正时，神经元不会饱和</p></li><li><p>由于ReLU线性、非饱和的性质，在SGD中能够快速收敛</p></li><li><p>计算复杂度低，不需要进行指数运算</p></li></ul><p>ReLU有哪些缺点？</p><ul><li><p>与Sigmoid一样，其输出不是以0为中心的</p></li><li><p>Dead ReLU 问题。当输入为负时，梯度为0。这个神经元及之后的神经元梯度永远为0，不再对任何数据有所响应，导致相应参数永远不会被更新</p></li><li><p>训练神经网络的时候，一旦学习率没有设置好，第一次更新权重的时候，输入是负值，那么这个含有ReLU的神经节点就会死亡，再也不会被激活。所以，要设置一个合适的较小的学习率，来降低这种情况的发生</p></li></ul><h2 id="4-神经网络的基本架构"><a class="markdownIt-Anchor" href="#4-神经网络的基本架构"></a> 4. 神经网络的基本架构</h2><img src="/posts/23492/bf32fef369b3823adc20dcdf9af603e3.jpg" class="" title="bf32fef369b3823adc20dcdf9af603e3"><ul><li><p>神经网络最左边的称为<strong>输入层</strong>，其中的神经元称为<strong>输入神经元</strong>，原始数据经由该层输入到神经网络进行后续处理。</p></li><li><p>最右边的称为<strong>输出层</strong>，包含输出神经元，该层的输出是神经网络对样本处理后的最终结果，如分类结果。</p></li><li><p>在输入层和输出层之间的是中间层，也称为 <strong>隐藏层</strong>，即既非输入也非输出的神经网络层，一个神经网络可以有一个或者多个隐藏层，隐藏层的主要作用是处理从上一层神经元传递来的信号。</p></li></ul><p>一般的，<strong>输入层</strong>和 <strong>输出层</strong>在整体神经网络的外部，称为可见层。设计神经网络的输入输出通常比较简单，直接，例如，假设我们知道了一朵花的4个明显特征（如花瓣的长度，宽度），可以利用这4个特征确定它是哪一种类的花，由于我们已经知道这朵花的4个特征，那么就需要4个输入神经元，每个数值代表花朵的一种特征的具体数值。<strong>输出层</strong>可以包含一个或者多个神经元，这由我们想要设定的具体花朵类别决定，可以根据输出的数字，确定花朵的类型。我们可以使用每一个<strong>输出神经元</strong>代表一种类型的花，这种方法称为One-Hot，One-Hot是一种常见的输出层编码方法。</p><h2 id="5-梯度下降"><a class="markdownIt-Anchor" href="#5-梯度下降"></a> 5. 梯度下降</h2><p><a href="https://blog.csdn.net/iqdutao/article/details/107174240">机器学习-梯度下降算法原理及公式推导_梯度下降计算公式-CSDN博客</a></p><h2 id="6-反向传播"><a class="markdownIt-Anchor" href="#6-反向传播"></a> 6. 反向传播</h2><p><a href="https://blog.csdn.net/ft_sunshine/article/details/90221691">“反向传播算法”过程及公式推导（超直观好懂的Backpropagation）_反向传播算法(过程及公式推导)-CSDN博客</a></p><p><strong>“正向传播”求损失，“反向传播”回传误差</strong>。同时，神经网络每层的每个神经元都可以<strong>根据误差信号修正每层的权重</strong></p><h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h1><h2 id="一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"><a class="markdownIt-Anchor" href="#一-输入x是-784长度的向量什么机制使得输出y变成的长度为10的向量"></a> 一、输入x是 784长度的向量，什么机制使得输出y变成的长度为10的向量？</h2><p>将长度为784的向量 x<em>x</em> 转换为长度为10的向量，是通过<strong>全连接层（Fully Connected Layer）</strong> 实现的。具体操作通过 <strong>权重矩阵</strong> 和 <strong>偏置向量</strong> 来完成。</p><h3 id="1-全连接层的基本机制"><a class="markdownIt-Anchor" href="#1-全连接层的基本机制"></a> 1. <strong>全连接层的基本机制：</strong></h3><p>全连接层的工作机制可以用矩阵乘法来描述。给定输入向量 x<em>x</em>（长度为784），要转换为长度为10的输出向量，通常通过如下步骤：</p><h4 id="2-步骤"><a class="markdownIt-Anchor" href="#2-步骤"></a> 2. <strong>步骤：</strong></h4><ol><li><p><strong>输入向量 <img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"></strong>：这是一个长度为784的向量，表示神经网络的输入。</p><img src="/posts/23492/image-20240907224042533.png" class="" title="image-20240907224042533"></li><li><p><strong>权重矩阵 <img src="/posts/23492/image-20240907224200098.png" class="" title="image-20240907224200098"></strong>：全连接层会有一个权重矩阵 W<em>W</em>，其维度是 10×78410×784，表示从输入784维向量到输出10维向量的权重连接。每一行表示一个输出神经元与所有输入神经元的权重连接。</p></li><li><p><strong>偏置向量 <img src="/posts/23492/image-20240907224226570.png" class="" title="image-20240907224226570"></strong>：偏置向量 b<em>b</em> 是一个长度为10的向量，表示每个输出神经元的偏置。</p></li><li><p><strong>计算输出向量 <img src="/posts/23492/image-20240907224234671.png" class="" title="image-20240907224234671"></strong>：通过矩阵乘法计算输出向量。输出向量 o<em>o</em> 的维度是10。具体计算方式如下：</p><img src="/posts/23492/image-20240907224051327.png" class="" title="image-20240907224051327"><ul><li>W \cdot x )：矩阵 ( W ) 乘以向量 ( x )，将784维的输入向量映射为10维的输出向量。</li></ul></li></ol><h3 id="3-矩阵乘法具体步骤"><a class="markdownIt-Anchor" href="#3-矩阵乘法具体步骤"></a> 3. <strong>矩阵乘法具体步骤：</strong></h3><ul><li><p>假设输入向量<img src="/posts/23492/image-20240907224214042.png" class="" title="image-20240907224214042"> 是长度为784的向量：</p><img src="/posts/23492/image-20240907224100515.png" class="" title="image-20240907224100515"></li><li><p>权重矩阵 W<em>W</em> 是一个 10×78410×784 的矩阵：</p><img src="/posts/23492/image-20240907224116095.png" class="" title="image-20240907224116095"></li><li><p>偏置向量 b<em>b</em> 是一个长度为10的向量：</p><img src="/posts/23492/image-20240907224125174.png" class="" title="image-20240907223954313"></li><li><p>输出向量 o<em>o</em> 通过矩阵乘法和加法得到，维度为10：</p><img src="/posts/23492/image-20240907224134345.png" class="" title="image-20240907224134345"></li></ul><p>每一行表示一个输出神经元的结果，最终得到一个长度为10的向量。</p><h3 id="4-激活函数"><a class="markdownIt-Anchor" href="#4-激活函数"></a> 4. <strong>激活函数：</strong></h3><p>在得到长度为10的向量后，通常会将其通过激活函数进行处理。在分类任务中，输出层通常使用 <strong>Softmax</strong> 函数，将每个输出值转换为概率值。Softmax 函数公式为：</p><img src="/posts/23492/image-20240907224012315.png" class="" title="image-20240907224012315"><p>这会将输出向量 o<em>o</em> 转换为一个概率分布，表示输入属于不同类别的概率。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>将784长度的输入向量变为10长度的输出向量的关键步骤是通过 <strong>全连接层的矩阵乘法</strong> 和 <strong>偏置项</strong>，最终计算出长度为10的向量，并通过 <strong>Softmax</strong> 函数将其转换为概率分布，从而实现分类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-神经网络的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-神经网络的基本概念&quot;&gt;&lt;/a&gt; 一、神经网络的基本概念&lt;/h1&gt;
&lt;h2 id=&quot;1-神经元感知器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    
    <category term="学习笔记,深度学习" scheme="https://szturin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][2]stm32时钟树</title>
    <link href="https://szturin.github.io/posts/9067/"/>
    <id>https://szturin.github.io/posts/9067/</id>
    <published>2024-08-14T13:47:44.000Z</published>
    <updated>2024-09-03T04:22:44.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-锁相环的原理与应用"><a class="markdownIt-Anchor" href="#一-锁相环的原理与应用"></a> 一、锁相环的原理与应用</h1><p>参考文章：<a href="https://blog.csdn.net/weixin_46274168/article/details/130437627">【STM32】知识补充 锁相环原理与应用解析_stm32数字锁相-CSDN博客</a></p><h2 id="什么是锁相环-ppl"><a class="markdownIt-Anchor" href="#什么是锁相环-ppl"></a> 什么是锁相环 (PPL)</h2><p>锁相环是一种闭环反馈控制系统. 用于生成与输入信号同步且<a href="https://so.csdn.net/so/search?q=%E7%9B%B8%E4%BD%8D&amp;spm=1001.2101.3001.7020">相位</a>相同的输出信号. 它的核心功能是在输入信号的相位变化时, 自动调整输出信号以保持同步. 这使得锁相环成为了一种理想的频率和相位控制技术.</p><img src="/posts/9067/f9cb0a753bddf1fb37003ddd1310111b.png" class="" title="锁相环原理图"><h2 id="锁相环的基本组成"><a class="markdownIt-Anchor" href="#锁相环的基本组成"></a> 锁相环的基本组成</h2><p>锁相环主要由以下几个部分组成:</p><ul><li>相位比较器 (Phase Detector): 相位比较器负责比较输入信号和反馈信号的相位差, 并将其转换为电压信号</li><li>低通滤波器 (Low-Pass Filter): 低通滤波器对相位比较器的输出信号进行滤波, 以消除高频噪声和相位抖动</li><li>电压控制振荡器 (Voltage-Controlled Oscillator): 根据低通过滤波器的输出电压调整输出信号的频率和相位</li><li>反馈分频器 (Feedback Divider): 反馈分频器对 VCO 的输出信号进行分频处理, 并将其反馈给相位比较器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-锁相环的原理与应用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-锁相环的原理与应用&quot;&gt;&lt;/a&gt; 一、锁相环的原理与应用&lt;/h1&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://blog.csdn.net/weixin_46</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
  </entry>
  
  <entry>
    <title>【Tensorflow】[1]配置Tensorflow-GPU的快速模型训练</title>
    <link href="https://szturin.github.io/posts/33676/"/>
    <id>https://szturin.github.io/posts/33676/</id>
    <published>2024-08-11T16:11:53.000Z</published>
    <updated>2024-09-07T17:04:52.217Z</updated>
    
    <content type="html"><![CDATA[<p>author: sz_jmu</p><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>TensorFlow 是一个用于机器学习和深度学习的开源框架，由 Google Brain 团队开发并在 2015 年发布。它是目前最流行的深度学习框架之一，广泛用于构建、训练和部署机器学习模型，特别是在处理复杂的神经网络任务时。TensorFlow 提供了灵活的工具和库，支持从研究到生产环境中的机器学习应用。</p><p>TensorFlow可以支持CPU，也可以支持CPU+GPU，前者配置较为简单，兼容性较好，后者需要一些额外的操作支持。</p><p>在训练规模庞大的模型时，使用CPU往往存在较大的性能限制，模型训练速度较慢。神经网络算法通常涉及大量的参数、激活值、梯度值的缓冲区，其中每个值在每一次训练迭代中国都要被完全更新，有可能会超出传统计算机的高速缓存（Cache），所以内存带宽通常会成为主要瓶颈。而与CPU相比，GPU的一个显著优势就是具有极高的内存带宽。神经网络的训练算法通常不涉及大量的分支运算和复杂控制指令，更适合在GPU硬件上完成，具有并行特性的GPU更适合神经网络的计算，因此，安装TensorFlow的GPU环境是合适的选择。</p><p>参考文章：</p><p><a href="https://blog.csdn.net/Sciws/article/details/125290718">解决tensorflow-gpu版本训练loss一直为nan，或者loss，accuracy数值明显不对问题_采用gpu训练 loss为负数 采用cpu训练正常-CSDN博客</a></p><p>注意：配置Tensorflow gpu版本，建议使用Anoconda创建环境，避免出现污染环境变量等问题，Anoconda的配置与使用，不做过多赘述。</p><h1 id="一-tensorflow环境的基本配置"><a class="markdownIt-Anchor" href="#一-tensorflow环境的基本配置"></a> 一、Tensorflow环境的基本配置</h1><p>Tensorflow的GPU环境，在不同的系统下配置存在一些兼容性问题，如果直接安装最新的版本，很难完成通过GPU进行深度学习相关的环境搭建。</p><p>CUDA,cuDNN,python,tensorflow的版本需要一一对应。</p><p>使用如：python=3.8 CUDA=11.3 cuDNN=8.2.1 tensorflow-gpu=2.7.0，运行较为稳定。</p><p><strong>在Anoconda命令行环境下，创建Tensorflow的专属环境</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tf_gpu_1 python==<span class="number">3.8</span></span><br></pre></td></tr></tbody></table></figure><p><strong>诸如CSDN等网站，许多参考文章说明要从Nivida官网安装CUDA，比较耗时麻烦，实际上tensorflow需要的是CUDA中的cudatoolkit，所以在Anoconda环境下进行如下安装操作即可：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install cudatoolkit=<span class="number">11.3</span></span><br></pre></td></tr></tbody></table></figure><p><strong>安装cudnn,实际上作用是CUDA的补丁包</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install cudnn=<span class="number">8.2</span><span class="number">.1</span></span><br></pre></td></tr></tbody></table></figure><p><strong>安装tensorflow-gpu版本</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install tensorflow-gpu=<span class="number">2.7</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><p><strong>安装完成后，在tf_gpu_1环境中，检查是否能够查找到显卡驱动</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nivida-smi</span><br></pre></td></tr></tbody></table></figure><p><strong>检查tensorflow是否识别到GPU设备</strong></p><p>1.进入python命令行环境</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></tbody></table></figure><p>2.导入tensorflow库</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></tbody></table></figure><p>3.是否查找到GPU设备</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"是否有 GPU 设备:"</span>, <span class="built_in">len</span>(tf.config.list_physical_devices(<span class="string">'GPU'</span>)) &gt; <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><p>如果tensorflow环境配置正常，能够正常识别到主机GPU，tensorflow深度学习框架基本搭建完成，由于此例使用的tensorflow和python版本不是当前最高版本，后续自行编写相关代码可能需要根据具体的情况安装更多的依赖包或对代码进行调整。</p><h1 id="二-手写汉字识别神经网络模型训练"><a class="markdownIt-Anchor" href="#二-手写汉字识别神经网络模型训练"></a> 二、手写汉字识别神经网络模型训练</h1><h2 id="1数据集的准备"><a class="markdownIt-Anchor" href="#1数据集的准备"></a> 1.数据集的准备</h2><p>要实现手写汉字识别，需要准备规模庞大的数据集。仅仅是常见的汉字数据集，就有高达七千多种类别，且汉字书法风格迥异，若要训练出泛化性强，准确度高的神经网络模型，就需要足够充分复杂的数据集，数据集即要体现出汉字的普遍特征，也要具备不同的形式风格，通过数据集也可以预料到需要足够强大的模型才能实现对任意手写汉字的识别。</p><p>例如，常见手写汉字识别数据集的下载：</p><p><a href="https://drive.google.com/file/d/1k849yUZhkUfbupZT0kRR2ZzZj5g89yLw/view?usp=sharing">汉字名为类别标签的手写数据集</a> (747M)</p><p>文件结构如下：</p><p>├── data<br>│   ├── chinese-calligraphy-dataset<br>│   │   ├── ㄚ<br>│   │   ├── 一<br>│   │   ├── 丁<br>│   │   ├── 七<br>│   │   ├── 万<br>│   │   └── …<br>│   └── label_character.csv</p><h2 id="2编写tensorflow工具链与使用说明"><a class="markdownIt-Anchor" href="#2编写tensorflow工具链与使用说明"></a> 2.编写Tensorflow工具链与使用说明</h2><p>准备好数据集后，我们首先要做的工作是对数据集进行处理，使其符合神经网络模型训练的规范格式，其次，也有一些通过程序的方法能够对原始数据集进行处理，增加数据集的多样性，我们使用的方法为“数据增强”，即在原始数据集的基础上，对每张图片进行小幅度旋转，对比度调节，平移，压缩，放大等操作，这样有利于提高最后训练的模型的泛化性。</p><p>注意：代码运行需要在在命令行的<mark>本例：tf_gpu_1</mark>的环境中运行</p><h3 id="21数据集划分脚本"><a class="markdownIt-Anchor" href="#21数据集划分脚本"></a> 2.1<strong>数据集划分脚本</strong></h3><p>本脚本分为三个阶段：</p><p>1.将原始数据集复制到指定目录，并且分为test,val,train，即测试集，验证集，训练集。</p><p>2.对分类后的数据集进行数据增强，每张图片生成5张增强后的图像，那么，数据集的复杂程度得到了一定的增加</p><p>3.检查测试集中是否存在空的子文件夹，由于有些类别的汉字图片可能较少，按照代码中：20%的比例从训练集划分给测试集，若测试集图片少于2张，可能导致测试集中该类别没有对应的图片，所以，这个阶段用于对测试集文件夹进行二次排查，确保测试集中不存在空的汉字类别图片。</p><p><mark>使用方法：</mark></p><p>修改</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src_data_folder = <span class="string">"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/CursiveChineseCalligraphyDataset-master/Cursive_Chinese_Calligraphy_Dataset/Training"</span>  <span class="comment"># todo 修改你的原始数据集路径</span></span><br><span class="line">target_data_folder = <span class="string">"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu"</span>  <span class="comment"># </span></span><br></pre></td></tr></tbody></table></figure><p>其中src_data_folder为原始数据集路径，target_data_folder为划分好的目标路径(将包含train,val,test三个子文件夹)</p><p>在tf_gpu_1环境下，输入命令 python data_split.py</p><p><strong>完整代码(data_split.py)如下：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copy2, move</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageEnhance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_file</span>(<span class="params">src_dest</span>):</span><br><span class="line">    src_img_path, target_folder = src_dest</span><br><span class="line">    copy2(src_img_path, target_folder)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_file</span>(<span class="params">src_dest</span>):</span><br><span class="line">    src_img_path, target_folder = src_dest</span><br><span class="line">    move(src_img_path, target_folder)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">augment_image</span>(<span class="params">src_img_path, target_folder, num_augments=<span class="number">5</span></span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(src_img_path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_augments):</span><br><span class="line">        img_aug = img.copy()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机旋转</span></span><br><span class="line">        angle = random.uniform(-<span class="number">15</span>, <span class="number">15</span>)  <span class="comment"># -15到15度之间的随机旋转</span></span><br><span class="line">        img_aug = img_aug.rotate(angle, fillcolor=<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机平移</span></span><br><span class="line">        max_translate = <span class="number">5</span>  <span class="comment"># 最大平移像素值</span></span><br><span class="line">        x_translate = random.randint(-max_translate, -max_translate)</span><br><span class="line">        y_translate = random.randint(-max_translate, -max_translate)</span><br><span class="line">        img_aug = img_aug.transform(img_aug.size, Image.AFFINE, (<span class="number">1</span>, <span class="number">0</span>, x_translate, <span class="number">0</span>, <span class="number">1</span>, y_translate),</span><br><span class="line">                                    fillcolor=<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机缩放</span></span><br><span class="line">        scale_factor = random.uniform(<span class="number">0.9</span>, <span class="number">1.1</span>)</span><br><span class="line">        w, h = img_aug.size</span><br><span class="line">        img_aug = img_aug.resize((<span class="built_in">int</span>(w * scale_factor), <span class="built_in">int</span>(h * scale_factor)), Image.Resampling.LANCZOS)</span><br><span class="line">        img_aug = img_aug.resize((w, h), Image.Resampling.LANCZOS)  <span class="comment"># 重新调整为原始尺寸</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机对比度调整</span></span><br><span class="line">        enhancer = ImageEnhance.Contrast(img_aug)</span><br><span class="line">        img_aug = enhancer.enhance(random.uniform(<span class="number">0.8</span>, <span class="number">1.2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机亮度调整</span></span><br><span class="line">        enhancer = ImageEnhance.Brightness(img_aug)</span><br><span class="line">        img_aug = enhancer.enhance(random.uniform(<span class="number">0.8</span>, <span class="number">1.2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存增强后的图像</span></span><br><span class="line">        aug_img_name = os.path.basename(src_img_path).replace(<span class="string">"."</span>, <span class="string">f"_aug_<span class="subst">{i}</span>."</span>)</span><br><span class="line">        img_aug.save(os.path.join(target_folder, aug_img_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_set_split_and_augment</span>(<span class="params">src_data_folder, target_data_folder, train_scale=<span class="number">0.8</span>, val_scale=<span class="number">0.2</span>, test_scale=<span class="number">0.0</span>,</span></span><br><span class="line"><span class="params">                               num_augments=<span class="number">5</span></span>):</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    读取源数据文件夹，生成划分好的文件夹，并对每张图片生成5张增强图片。</span></span><br><span class="line"><span class="string">    :param src_data_folder: 源文件夹</span></span><br><span class="line"><span class="string">    :param target_data_folder: 目标文件夹</span></span><br><span class="line"><span class="string">    :param train_scale: 训练集比例</span></span><br><span class="line"><span class="string">    :param val_scale: 验证集比例</span></span><br><span class="line"><span class="string">    :param test_scale: 测试集比例</span></span><br><span class="line"><span class="string">    :param num_augments: 每张图片生成的增强图片数量</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    class_names = os.listdir(src_data_folder)</span><br><span class="line">    split_names = [<span class="string">'train'</span>, <span class="string">'val'</span>, <span class="string">'test'</span>]</span><br><span class="line">    data_split_completed = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查目标文件夹是否已存在文件，如果存在则跳过数据集划分</span></span><br><span class="line">    <span class="keyword">for</span> split_name <span class="keyword">in</span> split_names:</span><br><span class="line">        split_path = os.path.join(target_data_folder, split_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(split_path) <span class="keyword">or</span> <span class="built_in">len</span>(os.listdir(split_path)) == <span class="number">0</span>:</span><br><span class="line">            data_split_completed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data_split_completed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"开始数据集划分"</span>)</span><br><span class="line">        <span class="comment"># 在目标目录下创建文件夹</span></span><br><span class="line">        <span class="keyword">for</span> split_name <span class="keyword">in</span> split_names:</span><br><span class="line">            split_path = os.path.join(target_data_folder, split_name)</span><br><span class="line">            os.makedirs(split_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># 在split_path的目录下创建类别文件夹</span></span><br><span class="line">            <span class="keyword">for</span> class_name <span class="keyword">in</span> class_names:</span><br><span class="line">                class_split_path = os.path.join(split_path, class_name)</span><br><span class="line">                os.makedirs(class_split_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        tasks = []</span><br><span class="line">        total_files = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算总文件数并生成任务列表</span></span><br><span class="line">        <span class="keyword">for</span> class_name <span class="keyword">in</span> class_names:</span><br><span class="line">            current_class_data_path = os.path.join(src_data_folder, class_name)</span><br><span class="line">            current_all_data = os.listdir(current_class_data_path)</span><br><span class="line">            total_files += <span class="built_in">len</span>(current_all_data)</span><br><span class="line"></span><br><span class="line">            random.shuffle(current_all_data)</span><br><span class="line"></span><br><span class="line">            train_folder = os.path.join(os.path.join(target_data_folder, <span class="string">'train'</span>), class_name)</span><br><span class="line">            val_folder = os.path.join(os.path.join(target_data_folder, <span class="string">'val'</span>), class_name)</span><br><span class="line">            test_folder = os.path.join(os.path.join(target_data_folder, <span class="string">'test'</span>), class_name)</span><br><span class="line"></span><br><span class="line">            train_stop_flag = <span class="built_in">len</span>(current_all_data) * train_scale</span><br><span class="line">            val_stop_flag = <span class="built_in">len</span>(current_all_data) * (train_scale + val_scale)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> idx, img_name <span class="keyword">in</span> <span class="built_in">enumerate</span>(current_all_data):</span><br><span class="line">                src_img_path = os.path.join(current_class_data_path, img_name)</span><br><span class="line">                <span class="keyword">if</span> idx &lt;= train_stop_flag:</span><br><span class="line">                    tasks.append((src_img_path, train_folder))</span><br><span class="line">                <span class="keyword">elif</span> idx &lt;= val_stop_flag:</span><br><span class="line">                    tasks.append((src_img_path, val_folder))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tasks.append((src_img_path, test_folder))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用多线程进行复制，并显示进度条</span></span><br><span class="line">        <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">8</span>) <span class="keyword">as</span> executor:</span><br><span class="line">            <span class="built_in">list</span>(tqdm(executor.<span class="built_in">map</span>(copy_file, tasks), total=total_files, desc=<span class="string">"文件复制进度"</span>))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"数据集划分完成！"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"数据集划分已经完成，跳过该步骤。"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二阶段：数据增强</span></span><br><span class="line">    data_augmentation_completed = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> class_name <span class="keyword">in</span> class_names:</span><br><span class="line">        train_class_folder = os.path.join(target_data_folder, <span class="string">'train'</span>, class_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>(<span class="string">"_aug_"</span> <span class="keyword">in</span> fname <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(train_class_folder)):</span><br><span class="line">            data_augmentation_completed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data_augmentation_completed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"开始数据增强"</span>)</span><br><span class="line">        aug_tasks = []</span><br><span class="line">        <span class="keyword">for</span> split_name <span class="keyword">in</span> split_names:</span><br><span class="line">            split_folder = os.path.join(target_data_folder, split_name)</span><br><span class="line">            <span class="keyword">for</span> class_name <span class="keyword">in</span> class_names:</span><br><span class="line">                class_split_folder = os.path.join(split_folder, class_name)</span><br><span class="line">                <span class="keyword">for</span> img_name <span class="keyword">in</span> os.listdir(class_split_folder):</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">"_aug_"</span> <span class="keyword">in</span> img_name:  <span class="comment"># 检查是否已经增强过</span></span><br><span class="line">                        src_img_path = os.path.join(class_split_folder, img_name)</span><br><span class="line">                        aug_tasks.append((src_img_path, class_split_folder, num_augments))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">8</span>) <span class="keyword">as</span> executor:</span><br><span class="line">            <span class="built_in">list</span>(tqdm(executor.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: augment_image(*x), aug_tasks), total=<span class="built_in">len</span>(aug_tasks), desc=<span class="string">"数据增强进度"</span>))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"数据增强完成！"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"数据增强已经完成，跳过该步骤。"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三阶段：检查并补充val文件夹中的内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"开始检查并补充val文件夹"</span>)</span><br><span class="line">    supplement_tasks = []</span><br><span class="line">    <span class="keyword">for</span> class_name <span class="keyword">in</span> class_names:</span><br><span class="line">        val_class_folder = os.path.join(target_data_folder, <span class="string">'val'</span>, class_name)</span><br><span class="line">        train_class_folder = os.path.join(target_data_folder, <span class="string">'train'</span>, class_name)</span><br><span class="line"></span><br><span class="line">        val_files = os.listdir(val_class_folder)</span><br><span class="line">        train_files = os.listdir(train_class_folder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(val_files) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(val_files) &lt; <span class="built_in">len</span>(train_files) * <span class="number">0.1</span>:</span><br><span class="line">            num_to_move = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="built_in">len</span>(train_files) * <span class="number">0.1</span>))</span><br><span class="line">            random.shuffle(train_files)</span><br><span class="line">            files_to_move = train_files[:num_to_move]</span><br><span class="line">            <span class="keyword">for</span> file_name <span class="keyword">in</span> files_to_move:</span><br><span class="line">                src_img_path = os.path.join(train_class_folder, file_name)</span><br><span class="line">                supplement_tasks.append((src_img_path, val_class_folder))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">8</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="built_in">list</span>(tqdm(executor.<span class="built_in">map</span>(move_file, supplement_tasks), total=<span class="built_in">len</span>(supplement_tasks), desc=<span class="string">"补充val文件夹进度"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"val文件夹补充完成！"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    src_data_folder = <span class="string">"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/CursiveChineseCalligraphyDataset-master/Cursive_Chinese_Calligraphy_Dataset/Training"</span>  <span class="comment"># todo 修改你的原始数据集路径</span></span><br><span class="line">    target_data_folder = <span class="string">"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu"</span>  <span class="comment"># todo 修改为你要存放的路径</span></span><br><span class="line">    data_set_split_and_augment(src_data_folder, target_data_folder, num_augments=<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="22数据集标签的提取"><a class="markdownIt-Anchor" href="#22数据集标签的提取"></a> 2.2数据集标签的提取</h3><p>此例汉字识别的类别高达7318种，并且为中文的格式，手动定义数据集的标签显然不太现实，因此，需要编写一个能够提取数据集标签的脚本。</p><p>使用方法：</p><p>在tf_gpu_1环境下使用命令 python labels_get.py运行此代码，将在代码相同目录下生成标签文件</p><p><strong>完整代码(labels_get)如下</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集加载函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_chinese_dataset</span>(<span class="params">data_dir</span>):</span><br><span class="line">    <span class="comment"># 使用 pathlib 处理路径</span></span><br><span class="line">    data_dir = Path(data_dir).resolve()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载数据集，获取类别标签和图像数据</span></span><br><span class="line">    dataset = tf.keras.preprocessing.image_dataset_from_directory(</span><br><span class="line">        <span class="built_in">str</span>(data_dir),</span><br><span class="line">        label_mode=<span class="string">'int'</span>,  <span class="comment"># 使用整数标签</span></span><br><span class="line">        seed=<span class="number">123</span>,</span><br><span class="line">        batch_size=<span class="number">32</span>,  <span class="comment"># 根据内存大小调整批量大小</span></span><br><span class="line">        image_size=(<span class="number">256</span>, <span class="number">256</span>)  <span class="comment"># 根据需要调整图像大小</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取类别标签</span></span><br><span class="line">    class_names = dataset.class_names</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印类别标签</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"类别标签（中文）："</span>, class_names)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存标签到 Python 文件</span></span><br><span class="line">    labels_file_path = Path(data_dir).parent / <span class="string">"lables_caoshu.py"</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(labels_file_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(<span class="string">"labels_caoshu = [\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> label <span class="keyword">in</span> class_names:</span><br><span class="line">            file.write(<span class="string">f"    '<span class="subst">{label}</span>',\n"</span>)</span><br><span class="line">        file.write(<span class="string">"]\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"标签已保存到 <span class="subst">{labels_file_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回数据集和标签</span></span><br><span class="line">    <span class="keyword">return</span> dataset, class_names</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：使用指定路径加载汉字数据集</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data_dir = <span class="string">r"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu/train"</span></span><br><span class="line">    dataset, chinese_labels = load_chinese_dataset(data_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印一些样本数据</span></span><br><span class="line">    <span class="keyword">for</span> images, labels <span class="keyword">in</span> dataset.take(<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"图像批次："</span>, images.numpy())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"标签批次："</span>, labels.numpy())</span><br></pre></td></tr></tbody></table></figure><h3 id="23模型的训练"><a class="markdownIt-Anchor" href="#23模型的训练"></a> 2.3模型的训练</h3><h4 id="231基于卷积神经网络cnn的模型训练"><a class="markdownIt-Anchor" href="#231基于卷积神经网络cnn的模型训练"></a> 2.3.1基于卷积神经网络(CNN)的模型训练</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量以确保使用 UTF-8 编码</span></span><br><span class="line">os.environ[<span class="string">'PYTHONIOENCODING'</span>] = <span class="string">'utf-8'</span></span><br><span class="line">os.environ[<span class="string">'LANG'</span>] = <span class="string">'zh_CN.UTF-8'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集加载函数，指明数据集的位置并统一处理为imgheight*imgwidth的大小，同时设置batch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_load</span>(<span class="params">data_dir, test_data_dir, img_height, img_width, batch_size</span>):</span><br><span class="line">    <span class="comment"># 使用 pathlib 处理路径</span></span><br><span class="line">    data_dir = Path(data_dir).resolve()</span><br><span class="line">    test_data_dir = Path(test_data_dir).resolve()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载训练集</span></span><br><span class="line">    train_ds = tf.keras.preprocessing.image_dataset_from_directory(</span><br><span class="line">        <span class="built_in">str</span>(data_dir),</span><br><span class="line">        label_mode=<span class="string">'categorical'</span>,</span><br><span class="line">        seed=<span class="number">123</span>,</span><br><span class="line">        image_size=(img_height, img_width),</span><br><span class="line">        batch_size=batch_size)</span><br><span class="line">    <span class="comment"># 加载测试集</span></span><br><span class="line">    val_ds = tf.keras.preprocessing.image_dataset_from_directory(</span><br><span class="line">        <span class="built_in">str</span>(test_data_dir),</span><br><span class="line">        label_mode=<span class="string">'categorical'</span>,</span><br><span class="line">        seed=<span class="number">123</span>,</span><br><span class="line">        image_size=(img_height, img_width),</span><br><span class="line">        batch_size=batch_size)</span><br><span class="line">    class_names = train_ds.class_names</span><br><span class="line">    <span class="comment"># 返回处理之后的训练集、验证集和类名</span></span><br><span class="line">    <span class="keyword">return</span> train_ds, val_ds, class_names</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建CNN模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model_load</span>(<span class="params">IMG_SHAPE=(<span class="params"><span class="number">160</span>, <span class="number">160</span>, <span class="number">3</span></span>), class_num=<span class="number">12</span></span>):</span><br><span class="line">    <span class="comment"># 搭建模型</span></span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">        <span class="comment"># 对模型做归一化的处理，将0-255之间的数字统一处理到0到1之间</span></span><br><span class="line">        <span class="comment"># 使用 Lambda 层代替 Rescaling 层以兼容旧版本 TensorFlow</span></span><br><span class="line">        tf.keras.layers.Lambda(<span class="keyword">lambda</span> x: x / <span class="number">255.0</span>, input_shape=IMG_SHAPE),</span><br><span class="line">        <span class="comment"># 卷积层，该卷积层的输出为32个通道，卷积核的大小是3*3，激活函数为relu</span></span><br><span class="line">        tf.keras.layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>),</span><br><span class="line">        <span class="comment"># 添加池化层，池化的kernel大小是2*2</span></span><br><span class="line">        tf.keras.layers.MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="comment"># Add another convolution</span></span><br><span class="line">        <span class="comment"># 卷积层，输出为64个通道，卷积核大小为3*3，激活函数为relu</span></span><br><span class="line">        tf.keras.layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>),</span><br><span class="line">        <span class="comment"># 池化层，最大池化，对2*2的区域进行池化操作</span></span><br><span class="line">        tf.keras.layers.MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">        <span class="comment"># 将二维的输出转化为一维</span></span><br><span class="line">        tf.keras.layers.Flatten(),</span><br><span class="line">        <span class="comment"># 和卷积前的例子一样，这里使用了 128 个全连接层和 10 个输出层</span></span><br><span class="line">        tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">        <span class="comment"># 通过softmax函数将模型输出为类名长度的神经元上，激活函数采用softmax对应概率值</span></span><br><span class="line">        tf.keras.layers.Dense(class_num, activation=<span class="string">'softmax'</span>)</span><br><span class="line">    ])</span><br><span class="line">    <span class="comment"># 输出模型信息</span></span><br><span class="line">    model.summary()</span><br><span class="line">    <span class="comment"># 指明模型的训练参数，优化器为sgd优化器，损失函数为交叉熵损失函数</span></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=<span class="string">'sgd'</span>, loss=<span class="string">'categorical_crossentropy'</span>, metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">    <span class="comment"># 返回模型</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示训练过程的曲线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_loss_acc</span>(<span class="params">history</span>):</span><br><span class="line">    <span class="comment"># 从history中提取模型训练集和验证集准确率信息和误差信息</span></span><br><span class="line">    acc = history.history[<span class="string">'accuracy'</span>]</span><br><span class="line">    val_acc = history.history[<span class="string">'val_accuracy'</span>]</span><br><span class="line">    loss = history.history[<span class="string">'loss'</span>]</span><br><span class="line">    val_loss = history.history[<span class="string">'val_loss'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照上下结构将图画输出</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    plt.plot(acc, label=<span class="string">'Training Accuracy'</span>)</span><br><span class="line">    plt.plot(val_acc, label=<span class="string">'Validation Accuracy'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'lower right'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Accuracy'</span>)</span><br><span class="line">    plt.ylim([<span class="built_in">min</span>(plt.ylim()), <span class="number">1</span>])</span><br><span class="line">    plt.title(<span class="string">'Training and Validation Accuracy'</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    plt.plot(loss, label=<span class="string">'Training Loss'</span>)</span><br><span class="line">    plt.plot(val_loss, label=<span class="string">'Validation Loss'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Cross Entropy'</span>)</span><br><span class="line">    plt.title(<span class="string">'Training and Validation Loss'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">    plt.savefig(<span class="string">'results/results_cnn.png'</span>, dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epochs</span>):</span><br><span class="line">    <span class="comment"># 开始训练，记录开始时间</span></span><br><span class="line">    begin_time = time()</span><br><span class="line">    <span class="comment"># 加载数据集， 修改为你的数据集的路径</span></span><br><span class="line">    train_ds, val_ds, class_names = data_load(</span><br><span class="line">        <span class="string">r"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-all-more/train"</span>,</span><br><span class="line">        <span class="string">r"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-all-more/val"</span>,</span><br><span class="line">        <span class="number">160</span>, <span class="number">160</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"类别标签（中文）："</span>, class_names)</span><br><span class="line">    <span class="comment"># 加载模型</span></span><br><span class="line">    model = model_load(class_num=<span class="built_in">len</span>(class_names))</span><br><span class="line">    <span class="comment"># 指明训练的轮数epoch，开始训练</span></span><br><span class="line">    history = model.fit(train_ds, validation_data=val_ds, epochs=epochs)</span><br><span class="line">    <span class="comment"># 保存模型， 修改为你要保存的模型的名称</span></span><br><span class="line">    model.save(<span class="string">"models/cnn_hanzi_2.h5"</span>)</span><br><span class="line">    <span class="comment"># 记录结束时间</span></span><br><span class="line">    end_time = time()</span><br><span class="line">    run_time = end_time - begin_time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'该循环程序运行时间：'</span>, run_time, <span class="string">"s"</span>)  <span class="comment"># 该循环程序运行时间： 1.4201874732</span></span><br><span class="line">    <span class="comment"># 绘制模型训练过程图</span></span><br><span class="line">    show_loss_acc(history)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    train(epochs=<span class="number">40</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="232基于残差神经网络resnet的模型训练"><a class="markdownIt-Anchor" href="#232基于残差神经网络resnet的模型训练"></a> <strong>2.3.2基于残差神经网络(Resnet)的模型训练</strong></h4><p>汉字识别模型类别非常多，使用一般的神经网络训练出来的模型可能泛化性并不理想，针对多类别的模型训练可以采用更复杂的网络，比如本例的Resnet残差神经网络，最终训练的模型准确率和泛化性极高。</p><p><mark>使用方法：</mark></p><p>代码片段中，修改路径为已经划分好的训练集，测试集路径</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_ds, val_ds, class_names = data_load(</span><br><span class="line">    <span class="string">r"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu/train"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">r"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu/val"</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">128</span>, <span class="number">64</span>)  <span class="comment"># 减小批处理大小</span></span><br></pre></td></tr></tbody></table></figure><p>模型保存名称修改</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.save(<span class="string">"models/final_resnet50_chinese_kai"</span>, save_format=<span class="string">'tf'</span>)</span><br></pre></td></tr></tbody></table></figure><p>在tf_gpu_1环境下，使用命令 python model_train_resnet50.py</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量以确保使用 UTF-8 编码</span></span><br><span class="line">os.environ[<span class="string">'PYTHONIOENCODING'</span>] = <span class="string">'utf-8'</span></span><br><span class="line">os.environ[<span class="string">'LANG'</span>] = <span class="string">'zh_CN.UTF-8'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用混合精度训练</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.mixed_precision <span class="keyword">import</span> experimental <span class="keyword">as</span> mixed_precision</span><br><span class="line">policy = mixed_precision.Policy(<span class="string">'mixed_float16'</span>)</span><br><span class="line">mixed_precision.set_policy(policy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据加载函数，加入数据增强</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_load</span>(<span class="params">data_dir, test_data_dir, img_height, img_width, batch_size</span>):</span><br><span class="line">    data_dir = Path(data_dir).resolve()</span><br><span class="line">    test_data_dir = Path(test_data_dir).resolve()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载训练集</span></span><br><span class="line">    train_ds = tf.keras.preprocessing.image_dataset_from_directory(</span><br><span class="line">        <span class="built_in">str</span>(data_dir),</span><br><span class="line">        label_mode=<span class="string">'categorical'</span>,</span><br><span class="line">        seed=<span class="number">123</span>,</span><br><span class="line">        image_size=(img_height, img_width),</span><br><span class="line">        batch_size=batch_size</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取类别标签</span></span><br><span class="line">    class_names = train_ds.class_names</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据增强</span></span><br><span class="line">    data_augmentation = tf.keras.Sequential([</span><br><span class="line">        tf.keras.layers.experimental.preprocessing.RandomFlip(<span class="string">'horizontal'</span>),</span><br><span class="line">        tf.keras.layers.experimental.preprocessing.RandomRotation(<span class="number">0.1</span>),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加入数据增强</span></span><br><span class="line">    train_ds = train_ds.<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: (data_augmentation(x), y), num_parallel_calls=tf.data.experimental.AUTOTUNE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载测试集</span></span><br><span class="line">    val_ds = tf.keras.preprocessing.image_dataset_from_directory(</span><br><span class="line">        <span class="built_in">str</span>(test_data_dir),</span><br><span class="line">        label_mode=<span class="string">'categorical'</span>,</span><br><span class="line">        seed=<span class="number">123</span>,</span><br><span class="line">        image_size=(img_height, img_width),</span><br><span class="line">        batch_size=batch_size</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预取数据</span></span><br><span class="line">    train_ds = train_ds.prefetch(buffer_size=tf.data.experimental.AUTOTUNE)</span><br><span class="line">    val_ds = val_ds.prefetch(buffer_size=tf.data.experimental.AUTOTUNE)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_ds, val_ds, class_names</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建ResNet模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model_load</span>(<span class="params">IMG_SHAPE=(<span class="params"><span class="number">128</span>, <span class="number">128</span>, <span class="number">3</span></span>), class_num=<span class="number">7200</span></span>):</span><br><span class="line">    resnet = tf.keras.applications.ResNet50(weights=<span class="string">'imagenet'</span>, include_top=<span class="literal">False</span>, input_shape=IMG_SHAPE)</span><br><span class="line"></span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">        resnet,</span><br><span class="line">        tf.keras.layers.GlobalAveragePooling2D(),</span><br><span class="line">        tf.keras.layers.Dense(<span class="number">1024</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">        tf.keras.layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">        tf.keras.layers.Dense(class_num, activation=<span class="string">'softmax'</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    model.summary()</span><br><span class="line"></span><br><span class="line">    initial_learning_rate = <span class="number">0.01</span></span><br><span class="line">    lr_schedule = tf.keras.optimizers.schedules.ExponentialDecay(</span><br><span class="line">        initial_learning_rate, decay_steps=<span class="number">10000</span>, decay_rate=<span class="number">0.9</span>, staircase=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    optimizer = tf.keras.optimizers.SGD(learning_rate=lr_schedule, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=optimizer,</span><br><span class="line">                  loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">                  metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示训练过程的曲线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_loss_acc</span>(<span class="params">history</span>):</span><br><span class="line">    acc = history.history[<span class="string">'accuracy'</span>]</span><br><span class="line">    val_acc = history.history[<span class="string">'val_accuracy'</span>]</span><br><span class="line">    loss = history.history[<span class="string">'loss'</span>]</span><br><span class="line">    val_loss = history.history[<span class="string">'val_loss'</span>]</span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    plt.plot(acc, label=<span class="string">'Training Accuracy'</span>)</span><br><span class="line">    plt.plot(val_acc, label=<span class="string">'Validation Accuracy'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'lower right'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Accuracy'</span>)</span><br><span class="line">    plt.ylim([<span class="built_in">min</span>(plt.ylim()), <span class="number">1</span>])</span><br><span class="line">    plt.title(<span class="string">'Training and Validation Accuracy'</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    plt.plot(loss, label=<span class="string">'Training Loss'</span>)</span><br><span class="line">    plt.plot(val_loss, label=<span class="string">'Validation Loss'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Cross Entropy'</span>)</span><br><span class="line">    plt.title(<span class="string">'Training and Validation Loss'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">    plt.savefig(<span class="string">'results/results_resnet.png'</span>, dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加早停和模型检查点回调</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epochs</span>):</span><br><span class="line">    begin_time = time()</span><br><span class="line"></span><br><span class="line">    train_ds, val_ds, class_names = data_load(</span><br><span class="line">        <span class="string">r"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu/train"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">r"s:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-caoshu/val"</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">128</span>, <span class="number">64</span>)  <span class="comment"># 减小批处理大小</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"类别标签（中文）："</span>, class_names)</span><br><span class="line"></span><br><span class="line">    model = model_load(class_num=<span class="built_in">len</span>(class_names))</span><br><span class="line"></span><br><span class="line">    early_stopping = tf.keras.callbacks.EarlyStopping(</span><br><span class="line">        monitor=<span class="string">'val_loss'</span>, patience=<span class="number">10</span>, restore_best_weights=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    checkpoint = tf.keras.callbacks.ModelCheckpoint(</span><br><span class="line">        <span class="string">'models/final_resnet50_chinese_kai'</span>, monitor=<span class="string">'val_loss'</span>, save_best_only=<span class="literal">True</span>, save_format=<span class="string">'tf'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    history = model.fit(</span><br><span class="line">        train_ds, validation_data=val_ds, epochs=epochs,</span><br><span class="line">        callbacks=[early_stopping, checkpoint]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    model.save(<span class="string">"models/final_resnet50_chinese_kai"</span>, save_format=<span class="string">'tf'</span>)</span><br><span class="line"></span><br><span class="line">    end_time = time()</span><br><span class="line">    run_time = end_time - begin_time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'该循环程序运行时间：'</span>, run_time, <span class="string">"s"</span>)</span><br><span class="line"></span><br><span class="line">    show_loss_acc(history)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    train(epochs=<span class="number">15</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="24-模型的测试"><a class="markdownIt-Anchor" href="#24-模型的测试"></a> 2.4 模型的测试</h3><p>代码如下，更改测试集以及模型路径为相应的目标路径即可</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Matplotlib显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">'font.family'</span>] = [<span class="string">'sans-serif'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据加载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_load</span>(<span class="params">data_dir, test_data_dir, img_height, img_width, batch_size</span>):</span><br><span class="line">    class_names = <span class="built_in">sorted</span>(</span><br><span class="line">        [dir_name <span class="keyword">for</span> dir_name <span class="keyword">in</span> os.listdir(data_dir) <span class="keyword">if</span> os.path.isdir(os.path.join(data_dir, dir_name))])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Detected <span class="subst">{<span class="built_in">len</span>(class_names)}</span> classes."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_path</span>(<span class="params">file_path</span>):</span><br><span class="line">        label = tf.strings.split(file_path, os.path.sep)[-<span class="number">2</span>]</span><br><span class="line">        label = tf.where(tf.equal(tf.constant(class_names), label))[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        img = tf.io.read_file(file_path)</span><br><span class="line">        img = tf.image.decode_jpeg(img, channels=<span class="number">3</span>)</span><br><span class="line">        img = tf.image.resize(img, [img_height, img_width])</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepare_dataset</span>(<span class="params">directory</span>):</span><br><span class="line">        list_ds = tf.data.Dataset.list_files(os.path.join(directory, <span class="string">'*/*'</span>), shuffle=<span class="literal">True</span>)</span><br><span class="line">        labeled_ds = list_ds.<span class="built_in">map</span>(process_path, num_parallel_calls=tf.data.experimental.AUTOTUNE)</span><br><span class="line">        labeled_ds = labeled_ds.batch(batch_size).prefetch(buffer_size=tf.data.experimental.AUTOTUNE)</span><br><span class="line">        <span class="keyword">return</span> labeled_ds</span><br><span class="line"></span><br><span class="line">    train_ds = prepare_dataset(data_dir)</span><br><span class="line">    val_ds = prepare_dataset(test_data_dir)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Loaded datasets: <span class="subst">{<span class="built_in">len</span>(train_ds)}</span> training batches, <span class="subst">{<span class="built_in">len</span>(val_ds)}</span> validation batches."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_ds, val_ds, class_names</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚合类别并随机抽取10个类别生成热力图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aggregate_labels_and_select</span>(<span class="params">real_labels, pred_labels, num_classes, num_groups, selected_groups</span>):</span><br><span class="line">    group_size = num_classes // num_groups</span><br><span class="line">    real_labels_agg = [label // group_size <span class="keyword">for</span> label <span class="keyword">in</span> real_labels]</span><br><span class="line">    pred_labels_agg = [label // group_size <span class="keyword">for</span> label <span class="keyword">in</span> pred_labels]</span><br><span class="line"></span><br><span class="line">    real_labels_selected = [real_labels_agg[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_labels_agg)) <span class="keyword">if</span></span><br><span class="line">                            real_labels_agg[i] <span class="keyword">in</span> selected_groups]</span><br><span class="line">    pred_labels_selected = [pred_labels_agg[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pred_labels_agg)) <span class="keyword">if</span></span><br><span class="line">                            real_labels_agg[i] <span class="keyword">in</span> selected_groups]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> real_labels_selected, pred_labels_selected</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试cnn模型准确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_cnn</span>():</span><br><span class="line">    <span class="comment"># 加载数据</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    train_ds, test_ds, class_names = data_load(</span><br><span class="line">        <span class="string">r"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-all/train"</span>,</span><br><span class="line">        <span class="string">r"S:/2_tensflow_Project/chinese-calligraphy-dataset-master/data/data-chinese-all/val"</span>,</span><br><span class="line">        <span class="number">160</span>, <span class="number">160</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Data loading completed in <span class="subst">{time.time() - start_time:<span class="number">.2</span>f}</span> seconds."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载模型</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    model = tf.keras.models.load_model(<span class="string">"models/final_resnet50_chinese"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Model loaded in <span class="subst">{time.time() - start_time:<span class="number">.2</span>f}</span> seconds."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 编译模型</span></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=<span class="string">'adam'</span>, loss=<span class="string">'sparse_categorical_crossentropy'</span>, metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 推理</span></span><br><span class="line">    test_real_labels = []</span><br><span class="line">    test_pre_labels = []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Starting model inference..."</span>)</span><br><span class="line">    inference_start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (test_batch_images, test_batch_labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_ds):</span><br><span class="line">        <span class="keyword">if</span> batch_idx &gt;= <span class="number">10</span>:  <span class="comment"># 只处理前10个batch来加速测试</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"Processing batch <span class="subst">{batch_idx + <span class="number">1</span>}</span>..."</span>)</span><br><span class="line">        test_batch_labels = test_batch_labels.numpy()</span><br><span class="line">        test_batch_pres = model.predict(test_batch_images)</span><br><span class="line"></span><br><span class="line">        test_real_labels.extend(test_batch_labels)</span><br><span class="line">        test_pre_labels.extend(np.argmax(test_batch_pres, axis=<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Inference completed in <span class="subst">{time.time() - inference_start_time:<span class="number">.2</span>f}</span> seconds."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 聚合类别并随机抽取10个类别</span></span><br><span class="line">    num_groups = <span class="number">10</span></span><br><span class="line">    selected_groups = random.sample(<span class="built_in">range</span>(num_groups), <span class="number">10</span>)</span><br><span class="line">    test_real_labels_agg, test_pre_labels_agg = aggregate_labels_and_select(</span><br><span class="line">        test_real_labels, test_pre_labels, <span class="built_in">len</span>(class_names), num_groups, selected_groups</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成聚合后的热力图</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Generating aggregated heatmaps..."</span>)</span><br><span class="line">    heat_maps = np.zeros((num_groups, num_groups))</span><br><span class="line">    <span class="keyword">for</span> real_label, pred_label <span class="keyword">in</span> <span class="built_in">zip</span>(test_real_labels_agg, test_pre_labels_agg):</span><br><span class="line">        heat_maps[real_label][pred_label] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    heat_maps_sum = np.<span class="built_in">sum</span>(heat_maps, axis=<span class="number">1</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    heat_maps_sum[heat_maps_sum == <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    heat_maps_float = heat_maps / heat_maps_sum</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建存储热力图的文件夹</span></span><br><span class="line">    output_dir = <span class="string">"results/aggregated_heatmap"</span></span><br><span class="line">    os.makedirs(output_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存聚合热力图</span></span><br><span class="line">    save_path = os.path.join(output_dir, <span class="string">"aggregated_heatmap.png"</span>)</span><br><span class="line">    show_heatmaps(<span class="string">"Aggregated Heatmap"</span>, selected_groups, selected_groups,</span><br><span class="line">                  heat_maps_float[selected_groups][:, selected_groups], save_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Saved aggregated heatmap to <span class="subst">{save_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"All heatmaps generated and saved."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_heatmaps</span>(<span class="params">title, x_labels, y_labels, harvest, save_name</span>):</span><br><span class="line">    <span class="comment"># 创建画布</span></span><br><span class="line">    fig, ax = plt.subplots()</span><br><span class="line">    im = ax.imshow(harvest, cmap=<span class="string">"OrRd"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改标签</span></span><br><span class="line">    ax.set_xticks(np.arange(<span class="built_in">len</span>(y_labels)))</span><br><span class="line">    ax.set_yticks(np.arange(<span class="built_in">len</span>(x_labels)))</span><br><span class="line">    ax.set_xticklabels(y_labels)</span><br><span class="line">    ax.set_yticklabels(x_labels)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 旋转x轴标签</span></span><br><span class="line">    plt.setp(ax.get_xticklabels(), rotation=<span class="number">45</span>, ha=<span class="string">"right"</span>, rotation_mode=<span class="string">"anchor"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加每个热力块的具体数值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_labels)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_labels)):</span><br><span class="line">            ax.text(j, i, <span class="built_in">round</span>(harvest[i, j], <span class="number">2</span>), ha=<span class="string">"center"</span>, va=<span class="string">"center"</span>, color=<span class="string">"black"</span>)</span><br><span class="line"></span><br><span class="line">    ax.set_xlabel(<span class="string">"Predict label"</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">"Actual label"</span>)</span><br><span class="line">    ax.set_title(title)</span><br><span class="line">    fig.tight_layout()</span><br><span class="line">    plt.colorbar(im)</span><br><span class="line">    plt.savefig(save_name, dpi=<span class="number">100</span>)</span><br><span class="line">    plt.close(fig)  <span class="comment"># 关闭图形以释放内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    test_cnn()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Total execution time: <span class="subst">{time.time() - start_time:<span class="number">.2</span>f}</span> seconds."</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="25-tensorboard工具模型流图"><a class="markdownIt-Anchor" href="#25-tensorboard工具模型流图"></a> 2.5 tensorboard工具——模型流图</h3><p>model = tf.saved_model.load(“models/final_resnet50_chinese”) 语句中修改为目标模型</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设你已经加载了你的模型</span></span><br><span class="line">model = tf.saved_model.load(<span class="string">"models/final_resnet50_chinese"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取模型的推理签名（与导出的模型相关，可能需要调整具体签名名称）</span></span><br><span class="line">infer = model.signatures[<span class="string">'serving_default'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 TensorBoard 日志目录</span></span><br><span class="line">log_dir = <span class="string">"logs/graph"</span></span><br><span class="line">writer = tf.summary.create_file_writer(log_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包装函数并使用 tf.function</span></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model_inference</span>(<span class="params">input_tensor</span>):</span><br><span class="line">    <span class="keyword">return</span> infer(input_tensor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个示例输入张量（调整形状以匹配模型的输入要求）</span></span><br><span class="line">example_input = tf.random.normal([<span class="number">1</span>, <span class="number">160</span>, <span class="number">160</span>, <span class="number">3</span>])  <span class="comment"># 假设模型输入是160x160x3的图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录数据流图</span></span><br><span class="line"><span class="keyword">with</span> writer.as_default():</span><br><span class="line">    <span class="comment"># 开启追踪</span></span><br><span class="line">    tf.summary.trace_on(graph=<span class="literal">True</span>, profiler=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行一次推理以记录计算图</span></span><br><span class="line">    model_inference(example_input)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录计算图</span></span><br><span class="line">    tf.summary.trace_export(name=<span class="string">"model_trace"</span>, step=<span class="number">0</span>, profiler_outdir=log_dir)</span><br><span class="line"></span><br><span class="line">    writer.flush()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Graph has been written to TensorBoard logs. You can view it using TensorBoard."</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="26-模型的使用"><a class="markdownIt-Anchor" href="#26-模型的使用"></a> 2.6 模型的使用</h2><p>本例为基于Qt界面的汉字识别程序，通过加载训练好的Tensorflow模型，选择本地的图片作为输入，进行手写汉字识别</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2021/6/17 20:29</span></span><br><span class="line"><span class="comment"># @Author  : dejahu</span></span><br><span class="line"><span class="comment"># @Email   : 1148392984@qq.com</span></span><br><span class="line"><span class="comment"># @File    : window.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># @Brief   : 图形化界面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> lables_caoshu <span class="keyword">import</span> labels_caoshu</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>(<span class="title class_ inherited__">QTabWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.setWindowIcon(QIcon(<span class="string">'images/logo.png'</span>))</span><br><span class="line">        self.setWindowTitle(<span class="string">'CNN汉字识别系统'</span>)</span><br><span class="line">        self.model = tf.keras.models.load_model(<span class="string">"models/final_resnet50_chinese"</span>)</span><br><span class="line">        self.to_predict_name = <span class="string">"images/Start_1.png"</span></span><br><span class="line">        self.class_names = labels_caoshu</span><br><span class="line">        self.resize(<span class="number">900</span>, <span class="number">700</span>)</span><br><span class="line">        self.initUI()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initUI</span>(<span class="params">self</span>):</span><br><span class="line">        main_widget = QWidget()</span><br><span class="line">        main_layout = QHBoxLayout()</span><br><span class="line">        font = QFont(<span class="string">'楷体'</span>, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">        dark_style = <span class="string">"""</span></span><br><span class="line"><span class="string">            QWidget {</span></span><br><span class="line"><span class="string">                background-color: #2E2E2E;</span></span><br><span class="line"><span class="string">                color: #FFFFFF;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QLabel {</span></span><br><span class="line"><span class="string">                color: #FFFFFF;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QPushButton {</span></span><br><span class="line"><span class="string">                background-color: #4F4F4F;</span></span><br><span class="line"><span class="string">                border: 2px solid #6E6E6E;</span></span><br><span class="line"><span class="string">                color: #FFFFFF;</span></span><br><span class="line"><span class="string">                padding: 5px;</span></span><br><span class="line"><span class="string">                border-radius: 5px;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QPushButton:hover {</span></span><br><span class="line"><span class="string">                background-color: #6E6E6E;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QPushButton:pressed {</span></span><br><span class="line"><span class="string">                background-color: #3D3D3D;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QTabBar::tab {</span></span><br><span class="line"><span class="string">                background: #3D3D3D;</span></span><br><span class="line"><span class="string">                color: #FFFFFF;</span></span><br><span class="line"><span class="string">                padding: 10px;</span></span><br><span class="line"><span class="string">                border-radius: 5px;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QTabBar::tab:selected {</span></span><br><span class="line"><span class="string">                background: #2E2E2E;</span></span><br><span class="line"><span class="string">                border-bottom: 2px solid #4F4F4F;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">            QTabBar::tab:!selected {</span></span><br><span class="line"><span class="string">                background: #3D3D3D;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.setStyleSheet(dark_style)</span><br><span class="line"></span><br><span class="line">        left_widget = QWidget()</span><br><span class="line">        left_layout = QVBoxLayout()</span><br><span class="line">        img_title = QLabel(<span class="string">"输入作品"</span>)</span><br><span class="line">        img_title.setFont(font)</span><br><span class="line">        img_title.setAlignment(Qt.AlignCenter)</span><br><span class="line">        self.img_label = QLabel()</span><br><span class="line">        self.process_image(self.to_predict_name)</span><br><span class="line">        self.img_label.setPixmap(QPixmap(<span class="string">"images/binary_show.png"</span>))</span><br><span class="line">        left_layout.addWidget(img_title)</span><br><span class="line">        left_layout.addWidget(self.img_label, <span class="number">1</span>, Qt.AlignCenter)</span><br><span class="line">        left_widget.setLayout(left_layout)</span><br><span class="line"></span><br><span class="line">        right_widget = QWidget()</span><br><span class="line">        right_layout = QVBoxLayout()</span><br><span class="line">        btn_change = QPushButton(<span class="string">" 上传作品 "</span>)</span><br><span class="line">        btn_change.setIcon(QIcon(<span class="string">'images/upload.png'</span>))</span><br><span class="line">        btn_change.clicked.connect(self.change_img)</span><br><span class="line">        btn_change.setFont(font)</span><br><span class="line">        btn_predict = QPushButton(<span class="string">" 开始识别 "</span>)</span><br><span class="line">        btn_predict.setIcon(QIcon(<span class="string">'images/recognize.png'</span>))</span><br><span class="line">        btn_predict.setFont(font)</span><br><span class="line">        btn_predict.clicked.connect(self.predict_img)</span><br><span class="line">        label_result = QLabel(<span class="string">' 识别结果 '</span>)</span><br><span class="line">        self.result = QLabel(<span class="string">"等待识别"</span>)</span><br><span class="line">        label_result.setFont(QFont(<span class="string">'楷体'</span>, <span class="number">16</span>))</span><br><span class="line">        self.result.setFont(QFont(<span class="string">'楷体'</span>, <span class="number">24</span>))</span><br><span class="line">        right_layout.addStretch()</span><br><span class="line">        right_layout.addWidget(label_result, <span class="number">0</span>, Qt.AlignCenter)</span><br><span class="line">        right_layout.addStretch()</span><br><span class="line">        right_layout.addWidget(self.result, <span class="number">0</span>, Qt.AlignCenter)</span><br><span class="line">        right_layout.addStretch()</span><br><span class="line">        right_layout.addStretch()</span><br><span class="line">        right_layout.addWidget(btn_change)</span><br><span class="line">        right_layout.addWidget(btn_predict)</span><br><span class="line">        right_layout.addStretch()</span><br><span class="line">        right_widget.setLayout(right_layout)</span><br><span class="line"></span><br><span class="line">        main_layout.addWidget(left_widget)</span><br><span class="line">        main_layout.addWidget(right_widget)</span><br><span class="line">        main_widget.setLayout(main_layout)</span><br><span class="line"></span><br><span class="line">        about_widget = QWidget()</span><br><span class="line">        about_layout = QVBoxLayout()</span><br><span class="line">        about_title = QLabel(<span class="string">'欢迎使用手写汉字识别系统'</span>)</span><br><span class="line">        about_title.setFont(QFont(<span class="string">'楷体'</span>, <span class="number">18</span>))</span><br><span class="line">        about_title.setAlignment(Qt.AlignCenter)</span><br><span class="line">        about_img = QLabel()</span><br><span class="line">        about_img.setPixmap(QPixmap(<span class="string">'images/CNN.png'</span>))</span><br><span class="line">        about_img.setAlignment(Qt.AlignCenter)</span><br><span class="line">        label_super = QLabel(<span class="string">"sz_jmu"</span>)</span><br><span class="line">        label_super.setFont(QFont(<span class="string">'楷体'</span>, <span class="number">12</span>))</span><br><span class="line">        label_super.setAlignment(Qt.AlignRight)</span><br><span class="line">        about_layout.addWidget(about_title)</span><br><span class="line">        about_layout.addStretch()</span><br><span class="line">        about_layout.addWidget(about_img)</span><br><span class="line">        about_layout.addStretch()</span><br><span class="line">        about_layout.addWidget(label_super)</span><br><span class="line">        about_widget.setLayout(about_layout)</span><br><span class="line"></span><br><span class="line">        self.addTab(main_widget, <span class="string">'主页'</span>)</span><br><span class="line">        self.addTab(about_widget, <span class="string">'关于'</span>)</span><br><span class="line">        self.setTabIcon(<span class="number">0</span>, QIcon(<span class="string">'images/主页面.png'</span>))</span><br><span class="line">        self.setTabIcon(<span class="number">1</span>, QIcon(<span class="string">'images/关于.png'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 上传并显示图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change_img</span>(<span class="params">self</span>):</span><br><span class="line">        openfile_name = QFileDialog.getOpenFileName(self, <span class="string">'chose files'</span>, <span class="string">''</span>,</span><br><span class="line">                                                    <span class="string">'Image files(*.jpg *.png *jpeg)'</span>)  <span class="comment"># 打开文件选择框选择文件</span></span><br><span class="line">        img_name = openfile_name[<span class="number">0</span>]  <span class="comment"># 获取图片名称</span></span><br><span class="line">        <span class="keyword">if</span> img_name == <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target_image_name = <span class="string">"images/tmp_up."</span> + img_name.split(<span class="string">"."</span>)[-<span class="number">1</span>]  <span class="comment"># 将图片移动到当前目录</span></span><br><span class="line">            shutil.copy(img_name, target_image_name)</span><br><span class="line">            self.to_predict_name = target_image_name</span><br><span class="line">            self.process_image(self.to_predict_name)</span><br><span class="line">            self.img_label.setPixmap(QPixmap(<span class="string">"images/binary_show.png"</span>))  <span class="comment"># 显示二值化后的图片</span></span><br><span class="line">            self.result.setText(<span class="string">"等待识别"</span>)</span><br><span class="line">            self.show_binary_image()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图片处理和二值化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_image</span>(<span class="params">self, image_path</span>):</span><br><span class="line">        img_init = cv2.imread(image_path)  <span class="comment"># 打开图片</span></span><br><span class="line">        h, w, c = img_init.shape</span><br><span class="line">        scale = <span class="number">400</span> / h</span><br><span class="line">        img_show = cv2.resize(img_init, (<span class="number">0</span>, <span class="number">0</span>), fx=scale, fy=scale)  <span class="comment"># 将图片的大小统一调整到400的高，方便界面显示</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二值化处理</span></span><br><span class="line">        gray_img = cv2.cvtColor(img_init, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        _, binary_img = cv2.threshold(gray_img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">        binary_img_inverted = cv2.bitwise_not(binary_img)</span><br><span class="line">        binary_img_colored = cv2.cvtColor(binary_img_inverted, cv2.COLOR_GRAY2BGR)</span><br><span class="line">        binary_img_show = cv2.resize(binary_img_colored, (<span class="number">0</span>, <span class="number">0</span>), fx=scale, fy=scale)  <span class="comment"># 将二值化图像调整到400高显示</span></span><br><span class="line"></span><br><span class="line">        cv2.imwrite(<span class="string">'images/binary_show.png'</span>, binary_img_show)  <span class="comment"># 保存显示用的二值化图片</span></span><br><span class="line">        cv2.imwrite(<span class="string">'images/target.png'</span>, binary_img_colored)  <span class="comment"># 保存用于识别的二值化图片</span></span><br><span class="line">        cv2.imwrite(<span class="string">'images/binary_target.png'</span>, binary_img)  <span class="comment"># 保存仅用于二值化显示的图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict_img</span>(<span class="params">self</span>):</span><br><span class="line">        img = Image.<span class="built_in">open</span>(<span class="string">'images/target.png'</span>)  <span class="comment"># 读取二值化图片</span></span><br><span class="line">        img = img.resize((<span class="number">128</span>, <span class="number">128</span>))  <span class="comment"># 调整图像大小到模型所需的输入尺寸</span></span><br><span class="line">        img = np.asarray(img)  <span class="comment"># 将图片转化为numpy的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确保图像是3个通道的</span></span><br><span class="line">        <span class="keyword">if</span> img.shape[-<span class="number">1</span>] != <span class="number">3</span>:</span><br><span class="line">            img = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)</span><br><span class="line"></span><br><span class="line">        img = img.reshape(<span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">3</span>)  <span class="comment"># 调整图像的形状以匹配模型输入</span></span><br><span class="line">        outputs = self.model.predict(img)  <span class="comment"># 将图片输入模型得到结果</span></span><br><span class="line">        result_index = <span class="built_in">int</span>(np.argmax(outputs))</span><br><span class="line">        result = self.class_names[result_index]  <span class="comment"># 获得对应的识别结果</span></span><br><span class="line">        self.result.setText(result)  <span class="comment"># 在界面上显示结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示二值化图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_binary_image</span>(<span class="params">self</span>):</span><br><span class="line">        binary_image_window = QMainWindow()</span><br><span class="line">        binary_image_window.setWindowTitle(<span class="string">'二值化处理结果'</span>)</span><br><span class="line">        binary_image_widget = QLabel()</span><br><span class="line">        binary_image = QPixmap(<span class="string">"images/binary_target.png"</span>)</span><br><span class="line">        binary_image_widget.setPixmap(binary_image)</span><br><span class="line">        binary_image_widget.setAlignment(Qt.AlignCenter)</span><br><span class="line">        binary_image_window.setCentralWidget(binary_image_widget)</span><br><span class="line">        binary_image_window.resize(binary_image.size())</span><br><span class="line">        binary_image_window.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 界面关闭事件，询问用户是否关闭</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">closeEvent</span>(<span class="params">self, event</span>):</span><br><span class="line">        reply = QMessageBox.question(self,</span><br><span class="line">                                     <span class="string">'退出'</span>,</span><br><span class="line">                                     <span class="string">"是否要退出程序？"</span>,</span><br><span class="line">                                     QMessageBox.Yes | QMessageBox.No,</span><br><span class="line">                                     QMessageBox.No)</span><br><span class="line">        <span class="keyword">if</span> reply == QMessageBox.Yes:</span><br><span class="line">            self.close()</span><br><span class="line">            event.accept()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            event.ignore()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    x = MainWindow()</span><br><span class="line">    x.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></tbody></table></figure><p><strong>运行结果如下：</strong></p><p>tensorflow_gpu_tools工具链总结：</p><ul><li><p>data_split.py：数据集划分脚本</p></li><li><p>labels_get.py：标签生成脚本</p></li><li><p>model_train_resnet50.py：训练脚本</p></li><li><p>tf_board.py：模型结构/流图展示脚本</p></li><li><p><a href="http://window.py">window.py</a>：模型识别QT程序</p></li></ul><h1 id="更新记录"><a class="markdownIt-Anchor" href="#更新记录"></a> 更新记录</h1><p>此栏目用于记录代码项目新增功能，bug修复等日志</p><blockquote><p>date:2024.8.29</p><p>对<strong>model_train_densenet169.py</strong> 新增<strong>参数接口化</strong>配置，使用<strong>命令行</strong>即可便捷配置模型训练参数</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse                          <span class="comment"># 导入argparse模块以处理命令行参数</span></span><br></pre></td></tr></tbody></table></figure><img src="/posts/33676/image-20240830003108581.png" class="" title="image-20240830003108581"><p>如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script_name.py --train_data_dir <span class="string">"path/to/train_data"</span> --test_data_dir <span class="string">"path/to/test_data"</span> --img_height <span class="number">128</span> --img_width <span class="number">128</span> --batch_size <span class="number">64</span> --epochs <span class="number">15</span></span><br></pre></td></tr></tbody></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;author: sz_jmu&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;TensorFlow 是一个用于机器学习和深度学习的开源框架，由 Google Brain 团队开发</summary>
      
    
    
    
    <category term="项目" scheme="https://szturin.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="深度学习" scheme="https://szturin.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>【TI】[2]常见外设的基本配置</title>
    <link href="https://szturin.github.io/posts/9383/"/>
    <id>https://szturin.github.io/posts/9383/</id>
    <published>2024-07-17T15:26:54.000Z</published>
    <updated>2024-09-03T04:33:33.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sysconfig界面"><a class="markdownIt-Anchor" href="#sysconfig界面"></a> Sysconfig界面:</h1><h2 id="1波特率数据格式的配置"><a class="markdownIt-Anchor" href="#1波特率数据格式的配置"></a> 1.波特率，数据格式的配置</h2><img src="/posts/9383/image-20240717232902923.png" class="" title="image-20240717232902923"><h2 id="2中断使能配置"><a class="markdownIt-Anchor" href="#2中断使能配置"></a> 2.中断使能配置</h2><img src="/posts/9383/image-20240718004436675.png" class="" title="image-20240718004436675"><h2 id="3引脚配置"><a class="markdownIt-Anchor" href="#3引脚配置"></a> 3.引脚配置</h2><p>PS：LP-G3507开发板上用于板载调试的串口与单片机的PA11和PA10连接（跳线帽），配置这两个引脚可以直接通过MicroUSB接口与主机进行串口通信</p><img src="/posts/9383/image-20240718004509861.png" class="" title="image-20240718004509861"><h1 id="库函数使用"><a class="markdownIt-Anchor" href="#库函数使用"></a> 库函数使用</h1><h2 id="1初始化部分"><a class="markdownIt-Anchor" href="#1初始化部分"></a> 1.初始化部分</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NVIC_ClearPendingIRQ(UART_0_INST_INT_IRQN);<span class="comment">//清除串口中断标志位</span></span><br><span class="line">NVIC_EnableIRQ(UART_0_INST_INT_IRQN);<span class="comment">//使能串口中断</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2中断配置"><a class="markdownIt-Anchor" href="#2中断配置"></a> 2.中断配置</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_0_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (DL_UART_Main_getPendingInterrupt(UART_0_INST)) {</span><br><span class="line">        <span class="keyword">case</span> DL_UART_MAIN_IIDX_RX:</span><br><span class="line">            gEchoData = DL_UART_Main_receiveData(UART_0_INST);</span><br><span class="line">            DL_UART_Main_transmitData(UART_0_INST, gEchoData);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sysconfig界面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sysconfig界面&quot;&gt;&lt;/a&gt; Sysconfig界面:&lt;/h1&gt;
&lt;h2 id=&quot;1波特率数据格式的配置&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MSPM0G3507" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MSPM0G3507/"/>
    
    
  </entry>
  
  <entry>
    <title>【电赛】2023-激光跟随系统复盘</title>
    <link href="https://szturin.github.io/posts/38463/"/>
    <id>https://szturin.github.io/posts/38463/</id>
    <published>2024-07-16T17:31:48.000Z</published>
    <updated>2024-09-03T04:19:17.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-图像处理方案"><a class="markdownIt-Anchor" href="#一-图像处理方案"></a> 一、图像处理方案</h1><p>Opencv: 开源计算机视觉处理库，使用嵌入式SOC板卡作为摄像头模块，提供相对可靠的性能。</p><p>由于激光点的亮度远高于其他位置，所以采用HSV格式的色彩空间，对图像H,S,V域进行识别。</p><p>若要区分红绿激光，那么就对图像的RGB空间进行处理</p><h2 id="2-电工胶带的识别"><a class="markdownIt-Anchor" href="#2-电工胶带的识别"></a> 2. 电工胶带的识别</h2><ul><li><p>使用原图像-&gt;灰度图像-&gt;设置阈值后进行二值化的方法，使得黑胶带区域识别为纯白色，其余部分全部为纯黑色区域。关于调参：建议使用创建滑块窗口的方法，进行动态调参，减少调参上浪费的时间。</p></li><li><p>摄像头容易受到外接环境光的干扰，可以通过调节分辨率，设置摄像头的图像获取范围，也有一种更为实用的方法：ROI（感兴趣区），可以通过创建<mark>掩膜</mark>的方式，只对ROI区域进行处理，这样就排除了外界环境的干扰。当然也可以使用切片的方法，定义一个变量用于读取图像的指定范围，然后再进行图像处理，需要显示参数时，再将一些特征点、辅助线、坐标点、数据显示在想要观看的图像上，使用opencv中的imshow进行可视化显示（注意：imshow是非常耗时的操作，在调试时可以使用，在最终运行时建议注释掉，提升程序执行效率，或者采取图像编解码的方法，使用TCP/UDP协议，ROS通信等方式进行远程图传，降低软件资源的使用）</p></li><li><p>ROI区域也不一定是适宜的图像处理区域，也可能有一些噪声信号的干扰，这可能就要需要用到一些滤波处理的算法，如：高斯平滑滤波（高斯模糊）。</p></li><li><p>胶带容易受激光点的影响，导致二值化图像被==“分割”==，所以需要对胶带的二值化图像先膨胀，后进行图形学闭运算缝合胶带二值化图像漏洞</p></li></ul><h2 id="3-串口通信的关键问题"><a class="markdownIt-Anchor" href="#3-串口通信的关键问题"></a> 3. 串口通信的关键问题</h2><ul><li>数据帧：一开始采用字符串发送地方法。结果单片机很容易接收不到一些数据帧</li><li>通信速率：19200</li></ul><h2 id="3-激光巡线的路径规划"><a class="markdownIt-Anchor" href="#3-激光巡线的路径规划"></a> 3. 激光“巡线”的路径规划</h2><ul><li><p>第一种方法：程序不断对图像进行处理，边缘检测，封闭图形检测，然后激光沿着检测出来的图形边沿进行巡线</p></li><li><p>第二种方法：采用“路径规划的方法”，进行一定时间的图像采集后，确定好激光的运行路径，这样，即避免了激光对矩形框识别的强光干扰，又大大减少了程序运行的资源损耗，只需要执行激光跟随部分的程序，不需要再对图像进行边沿检测。</p></li></ul><h1 id="opencv程序部分"><a class="markdownIt-Anchor" href="#opencv程序部分"></a> OpenCV程序部分</h1><h2 id="1-摄像头处理部分"><a class="markdownIt-Anchor" href="#1-摄像头处理部分"></a> 1. 摄像头处理部分</h2><h3 id="11-摄像头的类封装"><a class="markdownIt-Anchor" href="#11-摄像头的类封装"></a> 1.1 摄像头的类封装</h3><p>GuideLine 的作用：绘制辅助线</p><p>思考：Python中函数对形参的调用，会不会影响到实参？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 摄像头类创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pi_Camera</span>():</span><br><span class="line">    <span class="comment"># 类的初始化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 图像初始化配置</span></span><br><span class="line">        self.Video = cv2.VideoCapture(<span class="number">8</span>, cv2.CAP_V4L2)<span class="comment"># 使能摄像头8的驱动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查摄像头是否打开</span></span><br><span class="line">        ret = self.Video.isOpened()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The video is opened."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"No video."</span>)</span><br><span class="line">    </span><br><span class="line">        codec = cv2.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>)   </span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FOURCC, codec)</span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FPS, <span class="number">60</span>)                 <span class="comment"># 帧数</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">640</span>)        <span class="comment"># 列 宽度</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>)       <span class="comment"># 行 高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制辅助线</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GuideLine</span>(<span class="params">self, c1, c2</span>):</span><br><span class="line">        ret, image = self.Video.read()<span class="comment"># 注意：read返回一个bull值和图像数据list！，需要用两个变量获取</span></span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">360</span>), (<span class="number">640</span>, <span class="number">360</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)<span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">240</span>), (<span class="number">640</span>, <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)<span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="built_in">int</span>(c1), <span class="number">360</span>), (<span class="built_in">int</span>(c2), <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">2</span>)<span class="comment"># 绘出倾角线</span></span><br><span class="line">            cv2.imshow(<span class="string">"GuideLine"</span>, image)</span><br></pre></td></tr></tbody></table></figure><h3 id="12-摄像头的图像获取"><a class="markdownIt-Anchor" href="#12-摄像头的图像获取"></a> 1.2 摄像头的图像获取</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret, frame = Watch.Video.read() <span class="comment">#获取摄像头图像数据</span></span><br></pre></td></tr></tbody></table></figure><h3 id="13-相机资源的释放"><a class="markdownIt-Anchor" href="#13-相机资源的释放"></a> 1.3 相机资源的释放</h3><p>思考：Python中不对窗口，或者使用Python语言的硬件资源不释放会怎么样？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Watch.Video.release()</span><br></pre></td></tr></tbody></table></figure><h2 id="2-激光追踪相关"><a class="markdownIt-Anchor" href="#2-激光追踪相关"></a> 2. 激光追踪相关</h2><p>要想实现激光点的巡线，以及红绿激光的相互跟随，首先要做到单个激光点的精确识别与控制移动，这里我们使用了二维舵机云台，精度在能够完成基本要求之内。使用USB 1080P摄像头进行画面捕获。</p><p>激光点在图像中的亮度远远大于其他图像像素点，不难想到在HSV空间中对图像进行操作更容易识别到激光点。</p><h3 id="21-激光点识别的图形预处理"><a class="markdownIt-Anchor" href="#21-激光点识别的图形预处理"></a> 2.1 激光点识别的图形预处理</h3><p>通过调用v2.cvtColor()函数的方法，将图像颜色空间转换到 HSV中，然后通过设定阈值，进行图像的二值化（阈值调节建议采用滑块创建的方法，并且函数需要赋初值）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找激光点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_lasers</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># imgae:用于处理的画布图像，frame：原图像，且是最终数据展示的图像</span></span><br><span class="line">    <span class="keyword">global</span> load_process<span class="comment"># 声明使用外部定义的 load_process</span></span><br><span class="line">    </span><br><span class="line">    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)<span class="comment"># 转换颜色空间为HSV</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义红色激光点hsv色彩阈值范围，用作二值化</span></span><br><span class="line">    lower_laser = np.array([<span class="number">0</span>, <span class="number">100</span>, <span class="number">180</span>])</span><br><span class="line">    upper_laser = np.array([<span class="number">179</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建二值化图像</span></span><br><span class="line">    mask_laser = cv2.inRange(hsv, lower_laser, upper_laser) </span><br><span class="line">    <span class="comment"># cv2.imshow("mask_laser1", mask_laser)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 闭运算</span></span><br><span class="line">    kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">    mask_laser = cv2.morphologyEx(mask_laser, cv2.MORPH_CLOSE, kernel)</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-激光点的轮廓识别"><a class="markdownIt-Anchor" href="#2-2-激光点的轮廓识别"></a> 2. 2 激光点的轮廓识别</h3><p><strong>调用cv2.findContours()函数，对封闭图形进行检测，并且绘制出激光点的图形识别轮廓</strong></p><p>函数解释：</p><ol><li><strong><code>mask_laser</code></strong>：这是输入的二值图像，也就是说，它应该是经过阈值处理或其他形式的图像处理后得到的黑白图像（通常是单通道的，只有 0 和 255 两个像素值）。</li><li><strong><code>cv2.RETR_EXTERNAL</code></strong>：这是轮廓检索模式（Contour Retrieval Mode），指定了轮廓的检索模式。<code>RETR_EXTERNAL</code> 表示只检索最外层的轮廓，忽略内部的轮廓。还有其他的检索模式，比如 <code>RETR_LIST</code>、<code>RETR_TREE</code> 等，可以根据需要选择不同的模式。</li><li><strong><code>cv2.CHAIN_APPROX_SIMPLE</code></strong>：这是轮廓的逼近方法（Contour Approximation Method），指定了轮廓的表示方法。<code>CHAIN_APPROX_SIMPLE</code> 表示压缩水平、垂直和对</li><li>第一个返回值 <code>contours_laser</code> 是一个列表，其中每个元素是一个 numpy 数组，表示一个检测到的轮廓</li></ol><p><strong>cv2.minAreaRect()</strong></p><p>函数解释：</p><ul><li><strong><code>contour</code></strong>：这是一个轮廓，通常是通过 <code>findContours</code> 函数找到的其中一个轮廓对象，它是一个包含轮廓点的 numpy 数组。</li><li><strong><code>cv2.minAreaRect(contour)</code></strong>：这个函数接收一个轮廓作为输入，并返回一个 <code>RotatedRect</code> 对象，它表示包围轮廓的最小旋转矩形框。</li></ul><p>具体来说，返回的 <code>RotatedRect</code> 对象包含以下信息：</p><ul><li><strong><code>center</code></strong>：矩形框的中心点坐标 <code>(cx, cy)</code>。</li><li><strong><code>size</code></strong>：矩形框的宽度和高度 <code>(width, height)</code>。</li><li><strong><code>angle</code></strong>：矩形框相对于水平方向的旋转角度（逆时针为正）</li></ul><p><strong>获取矩形框角点：</strong></p><ol><li><strong><code>box = cv2.boxPoints(rect)</code></strong>：<ul><li><code>cv2.boxPoints</code> 函数接收一个 <code>RotatedRect</code> 对象作为输入，并返回该旋转矩形框的四个顶点坐标。</li><li>这些顶点坐标是浮点型数据，表示为一个包含四个点的 numpy 数组。</li></ul></li><li><strong><code>box = np.int0(box)</code></strong>：<ul><li>这一步将上一步得到的四个顶点坐标 <code>box</code> 转换为整数类型的 numpy 数组。</li><li><code>np.int0()</code> 函数会将浮点数数组四舍五入为最接近的整数，并返回一个整数类型的 numpy 数组。</li></ul></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找轮廓</span></span><br><span class="line">contours_laser, _ = cv2.findContours(mask_laser, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">laser_coords = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours_laser:</span><br><span class="line">    rect = cv2.minAreaRect(contour)<span class="comment"># 获取最小矩形框</span></span><br><span class="line">    laser_coords = <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, rect[<span class="number">0</span>]))<span class="comment"># 矩形框的中心坐标</span></span><br><span class="line">    box = cv2.boxPoints(rect)<span class="comment"># 矩形框的四个角点</span></span><br><span class="line">    box = np.int0(box)</span><br><span class="line">    cv2.drawContours(frame, [box], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)<span class="comment"># 绘制矩形框(原图像中) </span></span><br></pre></td></tr></tbody></table></figure><h3 id="23激光点的颜色区分"><a class="markdownIt-Anchor" href="#23激光点的颜色区分"></a> 2.3激光点的颜色区分</h3><p><strong>imge.shape[]</strong></p><ul><li><strong><code>image.shape</code></strong>：这是一个 numpy 数组属性，用于获取图像的尺寸和通道数信息。</li><li><strong><code>image.shape[:2]</code></strong>：这是对 <code>shape</code> 属性进行切片操作，<code>[:2]</code> 表示取前两个元素，即图像的高度和宽度。</li></ul><p>具体来说，如果 <code>image</code> 是一个图像的 numpy 数组，例如形状为 <code>(height, width, channels)</code>，那么 <code>image.shape[:2]</code> 将返回一个包含图像高度和宽度的元组 <code>(height, width)</code>。</p><p>这种操作通常用于获取图像的空间尺寸信息，以便在处理图像时进行尺寸相关的计算或操作</p><p><strong>方圆坐标确定：</strong></p><ol><li><strong>获取输入坐标：</strong><ul><li><code>x, y = coords</code>：这行代码将变量 <code>coords</code> 解构为 <code>x</code> 和 <code>y</code>，分别表示中心点的横纵坐标。</li></ul></li><li><strong>确定左上角坐标：</strong><ul><li><code>x_start = max(0, x - radius)</code>：计算方形区域的左上角横坐标。<code>x - radius</code> 表示以中心点 <code>x</code> 为基础，向左偏移半径 <code>radius</code> 的距离。<code>max(0, ...)</code> 确保左上角横坐标不会小于 0，即不会超出图像左边界。</li><li><code>y_start = max(0, y - radius)</code>：计算方形区域的左上角纵坐标。同理，<code>y - radius</code> 表示以中心点 <code>y</code> 为基础，向上偏移半径 <code>radius</code> 的距离。<code>max(0, ...)</code> 确保左上角纵坐标不会小于 0，即不会超出图像上边界。</li></ul></li><li><strong>确定右下角坐标：</strong><ul><li><code>x_end = min(width - 1, x + radius)</code>：计算方形区域的右下角横坐标。<code>x + radius</code> 表示以中心点 <code>x</code> 为基础，向右偏移半径 <code>radius</code> 的距离。<code>min(width - 1, ...)</code> 确保右下角横坐标不会超过图像的右边界。</li><li><code>y_end = min(height - 1, y + radius)</code>：计算方形区域的右下角纵坐标。同理，<code>y + radius</code> 表示以中心点 <code>y</code> 为基础，向下偏移半径 <code>radius</code> 的距离。<code>min(height - 1, ...)</code> 确保右下角纵坐标不会超过图像的下边界。</li></ul></li></ol><p><strong>get_pixel_sum</strong></p><p>这段代码用于从给定的区域中提取红色（R）和绿色（G）颜色通道的值。让我来解释一下这段代码的含义：</p><ol><li><strong><code>roi[:, :, 2]</code>：</strong><ul><li><code>roi</code> 应该是图像的一个区域，即感兴趣的区域（Region of Interest，ROI）。</li><li><code>:</code> 是一个表示所有行或所有列的切片操作。</li><li><code>[ : , : , 2]</code> 表示选取所有行的所有列的第三个颜色通道。在 BGR 颜色空间中，第三个通道对应的是红色通道，所以这行代码获取了 ROI 中所有的红色通道值。</li></ul></li><li><strong><code>roi[:, :, 1]</code>：</strong><ul><li>与上面的代码类似，这行代码选取了所有行的所有列的第二个颜色通道。在 BGR 颜色空间中，第二个通道对应的是绿色通道，所以这行代码获取了 ROI 中所有的绿色通道值。</li></ul></li></ol><p>在大多数图像处理库中（如 OpenCV），图像默认是以 BGR 顺序存储的，而不是 RGB。这意味着在获取颜色通道时需要使用 <code>[ : , : , 2]</code> 来获取红色通道，<code>[ : , : , 1]</code> 来获取绿色通道，<code>[ : , : , 0]</code> 来获取蓝色通道。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激光点RGB值获取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pixel_sum</span>(<span class="params">image, coords</span>):</span><br><span class="line">    <span class="comment"># 获取图像宽度和高度</span></span><br><span class="line">    height, width = image.shape[:<span class="number">2</span>]</span><br><span class="line">    radius = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确定方圆的左上角和右下角坐标</span></span><br><span class="line">    x, y = coords</span><br><span class="line">    x_start = <span class="built_in">max</span>(<span class="number">0</span>, x - radius)</span><br><span class="line">    y_start = <span class="built_in">max</span>(<span class="number">0</span>, y - radius)</span><br><span class="line">    x_end = <span class="built_in">min</span>(width - <span class="number">1</span>, x + radius)</span><br><span class="line">    y_end = <span class="built_in">min</span>(height - <span class="number">1</span>, y + radius)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取方圆区域</span></span><br><span class="line">    roi = image[y_start:y_end, x_start:x_end]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算 R 和 G 通道总值</span></span><br><span class="line">    r_channel = roi[:, :, <span class="number">2</span>]</span><br><span class="line">    g_channel = roi[:, :, <span class="number">1</span>]</span><br><span class="line">    r_sum = <span class="built_in">int</span>(r_channel.<span class="built_in">sum</span>())</span><br><span class="line">    g_sum = <span class="built_in">int</span>(g_channel.<span class="built_in">sum</span>())</span><br><span class="line">    <span class="keyword">return</span> r_sum, g_sum</span><br></pre></td></tr></tbody></table></figure><p><strong>cv2.circle(frame, laser_coords, 4, (0, 0, 255), -1)</strong></p><p>绘制实心圆</p><p><strong>cv2.putText()</strong></p><ol><li><strong>参数解释：</strong><ul><li><code>frame</code>：这是目标图像帧，即要在其上添加文本的图像。</li><li><code>"RED"</code>：要写入的文本内容，这里是字符串 “RED”。</li><li><code>(laser_coords[0] - 10, laser_coords[1] - 10)</code>：文本放置的起始位置，由 <code>laser_coords</code> 提供，向左上方偏移了 <code>(10, 10)</code> 的像素值。</li><li><code>cv2.FONT_HERSHEY_SIMPLEX</code>：字体类型，这里使用了简单的字体类型。</li><li><code>0.5</code>：字体大小因子，控制文本大小相对于基础字体的比例。</li><li><code>(0, 0, 255)</code>：文本的颜色，这里是红色，对应 BGR 颜色空间中的 <code>(0, 0, 255)</code>。</li><li><code>2</code>：文本的线宽，即文本轮廓的粗细。</li></ul></li><li><strong>作用说明：</strong><ul><li>这行代码的主要作用是在图像帧的指定位置绘制红色的文本 “RED”。通常用于在图像或视频中标记特定的对象、位置或状态信息。</li></ul></li><li><strong>注意事项：</strong><ul><li>如果 <code>laser_coords</code> 提供的坐标 <code>(x, y)</code> 位于图像的边缘，确保 <code>(x - 10, y - 10)</code> 不会超出图像边界，以避免出现越界错误。</li></ul></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否获取到激光点矩形框的中心坐标，防止读取值为空</span></span><br><span class="line"><span class="keyword">if</span> laser_coords <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 获取激光点的RGB数据</span></span><br><span class="line">    color_vel = get_pixel_sum(image, laser_coords)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在红色激光点中心坐标出绘制圆点图像(原图像中)</span></span><br><span class="line">    cv2.circle(frame, laser_coords, <span class="number">4</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 打印文本数据“RED”在红色激光点上 </span></span><br><span class="line">    cv2.putText(frame ,<span class="string">"RED"</span>, (laser_coords[<span class="number">0</span>] - <span class="number">10</span>, laser_coords[<span class="number">1</span>] - <span class="number">10</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)    </span><br></pre></td></tr></tbody></table></figure><h3 id="24差值计算与串口通信"><a class="markdownIt-Anchor" href="#24差值计算与串口通信"></a> 2.4差值计算与串口通信</h3><p>PS:上位机与下位机通信，建议采用十六进制：帧头+数据类型+数据内容 的单帧数据包格式，这样才能保证下位机能够同步反应上位机发送的特征值，减小通信的复杂度，同时可靠性和速率较高，不建议采用发送字符串类型的通信。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> mode == <span class="string">'A'</span>:</span><br><span class="line">        direction = long_path[load_process]</span><br><span class="line">        <span class="comment"># 获取激光点与图像中心坐标或目标坐标的差值</span></span><br><span class="line">        x_err = laser_coords[<span class="number">0</span>]-direction[<span class="number">0</span>]</span><br><span class="line">        y_err = laser_coords[<span class="number">1</span>]-direction[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">'B'</span>:     </span><br><span class="line">        x_err = laser_coords[<span class="number">0</span>]-center_point_x</span><br><span class="line">        y_err = laser_coords[<span class="number">1</span>]-center_point_y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果激光点到达目标点（误差小于定值），目标点切换到下一个路径点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x_err) &lt;= <span class="number">5</span> <span class="keyword">and</span> <span class="built_in">abs</span>(y_err) &lt;= <span class="number">5</span>:</span><br><span class="line">        load_process-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> load_process == -<span class="number">1</span>:</span><br><span class="line">        load_process=<span class="number">11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 串口发送，数据帧格式:0xFF(帧头),&lt;x轴误差的数据类型&gt;,&lt;y轴误差的数据类型&gt;,&lt;x轴误差大小&gt;,&lt;y轴误差大小&gt;</span></span><br><span class="line">    <span class="keyword">if</span> x_err &lt; <span class="number">0</span>:</span><br><span class="line">        x_data_type = <span class="number">0x2D</span>  <span class="comment"># -x</span></span><br><span class="line">        x_data = <span class="built_in">abs</span>(x_err)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x_data_type = <span class="number">0x2B</span>  <span class="comment"># +x</span></span><br><span class="line">        x_data = x_err</span><br><span class="line">    <span class="keyword">if</span> y_err &lt; <span class="number">0</span>:</span><br><span class="line">        y_data_type = <span class="number">0x3D</span>  <span class="comment"># -y</span></span><br><span class="line">        y_data = <span class="built_in">abs</span>(y_err)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_data_type = <span class="number">0x3B</span>  <span class="comment"># +y</span></span><br><span class="line">        y_data = y_err</span><br><span class="line"></span><br><span class="line">    hex_data = <span class="built_in">bytes</span>([<span class="number">0xFF</span>,x_data_type,y_data_type,x_data, y_data])<span class="comment">#y-</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(hex_data.<span class="built_in">hex</span>())</span><br><span class="line">    ser.write(hex_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print('x:'+ str(x_err))</span></span><br><span class="line">    <span class="comment">#print('y:'+ str(y_err))</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"没找到激光点"</span>)</span><br><span class="line"><span class="keyword">return</span> image</span><br><span class="line"><span class="comment">#cv2.circle(image, (center_x, center_y), 5, (0, 255, 0), -1)</span></span><br><span class="line"><span class="comment">#cv2.imshow("Laser Detection", image)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3胶带矩形框识别"><a class="markdownIt-Anchor" href="#3胶带矩形框识别"></a> 3.胶带矩形框识别</h2><h3 id="31-roi区域的创建"><a class="markdownIt-Anchor" href="#31-roi区域的创建"></a> 3.1 ROI区域的创建</h3><p>PS: 使用ROI区域后，又想还原到原图像上对图像进行处理，就需要对坐标进行还原操作，保证图形每个像素点的索引和原图像对应</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROIPixelProcessor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_roi</span>(<span class="params">self, image, roi</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        取得 ROI 区域的像素值进行处理，但不改变索引号</span></span><br><span class="line"><span class="string">        :param image: 输入图像</span></span><br><span class="line"><span class="string">        :param roi: ROI 参数 (x, y, width, height)</span></span><br><span class="line"><span class="string">        :return: ROI 区域的像素值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x, y, w, h = roi</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确保 ROI 在图像范围内</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            w += x</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> y &lt; <span class="number">0</span>:</span><br><span class="line">            h += y</span><br><span class="line">            y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x + w &gt; image.shape[<span class="number">1</span>]:</span><br><span class="line">            w = image.shape[<span class="number">1</span>] - x</span><br><span class="line">        <span class="keyword">if</span> y + h &gt; image.shape[<span class="number">0</span>]:</span><br><span class="line">            h = image.shape[<span class="number">0</span>] - y</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 提取 ROI 区域的像素值</span></span><br><span class="line">        roi_pixels = image[y:y+h, x:x+w]</span><br><span class="line">        <span class="keyword">return</span> roi_pixels</span><br></pre></td></tr></tbody></table></figure><h3 id="32-图像的预处理"><a class="markdownIt-Anchor" href="#32-图像的预处理"></a> 3.2 图像的预处理</h3><p>通过BGR转灰度，自设定阈值进行二值化地方法，将胶带部分转换为白色单值，其他部分全为黑色单值，并且通过滤波、腐蚀、闭运算地方法对图形进行处理，降低噪点干扰，提高图形识别完整性。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> time.time()-start_time &lt;= <span class="number">5</span>:       </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将图像转换为灰度图</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment">#cv2.imshow('gray',gray)</span></span><br><span class="line"></span><br><span class="line">    gray = cv2.GaussianBlur(gray, (<span class="number">9</span>, <span class="number">9</span>), <span class="number">0</span>) <span class="comment">#高斯平滑滤波,(9,9)是卷积核，0 代表函数自动计算标准差</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#cv2.imshow('gauss',gray)</span></span><br><span class="line">    <span class="comment"># 对灰度图进行阈值处理，将黑色部分变为白色，其他部分变为黑色</span></span><br><span class="line">    _, threshold = cv2.threshold(gray, <span class="number">120</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行形态学闭操作，填充内部空洞</span></span><br><span class="line">    kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">    closing = cv2.morphologyEx(threshold, cv2.MORPH_CLOSE, kernel, iterations=<span class="number">3</span>)       </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行形态学腐蚀操作，缩小黑框大小，减少噪点信号干扰</span></span><br><span class="line">    kernel = np.ones((<span class="number">3</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">    erosion = cv2.erode(closing,kernel,iterations = <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#dilation = cv2.dilate(threshold, kernel, iterations=1) </span></span><br></pre></td></tr></tbody></table></figure><h3 id="33-矩形框轮廓的识别"><a class="markdownIt-Anchor" href="#33-矩形框轮廓的识别"></a> 3.3 矩形框轮廓的识别</h3><p>同样地，使用封闭图形检测算法，检测矩形框轮廓，这里使用 ROI处理，要特别注意像素点索引（坐标）的复原的操作。</p><p>即：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将轮廓绘制在原始图像上</span></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    <span class="comment"># 将轮廓点的坐标映射回原始图像的坐标系</span></span><br><span class="line">    contour += (x, y)  <span class="comment"># 将ROI的偏移加回来</span></span><br></pre></td></tr></tbody></table></figure><p><strong>近似曲线</strong></p><p>注意：这里approx_contour得到的是最终近似矩形的四个角点的坐标！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epsilon = 0.01 * cv2.arcLength(max_contour, True)</span><br><span class="line">approx_contour = cv2.approxPolyDP(max_contour, epsilon, True)</span><br></pre></td></tr></tbody></table></figure><ul><li><code>cv2.arcLength</code> 用于计算轮廓的周长或弧长。</li><li><code>epsilon</code> 是一个近似精度参数，通常是轮廓周长的某个百分比，这里设定为总周长的1%。</li><li><code>cv2.approxPolyDP</code> 用来对轮廓进行多边形逼近，通过减少顶点的数量来近似表示轮廓。</li><li><code>approx_contour</code> 是近似后的多边形轮廓。</li></ul><p><strong>找到左右轮廓的边界点（列表）</strong></p><p>leftmost[0]就是左轮廓第一个点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftmost = min(path, key=lambda x: x[0])  # 左轮廓边界坐标点</span><br><span class="line">rightmost = max(path, key=lambda x: x[0])  # 右轮廓边界坐标点</span><br></pre></td></tr></tbody></table></figure><ul><li><code>path</code> 是一组坐标点的集合，通常表示为一个列表或数组。</li><li><code>min(path, key=lambda x: x[0])</code> 和 <code>max(path, key=lambda x: x[0])</code> 分别用于找到 <code>path</code> 中横坐标 <code>x</code> 最小和最大的点，即左轮廓和右轮廓的边界点。</li></ul><p><strong>参数说明</strong>：</p><ul><li><code>lambda x: x[0]</code> 是一个匿名函数，用于指定以每个点的横坐标 <code>x</code> 作为比较的关键字。因此，<code>min</code> 函数找到具有最小横坐标的点，而 <code>max</code> 函数找到具有最大横坐标的点。</li></ul><p><strong>计算轮廓的中心点</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">center_point_x = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">0</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">center_point_y = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">1</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">center_point = (center_point_x, center_point_y)</span><br></pre></td></tr></tbody></table></figure><ul><li><code>path</code> 是一组轮廓的坐标点集合，通常表示为一个列表或数组。</li><li><code>sum([point[0] for point in path])</code> 对 <code>path</code> 中所有点的横坐标进行求和。</li><li><code>sum([point[1] for point in path])</code> 对 <code>path</code> 中所有点的纵坐标进行求和。</li><li><code>len(path)</code> 是 <code>path</code> 中点的数量，即轮廓的长度或大小。</li></ul><p><strong>参数说明</strong>：</p><ul><li><code>center_point_x</code> 和 <code>center_point_y</code> 分别是计算得到的轮廓中心点的横坐标和纵坐标。</li><li><code>center_point</code> 是由 <code>center_point_x</code> 和 <code>center_point_y</code> 组成的元组，表示轮廓的中心点坐标 <code>(x, y)</code>。</li></ul><p><strong>作用</strong>：</p><ul><li>这段代码的作用是计算轮廓 <code>path</code> 的几何中心点，通过对所有点的坐标进行平均值计算得出</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cv2.imshow('dilation',erosion)</span></span><br><span class="line"></span><br><span class="line">roi = closing[center_y-<span class="number">120</span>:center_y+<span class="number">120</span>, center_x-<span class="number">120</span>:center_x+<span class="number">120</span>]<span class="comment">#创建ROI图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow('roi',roi)</span></span><br><span class="line">x,y,w,h = center_x-<span class="number">120</span>,center_y-<span class="number">120</span>,<span class="number">240</span>,<span class="number">240</span> <span class="comment">#ROI左上角点为220,140，ROI检测框高度为200，宽度为200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制ROI矩形</span></span><br><span class="line">cv2.rectangle(frame,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow('erosion',erosion)</span></span><br><span class="line"><span class="comment"># 利用轮廓检测函数找到黑色框的轮廓</span></span><br><span class="line">contours, hierarchy = cv2.findContours(roi, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"><span class="comment"># 轮廓      层级                               轮廓检索模式  轮廓逼近方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将轮廓绘制在原始图像上</span></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    <span class="comment"># 将轮廓点的坐标映射回原始图像的坐标系</span></span><br><span class="line">    contour += (x, y)  <span class="comment"># 将ROI的偏移加回来</span></span><br><span class="line">    <span class="comment">#cv2.drawContours(frame, [contour], -1, (0, 0, 255), 2) 原始轮廓，这里用近似法得到更平滑的外围轮廓</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果找到了轮廓</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(contours) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 提取最大的轮廓</span></span><br><span class="line">    max_contour = <span class="built_in">max</span>(contours, key=cv2.contourArea)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 近似曲线</span></span><br><span class="line">    epsilon = <span class="number">0.01</span> * cv2.arcLength(max_contour, <span class="literal">True</span>)</span><br><span class="line">    approx_contour = cv2.approxPolyDP(max_contour, epsilon, <span class="literal">True</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 获取路径坐标</span></span><br><span class="line">    path = []</span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> approx_contour:</span><br><span class="line">        path.append(<span class="built_in">tuple</span>(point[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到左右轮廓的边界点</span></span><br><span class="line">    leftmost = <span class="built_in">min</span>(path, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])<span class="comment"># 左轮廓边界坐标点</span></span><br><span class="line">    rightmost = <span class="built_in">max</span>(path, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])<span class="comment"># 右轮廓边界坐标点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算左右轮廓的中间点</span></span><br><span class="line">    middle_x = <span class="built_in">int</span>((leftmost[<span class="number">0</span>] + rightmost[<span class="number">0</span>]) / <span class="number">2</span>)<span class="comment"># x中心坐标</span></span><br><span class="line">    middle_y = <span class="built_in">int</span>((leftmost[<span class="number">1</span>] + rightmost[<span class="number">1</span>]) / <span class="number">2</span>)<span class="comment"># y中心坐标</span></span><br><span class="line">    middle_point = (middle_x, middle_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制左右轮廓中心点                 </span></span><br><span class="line">    <span class="comment">#cv2.circle(frame, middle_point, 5, (0, 255, 0), -1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算轮廓的中心点</span></span><br><span class="line">    center_point_x = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">0</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">    center_point_y = <span class="built_in">int</span>(<span class="built_in">sum</span>([point[<span class="number">1</span>] <span class="keyword">for</span> point <span class="keyword">in</span> path]) / <span class="built_in">len</span>(path))</span><br><span class="line">    center_point = (center_point_x, center_point_y)            </span><br><span class="line"></span><br><span class="line">    cv2.drawContours(frame, [np.array(path)], -<span class="number">1</span>, (<span class="number">125</span>, <span class="number">255</span>, <span class="number">125</span>), <span class="number">1</span>) <span class="comment">#近似后的轮廓</span></span><br><span class="line">    <span class="comment">#                           轮廓     第几个(默认-1：所有)   颜色       线条厚度       </span></span><br><span class="line">    <span class="comment"># 绘制轮廓中心点</span></span><br><span class="line">    cv2.circle(frame, center_point, <span class="number">3</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)        </span><br><span class="line"></span><br><span class="line">    resize = <span class="number">0.92</span></span><br><span class="line"></span><br><span class="line">    resize_path = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> path:</span><br><span class="line">        resize_x =  <span class="built_in">int</span>(center_point_x + resize*(point[<span class="number">0</span>]-center_point_x))</span><br><span class="line">        resize_y =  <span class="built_in">int</span>(center_point_y + resize*(point[<span class="number">1</span>]-center_point_y))</span><br><span class="line">        resize_path.append((resize_x,resize_y))</span><br><span class="line"></span><br><span class="line">    cv2.drawContours(frame, [np.array(resize_path)], -<span class="number">1</span>, (<span class="number">125</span>, <span class="number">255</span>, <span class="number">125</span>), <span class="number">1</span>) <span class="comment"># 内缩后的轮廓</span></span><br><span class="line">    long_path = interpolate_points(resize_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> long_path:</span><br><span class="line">        cv2.circle(frame, point, <span class="number">4</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="3-4-矩形框的路径规划-插值算法"><a class="markdownIt-Anchor" href="#3-4-矩形框的路径规划-插值算法"></a> 3-4 矩形框的路径规划-插值算法</h3><p>如果让激光点沿着轮廓一个一个坐标点去走，这样计算量会相当大，不如将矩形轮廓通过近似得到四个角点，再通过插值法，设置相邻点的插值参数，得到12个路径点，这样就既保证了巡线的稳定性，也大大减少了巡线的计算量。同时，通过调用time库来计时，程序启动时定时5s后，这段时间提供给我们确认摄像机状态，移动ROI区域，完成路径规划，实现“动态建图”的效果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#插值算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">interpolate_points</span>(<span class="params">points</span>):</span><br><span class="line">    interpolated_points = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">        start_point = points[i]</span><br><span class="line">        end_point = points[(i+<span class="number">1</span>) % <span class="built_in">len</span>(points)]</span><br><span class="line">        <span class="comment"># 计算两点之间的距离</span></span><br><span class="line">        dx = end_point[<span class="number">0</span>] - start_point[<span class="number">0</span>]</span><br><span class="line">        dy = end_point[<span class="number">1</span>] - start_point[<span class="number">1</span>]</span><br><span class="line">        distance = <span class="number">3</span></span><br><span class="line">        <span class="comment"># 根据距离进行插值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(distance):</span><br><span class="line">            x = start_point[<span class="number">0</span>] + <span class="built_in">int</span>(dx * j / distance)</span><br><span class="line">            y = start_point[<span class="number">1</span>] + <span class="built_in">int</span>(dy * j / distance)</span><br><span class="line">            interpolated_points.append((x, y))</span><br><span class="line">    <span class="keyword">return</span> interpolated_points</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-图像处理方案&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-图像处理方案&quot;&gt;&lt;/a&gt; 一、图像处理方案&lt;/h1&gt;
&lt;p&gt;Opencv: 开源计算机视觉处理库，使用嵌入式SOC板卡作为摄像头模块，提供相对可靠的性能。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="RDK X3" scheme="https://szturin.github.io/categories/RDK-X3/"/>
    
    <category term="OpenCV" scheme="https://szturin.github.io/categories/OpenCV/"/>
    
    
    <category term="电赛" scheme="https://szturin.github.io/tags/%E7%94%B5%E8%B5%9B/"/>
    
    <category term="OpenCV" scheme="https://szturin.github.io/tags/OpenCV/"/>
    
    <category term="激光追踪" scheme="https://szturin.github.io/tags/%E6%BF%80%E5%85%89%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【TI】-1-Sysconfig工具使用（GPIO、定时器为例）</title>
    <link href="https://szturin.github.io/posts/35334/"/>
    <id>https://szturin.github.io/posts/35334/</id>
    <published>2024-07-15T11:24:42.000Z</published>
    <updated>2024-09-03T04:33:38.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-编译器ccs-theia的基本使用"><a class="markdownIt-Anchor" href="#一-编译器ccs-theia的基本使用"></a> 一、编译器CCS Theia的基本使用</h1><p>​本文主要介绍通过CCS Theia以及Sysconfig的基本使用方法，将以GPIO和定时器为例，泛化性地介绍CCS Theia这个工具，便于其他外设配置的理解，对于CCS Theia IDE的安装及其环境配置，不做多赘述。</p><h2 id="1-范例程序的导入"><a class="markdownIt-Anchor" href="#1-范例程序的导入"></a> 1.  范例程序的导入</h2><blockquote><p>步骤：</p><ol><li><p>选择File -&gt; import Project(s)</p></li><li><p>选择SDK中官方示例的地址，本文安装路径为：S:\ti\mspm0_sdk_2_01_00_03\examples\nortos\LP_MSPM0G3507\driverlib</p><img src="/posts/35334/image-20240806015913088.png" class="" title="image-20240806015913088"><ul><li>gcc：代表C++方式编程的工程格式</li><li>ticlang：代表TI官方IDE的工程格式</li></ul></li></ol></blockquote><h2 id="2-sysconfig界面"><a class="markdownIt-Anchor" href="#2-sysconfig界面"></a> 2.  Sysconfig界面</h2><p>​Sysconfig界面是TI推出的图形化界面配置，类似于ST 的CubeMX，能够极大简化对于单片机外设的初始化配置，更容易上手，但是这也需要我们正确小心地去使用这个工具，错误的配置很容易导致单片机无法正常工作。</p><p>​一般的，在我们使用CCS Theia配置工程时，CCS<mark>成功加载</mark>工程文件后会显示一些特殊图标（偶尔会加载不成功，这个时候工程是无效的使用状态，需要重启软件），其中，主程序（如 main.c）同级目录下会生成一个后缀名为.syscfg的文件，这个文件用于存放TI M0系列图形化配置，点击main.syscfg即可打开图形化配置界面，本文着重介绍外设配置界面。</p><img src="/posts/35334/image-20240806020630210.png" class="" title="image-20240806020630210"><h1 id="二-gpio口的基本配置"><a class="markdownIt-Anchor" href="#二-gpio口的基本配置"></a> 二、GPIO口的基本配置</h1><img src="/posts/35334/image-20240806021554207.png" class="" title="image-20240806021554207"><h2 id="1-gpio输出模式"><a class="markdownIt-Anchor" href="#1-gpio输出模式"></a> 1. GPIO输出模式</h2><p>简单配置Direction(方向)为Output即可</p><img src="/posts/35334/image-20240806021652604.png" class="" title="image-20240806021652604"><p><strong>GPIO引脚置高电平</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DL_GPIO_setPins(GPIO_MOTOR_PIN_FR1_PORT, GPIO_MOTOR_PIN_FR1_PIN); <span class="comment">//将FR1置高</span></span><br></pre></td></tr></tbody></table></figure><p><strong>GPIO引脚清空</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DL_GPIO_clearPins(GPIO_MOTOR_PIN_FR2_PORT, GPIO_MOTOR_PIN_FR2_PIN);<span class="comment">//将FR2置低</span></span><br></pre></td></tr></tbody></table></figure><p>注意：PORT和PIN的区别</p><ul><li><strong>PORT</strong>更侧重于表示一种逻辑或物理接口的集合，而<strong>PIN</strong>则是指具体的电气连接点。在微控制器中，端口通常由多个引脚组成，而引脚是最基本的物理连接单位。</li></ul><h2 id="2-gpio输入模式"><a class="markdownIt-Anchor" href="#2-gpio输入模式"></a> 2. GPIO输入模式</h2><h3 id="21-读取引脚值"><a class="markdownIt-Anchor" href="#21-读取引脚值"></a> 2.1 读取引脚值</h3><p><strong>GPIO读取引脚状态</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DL_GPIO_readPins(GPIO_TRACE_PORT,GPIO_TRACE_PIN_TRACE_0_PIN);<span class="comment">//读取TRACE0的电平（可能是n位返回值）</span></span><br></pre></td></tr></tbody></table></figure><p>注意：</p><p>​使用此函数读取的GPIO引脚状态为多个引脚的组合，需要经过逻辑操作来单独取一位。</p><h3 id="22-按键"><a class="markdownIt-Anchor" href="#22-按键"></a> 2.2 按键</h3><p>注意：特别地，如果要配置外部按键控制单片机，对应的引脚不能是浮空输入的状态，必须有具体的TTL电平状态，可以在Digtial IOMUX Features配置Internal Resistor选项为上拉输入，其他的默认配置即可。</p><p><img src="C:%5CUsers%5C123%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240811011437475.png" alt="image-20240811011437475"></p><h3 id="23-外部中断"><a class="markdownIt-Anchor" href="#23-外部中断"></a> 2.3. 外部中断</h3><p>外部中断一般用于特定的事件检测，计数（如：里程），配合定时器测电机速度等，图示为<strong>双边沿触发的外部中断</strong>，并且中断优先级配置为1</p><img src="/posts/35334/image-20240811012509997.png" class="" title="image-20240811012509997"><h1 id="三-定时器的基本配置"><a class="markdownIt-Anchor" href="#三-定时器的基本配置"></a> 三、定时器的基本配置</h1><h2 id="1-定时器频率设置"><a class="markdownIt-Anchor" href="#1-定时器频率设置"></a> 1.  定时器频率设置</h2><blockquote><ul><li>Timer Clock Source: 时钟源选择，一般为BUSCLK</li><li>Timer Clock Divider:前分频</li><li>Timer Clock Prescaler:后分频</li></ul><p>定时器的频率/单位周期会在sysconfig中自动计算好</p></blockquote><img src="/posts/35334/image-20240715192616803.png" class="" title="image-20240715192616803"><p>注意：</p><ul><li>定时器的计数精度有限，具体由设置决定</li></ul><h2 id="3-定时器计数模式"><a class="markdownIt-Anchor" href="#3-定时器计数模式"></a> 3. 定时器计数模式</h2><img src="/posts/35334/image-20240811012753418.png" class="" title="image-20240811012753418"><h2 id="4-advanced-configuration高级功能设置"><a class="markdownIt-Anchor" href="#4-advanced-configuration高级功能设置"></a> 4. Advanced Configuration：高级功能设置</h2><h2 id="5-中断配置"><a class="markdownIt-Anchor" href="#5-中断配置"></a> 5. 中断配置</h2><blockquote><ul><li>如图，计数到零触发中断</li><li>interrupt Priority：中断优先级</li></ul></blockquote><img src="/posts/35334/image-20240715193539699.png" class="" title="image-20240715193539699"><h3 id="51-中断事件使能"><a class="markdownIt-Anchor" href="#51-中断事件使能"></a> 5.1 <strong>中断事件使能：</strong></h3><p>与一般单片机不同，G3507配置中断后，程序中需要加上对中断事件类型的判断。</p><img src="/posts/35334/image-20240715194038332.png" class="" title="image-20240715194038332"><p><strong>定时器中断代码部分：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIMER_0_INST_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (DL_TimerG_getPendingInterrupt(TIMER_0_INST)) {</span><br><span class="line">        <span class="keyword">case</span> DL_TIMER_IIDX_ZERO:</span><br><span class="line">            DL_GPIO_togglePins(GPIO_LEDS_PORT,</span><br><span class="line">                GPIO_LEDS_USER_LED_1_PIN | GPIO_LEDS_USER_TEST_PIN);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-定时器设备选择"><a class="markdownIt-Anchor" href="#6-定时器设备选择"></a> 6. 定时器设备选择</h2><img src="/posts/35334/image-20240715193738345.png" class="" title="image-20240715193738345"><h1 id="m0系列的低功耗工艺"><a class="markdownIt-Anchor" href="#m0系列的低功耗工艺"></a> #M0系列的低功耗工艺</h1><img src="/posts/35334/image-20240715194311900.png" class="" title="image-20240715194311900"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DL_SYSCTL_enableSleepOnExit();<span class="comment">//使能：当从中断返回到主函数中，单片机工作状态从RUN切换到SLEEP状态</span></span><br><span class="line"><span class="comment">// __WFI();</span></span><br></pre></td></tr></tbody></table></figure><h1 id="四-定时器pwm配置"><a class="markdownIt-Anchor" href="#四-定时器pwm配置"></a> 四、定时器PWM配置</h1><h2 id="1-pwm工作模式"><a class="markdownIt-Anchor" href="#1-pwm工作模式"></a> 1. PWM工作模式</h2><ul><li>Edge-aligned:边沿对齐</li><li>Center-aligned:中心对齐</li></ul><img src="/posts/35334/image-20240715214605017.png" class="" title="image-20240715214605017"><p>PS：</p><ul><li>定时器0可以生成四路PWM</li></ul><h2 id="2-pwm的频率设置"><a class="markdownIt-Anchor" href="#2-pwm的频率设置"></a> 2. PWM的频率设置</h2><img src="/posts/35334/image-20240715215253775.png" class="" title="image-20240715215253775"><h2 id="3-pwm占空比设置"><a class="markdownIt-Anchor" href="#3-pwm占空比设置"></a> 3. PWM占空比设置</h2><p>注意：</p><ul><li>Compare Value = PWM Period Count  * (1-Duty Cycle)</li><li>xxxxxxxxxx&nbsp;python script_name.py --train_data_dir “path/to/train_data” --test_data_dir “path/to/test_data” --img_height 128 --img_width 128 --batch_size 64 --epochs 15python</li></ul><img src="/posts/35334/image-20240715215418979.png" class="" title="image-20240715215418979"><h2 id="4-pwm输出引脚设置"><a class="markdownIt-Anchor" href="#4-pwm输出引脚设置"></a> 4. PWM输出引脚设置</h2><p>注意：</p><ul><li>PWM四个引脚输出可以复用PWM通道</li></ul><img src="/posts/35334/image-20240715215919260.png" class="" title="image-20240715215919260">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-编译器ccs-theia的基本使用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-编译器ccs-theia的基本使用&quot;&gt;&lt;/a&gt; 一、编译器CCS Theia的基本使用&lt;/h1&gt;
&lt;p&gt;​	本文主要介绍通过CCS Theia以及</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MSPM0G3507" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MSPM0G3507/"/>
    
    
  </entry>
  
  <entry>
    <title>【yolov5】[1]初探目标检测算法--YOLOv5的训练及在地平线RDK X3上的快速部署</title>
    <link href="https://szturin.github.io/posts/31493/"/>
    <id>https://szturin.github.io/posts/31493/</id>
    <published>2024-07-11T04:12:30.000Z</published>
    <updated>2024-09-04T11:13:25.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-windows环境下的模型训练"><a class="markdownIt-Anchor" href="#一-windows环境下的模型训练"></a> 一、Windows环境下的模型训练</h1><p>针对YOLO的模型训练环境配置，Windows端兼容性差于Ubuntu，如果电脑上有Ubuntu系统，建议用Ubuntu系统进行训练（但注意，虚拟机安装的Ubuntu系统无法使用物理GPU进行训练）。</p><p><strong><mark>YOLO版本：YOLOV5 7.0</mark></strong></p><h2 id="xxxxxxxxxx-tags-数字电路与vhdl设计bash"><a class="markdownIt-Anchor" href="#xxxxxxxxxx-tags-数字电路与vhdl设计bash"></a> xxxxxxxxxx&nbsp;$ tags: -数字电路与VHDL设计"bash</h2><p>准备好目标模型对应的图片数据集，使用labelme命令，启动数据集打标工具</p><h2 id="2-模型的训练和导出onnx"><a class="markdownIt-Anchor" href="#2-模型的训练和导出onnx"></a> 2. 模型的训练和导出ONNX</h2><h3 id="21-环境配置"><a class="markdownIt-Anchor" href="#21-环境配置"></a> 2.1 环境配置</h3><blockquote><p>Anoconda可以区分不同的环境，不同的环境下可以使用的命令是不同的</p><p>创建环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n yolov5_7<span class="number">.0</span> python==<span class="number">3.8</span><span class="number">.5</span></span><br></pre></td></tr></tbody></table></figure><p>列举所有环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env <span class="built_in">list</span></span><br></pre></td></tr></tbody></table></figure><p>删除’环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env remove --name &lt;env_name&gt;</span><br></pre></td></tr></tbody></table></figure><p>激活环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate &lt;env_name&gt;</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p>如配置好yolo的环境，安装好pytorch，cuda，yolo相关依赖，就需要使用conda activate yolov5_7.0激活</p></blockquote><h4 id="211-常见问题"><a class="markdownIt-Anchor" href="#211-常见问题"></a> 2.1.1 <mark>常见问题：</mark></h4><p>Anoconda环境下无法识别到CUDA</p><p><strong>参考文章</strong>：<a href="https://blog.csdn.net/qq_71547093/article/details/133581922">print(torch.cuda.is_available())是false_pip install torch==2.0.1+cu117-CSDN博客</a></p><img src="/posts/31493/0248d8bfdc09cf576bce9846dbea681e.png" class="" title="img"><p><strong>问题原因</strong>：</p><p>所使用的环境是anaconda pytorch。</p><p>使用GPU来加速某个项目，但是GPU不能用，原因是没有安装GPU版本的torch和torchvision</p><p><strong>解决方法</strong>：</p><p>使用pip安装GPU版本的支持CUDA 11.7的torch和torchvision，并且版本分别为torch<mark>2.0.1和torchvision</mark>0.15.2。具体可以根据需要的版本进行修改。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==<span class="number">2.0</span><span class="number">.1</span>+cu117 torchvision==<span class="number">0.15</span><span class="number">.2</span>+cu117 -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></tbody></table></figure><p>安装完成之后，检查是否可以正常使用。</p><p><strong><mark>如果在线安装速度过慢，可以尝试进入网页的方法：</mark></strong></p><p>手动下载 <code>.whl</code> 文件并离线安装。</p><ol><li><p><strong>下载 <code>.whl</code> 文件</strong>：<br>访问 <a href="https://download.pytorch.org/whl/torch_stable.html">PyTorch 官网</a> 或使用下面的链接手动下载相应的 <code>.whl</code> 文件：</p><ul><li><a href="https://download.pytorch.org/whl/cu117/torch-2.0.1%2Bcu117-cp38-cp38-win_amd64.whl">torch-2.0.1+cu117</a></li><li><a href="https://download.pytorch.org/whl/cu117/torchvision-0.15.2%2Bcu117-cp38-cp38-win_amd64.whl">torchvision-0.15.2+cu117</a></li></ul></li><li><p><strong>离线安装</strong>：<br>下载完成后，使用 <code>pip</code> 离线安装：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install path/to/torch-<span class="number">2.0</span><span class="number">.1</span>+cu117-cp38-cp38-win_amd64.whl</span><br><span class="line">pip install path/to/torchvision-<span class="number">0.15</span><span class="number">.2</span>+cu117-cp38-cp38-win_amd64.whl</span><br></pre></td></tr></tbody></table></figure></li></ol><p>输入python，回车，然后输入：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="23-训练过程源码修改板端设备-rdk-x3"><a class="markdownIt-Anchor" href="#23-训练过程源码修改板端设备-rdk-x3"></a> 2.3 <strong>训练过程源码修改(板端设备 RDK X3)</strong></h3><p>修改YOLO源码的内容，使用GPU进行快速训练</p><p><strong>参考文章：</strong><a href="https://developer.horizon.cc/forumDetail/177840589839214598">YOLOv5较新版本的部署方法 (horizon.cc)</a></p><p>主目录下 <a href="http://export.py">export.py</a> 约1351行附近，标注两处不做注释</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shape = <span class="built_in">tuple</span>((y[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">isinstance</span>(y, <span class="built_in">tuple</span>) <span class="keyword">else</span> y).shape)  <span class="comment"># model output shape#转换时注释</span></span><br><span class="line">metadata = {<span class="string">"stride"</span>: <span class="built_in">int</span>(<span class="built_in">max</span>(model.stride)), <span class="string">"names"</span>: model.names}  <span class="comment"># model metadata###</span></span><br><span class="line">LOGGER.info(<span class="string">f"\n<span class="subst">{colorstr(<span class="string">'PyTorch:'</span>)}</span> starting from <span class="subst">{file}</span> with output shape <span class="subst">{shape}</span> (<span class="subst">{file_size(file):<span class="number">.1</span>f}</span> MB)"</span>)<span class="comment">#转换时注释</span></span><br></pre></td></tr></tbody></table></figure><p>model/yolo.py 约91行处</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    <span class="string">"""Processes input through YOLOv5 layers, altering shape for detection: `x(bs, 3, ny, nx, 85)`."""</span></span><br><span class="line">    z = []  <span class="comment"># inference output</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.nl):</span><br><span class="line">        x[i] = self.m[i](x[i])  <span class="comment"># conv###</span></span><br><span class="line">        bs, _, ny, nx = x[i].shape  <span class="comment"># x(bs,255,20,20) to x(bs,3,20,20,85)###</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">### ###</span></span><br><span class="line">        <span class="comment">#转换成注释，训练时启用</span></span><br><span class="line">        x[i] = x[i].view(bs, self.na, self.no, ny, nx).permute(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>).contiguous()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.training:  <span class="comment"># inference</span></span><br><span class="line">            <span class="keyword">if</span> self.dynamic <span class="keyword">or</span> self.grid[i].shape[<span class="number">2</span>:<span class="number">4</span>] != x[i].shape[<span class="number">2</span>:<span class="number">4</span>]:</span><br><span class="line">                self.grid[i], self.anchor_grid[i] = self._make_grid(nx, ny, i)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(self, Segment):  <span class="comment"># (boxes + masks)</span></span><br><span class="line">                xy, wh, conf, mask = x[i].split((<span class="number">2</span>, <span class="number">2</span>, self.nc + <span class="number">1</span>, self.no - self.nc - <span class="number">5</span>), <span class="number">4</span>)</span><br><span class="line">                xy = (xy.sigmoid() * <span class="number">2</span> + self.grid[i]) * self.stride[i]  <span class="comment"># xy</span></span><br><span class="line">                wh = (wh.sigmoid() * <span class="number">2</span>) ** <span class="number">2</span> * self.anchor_grid[i]  <span class="comment"># wh</span></span><br><span class="line">                y = torch.cat((xy, wh, conf.sigmoid(), mask), <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># Detect (boxes only)</span></span><br><span class="line">                xy, wh, conf = x[i].sigmoid().split((<span class="number">2</span>, <span class="number">2</span>, self.nc + <span class="number">1</span>), <span class="number">4</span>)</span><br><span class="line">                xy = (xy * <span class="number">2</span> + self.grid[i]) * self.stride[i]  <span class="comment"># xy</span></span><br><span class="line">                wh = (wh * <span class="number">2</span>) ** <span class="number">2</span> * self.anchor_grid[i]  <span class="comment"># wh</span></span><br><span class="line">                y = torch.cat((xy, wh, conf), <span class="number">4</span>)</span><br><span class="line">            z.append(y.view(bs, self.na * nx * ny, self.no))</span><br><span class="line">    <span class="keyword">return</span> x <span class="keyword">if</span> self.training <span class="keyword">else</span> (torch.cat(z, <span class="number">1</span>),) <span class="keyword">if</span> self.export <span class="keyword">else</span> (torch.cat(z, <span class="number">1</span>), x)</span><br><span class="line"><span class="comment">### ###</span></span><br><span class="line">        <span class="comment"># x[i] = x[i].permute(0, 2, 3, 1).contiguous()#转换时启用,训练时注释</span></span><br><span class="line">    <span class="comment"># return x#转换时启用</span></span><br></pre></td></tr></tbody></table></figure><h3 id="21-模型的训练"><a class="markdownIt-Anchor" href="#21-模型的训练"></a> 2.1 模型的训练</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --data face_data.yaml --cfg face_yolo5s.yaml --weights pretrained/yolov5s.pt --batch-size <span class="number">16</span> --epochs <span class="number">300</span>  --imgsz <span class="number">672</span> --device <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><ul><li>face_data.yaml：指定数据集的配置文件为 <code>face_data.yaml</code>，这个文件包含了训练和验证数据集的路径、类别数以及类别名称等信息</li><li>face_yolo5s.yaml：指定 YOLOv5 模型的配置文件为 <code>face_yolo5s.yaml</code>，这个文件定义了模型的结构和各项超参数</li><li>weights：指定预训练权重文件的路径为 <code>pretrained/yolov5s.pt</code>，这些权重将用于初始化模型的参数，以加速训练收敛</li><li>batch-size：设置训练时的批量大小为 4，这表示每次迭代中使用的样本数为 4，影响训练速度和模型训练过程</li><li>device：指定训练时使用的设备，这里的 <code>0</code> 表示使用 GPU 0。如果你有多个 GPU，可以根据需要更改这个数字；如果你想使用 CPU，可以将其设置为 <code>cpu</code></li><li>epochs：训练轮数</li><li>imgsz：模型大小（本例 输入输出为 672 x672）</li><li>deviece：选择设备号，0一般指向GPU（需要安装对应版本的CUDA和cudnn）</li></ul><h2 id="22-模型的onnx格式导出"><a class="markdownIt-Anchor" href="#22-模型的onnx格式导出"></a> 2.2 模型的ONNX格式导出</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python export.py --weights runs/train/exp/weights/best.pt --include onnx engine --img-size <span class="number">672</span> --batch-size <span class="number">1</span> --device <span class="number">0</span> </span><br></pre></td></tr></tbody></table></figure><ul><li>–weights：此段命令指向训练好的pt模型目录</li><li>include：目标格式</li></ul><h2 id="3-模型的windows端验证"><a class="markdownIt-Anchor" href="#3-模型的windows端验证"></a> 3. 模型的Windows端验证</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测摄像头</span></span><br><span class="line">python detect.py  --weights runs/train/exp_yolov5s/weights/best.pt --source <span class="number">0</span>  <span class="comment"># webcam</span></span><br><span class="line"><span class="comment"># 检测图片文件</span></span><br><span class="line"> python detect.py  --weights runs/train/exp_yolov5s/weights/best.pt --source file.jpg  <span class="comment"># image </span></span><br><span class="line"><span class="comment"># 检测视频文件</span></span><br><span class="line">  python detect.py --weights runs/train/exp_yolov5s/weights/best.pt --source file.mp4  <span class="comment"># video</span></span><br><span class="line"><span class="comment"># 检测一个目录下的文件</span></span><br><span class="line"> python detect.py --weights runs/train/exp_yolov5s/weights/best.pt path/  <span class="comment"># directory</span></span><br><span class="line"><span class="comment"># 检测网络视频</span></span><br><span class="line"> python detect.py --weights runs/train/exp_yolov5s/weights/best.pt <span class="string">'https://youtu.be/NUsoVlDFqZg'</span>  <span class="comment"># YouTube video</span></span><br><span class="line"><span class="comment"># 检测流媒体</span></span><br><span class="line"> python detect.py --weights runs/train/exp_yolov5s/weights/best.pt <span class="string">'rtsp://example.com/media.mp4'</span>  <span class="comment"># RTSP, RTMP, HTTP stream                            </span></span><br></pre></td></tr></tbody></table></figure><h1 id="二-模型部署"><a class="markdownIt-Anchor" href="#二-模型部署"></a> 二、模型部署</h1><h2 id="1-模型的工具链环境ubuntuonnx转化bin格式"><a class="markdownIt-Anchor" href="#1-模型的工具链环境ubuntuonnx转化bin格式"></a> 1. 模型的工具链环境(Ubuntu)——onnx转化bin格式</h2><p><strong>参考文章：<a href="https://developer.horizon.cc/forumDetail/163807123501918330">【模型提速】如何在X3pi使用yolov5模型50ms推理 (horizon.cc)</a></strong></p><hr><p><strong>文件结构</strong>：</p><p><code>hb_mapper_makertbin.log</code>是工具链自动生成的日志文件<br><code>imgs_train</code>存放训练集中的原图片<br><code>imgs_cal</code>存放转化模型需要的图片校准数据<br><code>tran.py</code>用于将原训练集图片转化成校准数据<br><code>medels_onnx</code>存放转化前的onnx模型<br><code>models_onnx</code>存放转化后的bin文件<br><code>tran.yaml</code>是转化所需的文本</p><hr><p><strong>模型验证</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hb_mapper checker --model-<span class="built_in">type</span> onnx --march bernoulli2 --model models_onnx/my_face.onnx --<span class="built_in">input</span>-shape images 1x3x672x672</span><br></pre></td></tr></tbody></table></figure><p>注意：–input-shape 需要跟之前的模型尺寸参数对应</p><p>验证执行之后，在命令行界面可以看到算子是否在CPU/BPU上支持运行</p><p><strong>板载模型转化</strong></p><p>转化之前，yaml文件中要注意修改对应标注的参数</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hb_mapper makertbin --config yaml文件的位置 --model-<span class="built_in">type</span> onnx</span><br></pre></td></tr></tbody></table></figure><p>执行命令之后，可以在model_output文件夹中找到对应的bin文件</p><p><strong>模型性能分析(开发机评测性能)</strong></p><p>使用 <code>hb_perf</code> 工具评测模型性能，使用方式如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hb_perf  ***.bin</span><br></pre></td></tr></tbody></table></figure><h2 id="2-板端rdk-x3部署"><a class="markdownIt-Anchor" href="#2-板端rdk-x3部署"></a> 2. 板端（RDK X3）部署</h2><p>将转换完成的bin文件，复制到板端对应目录即可</p><p><strong>RDK X3 板端模型运行过程：</strong></p><ul><li><p>模型预处理：CPU</p></li><li><p>模型推理：BPU 与 CPU 并行</p></li><li><p>模型后处理：CPU</p></li></ul><h3 id="21-后处理函数部分"><a class="markdownIt-Anchor" href="#21-后处理函数部分"></a> 2.1 后处理函数部分</h3><h4 id="211-python版本"><a class="markdownIt-Anchor" href="#211-python版本"></a> 2.1.1 Python版本</h4><blockquote><p>后处理函数中类别数目，类名都要跟模型一一对应</p><ul><li><code>postprocess.py</code>，把<code>num_classes</code>改成自己模型的class数量</li><li><code>def get_classes(class_file_name='dominoes.names')</code>，改成存放标签的名词</li></ul></blockquote><p><strong>后处理函数中数据处理模块需要根据模型的分辨率，类别数目进行修改。如若参数不对应，使用后处理函数时会报错</strong></p><p><a href="https://developer.horizon.cc/forumDetail/198686198578007656">YOLOV5 在地平线RDK X3的高效部署 (horizon.cc)</a></p><img src="/posts/31493/605ba25c7844d1c31120f0361c46893.png" class="" title="605ba25c7844d1c31120f0361c46893"><h4 id="212-c版本"><a class="markdownIt-Anchor" href="#212-c版本"></a> 2.1.2 C++版本</h4><p>由于Python是解释型语言，运行后处理这类计算量较大的操作非常耗时，用C++的方法编写代码速度快得多。</p><p>一种解决方案是，使用Cython加速后处理部分，用Cython的方法封装C++为Python的接口。能够极大提升模型性能。</p><p><strong>参考文章：</strong>[<a href="https://developer.d-robotics.cc/forumDetail/112555549341653639">BPU部署教程] 教你搞定YOLOV5部署 (版本_ 6.2) (d-robotics.cc)</a></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>参考文章汇总：</p><ul><li><a href="https://blog.csdn.net/qq_71547093/article/details/133581922">print(torch.cuda.is_available())是false_pip install torch==2.0.1+cu117-CSDN博客</a></li><li><a href="https://developer.horizon.cc/forumDetail/177840589839214598">YOLOv5较新版本的部署方法 (horizon.cc)</a></li><li><a href="https://developer.horizon.cc/forumDetail/163807123501918330">【模型提速】如何在X3pi使用yolov5模型50ms推理 (horizon.cc)</a></li><li><a href="https://developer.horizon.cc/forumDetail/198686198578007656">YOLOV5 在地平线RDK X3的高效部署 (horizon.cc)</a></li><li>[<a href="https://developer.d-robotics.cc/forumDetail/112555549341653639">BPU部署教程] 教你搞定YOLOV5部署 (版本_ 6.2) (d-robotics.cc)</a></li></ul><p>本文使用环境：Windows(训练) -&gt; 虚拟机Ubuntu(转换，校验) -&gt; 板端RDK X3(最终部署)</p><p>建议环境：Ubuntu(训练)-&gt;Ubuntu(转换，校验)-&gt;板端部署</p><p>本文使用YOLOv5 7.0，也可以尝试 YOLOv5 tag2.0 版本，站内有教程说明tag2.0版本与BPU的适配性更好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-windows环境下的模型训练&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-windows环境下的模型训练&quot;&gt;&lt;/a&gt; 一、Windows环境下的模型训练&lt;/h1&gt;
&lt;p&gt;针对YOLO的模型训练环境配置，Windows端兼容性</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>【ROS2】[2]ROS2节点的编写</title>
    <link href="https://szturin.github.io/posts/9164/"/>
    <id>https://szturin.github.io/posts/9164/</id>
    <published>2024-07-09T16:56:46.000Z</published>
    <updated>2024-09-03T04:21:59.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros2节点的代码结构面向对象"><a class="markdownIt-Anchor" href="#ros2节点的代码结构面向对象"></a> ROS2节点的代码结构（面向对象）</h1><h2 id="主程序"><a class="markdownIt-Anchor" href="#主程序"></a> 主程序</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3 </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@作者: 古月居(www.guyuehome.com)</span></span><br><span class="line"><span class="string">@说明: ROS2节点示例-通过摄像头识别检测图片中出现的苹果</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy                            <span class="comment"># ROS2 Python接口库</span></span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node             <span class="comment"># ROS2 节点类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2                              <span class="comment"># OpenCV图像处理库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np                      <span class="comment"># Python数值计算库</span></span><br><span class="line"></span><br><span class="line">lower_red = np.array([<span class="number">0</span>, <span class="number">90</span>, <span class="number">128</span>])     <span class="comment"># 红色的HSV阈值下限</span></span><br><span class="line">upper_red = np.array([<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>])  <span class="comment"># 红色的HSV阈值上限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">object_detect</span>(<span class="params">image</span>):</span><br><span class="line">    hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)       <span class="comment"># 图像从BGR颜色模型转换为HSV模型</span></span><br><span class="line">    mask_red = cv2.inRange(hsv_img, lower_red, upper_red)  <span class="comment"># 图像二值化</span></span><br><span class="line"></span><br><span class="line">    contours, hierarchy = cv2.findContours(mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) <span class="comment"># 图像中轮廓检测</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:                                   <span class="comment"># 去除一些轮廓面积太小的噪声</span></span><br><span class="line">        <span class="keyword">if</span> cnt.shape[<span class="number">0</span>] &lt; <span class="number">150</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        (x, y, w, h) = cv2.boundingRect(cnt)               <span class="comment"># 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高</span></span><br><span class="line">        cv2.drawContours(image, [cnt], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>) <span class="comment"># 将苹果的轮廓勾勒出来</span></span><br><span class="line">        cv2.circle(image, (<span class="built_in">int</span>(x+w/<span class="number">2</span>), <span class="built_in">int</span>(y+h/<span class="number">2</span>)), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)    <span class="comment"># 将苹果的图像中心点画出来</span></span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">"object"</span>, image)                            <span class="comment"># 使用OpenCV显示处理后的图像效果</span></span><br><span class="line">    cv2.waitKey(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):                                       <span class="comment"># ROS2节点主入口main函数</span></span><br><span class="line">    rclpy.init(args=args)                                  <span class="comment"># ROS2 Python接口初始化</span></span><br><span class="line">    node = Node(<span class="string">"node_object_webcam"</span>)                      <span class="comment"># 创建ROS2节点对象并进行初始化</span></span><br><span class="line">    node.get_logger().info(<span class="string">"ROS2节点示例：检测图片中的苹果"</span>)</span><br><span class="line"></span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> rclpy.ok():</span><br><span class="line">        ret, image = cap.read()          <span class="comment"># 读取一帧图像</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">            object_detect(image)         <span class="comment"># 苹果检测</span></span><br><span class="line"></span><br><span class="line">    node.destroy_node()                  <span class="comment"># 销毁节点对象</span></span><br><span class="line">    rclpy.shutdown()                     <span class="comment"># 关闭ROS2 Python接口</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="setuppy"><a class="markdownIt-Anchor" href="#setuppy"></a> <a href="http://setup.py">setup.py</a>——节点的入口</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry_points={</span><br><span class="line">    <span class="string">'console_scripts'</span>: [</span><br><span class="line">     <span class="string">'node_helloworld       = learning_node.node_helloworld:main'</span>,</span><br><span class="line">     <span class="string">'node_helloworld_class = learning_node.node_helloworld_class:main'</span>,</span><br><span class="line">     <span class="string">'node_object           = learning_node.node_object:main'</span>,</span><br><span class="line">     <span class="string">'node_object_webcam    = learning_node.node_object_webcam:main'</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="ros2话题的编写"><a class="markdownIt-Anchor" href="#ros2话题的编写"></a> ROS2话题的编写</h1><h2 id="发布者"><a class="markdownIt-Anchor" href="#发布者"></a> 发布者</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@作者: 古月居(www.guyuehome.com)</span></span><br><span class="line"><span class="string">@说明: ROS2话题示例-发布图像话题</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy                        <span class="comment"># ROS2 Python接口库</span></span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node         <span class="comment"># ROS2 节点类</span></span><br><span class="line"><span class="keyword">from</span> sensor_msgs.msg <span class="keyword">import</span> Image   <span class="comment"># 图像消息类型</span></span><br><span class="line"><span class="keyword">from</span> cv_bridge <span class="keyword">import</span> CvBridge      <span class="comment"># ROS与OpenCV图像转换类</span></span><br><span class="line"><span class="keyword">import</span> cv2                          <span class="comment"># Opencv图像处理库</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">创建一个发布者节点</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImagePublisher</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)                                           <span class="comment"># ROS2节点父类初始化</span></span><br><span class="line">        self.publisher_ = self.create_publisher(Image, <span class="string">'image_raw'</span>, <span class="number">10</span>)  <span class="comment"># 创建发布者对象（消息类型、话题名、队列长度）</span></span><br><span class="line">        self.timer = self.create_timer(<span class="number">0.1</span>, self.timer_callback)         <span class="comment"># 创建一个定时器（单位为秒的周期，定时执行的回调函数）</span></span><br><span class="line">        self.cap = cv2.VideoCapture(<span class="number">0</span>)                                   <span class="comment"># 创建一个视频采集对象，驱动相机采集图像（相机设备号）</span></span><br><span class="line">        self.cv_bridge = CvBridge()                                      <span class="comment"># 创建一个图像转换对象，用于稍后将OpenCV的图像转换成ROS的图像消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timer_callback</span>(<span class="params">self</span>):</span><br><span class="line">        ret, frame = self.cap.read()                         <span class="comment"># 一帧一帧读取图像</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret == <span class="literal">True</span>:                                      <span class="comment"># 如果图像读取成功</span></span><br><span class="line">            self.publisher_.publish(</span><br><span class="line">                self.cv_bridge.cv2_to_imgmsg(frame, <span class="string">'bgr8'</span>)) <span class="comment"># 发布图像消息</span></span><br><span class="line"></span><br><span class="line">        self.get_logger().info(<span class="string">'Publishing video frame'</span>)     <span class="comment"># 输出日志信息，提示已经完成图像话题发布</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):                                 <span class="comment"># ROS2节点主入口main函数</span></span><br><span class="line">    rclpy.init(args=args)                            <span class="comment"># ROS2 Python接口初始化</span></span><br><span class="line">    node = ImagePublisher(<span class="string">"topic_webcam_pub"</span>)        <span class="comment"># 创建ROS2节点对象并进行初始化</span></span><br><span class="line">    rclpy.spin(node)                                 <span class="comment"># 循环等待ROS2退出</span></span><br><span class="line">    node.destroy_node()                              <span class="comment"># 销毁节点对象</span></span><br><span class="line">    rclpy.shutdown()                                 <span class="comment"># 关闭ROS2 Python接口</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="订阅者"><a class="markdownIt-Anchor" href="#订阅者"></a> 订阅者</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@作者: 古月居(www.guyuehome.com)</span></span><br><span class="line"><span class="string">@说明: ROS2话题示例-订阅图像话题</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy                            <span class="comment"># ROS2 Python接口库</span></span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node             <span class="comment"># ROS2 节点类</span></span><br><span class="line"><span class="keyword">from</span> sensor_msgs.msg <span class="keyword">import</span> Image       <span class="comment"># 图像消息类型</span></span><br><span class="line"><span class="keyword">from</span> cv_bridge <span class="keyword">import</span> CvBridge          <span class="comment"># ROS与OpenCV图像转换类</span></span><br><span class="line"><span class="keyword">import</span> cv2                              <span class="comment"># Opencv图像处理库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np                      <span class="comment"># Python数值计算库</span></span><br><span class="line"></span><br><span class="line">lower_red = np.array([<span class="number">0</span>, <span class="number">90</span>, <span class="number">128</span>])      <span class="comment"># 红色的HSV阈值下限</span></span><br><span class="line">upper_red = np.array([<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>])   <span class="comment"># 红色的HSV阈值上限</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">创建一个订阅者节点</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageSubscriber</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)                                <span class="comment"># ROS2节点父类初始化</span></span><br><span class="line">        self.sub = self.create_subscription(</span><br><span class="line">            Image, <span class="string">'image_raw'</span>, self.listener_callback, <span class="number">10</span>)   <span class="comment"># 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度）</span></span><br><span class="line">        self.cv_bridge = CvBridge()                           <span class="comment"># 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">object_detect</span>(<span class="params">self, image</span>):</span><br><span class="line">        hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)      <span class="comment"># 图像从BGR颜色模型转换为HSV模型</span></span><br><span class="line">        mask_red = cv2.inRange(hsv_img, lower_red, upper_red) <span class="comment"># 图像二值化</span></span><br><span class="line">        contours, hierarchy = cv2.findContours(</span><br><span class="line">            mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)   <span class="comment"># 图像中轮廓检测</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:                                  <span class="comment"># 去除一些轮廓面积太小的噪声</span></span><br><span class="line">            <span class="keyword">if</span> cnt.shape[<span class="number">0</span>] &lt; <span class="number">150</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            (x, y, w, h) = cv2.boundingRect(cnt)              <span class="comment"># 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高</span></span><br><span class="line">            cv2.drawContours(image, [cnt], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)<span class="comment"># 将苹果的轮廓勾勒出来</span></span><br><span class="line">            cv2.circle(image, (<span class="built_in">int</span>(x+w/<span class="number">2</span>), <span class="built_in">int</span>(y+h/<span class="number">2</span>)), <span class="number">5</span>,</span><br><span class="line">                       (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)                       <span class="comment"># 将苹果的图像中心点画出来</span></span><br><span class="line"></span><br><span class="line">        cv2.imshow(<span class="string">"object"</span>, image)                           <span class="comment"># 使用OpenCV显示处理后的图像效果</span></span><br><span class="line">        cv2.waitKey(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">listener_callback</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.get_logger().info(<span class="string">'Receiving video frame'</span>)     <span class="comment"># 输出日志信息，提示已进入回调函数</span></span><br><span class="line">        image = self.cv_bridge.imgmsg_to_cv2(data, <span class="string">'bgr8'</span>)  <span class="comment"># 将ROS的图像消息转化成OpenCV图像</span></span><br><span class="line">        self.object_detect(image)                           <span class="comment"># 苹果检测</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):                            <span class="comment"># ROS2节点主入口main函数</span></span><br><span class="line">    rclpy.init(args=args)                       <span class="comment"># ROS2 Python接口初始化</span></span><br><span class="line">    node = ImageSubscriber(<span class="string">"topic_webcam_sub"</span>)  <span class="comment"># 创建ROS2节点对象并进行初始化</span></span><br><span class="line">    rclpy.spin(node)                            <span class="comment"># 循环等待ROS2退出</span></span><br><span class="line">    node.destroy_node()                         <span class="comment"># 销毁节点对象</span></span><br><span class="line">    rclpy.shutdown()                            <span class="comment"># 关闭ROS2 Python接口</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>话题通信是异步单工通信，适合周期性发布逻辑固定的信息</p></blockquote><blockquote><p>在ROS系统中，话题通信数据的描述格式称之为消息，对应编程语言中数据结构的概念</p></blockquote><h2 id="话题的命令行操作"><a class="markdownIt-Anchor" href="#话题的命令行操作"></a> 话题的命令行操作</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic <span class="built_in">list</span>                <span class="comment"># 查看话题列表</span></span><br><span class="line">ros2 topic info &lt;topic_name&gt;   <span class="comment"># 查看话题信息</span></span><br><span class="line">ros2 topic hz &lt;topic_name&gt;     <span class="comment"># 查看话题发布频率</span></span><br><span class="line">ros2 topic bw &lt;topic_name&gt;     <span class="comment"># 查看话题传输带宽</span></span><br><span class="line">ros2 topic echo &lt;topic_name&gt;   <span class="comment"># 查看话题数据</span></span><br><span class="line">ros2 topic pub &lt;topic_name&gt; &lt;msg_type&gt; &lt;msg_data&gt;   <span class="comment"># 发布话题消息</span></span><br></pre></td></tr></tbody></table></figure><h2 id="虚拟机配置与开发机通信"><a class="markdownIt-Anchor" href="#虚拟机配置与开发机通信"></a> 虚拟机配置与开发机通信</h2><blockquote><p>虚拟器配置为桥接模式，且虚拟网络设置要配置与本机的有线网卡一置</p></blockquote><blockquote><p>Ubuntu22.04 使用 ip addr查看网络地址，或者ip a</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ros2节点的代码结构面向对象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ros2节点的代码结构面向对象&quot;&gt;&lt;/a&gt; ROS2节点的代码结构（面向对象）&lt;/h1&gt;
&lt;h2 id=&quot;主程序&quot;&gt;&lt;a class=&quot;markdownIt-</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="ROS" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ROS/"/>
    
    
  </entry>
  
  <entry>
    <title>【Opencv】[1]图像处理基本概念</title>
    <link href="https://szturin.github.io/posts/51713/"/>
    <id>https://szturin.github.io/posts/51713/</id>
    <published>2024-07-07T16:42:28.000Z</published>
    <updated>2024-09-03T04:21:35.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="opencv常见基本概念"><a class="markdownIt-Anchor" href="#opencv常见基本概念"></a> Opencv常见基本概念</h1><hr><h1 id="一-opencv常见基本概念"><a class="markdownIt-Anchor" href="#一-opencv常见基本概念"></a> 一、Opencv常见基本概念</h1><h2 id="1bgr和rgb格式"><a class="markdownIt-Anchor" href="#1bgr和rgb格式"></a> 1.BGR和RGB格式</h2><blockquote><ul><li><p>BGR和RGB是两种常见的颜色编码格式，它们在像素颜色排列的顺序上有所不同：</p><ol><li><strong>RGB格式</strong>：<ul><li>RGB指的是红色（R）、绿色（G）、蓝色（B）三个颜色通道的顺序。</li><li>在RGB格式中，像素的颜色值按照红、绿、蓝的顺序排列，即最开始的三个字节依次表示红色、绿色和蓝色分量。</li></ul></li><li><strong>BGR格式</strong>：<ul><li>BGR则是蓝色（B）、绿色（G）、红色（R）的顺序。</li><li>在BGR格式中，像素的颜色值按照蓝、绿、红的顺序排列，即最开始的三个字节依次表示蓝色、绿色和红色分量。</li></ul></li></ol><p>这两种格式主要在图像处理中有所区别。例如，<mark>在OpenCV中，默认情况下读取的图像格式是BGR而非RGB</mark>，这意味着你在处理图像数据时需要注意颜色通道的顺序。如果需要与其他软件或标准的RGB格式进行交互，通常需要进行颜色通道的重新排列。</p><p>总结：</p><ul><li><strong>RGB</strong>：红色、绿色、蓝色，像素颜色排列顺序是RGB。</li><li><strong>BGR</strong>：蓝色、绿色、红色，像素颜色排列顺序是BGR。</li></ul></li></ul></blockquote><h2 id="2常用函数库和视觉处理方法"><a class="markdownIt-Anchor" href="#2常用函数库和视觉处理方法"></a> 2.常用函数库和视觉处理方法</h2><h3 id="摄像头的开启"><a class="markdownIt-Anchor" href="#摄像头的开启"></a> 摄像头的开启</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#摄像头类创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pi_Camera</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 图像初始化配置</span></span><br><span class="line">        self.Video = cv2.VideoCapture(<span class="number">8</span>, cv2.CAP_V4L2) <span class="comment"># 使能摄像头8的驱动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查摄像头是否打开</span></span><br><span class="line">        ret = self.Video.isOpened()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The video is opened."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"No video."</span>)</span><br><span class="line">    </span><br><span class="line">        codec = cv2.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>)</span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FOURCC, codec)</span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FPS, <span class="number">60</span>)  <span class="comment"># 帧数</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">640</span>)  <span class="comment"># 列 宽度</span></span><br><span class="line">        self.Video.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>)  <span class="comment"># 行 高度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GuideLine</span>(<span class="params">self, c1, c2</span>):</span><br><span class="line">        ret, image = self.Video.read()<span class="comment">#注意：read返回一个bull值和图像数据list！，需要用两个变量获取</span></span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">360</span>), (<span class="number">640</span>, <span class="number">360</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)  <span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="number">0</span>, <span class="number">240</span>), (<span class="number">640</span>, <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)  <span class="comment"># 红色的线</span></span><br><span class="line">            cv2.line(image, (<span class="built_in">int</span>(c1), <span class="number">360</span>), (<span class="built_in">int</span>(c2), <span class="number">240</span>), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">2</span>)  <span class="comment"># 绘出倾角线</span></span><br><span class="line">            cv2.imshow(<span class="string">"GuideLine"</span>, image)</span><br></pre></td></tr></tbody></table></figure><p><strong>异常的处理：</strong><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017598873256736">错误处理 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p><strong>ret的作用：</strong></p><p>​通常是一个函数返回值的缩写，在opencv中经常用来读取函数的布尔值，判断摄像是否打开、头图像是否读取成功等，防止后续处理空值报错</p><p><strong>摄像头的驱动：</strong></p><ul><li><pre class="highlight"><code class="python">self.Video = cv2.VideoCapture(<span class="hljs-number">8</span>, cv2.CAP_V4L2)&lt;!--code￼<span class="hljs-number">1</span>--&gt;</code></pre></li></ul><h1 id="三-opencv实现色块识别"><a class="markdownIt-Anchor" href="#三-opencv实现色块识别"></a> 三、Opencv实现色块识别</h1><h1 id="rdk-x3-开发体验"><a class="markdownIt-Anchor" href="#rdk-x3-开发体验"></a> #RDK X3 开发体验</h1><p>题主目前初学Python,OpenCV,Ros2, 且对深度学习，图像处理等知识存在相当大的欠缺，基本参考RDK X3的官方手册学习，不得不说，RDK X3的官方镜像，社区生态支持做的都相当便捷，嵌入式边缘计算设备方面领域能做到对初学者如此友好的仅此一家。</p><blockquote><p>sudo bash -c ‘echo 1 &gt; /sys/devices/system/cpu/cpufreq/boost’</p></blockquote><blockquote><p>可通过<code>sudo hrut_somstatus</code>命令查看当前芯片工作频率、温度等状态：</p></blockquote><blockquote><p>供电不稳定导致X3无法正常启动，或者程序执行过程中摄像头无法正常驱动</p></blockquote><blockquote><p>驱动USB摄像头时应该确定设备号，使用<code>ls /dev/video*</code>命令查看当前的video设备</p></blockquote><blockquote><p>使用 rc.local 可以便捷配置开机自启动脚本</p></blockquote><blockquote><p>使用ros2或者tros命令应配置好环境变量</p></blockquote><blockquote><p>烧录镜像应选择稳定版本，比如 2.10 ，3.0.0beta存在一些小毛病（VNC无法正常使用）</p></blockquote><blockquote><p>vscode remote无法获得opencv imshow的图像，使用MobaXterm则正常显示X3的摄像头图像</p></blockquote><h1 id="rdk-x3多媒体"><a class="markdownIt-Anchor" href="#rdk-x3多媒体"></a> RDK X3多媒体</h1><h2 id="术语约定httpsdeveloperhorizonccdocuments_rdkmultimedia_developmentoverviewterminology"><a class="markdownIt-Anchor" href="#术语约定httpsdeveloperhorizonccdocuments_rdkmultimedia_developmentoverviewterminology"></a> 术语约定(<a href="https://developer.horizon.cc/documents_rdk/multimedia_development/overview#terminology">https://developer.horizon.cc/documents_rdk/multimedia_development/overview#terminology</a>)</h2><table><thead><tr><th>缩写</th><th>全称</th><th>解释</th></tr></thead><tbody><tr><td>VIN</td><td>Video IN</td><td>包含视频处理接入、图像信号处理器、畸变矫正和防抖处理，接收来自sensor的数据并处理，也可以直接接收内存中的图像数据</td></tr><tr><td>VPS</td><td>Video Process System</td><td>包含图像旋转、图像裁剪、缩放功能，可对同一种输入源输出不同分辨率的图像。输入源可以是VIN模块，也可以是内存中的图像数据</td></tr><tr><td>VENC</td><td>Video Encode</td><td>VENC编码模块支持H.264/H.265/JPEG/MJPEG编码，VPS模块处理后的数据可通过编码模块按不同协议编码做码流输出</td></tr><tr><td>VDEC</td><td>Video Decode</td><td>VDEC解码模块支持H.264/H.265/JPEG/MJPEG解码，可对已编码的码流进行解码，交给VPS模块做进一步处理，输出到VOT模块进行显示</td></tr><tr><td>VPU</td><td>Video Processing Unit</td><td>视频处理单元，完成视频的编解码功能</td></tr><tr><td>JPU</td><td>JPEG Processing Unit</td><td>JPEG 图片处理单元，完成JPEG、MJPEG的编解码功能</td></tr><tr><td>VOT</td><td>Video Output</td><td>视频输出模块接收VPS、VDEC的图像数据，可输出到显示设备</td></tr><tr><td>VIO</td><td>Video IN/OUT</td><td>视频输入、输出，包括VIN和VOT模块</td></tr><tr><td>MIPI</td><td>Mobile Industry Processor Interface</td><td>移动产业处理器接口</td></tr><tr><td>CSI</td><td>Camera Serial Interface</td><td>相机串行接口。CSI接口与DSI接口同属一门，都是MIPI（移动产业处理器接口联盟）制定的一种接口规范</td></tr><tr><td>DVP</td><td>Digital Video Port</td><td>数字视频端口</td></tr><tr><td>SIF</td><td>Sensor Interface</td><td>sensor接口，用来接收mipi、dvp或者内存的图像数据</td></tr><tr><td>ISP</td><td>Image Signal Processor</td><td>图像信号处理器，完成图像的效果调校</td></tr><tr><td>LDC</td><td>Lens Distortion Correction</td><td>镜头畸变校正</td></tr><tr><td>DIS</td><td>Digital Image Stabilizer</td><td>数字图像稳定</td></tr><tr><td>DWE</td><td>Dewarp Engine</td><td>畸变矫正引擎，主要是将LDC和DIS集成在一起，包括LDC的畸变矫正和DIS的统计结果</td></tr><tr><td>IPU</td><td>Image Process Unit</td><td>图像信号处理单元，支持图像的旋转、图像裁剪、缩放功能</td></tr><tr><td>GDC</td><td>Geometrical Distortion Correction</td><td>几何畸变矫正</td></tr><tr><td>PYM</td><td>Pyramid</td><td>图像金字塔</td></tr><tr><td>OSD</td><td>On Screen Display</td><td>视频图像叠层显示</td></tr><tr><td>BPU</td><td>Brain Process Unit</td><td>地平线机器人自主研发的可编程AI加速引擎</td></tr><tr><td>HAL</td><td>Hardware Abstraction Layer</td><td>硬件抽象层</td></tr><tr><td>FW</td><td>Firmware</td><td>固件</td></tr><tr><td>Sensor</td><td>Sensor</td><td>如不做特别说明，特指CMOS图像传感器</td></tr></tbody></table><h1 id="usb推理函数解释"><a class="markdownIt-Anchor" href="#usb推理函数解释"></a> USB推理函数解释</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> hobot_dnn <span class="keyword">import</span> pyeasy_dnn <span class="keyword">as</span> dnn</span><br><span class="line"><span class="keyword">from</span> hobot_vio <span class="keyword">import</span> libsrcampy <span class="keyword">as</span> srcampy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> json </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_handler</span>(<span class="params">signal, frame</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nExiting program"</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">output_tensors = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">fcos_postprocess_info = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbSysMem_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"phyAddr"</span>,ctypes.c_double),</span><br><span class="line">        (<span class="string">"virAddr"</span>,ctypes.c_void_p),</span><br><span class="line">        (<span class="string">"memSize"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNQuantiShift_yt</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"shiftLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"shiftData"</span>,ctypes.c_char_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNQuantiScale_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"scaleLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"scaleData"</span>,ctypes.POINTER(ctypes.c_float)),</span><br><span class="line">        (<span class="string">"zeroPointLen"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"zeroPointData"</span>,ctypes.c_char_p)</span><br><span class="line">    ]    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensorShape_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"dimensionSize"</span>,ctypes.c_int * <span class="number">8</span>),</span><br><span class="line">        (<span class="string">"numDimensions"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensorProperties_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"validShape"</span>,hbDNNTensorShape_t),</span><br><span class="line">        (<span class="string">"alignedShape"</span>,hbDNNTensorShape_t),</span><br><span class="line">        (<span class="string">"tensorLayout"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"tensorType"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"shift"</span>,hbDNNQuantiShift_yt),</span><br><span class="line">        (<span class="string">"scale"</span>,hbDNNQuantiScale_t),</span><br><span class="line">        (<span class="string">"quantiType"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"quantizeAxis"</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">"alignedByteSize"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"stride"</span>,ctypes.c_int * <span class="number">8</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hbDNNTensor_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"sysMem"</span>,hbSysMem_t * <span class="number">4</span>),</span><br><span class="line">        (<span class="string">"properties"</span>,hbDNNTensorProperties_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FcosPostProcessInfo_t</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"height"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"width"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"ori_height"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"ori_width"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"score_threshold"</span>,ctypes.c_float),</span><br><span class="line">        (<span class="string">"nms_threshold"</span>,ctypes.c_float),</span><br><span class="line">        (<span class="string">"nms_top_k"</span>,ctypes.c_int),</span><br><span class="line">        (<span class="string">"is_pad_resize"</span>,ctypes.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libpostprocess = ctypes.CDLL(<span class="string">'/usr/lib/libpostprocess.so'</span>) </span><br><span class="line"></span><br><span class="line">get_Postprocess_result = libpostprocess.FcosPostProcess</span><br><span class="line">get_Postprocess_result.argtypes = [ctypes.POINTER(FcosPostProcessInfo_t)]  </span><br><span class="line">get_Postprocess_result.restype = ctypes.c_char_p  </span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_bboxs</span>(<span class="params">image, bboxes, classes=get_classes(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="string">"""draw the bboxes in the original image"""</span></span><br><span class="line">    <span class="comment"># 获取类别数量</span></span><br><span class="line">    num_classes = <span class="built_in">len</span>(classes)</span><br><span class="line">    <span class="comment"># 获取图像的高度、宽度和通道数</span></span><br><span class="line">    image_h, image_w, channel = image.shape</span><br><span class="line">    <span class="comment"># 生成颜色列表，每个类别一个颜色</span></span><br><span class="line">    hsv_tuples = [(<span class="number">1.0</span> * x / num_classes, <span class="number">1.</span>, <span class="number">1.</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(num_classes)]</span><br><span class="line">    colors = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: colorsys.hsv_to_rgb(*x), hsv_tuples))</span><br><span class="line">    <span class="comment"># 将颜色值转换为0-255范围内的RGB值</span></span><br><span class="line">    colors = <span class="built_in">list</span>(</span><br><span class="line">        <span class="built_in">map</span>(<span class="keyword">lambda</span> x: (<span class="built_in">int</span>(x[<span class="number">0</span>] * <span class="number">255</span>), <span class="built_in">int</span>(x[<span class="number">1</span>] * <span class="number">255</span>), <span class="built_in">int</span>(x[<span class="number">2</span>] * <span class="number">255</span>)),</span><br><span class="line">            colors))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置字体缩放比例</span></span><br><span class="line">    fontScale = <span class="number">0.5</span></span><br><span class="line">    <span class="comment"># 设置矩形框的厚度</span></span><br><span class="line">    bbox_thick = <span class="built_in">int</span>(<span class="number">0.6</span> * (image_h + image_w) / <span class="number">600</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每个检测结果</span></span><br><span class="line">    <span class="keyword">for</span> i, result <span class="keyword">in</span> <span class="built_in">enumerate</span>(bboxes):</span><br><span class="line">        <span class="comment"># 获取矩形框的位置信息</span></span><br><span class="line">        bbox = result[<span class="string">'bbox'</span>]</span><br><span class="line">        <span class="comment"># 获取检测分数</span></span><br><span class="line">        score = result[<span class="string">'score'</span>]</span><br><span class="line">        <span class="comment"># 获取类别ID</span></span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">int</span>(result[<span class="string">'id'</span>])</span><br><span class="line">        <span class="comment"># 获取类别名称</span></span><br><span class="line">        name = result[<span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将位置信息四舍五入为整数</span></span><br><span class="line">        coor = [<span class="built_in">round</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> bbox]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据类别ID获取对应的颜色</span></span><br><span class="line">        bbox_color = colors[<span class="built_in">id</span>]</span><br><span class="line">        <span class="comment"># 矩形框的两个顶点坐标</span></span><br><span class="line">        c1, c2 = (coor[<span class="number">0</span>], coor[<span class="number">1</span>]), (coor[<span class="number">2</span>], coor[<span class="number">3</span>])</span><br><span class="line">        <span class="comment"># 画矩形框</span></span><br><span class="line">        cv2.rectangle(image, c1, c2, bbox_color, bbox_thick)</span><br><span class="line">        <span class="comment"># 类别名称</span></span><br><span class="line">        classes_name = name</span><br><span class="line">        <span class="comment"># 矩形框内显示的文字</span></span><br><span class="line">        bbox_mess = <span class="string">'%s: %.2f'</span> % (classes_name, score)</span><br><span class="line">        <span class="comment"># 获取文字尺寸</span></span><br><span class="line">        t_size = cv2.getTextSize(bbox_mess,</span><br><span class="line">                                 <span class="number">0</span>,</span><br><span class="line">                                 fontScale,</span><br><span class="line">                                 thickness=bbox_thick // <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 画矩形框的填充部分，用于显示文字背景</span></span><br><span class="line">        cv2.rectangle(image, c1, (c1[<span class="number">0</span>] + t_size[<span class="number">0</span>], c1[<span class="number">1</span>] - t_size[<span class="number">1</span>] - <span class="number">3</span>),</span><br><span class="line">                      bbox_color, -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 在图像上显示文字</span></span><br><span class="line">        cv2.putText(image,</span><br><span class="line">                    bbox_mess, (c1[<span class="number">0</span>], c1[<span class="number">1</span>] - <span class="number">2</span>),</span><br><span class="line">                    cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">                    fontScale, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                    bbox_thick // <span class="number">2</span>,</span><br><span class="line">                    lineType=cv2.LINE_AA)</span><br><span class="line">        <span class="comment"># 打印检测结果</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"{} is in the picture with confidence:{:.4f}"</span>.<span class="built_in">format</span>(</span><br><span class="line">            classes_name, score))</span><br><span class="line">    <span class="comment"># 返回绘制了矩形框和文字的图像</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_display_res</span>():</span><br><span class="line">    <span class="comment"># 检查指定路径下的可执行文件是否存在，如果不存在则返回默认分辨率 1920x1080</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">"/usr/bin/get_hdmi_res"</span>) == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1920</span>, <span class="number">1080</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> subprocess</span><br><span class="line">    <span class="comment"># 使用子进程运行 get_hdmi_res 命令，获取输出</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"/usr/bin/get_hdmi_res"</span>], stdout=subprocess.PIPE)</span><br><span class="line">    result = p.communicate()</span><br><span class="line">    <span class="comment"># 将结果按逗号分割</span></span><br><span class="line">    res = result[<span class="number">0</span>].split(<span class="string">b','</span>)</span><br><span class="line">    <span class="comment"># 确保宽度和高度在合理范围内</span></span><br><span class="line">    res[<span class="number">1</span>] = <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(res[<span class="number">1</span>]), <span class="number">1920</span>), <span class="number">0</span>)</span><br><span class="line">    res[<span class="number">0</span>] = <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(res[<span class="number">0</span>]), <span class="number">1080</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(res[<span class="number">1</span>]), <span class="built_in">int</span>(res[<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get HDMI display object</span></span><br><span class="line">disp = srcampy.Display()</span><br><span class="line"><span class="comment"># For the meaning of parameters, please refer to the relevant documents of HDMI display</span></span><br><span class="line">disp_w, disp_h = get_display_res()</span><br><span class="line">disp.display(<span class="number">0</span>, disp_w, disp_h) <span class="comment"># 显示模块初始化，并配置显示参数</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 FcosPostProcessInfo_t 对象</span></span><br><span class="line">fcos_postprocess_info = FcosPostProcessInfo_t()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标图像的高度和宽度</span></span><br><span class="line">fcos_postprocess_info.height = <span class="number">512</span></span><br><span class="line">fcos_postprocess_info.width = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置原始图像的高度和宽度</span></span><br><span class="line">fcos_postprocess_info.ori_height = disp_h</span><br><span class="line">fcos_postprocess_info.ori_width = disp_w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置分数阈值，用于过滤低置信度的检测框</span></span><br><span class="line">fcos_postprocess_info.score_threshold = <span class="number">0.5</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置非极大值抑制（NMS）的阈值，用于合并重叠的检测框</span></span><br><span class="line">fcos_postprocess_info.nms_threshold = <span class="number">0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 NMS 阶段保留的检测框数量上限</span></span><br><span class="line">fcos_postprocess_info.nms_top_k = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定是否在图像调整大小时使用填充</span></span><br><span class="line">fcos_postprocess_info.is_pad_resize = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(models[<span class="number">0</span>].outputs)):</span><br><span class="line">    <span class="comment"># 设置每个输出张量的布局属性</span></span><br><span class="line">    output_tensors[i].properties.tensorLayout = get_TensorLayout(models[<span class="number">0</span>].outputs[i].properties.layout)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查输出张量的 scale_data 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(models[<span class="number">0</span>].outputs[i].properties.scale_data) == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 如果 scale_data 为空，设置量化类型为 0</span></span><br><span class="line">        output_tensors[i].properties.quantiType = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果 scale_data 不为空，设置量化类型为 2</span></span><br><span class="line">        output_tensors[i].properties.quantiType = <span class="number">2</span>  </span><br><span class="line">        <span class="comment"># 将 scale_data 重新调整形状</span></span><br><span class="line">        scale_data_tmp = models[<span class="number">0</span>].outputs[i].properties.scale_data.reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, models[<span class="number">0</span>].outputs[i].properties.shape[<span class="number">3</span>])  </span><br><span class="line">        <span class="comment"># 将 scale_data 转换为指向浮点数的指针</span></span><br><span class="line">        output_tensors[i].properties.scale.scaleData = scale_data_tmp.ctypes.data_as(ctypes.POINTER(ctypes.c_float))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置每个输出张量的有效形状和对齐形状</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(models[<span class="number">0</span>].outputs[i].properties.shape)):</span><br><span class="line">        output_tensors[i].properties.validShape.dimensionSize[j] = models[<span class="number">0</span>].outputs[i].properties.shape[j]</span><br><span class="line">        output_tensors[i].properties.alignedShape.dimensionSize[j] = models[<span class="number">0</span>].outputs[i].properties.shape[j]</span><br></pre></td></tr></tbody></table></figure><h2 id="主循环"><a class="markdownIt-Anchor" href="#主循环"></a> 主循环</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        _ ,frame = cap.read()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(frame.shape)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Failed to get image from usb camera"</span>)</span><br><span class="line">        <span class="comment"># 把图片缩放到模型的输入尺寸</span></span><br><span class="line">        <span class="comment"># 获取算法模型的输入tensor 的尺寸</span></span><br><span class="line">        h, w = models[<span class="number">0</span>].inputs[<span class="number">0</span>].properties.shape[<span class="number">2</span>], models[<span class="number">0</span>].inputs[<span class="number">0</span>].properties.shape[<span class="number">3</span>]</span><br><span class="line">        des_dim = (w, h)</span><br><span class="line">        resized_data = cv2.resize(frame, des_dim, interpolation=cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line">        nv12_data = bgr2nv12_opencv(resized_data)</span><br><span class="line"></span><br><span class="line">        t0 = time()</span><br><span class="line">        <span class="comment"># Forward</span></span><br><span class="line">        outputs = models[<span class="number">0</span>].forward(nv12_data)</span><br><span class="line">        t1 = time()</span><br><span class="line">        <span class="comment"># print("forward time is :", (t1 - t0))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Do post process</span></span><br><span class="line">        strides = [<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strides)):</span><br><span class="line">            <span class="keyword">if</span> (output_tensors[i].properties.quantiType == <span class="number">0</span>):</span><br><span class="line">                output_tensors[i].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">5</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">5</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">10</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">10</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), ctypes.c_void_p)</span><br><span class="line">            <span class="keyword">else</span>:      </span><br><span class="line">                output_tensors[i].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">5</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">5</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line">                output_tensors[i + <span class="number">10</span>].sysMem[<span class="number">0</span>].virAddr = ctypes.cast(outputs[i + <span class="number">10</span>].buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)), ctypes.c_void_p)</span><br><span class="line"></span><br><span class="line">            libpostprocess.FcosdoProcess(output_tensors[i], output_tensors[i + <span class="number">5</span>], output_tensors[i + <span class="number">10</span>], ctypes.pointer(fcos_postprocess_info), i)</span><br><span class="line"></span><br><span class="line">        result_str = get_Postprocess_result(ctypes.pointer(fcos_postprocess_info))  </span><br><span class="line">        result_str = result_str.decode(<span class="string">'utf-8'</span>)  </span><br><span class="line">        t2 = time()</span><br><span class="line">        <span class="comment"># print("FcosdoProcess time is :", (t2 - t1))</span></span><br><span class="line">        <span class="comment"># print(result_str)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># draw result</span></span><br><span class="line">        <span class="comment"># 解析JSON字符串  </span></span><br><span class="line">        data = json.loads(result_str[<span class="number">14</span>:])  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frame.shape[<span class="number">0</span>]!=disp_h <span class="keyword">or</span> frame.shape[<span class="number">1</span>]!=disp_w:</span><br><span class="line">            frame = cv2.resize(frame, (disp_w,disp_h), interpolation=cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Draw bboxs</span></span><br><span class="line">        box_bgr = draw_bboxs(frame, data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># cv2.imwrite("imf.jpg", box_bgr)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Convert to nv12 for HDMI display</span></span><br><span class="line">        box_nv12 = bgr2nv12_opencv(box_bgr)</span><br><span class="line">        disp.set_img(box_nv12.tobytes())</span><br><span class="line"></span><br><span class="line">        finish_time = time()</span><br><span class="line">        image_counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> finish_time - start_time &gt;  <span class="number">10</span>:</span><br><span class="line">            <span class="built_in">print</span>(start_time, finish_time, image_counter)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"FPS: {:.2f}"</span>.<span class="built_in">format</span>(image_counter / (finish_time - start_time)))</span><br><span class="line">            start_time = finish_time</span><br><span class="line">            image_counter = <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;opencv常见基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#opencv常见基本概念&quot;&gt;&lt;/a&gt; Opencv常见基本概念&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一-opencv常见基本概念&quot;&gt;&lt;a class=&quot;markdo</summary>
      
    
    
    
    
    <category term="学习笔记,计算机视觉" scheme="https://szturin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>【ROS2】[1]ROS2基本概念</title>
    <link href="https://szturin.github.io/posts/45607/"/>
    <id>https://szturin.github.io/posts/45607/</id>
    <published>2024-07-05T16:06:13.000Z</published>
    <updated>2024-09-03T04:22:15.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros2上手体验"><a class="markdownIt-Anchor" href="#ros2上手体验"></a> ROS2上手体验</h1><p>ros2环境的配置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/humble/setup.bash #添加环境变量，需要每次启动终端使用此命令，比较繁琐</span><br><span class="line">echo " source /opt/ros/humble/setup.bash" &gt;&gt; ~/.bashrc #将添加环境变量的命令添加到脚本，开启终端自启动，无需反复source</span><br></pre></td></tr></tbody></table></figure><p>发布者节点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run demo_nodes_cpp talker </span><br></pre></td></tr></tbody></table></figure><p>订阅者节点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run demo_nodes_py listener</span><br></pre></td></tr></tbody></table></figure><p>node</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node</span><br></pre></td></tr></tbody></table></figure><h1 id="linuxros2命令行操作"><a class="markdownIt-Anchor" href="#linuxros2命令行操作"></a> Linux/Ros2命令行操作</h1><p>Linux的命令庞大，但基本掌握常用的一些基础命令即可</p><p>获取当前终端操作的目录位置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></tbody></table></figure><p>列举当前目录显示的文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></tbody></table></figure><p>列举当前目录（包括被隐藏的）文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -A</span><br></pre></td></tr></tbody></table></figure><p>新建文件夹</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br></pre></td></tr></tbody></table></figure><p>修改当前终端路径</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd test/</span><br></pre></td></tr></tbody></table></figure><p>效果：</p><img src="/posts/45607/image-20240706002347136.png" class="" title="image-20240706002347136"><p>在当前路径新建文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch read.txt</span><br></pre></td></tr></tbody></table></figure><p>在当前路径删除文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm read.txt</span><br></pre></td></tr></tbody></table></figure><p>删除文件夹</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -R test/ #-R表示递归删除</span><br></pre></td></tr></tbody></table></figure><p>安装软件包</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libopencv(自动补全)# sudo表示提升当前使用者权限为管理员,apt表示应用,install表示安装,安装opencv</span><br></pre></td></tr></tbody></table></figure><h2 id="ros2相关"><a class="markdownIt-Anchor" href="#ros2相关"></a> ros2相关</h2><p>将正在运行的节点进行打印</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node list </span><br></pre></td></tr></tbody></table></figure><p>查看节点正在运行的信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node info /节点名</span><br></pre></td></tr></tbody></table></figure><p>查看节点的基本数据/参数</p><p>以查看话题为例，查看哪些话题正在发布和订阅</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></tbody></table></figure><p>对话题进行订阅并打印</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic echo /turtlel/pose</span><br></pre></td></tr></tbody></table></figure><p>使用topic 进行pub，发布一个消息，和run一样可以控制“海龟”进行运动</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}" </span><br><span class="line"># --rate 1:频率1HZ</span><br><span class="line"># /turtle1/cmd_vel geometry_msgs/msg/Twist</span><br><span class="line"># linear:线速度</span><br><span class="line"># angular:角速度</span><br></pre></td></tr></tbody></table></figure><p>使用“服务”，产生新的机器人</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: 'abb'}"</span><br><span class="line"></span><br><span class="line">#使用ros2 topic list查看是否产生新的接口：</span><br><span class="line">turin@turin-virtual-machine:~/Desktop$ ros2 topic list</span><br><span class="line">/abb/cmd_vel</span><br><span class="line">/abb/color_sensor</span><br><span class="line">/abb/pose</span><br><span class="line">/parameter_events</span><br><span class="line">/rosout</span><br><span class="line">/turtle1/cmd_vel</span><br><span class="line">/turtle1/color_sensor</span><br><span class="line">/turtle1/pose</span><br></pre></td></tr></tbody></table></figure><p>总结：话题是机器人控制的<mark>接口</mark>,接口的名称不同，控制的对象不同</p><p>录制机器人的运动过程(录制)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 bag record /turtle/cmd_vel</span><br></pre></td></tr></tbody></table></figure><h1 id="节点"><a class="markdownIt-Anchor" href="#节点"></a> 节点</h1><p><a href="http://setup.py">setup.py</a></p><p>配置ros2程序执行的入口</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">package_name = <span class="string">'learning_node'</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=package_name,</span><br><span class="line">    version=<span class="string">'0.0.0'</span>,</span><br><span class="line">    packages=[package_name],</span><br><span class="line">    data_files=[</span><br><span class="line">        (<span class="string">'share/ament_index/resource_index/packages'</span>,</span><br><span class="line">            [<span class="string">'resource/'</span> + package_name]),</span><br><span class="line">        (<span class="string">'share/'</span> + package_name, [<span class="string">'package.xml'</span>]),</span><br><span class="line">    ],</span><br><span class="line">    install_requires=[<span class="string">'setuptools'</span>],</span><br><span class="line">    zip_safe=<span class="literal">True</span>,</span><br><span class="line">    maintainer=<span class="string">'Hu Chunxu'</span>,</span><br><span class="line">    maintainer_email=<span class="string">'huchunxu@guyuehome.com'</span>,</span><br><span class="line">    description=<span class="string">'TODO: Package description'</span>,</span><br><span class="line">    license=<span class="string">'TODO: License declaration'</span>,</span><br><span class="line">    tests_require=[<span class="string">'pytest'</span>],</span><br><span class="line">    entry_points={</span><br><span class="line">        <span class="string">'console_scripts'</span>: [</span><br><span class="line">         <span class="string">'node_helloworld       = learning_node.node_helloworld:main'</span>, <span class="comment">#节点的配置信息,配置完成后就可以用ros2 run运行</span></span><br><span class="line">         <span class="string">'node_helloworld_class = learning_node.node_helloworld_class:main'</span>,</span><br><span class="line">         <span class="string">'node_object            = learning_node.node_object:main'</span>,</span><br><span class="line">         <span class="string">'node_object_webcam     = learning_node.node_object_webcam:main'</span>,</span><br><span class="line">        ],</span><br><span class="line">    },</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p><strong>面向过程编程</strong></p><img src="/posts/45607/image-20240706230802271.png" class="" title="image-20240706230802271"><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@作者: 古月居(www.guyuehome.com)</span></span><br><span class="line"><span class="string">@说明: ROS2节点示例-发布“Hello World”日志信息, 使用面向对象的实现方式</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy                                     <span class="comment"># ROS2 Python接口库</span></span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node                      <span class="comment"># ROS2 节点类</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">创建一个HelloWorld节点, 初始化时输出“hello world”日志</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorldNode</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)                       <span class="comment"># ROS2节点父类初始化</span></span><br><span class="line">        <span class="keyword">while</span> rclpy.ok():                            <span class="comment"># ROS2系统是否正常运行</span></span><br><span class="line">            self.get_logger().info(<span class="string">"Hello World"</span>)    <span class="comment"># ROS2日志输出</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)                          <span class="comment"># 休眠控制循环时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):                                 <span class="comment"># ROS2节点主入口main函数</span></span><br><span class="line">    rclpy.init(args=args)                            <span class="comment"># ROS2 Python接口初始化</span></span><br><span class="line">    node = HelloWorldNode(<span class="string">"node_helloworld_class"</span>)   <span class="comment"># 创建ROS2节点对象并进行初始化</span></span><br><span class="line">    node.destroy_node()                              <span class="comment"># 销毁节点对象</span></span><br><span class="line">    rclpy.shutdown()                                 <span class="comment"># 关闭ROS2 Python接口</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意：编写完成程序后，需要重新编译，纯py文件无法用ros2命令直接运行, ros2 run 运行的是install</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ros2上手体验&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ros2上手体验&quot;&gt;&lt;/a&gt; ROS2上手体验&lt;/h1&gt;
&lt;p&gt;ros2环境的配置&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="ROS" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ROS/"/>
    
    
  </entry>
  
  <entry>
    <title>2024微机原理课程设计-小车跟随系统</title>
    <link href="https://szturin.github.io/posts/50511/"/>
    <id>https://szturin.github.io/posts/50511/</id>
    <published>2024-06-20T20:44:16.000Z</published>
    <updated>2024-09-03T04:41:07.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小车基本控制设计"><a class="markdownIt-Anchor" href="#小车基本控制设计"></a> 小车基本控制设计</h1><h2 id="一-前期系统分析与设计"><a class="markdownIt-Anchor" href="#一-前期系统分析与设计"></a> 一、前期系统分析与设计</h2><p>​      在本次设计的前期准备工作中，通过对题目的分析，小车运动的精确低延迟控制+蓝牙通信都是相当重要的关键点。本次课程设计，使用电机型号为带霍尔传感器地无刷电机，能够通过内置编码器的A,B相固定输出390次/圈的脉冲，可以用于精准测量电机转速以及作为<mark>车辆里程表</mark>。因此，我基于所用电机的特性，利用PIC单片机CCP极其优秀的PWM输出功能，设计了一个易用的电机驱动程序，能够使得单片机输出频率10KHZ，占空比可调范围在0~100的PWM信号。对比于常规的使用定时器作为计时基准的方法，直接利用单片机设计好的电路外设模块，减轻了单片机<mark>程序</mark>上消耗的资源，也大幅提高了后续小车的运动性能以及稳定性。重要的一点是，基于对自动控制原理的粗略学习，我们可以利用本次电机所带的编码器模块，实现<strong>单片机测速——程序PID控制器——输出PWM波</strong>的一个PID自动控速系统以及能够精准记录脉冲数的<strong>车辆里程表（这在后面进行内外圈转向时发挥了关键的作用）</strong>，同时，蓝牙模块也是一个极其便捷的工具，使用两片蓝牙模块，分别连接单片机和计算机，在一些串口助手软件上，能够迅速实现基于上位机的参数检测以及调试系统。</p><p>注：本次设计的串口助手为VOFA，可以兼容所有串口调试的基本功能，能够根据数值的大小显示波形。</p><h3 id="设计框图蓝牙控速小车"><a class="markdownIt-Anchor" href="#设计框图蓝牙控速小车"></a> 设计框图：蓝牙控速小车</h3><p><strong>基于上述程序的编写以及小车板块的搭建，首先设计一个可以通过计算机或者手机终端等设备进行蓝牙遥控的小车运动系统。本次课程设计我们基于实验以及课程的理论经验，从搭建<mark>底层框架</mark>再到完成其余功能要求的设计思想，分阶段、板块完成设计，更有利于后面的高效分工与调试。</strong></p><img src="/posts/50511/image-20240625013830066.png" class="" title="image-20240625013830066"><h2 id="1电机驱动程序设计"><a class="markdownIt-Anchor" href="#1电机驱动程序设计"></a> 1.电机驱动程序设计</h2><p><strong>问题1：PWM输出</strong></p><p>​常见的8位单片机（stc89c52），产生PWM，通常是利用到定时器模块，以定时器计时为基准（时间基准t1，假设为1ms），程序上定义计时变量time(每次进定时器中断time自加1)、周期时间变量T（假设T=100）、占空比时间变量N（假设N=50），然后通过IF语句判断，翻转设定的引脚（假设为RC1）输出PWM方波信号。但是考虑到如果使用定时器，如果定时器的计数寄存器（计时溢出周期）设置过小，程序会频繁进入中断，不利于其他部分程序的执行，占用了软件上的资源；如果定时器计时周期设置的太大，比如10ms，又想输出一个可调范围0~100的PWM，那么PWM方波信号的周期就高达1s，PWM频率仅仅只有1HZ，这样就会使得电机无法正常驱动或者运动过程有明显的卡顿（PWM分辨率过低）。而本次使用的PIC16F877A单片机，具备CCP1+CCP2模块，能够通过配置寄存器，硬件自动生成两路的PWM信号，节省了软件资源，并且PIC单片机的CCP模块生成的PWM方波相当的精准可靠，在完成CCP模块PWM模式的初始化后，只需要修改CCP1L/CCP2L的值即可修改PWM（RC6、RC7）的占空比。</p><hr><p>电机驱动模块子程序设计</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_A RC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_B RC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_1 RB4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_2 RB5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_1 RB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_2 RB7</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函    数</span></span><br><span class="line"><span class="comment">参    数要写入的命令</span></span><br><span class="line"><span class="comment">返 回 值无</span></span><br><span class="line"><span class="comment">特殊说明无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_GPIO_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISB4=<span class="number">0</span>;</span><br><span class="line">TRISB5=<span class="number">0</span>;</span><br><span class="line">TRISB6=<span class="number">0</span>;</span><br><span class="line">TRISB7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;</span><br><span class="line">TRISC2=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_CCP_PWM_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*定义CCP1工作在PWM模式*/</span></span><br><span class="line">CCP1CON=<span class="number">0X0C</span>;<span class="comment">//定义CCP1模块工作在PWM模式</span></span><br><span class="line">CCPR1L=<span class="number">50</span>;<span class="comment">//定义脉宽为50us</span></span><br><span class="line">PR2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义CCP2工作在PWM模式*/</span></span><br><span class="line">    CCP2CON = <span class="number">0x0c</span>; <span class="comment">// 配置CCP2为PWM模式</span></span><br><span class="line">    CCPR2L = <span class="number">50</span>;          <span class="comment">// 设置CCP2 PWM占空比（高位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*与CCP模块PWM模式配合的TMR2*/</span></span><br><span class="line">T2CON=<span class="number">0</span>;<span class="comment">//定义TM2模块工作在预、后分频比都是1:1的定时器模式</span></span><br><span class="line">TMR2=<span class="number">0</span>;</span><br><span class="line">TMR2ON=<span class="number">1</span>;<span class="comment">//启动TMR2，此刻从RC2引脚输出所设的波形</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Speed_Set</span><span class="params">(<span class="type">int</span> Speed1,<span class="type">int</span> Speed2)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Speed1 &gt; <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">0</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">1</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Speed2 &gt;<span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">0</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">1</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>问题2：测速</strong></p><p><mark><strong>通过外部中断配合定时器1测速</strong></mark></p><p>​我们可以按照实验课中的方法，使用定时器1和外部中断配合设计测速系统，通过检测信号跳变，配合定时器1的TMR1ON控制启停，计算电平的持续时间，这样就能测量PWM的占空比。但是，通过对本次课程设计电机模块的分析以及学习（本次设计为无刷电机==(注意固定螺丝不能太长会磨损电机减速箱)==，并且自带霍尔编码器）</p><p>​霍尔编码器：通过霍尔传感器感应电机转过的次数，相应的，在本次设计中使用的电机模块，转动一圈产生390个脉冲。直接使用实验五的方法，通过串口调试助手打印测得速度，发现速度是不连续的（此图出现如290km/h 71km/h 15 km/h等速度）。因为如果要使用霍尔传感器，它的脉冲实际上不是代表的PWM，只有通过记录编码器输出的脉冲次数才能实现单位时间内小车的速度/里程计算。</p><img src="/posts/50511/image-20240621050939454.png" class="" title="image-20240621050939454"><hr><p><mark><strong>采用外部中断计数的方法测速，如下图</strong></mark></p><p><strong>我们改用定时器0（50ms为计数周期)，外部中断（测量电机驱动输出的编码器脉冲计数），这样就能轻而易举地计算出50ms内地脉冲数目，进而进行速度的精准测量+里程的累计。</strong></p><p>可见，直接通过计算脉冲次数的方法，速度的测量基本无波动（横坐标表示50ms时间内的脉冲计数,此图位48-49范围内波动，基本无误差）。</p><img src="/posts/50511/d34fd09e3d5cd10c526f393554abff6.png" class="" title="d34fd09e3d5cd10c526f393554abff6"><hr><p><strong>子函数设计</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_A RC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_PWM_B RC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_1 RB4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicA_2 RB5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_1 RB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_LogicB_2 RB7</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_measure2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函    数</span></span><br><span class="line"><span class="comment">参    数要写入的命令</span></span><br><span class="line"><span class="comment">返 回 值无</span></span><br><span class="line"><span class="comment">特殊说明无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_GPIO_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISB4=<span class="number">0</span>;</span><br><span class="line">TRISB5=<span class="number">0</span>;</span><br><span class="line">TRISB6=<span class="number">0</span>;</span><br><span class="line">TRISB7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;</span><br><span class="line">TRISC2=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_CCP_PWM_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*定义CCP1工作在PWM模式*/</span></span><br><span class="line">CCP1CON=<span class="number">0X0C</span>;<span class="comment">//定义CCP1模块工作在PWM模式</span></span><br><span class="line">CCPR1L=<span class="number">50</span>;<span class="comment">//定义脉宽为50us</span></span><br><span class="line">PR2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义CCP2工作在PWM模式*/</span></span><br><span class="line">    CCP2CON = <span class="number">0x0c</span>; <span class="comment">// 配置CCP2为PWM模式</span></span><br><span class="line">    CCPR2L = <span class="number">50</span>;          <span class="comment">// 设置CCP2 PWM占空比（高位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*与CCP模块PWM模式配合的TMR2*/</span></span><br><span class="line">T2CON=<span class="number">0</span>;<span class="comment">//定义TM2模块工作在预、后分频比都是1:1的定时器模式</span></span><br><span class="line">TMR2=<span class="number">0</span>;</span><br><span class="line">TMR2ON=<span class="number">1</span>;<span class="comment">//启动TMR2，此刻从RC2引脚输出所设的波形</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Speed_Set</span><span class="params">(<span class="type">int</span> Speed1,<span class="type">int</span> Speed2)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Speed1 &gt; <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">0</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicA_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicA_2 = <span class="number">1</span>;</span><br><span class="line">CCPR1L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Speed2 &gt;<span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">1</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">0</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)Speed2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Motor_LogicB_1 = <span class="number">0</span>;</span><br><span class="line">Motor_LogicB_2 = <span class="number">1</span>;</span><br><span class="line">CCPR2L=(<span class="type">unsigned</span> <span class="type">char</span>)(-Speed2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>电机的速度计算准确后，通过我们对自动控制原理的学习了解，或许可以应用一些简单的算法，进行小车的速度闭环负反馈控制？</li></ul><h3 id="3串口通信初始化"><a class="markdownIt-Anchor" href="#3串口通信初始化"></a> 3.串口通信初始化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//putch 重定向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putch</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">    TXREG=ch;</span><br><span class="line">    <span class="keyword">while</span>(TRMT==<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*??????????*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_PrintString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *String)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(*String != <span class="string">'\0'</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,*String++);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口引脚初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">TRISC6=<span class="number">1</span>;</span><br><span class="line">TRISC7=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    SPBRG=<span class="number">12</span>;<span class="comment">//波特率设置为19200</span></span><br><span class="line">    TXSTA=<span class="number">0B</span>00100100;<span class="comment">//异步模式。发送8位数据，允许发送</span></span><br><span class="line">    RCSTA=<span class="number">0B</span>10010000;<span class="comment">//允许串口工作，连续接收使能，接收8位数据</span></span><br><span class="line">    GIE=<span class="number">1</span>;PEIE=<span class="number">1</span>;RCIE=<span class="number">1</span>;<span class="comment">//开放USART接收中断</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将连接单片机的蓝牙模块配置为主机模式，连接计算机的蓝牙模块配置为从机模式，并且两片蓝牙的密码设置为一致，波特率与单片机、电脑串口助手都设置为19200。这样，单片机就能够发送数据到串口助手，串口中断打印出数据/波形，实现远程调参效果。</p><h3 id="pid控速的尝试与应用"><a class="markdownIt-Anchor" href="#pid控速的尝试与应用"></a> PID控速的尝试与应用</h3><p>1.给定占空比</p><p>​通过修改CCP1L和CCP2L的值，可以实现指定PWM占空比的电机变速效果，通过串口助手显示编码器测速的波形，发现给定PWM的速度也是比较稳定的。</p><img src="/posts/50511/image-20240625022659866.png" class="" title="image-20240625022659866"><p>2.PID控速</p><p>​编写PID速度环控制子程序，将速度测量值以及速度目标值作为输入，返回值为PID的输出值，作为PWM的输出，形成闭环反馈系统。经上位机显示速度波形，测量速度（红线）能够逐渐趋近于目标速度（绿线），说明PID速度闭环的程序是正确的，后面对各个参数（Kp、Ki、Kd）进行优化，减少过充现象，增大反应速度，提高PID速度闭环系统的抗干扰能力。</p><img src="/posts/50511/image-20240625023158792.png" class="" title="image-20240625023158792"><p>​经过我们后面对PIC16F877A的引脚分配，发现它能够进行速度测量的引脚基本上只能使用外部中断，CCP模块以及被用作PWM输出，那么PID控速的想法就暂时被搁置了。但是，我们后面将编码器的脉冲输入作为车辆里程表，也可以实现灵活度更高的功能（内外圈转向区分）。</p><h1 id="灰度巡线pid-数学模型解决工程问题"><a class="markdownIt-Anchor" href="#灰度巡线pid-数学模型解决工程问题"></a> 灰度巡线PID - 数学模型解决工程问题</h1><img src="/posts/50511/image-20240621050902381.png" class="" title="image-20240621050902381"><p><strong>头文件定义/变量定义</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span><span class="comment">//PIC库</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);<span class="comment">//配置起始位</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//C语言库</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*PIC单片机驱动相关子函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\LCD1602.H"</span><span class="comment">//LCD1602子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\KeyBoard.H"</span><span class="comment">//按键子函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\iic.H"</span><span class="comment">//iic通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Motor.H"</span><span class="comment">//电机驱动</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Usart.H"</span><span class="comment">//串口（蓝牙）通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Led.H"</span><span class="comment">//Led</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\Encoder.H"</span><span class="comment">//霍尔编码器测速</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\PID.H"</span><span class="comment">//PID控制程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\Driver\csb.H"</span><span class="comment">//超声波控制程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*PIC单片机系统相关子函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\System\Timer.H"</span><span class="comment">//定时器初始化程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\..\System\Delay.H"</span><span class="comment">//延时子程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bluetooth;<span class="comment">//蓝牙接收字节存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*外部中断测速*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Counter_temp;<span class="comment">//车辆旋转圈数计数变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Timer0_Counter;<span class="comment">//定时器0溢出计数变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Encoder_Counter;<span class="comment">//脉冲计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*循迹控制主要变量*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Motor_Flag;<span class="comment">//电机允许模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Turn_PWM;<span class="comment">//转向PWM，由循迹PID控制函数输出赋值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Byte;<span class="comment">//八路循迹对应一个字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_left,Speed_right;<span class="comment">//寻线速度77y89-</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Speed_Velcolity=<span class="number">33</span>;<span class="comment">//直行速度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> IO_flag=<span class="number">0</span>;<span class="comment">//（90度转向）启停标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Circle_Mode=<span class="number">0</span>;<span class="comment">//车辆运行模式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Start_Find_flag=<span class="number">0</span>;<span class="comment">//脉冲计数标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Bifurcate_Flag=<span class="number">0</span>;<span class="comment">//分叉路口标志位，0表示第一个，1表示第二个</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Stop_Flag=<span class="number">0</span>;<span class="comment">//停车标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Mode=<span class="number">0</span>;<span class="comment">//八路循迹状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> distance;<span class="comment">//超声波距离</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> BT_State=<span class="number">0</span>;<span class="comment">//蓝牙通信状态机，无线调参</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> csb_Flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> NQ_fast_Flag=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*//循迹工作验证函数</span></span><br><span class="line"><span class="comment">unsigned char yz[8]={0};</span></span><br><span class="line"><span class="comment">unsigned char mod;</span></span><br><span class="line"><span class="comment">void yanzheng()</span></span><br><span class="line"><span class="comment">{ </span></span><br><span class="line"><span class="comment">unsigned char temp = mod;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">yz[i] = temp %2;</span></span><br><span class="line"><span class="comment">temp/=2;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>模块验证函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*//循迹工作验证函数</span></span><br><span class="line"><span class="comment">unsigned char yz[8]={0};</span></span><br><span class="line"><span class="comment">unsigned char mod;</span></span><br><span class="line"><span class="comment">void yanzheng()</span></span><br><span class="line"><span class="comment">{ </span></span><br><span class="line"><span class="comment">unsigned char temp = mod;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">yz[i] = temp %2;</span></span><br><span class="line"><span class="comment">temp/=2;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>循迹控制函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Trace_Byte;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Kp=<span class="number">3.2</span>;</span><br><span class="line"><span class="type">int</span> Kd=<span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> turn_err;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> last_err;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> err_difference;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Trace_PID</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Trace_Byte = (RC0&lt;&lt;<span class="number">7</span>|RC3&lt;&lt;<span class="number">6</span>|RE0&lt;&lt;<span class="number">5</span>|RE1&lt;&lt;<span class="number">4</span>|RE2&lt;&lt;<span class="number">3</span>|RA4&lt;&lt;<span class="number">2</span>|RC4&lt;&lt;<span class="number">1</span>|RC5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Trace_Byte)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//直行</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11100111: </span><br><span class="line">turn_err=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11110111:</span><br><span class="line">turn_err=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11101111:</span><br><span class="line">turn_err=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//左转</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11001111:</span><br><span class="line">turn_err=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11011111:</span><br><span class="line">turn_err=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>10011111:</span><br><span class="line">turn_err=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>10111111:</span><br><span class="line">turn_err=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>00111111:</span><br><span class="line">turn_err=<span class="number">6</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>01111111:</span><br><span class="line">turn_err=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右转</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11110011:</span><br><span class="line">turn_err=<span class="number">-2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111011:</span><br><span class="line">turn_err=<span class="number">-3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111001:</span><br><span class="line">turn_err=<span class="number">-4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111101:</span><br><span class="line">turn_err=<span class="number">-5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111100:</span><br><span class="line">turn_err=<span class="number">-6</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0B</span>11111110:</span><br><span class="line">turn_err=<span class="number">-7</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err_difference= turn_err - last_err;</span><br><span class="line"></span><br><span class="line">last_err= turn_err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)(turn_err*Kp + err_difference*Kd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>路线控制函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Trace_Control</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Circle_Mode == <span class="number">0</span>)<span class="comment">//起始点</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">1</span>;<span class="comment">//脉冲计数标志位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt;<span class="number">550</span>)<span class="comment">//固定距离，越过黑线</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">1</span>)<span class="comment">//第一圈，外圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag =<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Find_flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">200</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">IO_flag = <span class="number">1</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">2</span>;<span class="comment">//内圈</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">2</span>)<span class="comment">//第二圈，内圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(IO_flag == <span class="number">0</span>)<span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//putch(3);//进入第三圈</span></span><br><span class="line">Start_Find_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Find_flag == <span class="number">1</span>  &amp;&amp; NQ_fast_Flag == <span class="number">0</span>)<span class="comment">//开启计脉冲且，内圈没有加速</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(Speed_Velcolity,Speed_Velcolity);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">300</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">IO_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Circle_Mode = <span class="number">3</span>;</span><br><span class="line">csb_Flag= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(NQ_fast_Flag)<span class="comment">//开启内圈加速</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">800</span>)<span class="comment">//固定里程前进一段</span></span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">NQ_fast_Flag = <span class="number">0</span>;</span><br><span class="line">Start_Find_flag = <span class="number">0</span>;</span><br><span class="line">Encoder_Counter=<span class="number">0</span>;</span><br><span class="line">Speed_Velcolity=<span class="number">35</span>;<span class="comment">//回归</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//内圈固定转向</span></span><br><span class="line">{</span><br><span class="line">Motor_Speed_Set(<span class="number">20</span>,<span class="number">60</span>);</span><br><span class="line"><span class="keyword">if</span>(Encoder_Counter &gt; <span class="number">320</span>)</span><br><span class="line">{</span><br><span class="line">csb_Flag=<span class="number">1</span>;</span><br><span class="line">NQ_fast_Flag = <span class="number">1</span>;</span><br><span class="line">IO_flag = <span class="number">0</span>;</span><br><span class="line">Speed_Velcolity+=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Circle_Mode == <span class="number">3</span>)<span class="comment">//第三圈，外圈</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Start_PD() == <span class="number">1</span>)<span class="comment">//起始线扫描判断</span></span><br><span class="line">{</span><br><span class="line">Start_Find_flag = <span class="number">1</span>;</span><br><span class="line">Stop_Flag=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Stop_Flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">putch(<span class="number">0x08</span>);</span><br><span class="line">Motor_Speed_Set(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//停车</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//正常巡线</span></span><br><span class="line">{</span><br><span class="line">Turn_PWM = Trace_PID();</span><br><span class="line">Speed_left = Speed_Velcolity - Turn_PWM;</span><br><span class="line">Speed_right = Speed_Velcolity + Turn_PWM;</span><br><span class="line">Motor_Speed_Set(Speed_left,Speed_right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;小车基本控制设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#小车基本控制设计&quot;&gt;&lt;/a&gt; 小车基本控制设计&lt;/h1&gt;
&lt;h2 id=&quot;一-前期系统分析与设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MSPM0G3507" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MSPM0G3507/"/>
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】PID平衡小车项目实战</title>
    <link href="https://szturin.github.io/posts/25248/"/>
    <id>https://szturin.github.io/posts/25248/</id>
    <published>2024-06-09T08:22:17.000Z</published>
    <updated>2024-09-03T08:44:27.641Z</updated>
    
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[Hal库][1]Hal库初始化配置</title>
    <link href="https://szturin.github.io/posts/253/"/>
    <id>https://szturin.github.io/posts/253/</id>
    <published>2024-06-09T07:31:45.000Z</published>
    <updated>2024-09-03T04:22:30.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><ul><li>xxxxxxxxxx&nbsp;$ tags: -数字电路与VHDL设计"bash</li><li>需要安装java环境，才能正常允许CubeMX</li><li>确保以及安装了Keil MDK，Keil完成了stm32的芯片包配置，至少下载串口通信（FLY MCU） , STLink Unit中其中一款下载/串口通信软件。</li></ul><h1 id="一-cubemx初始配置"><a class="markdownIt-Anchor" href="#一-cubemx初始配置"></a> 一、CubeMX初始配置</h1><h2 id="1cubemx安装芯片固件包"><a class="markdownIt-Anchor" href="#1cubemx安装芯片固件包"></a> 1.CubeMX安装芯片固件包</h2><img src="/posts/253/image-20240609153709278.png" class="" title="image-20240609153709278"><p>xxxxxxxxxx&nbsp;typedef struct//typedef为成员列表提供了一个GPIO_InitTypeDef的名字{}GPIO_InitTypeDef;c</p><p><strong>像常用的stm32f103c8t6，我们就选择STM32F1，勾选最新固件包，点击Install Now进行在线安装</strong></p><hr><img src="/posts/253/image-20240609155414174.png" class="" title="image-20240609155414174"><hr><h2 id="2工程创建"><a class="markdownIt-Anchor" href="#2工程创建"></a> 2.工程创建</h2><p>1.打开stm32cubeMX，File &gt; New project &gt;MCU/MPU Selector &gt;Part Number<br>2.输入stm32f103c8,Start Project<br>3.Project Manager &gt; Project</p><h2 id="3引脚配置"><a class="markdownIt-Anchor" href="#3引脚配置"></a> 3.引脚配置</h2><img src="/posts/253/image-20240609154359188.png" class="" title="image-20240609154359188"><h2 id="3外设配置"><a class="markdownIt-Anchor" href="#3外设配置"></a> 3.外设配置</h2><p><mark>GPIO属性配置</mark></p><img src="/posts/253/image-20240609155305797.png" class="" title="image-20240609155305797"><blockquote><p>GPIO output level &gt; High 输出等级 高</p><p>GPIO mode Output &gt; Push Pull 输出模式 推挽输出</p><p>GPIO Pull-up/Pull-down &gt; Pull-down 初始输出 设为低</p><p>User Label &gt;  用户标签，方便代码中使用，如图：</p><p>​<img src="/posts/253/image-20240609154825836.png" class="" title="image-20240609154825836"></p></blockquote><img src="/posts/253/image-20240609154611816.png" class="" title="image-20240609154611816"><p><mark>配置时钟模式</mark></p><p>Pinout &amp; Configuration &gt; A-Z &gt; RCC &gt; High Speed Clock<br>Crystal/Ceramic Resonator 使用外部时钟源</p><img src="/posts/253/image-20240609155203231.png" class="" title="image-20240609155203231"><p><mark>时钟可视化配置</mark></p><p>Clock Configuration<br>选中HSE,倍频x9，不分频</p><img src="/posts/253/image-20240609154912764.png" class="" title="image-20240609154912764"><h2 id="4工程设置"><a class="markdownIt-Anchor" href="#4工程设置"></a> 4.工程设置</h2><blockquote><p>Project Name 项目名称，填写led</p><p>Project Location 项目位置，选择一个你喜欢的文件夹，不要出现中文 Toolchain/IDE</p><p>交叉编译链，选择MDK，V5</p><p>勾选 Use latest available version</p></blockquote><img src="/posts/253/image-20240609155924976.png" class="" title="image-20240609155924976"><blockquote><p>Project Manager &gt; Code Generator</p><p>勾选Generate peripheral…</p></blockquote><img src="/posts/253/image-20240609160038284.png" class="" title="image-20240609160038284"><blockquote><p>其余默认配置即可</p></blockquote><img src="/posts/253/image-20240609160159606.png" class="" title="image-20240609160159606"><blockquote><p>GENERATE CODE生成代码，Open Project</p></blockquote><h1 id="二-mdk代码编写"><a class="markdownIt-Anchor" href="#二-mdk代码编写"></a> 二、MDK代码编写</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">  HAL_Init();<span class="comment">//HAL库初始化</span></span><br><span class="line">  SystemClock_Config();<span class="comment">//时钟初始化</span></span><br><span class="line">  MX_GPIO_Init();<span class="comment">//GPIO初始化</span></span><br><span class="line"><span class="comment">/* USER CODE END 1 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_5);<span class="comment">//翻转引脚电平</span></span><br><span class="line">  HAL_Delay(<span class="number">500</span>);<span class="comment">//延时500ms</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em><em>==注意：    /</em> USER CODE BEGIN 3 <em>/之内的代码不会杯CubeMX重新生成代码时覆盖掉！ /</em> USER CODE END 3 <em>/==</em></em></p><img src="/posts/253/image-20240609160459831.png" class="" title="image-20240609160459831"><img src="/posts/253/image-20240609160610985.png" class="" title="image-20240609160610985"><p>下载后编译，观察PA5引脚电平变化（利用LED），是否以0.5s周期变化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;xxxxxxxxxx&amp;nbsp;$ tags: -数字电路与VHDL设计&quot;bash&lt;/li&gt;
&lt;li&gt;需要安装java环境，才能正常</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
  </entry>
  
  <entry>
    <title>【蓝桥杯单片机】客观题</title>
    <link href="https://szturin.github.io/posts/24737/"/>
    <id>https://szturin.github.io/posts/24737/</id>
    <published>2024-05-26T04:04:07.000Z</published>
    <updated>2024-09-03T04:20:24.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rc低通滤波器"><a class="markdownIt-Anchor" href="#rc低通滤波器"></a> RC低通滤波器</h1><h2 id="截止频率"><a class="markdownIt-Anchor" href="#截止频率"></a> 截止频率</h2><img src="/posts/24737/image-20240526121741003.png" class="" title="image-20240526121741003">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rc低通滤波器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rc低通滤波器&quot;&gt;&lt;/a&gt; RC低通滤波器&lt;/h1&gt;
&lt;h2 id=&quot;截止频率&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#截止频率&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="学习笔记,蓝桥杯" scheme="https://szturin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[11]IIC通信(mpu6050)</title>
    <link href="https://szturin.github.io/posts/5621/"/>
    <id>https://szturin.github.io/posts/5621/</id>
    <published>2024-05-24T12:55:20.000Z</published>
    <updated>2024-09-03T10:37:46.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iic通信协议"><a class="markdownIt-Anchor" href="#iic通信协议"></a> IIC通信协议</h1><h2 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h2><ul><li><p>同步时序的稳定性比异步时序更高</p></li><li><p>半双工</p></li><li><p>SCL、SDA两根通信线</p></li><li><p>支持总线挂载（一主多从，多主多从）</p></li></ul><h2 id="硬件电路"><a class="markdownIt-Anchor" href="#硬件电路"></a> 硬件电路</h2><ul><li>所有I2C设备的SCL连接在一起，SDA连接在一起</li><li>设备的SCL和SDA均要配置成开漏输出模式(防止形成短路电流，SDA要么<mark>被上拉</mark>，要么<mark>输出低电平</mark>)，会有“线与”的现象。在多主机的模式下，可以利用线与的特性，实现总线仲裁和时钟同步。</li><li>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</li></ul><img src="/posts/5621/image-20240524211453559.png" class="" title="image-20240524211453559"><hr><img src="/posts/5621/image-20240524212810776.png" class="" title="image-20240524212810776"><p><strong>PS：IIC时序是高位先行，串口是低位先行</strong></p><hr><img src="/posts/5621/image-20240524212934134.png" class="" title="image-20240524212934134"><p><strong>PS：主机接收时，需要释放SDA，即输入模式</strong></p><hr><img src="/posts/5621/image-20240524213709342.png" class="" title="image-20240524213709342"><p><strong>PS:从机的地址可以通过电路改变</strong></p><hr><img src="/posts/5621/image-20240524214219090.png" class="" title="image-20240524214219090"><p><strong><mark>红线处，此时需要从机应答，这里如果但看主机的SDA，应该会释放SDA，即高电平，由于从机要发送应答，根据线与的特性，这里拉低了SDA，所以最后SDA呈现图中所示。</mark></strong></p><hr><img src="/posts/5621/image-20240524214908190.png" class="" title="image-20240524214908190"><p><strong>IIC通信的设备中会有单独一个字节空间存储地址指针，当给IIC设备指定地址写时，地址指针会加一，这时如果使用当前地址读，就是读取指针地址指向的内存。此时序较为少用、</strong></p><hr><img src="/posts/5621/image-20240524215204768.png" class="" title="image-20240524215204768"><p><strong><mark>指定地址读的实现原理：先调用指定地址写，但是不写数据。再次调用当前地址读，这样复合的时序就能完成指定地址读的功能了</mark></strong></p><h1 id="mpu6050"><a class="markdownIt-Anchor" href="#mpu6050"></a> MPU6050</h1><img src="/posts/5621/image-20240524220155605.png" class="" title="image-20240524220155605"><h2 id="姿态角欧拉角"><a class="markdownIt-Anchor" href="#姿态角欧拉角"></a> 姿态角（欧拉角）</h2><img src="/posts/5621/image-20240524220352017.png" class="" title="image-20240524220352017"><p><strong>飞机相对于初始三个轴的夹角：</strong></p><ul><li>俯仰角：Pitch</li><li>滚转：Roll</li><li>偏航：Yaw</li></ul><p>要想获得稳定的欧拉角，就需要进行数据融合，进一步得到姿态角。</p><p><strong>常见的数据融合算法：</strong></p><ul><li>互补滤波</li><li>卡尔曼滤波</li></ul><p>ps:惯性导航领域里，姿态解算</p><h2 id="加速度计结构"><a class="markdownIt-Anchor" href="#加速度计结构"></a> 加速度计结构</h2><img src="/posts/5621/image-20240524220855509.png" class="" title="image-20240524220855509"><p><strong>F=ma(测力计)</strong></p><img src="/posts/5621/image-20240524221000525.png" class="" title="image-20240524221000525"><p><strong><mark>加速度计测得的是静态加速度，只能在物体静止的时候使用</mark></strong></p><h2 id="陀螺仪传感器"><a class="markdownIt-Anchor" href="#陀螺仪传感器"></a> 陀螺仪传感器</h2><img src="/posts/5621/image-20240524221506605.png" class="" title="image-20240524221506605"><p><strong>测得的是角速度，要想得到角度，可以进行求积分</strong></p><p><strong><mark>陀螺仪具有动态稳定性，不具有静态稳定性</mark></strong></p><p><strong><mark>对两种传感器进行互补滤波，就可以得到稳定的姿态角了</mark></strong></p><h2 id="mpu6050的参数"><a class="markdownIt-Anchor" href="#mpu6050的参数"></a> MPU6050的参数</h2><img src="/posts/5621/image-20240524221944683.png" class="" title="image-20240524221944683"><p>eg: mpu6050的从机地址：0x68 ，IIC时序中发送的第一个字节，高七位为从机地址，第八位为读写位。有时候把0XD0当作MPU6050的地址</p><h2 id="硬件结构"><a class="markdownIt-Anchor" href="#硬件结构"></a> 硬件结构</h2><img src="/posts/5621/image-20240525205511856.png" class="" title="image-20240525205511856"><blockquote><p><strong>六轴传感器的缺点：没有稳定的参考方向</strong></p><p>XCL，XDA：挂载磁力计，气压计</p><p>INT引脚：可以配置MPU6050内部一些事件，产生电平跳变</p><p>PS：MPU6050内部包含DMP单元：进行姿态融合和数据结算</p><p>包含稳压电路</p></blockquote><p><mark><strong>传感器内部含有自测单元</strong></mark></p><img src="/posts/5621/image-20240525210718105.png" class="" title="image-20240525210718105"><p>使能自测-&gt;读取数据1-&gt;失能自测-&gt;读取数据2，两个数据相减，得到的数据称作自测响应，自测响应如果在<mark>规定的范围内</mark>，说明芯片性能没问题。</p><hr><p><strong>电荷泵</strong></p><img src="/posts/5621/image-20240525210953979.png" class="" title="image-20240525210953979"><p>是一种<mark>升压电路</mark></p><p>原理：电源和电容串并联的切换（充电-&gt;串联-&gt;相当于电压升高（放电）-&gt;快速切换到并联-&gt;充电-&gt;循环）+ 电容滤波 = 平稳升压</p><img src="/posts/5621/image-20240525211051107.png" class="" title="image-20240525211051107"><hr><p><strong>DMP</strong>（数字运动处理器）</p><img src="/posts/5621/image-20240525211323304.png" class="" title="image-20240525211323304"><p>配合MPU6050官方的DMP库，进行姿态解算。</p><p><mark>引脚说明</mark></p><blockquote><p>FSYNC：帧同步</p></blockquote><blockquote><p>通信接口：用于和STM32通信</p><img src="/posts/5621/image-20240525211535797.png" class="" title="image-20240525211535797"></blockquote><blockquote><p>xxxxxxxxxx&nbsp;python script_name.py --train_data_dir “path/to/train_data” --test_data_dir “path/to/test_data” --img_height 128 --img_width 128 --batch_size 64 --epochs 15python</p><p>​可以拓展连接磁力计</p><img src="/posts/5621/image-20240525211622949.png" class="" title="image-20240525211622949"></blockquote><hr><h2 id="软件iic读写mpu6050"><a class="markdownIt-Anchor" href="#软件iic读写mpu6050"></a> 软件IIC读写MPU6050</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MyIIC.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主机寻址MPU6050*/</span></span><br><span class="line">MyIIC_Init();</span><br><span class="line">MyIIC_Start();</span><br><span class="line">MyIIC_SendByte(<span class="number">0xD0</span>);<span class="comment">//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="type">uint8_t</span> Ack = MyIIC_ReceiveAck();</span><br><span class="line">MyIIC_Stop();</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,Ack,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> <img src="/posts/5621/image-20240525224436566.png" class="" title="image-20240525224436566"><hr><p><strong>修改MPU6050地址</strong></p><p>可见，寻址无应答</p><img src="/posts/5621/image-20240526152458852.png" class="" title="image-20240526152458852"><hr><p><strong>读取MPU6050 ID号</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="comment">/*//主机寻址MPU6050</span></span><br><span class="line"><span class="comment">MyIIC_Init();</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(0xD2);//1101 000 0 前七位为MPU6050的从机地址</span></span><br><span class="line"><span class="comment">uint8_t Ack = MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">OLED_ShowNum(1,1,Ack,3);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//读取MPU6050ID号</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154358599.png" class="" title="image-20240526154358599"><hr><p><strong>写MPU6050</strong>，需要关闭MPU6050的睡眠模式</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//在电源管理器1，写入0x00，接触睡眠模式</span></span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//更改采样频率</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x19</span>);<span class="comment">//读取MPU6050采样频率</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/5621/image-20240526154723015.png" class="" title="image-20240526154723015"><p><strong>PS:某种程度上来说，对寄存器的读写操作可以看作读写一个存储器，但是寄存器能反应硬件电路的状态，对硬件电路进行操作</strong></p><hr><h2 id="mpu6050读取六轴姿态值"><a class="markdownIt-Anchor" href="#mpu6050读取六轴姿态值"></a> MPU6050读取六轴姿态值</h2><p><strong>函数定义</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用指针，实现函数多返回值的操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params"><span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> DataH ,DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">*AccX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">*AccY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">*AccZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">*GyroX = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">*GyroY = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">DataL=MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">*GyroZ = (DataH&lt;&lt;<span class="number">8</span>) | DataL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>主程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int16_t</span> Ax,Ay,Az,Gx,Gy,Gz;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">MPU6050_GetData(&amp;Ax,&amp;Ay,&amp;Az,&amp;Gx,&amp;Gy,&amp;Gz);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">1</span>,Ax,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">1</span>,Ay,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">1</span>,Az,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">8</span>,Gx,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">8</span>,Gy,<span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">8</span>,Gz,<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>加速度计最大量程为16g</strong></p><img src="/posts/5621/image-20240526162104183.png" class="" title="image-20240526162104183"><p>左侧为加速度计，右侧为角速度测量值</p><hr><h2 id="硬件iic读写mpu6050"><a class="markdownIt-Anchor" href="#硬件iic读写mpu6050"></a> 硬件IIC读写MPU6050</h2><p>CR：控制寄存器</p><p>DR：数据寄存器</p><p>SR：状态寄存器</p><p><strong>STM32IIC外设</strong></p><img src="/posts/5621/image-20240526162959527.png" class="" title="image-20240526162959527"><h3 id="多主机模型"><a class="markdownIt-Anchor" href="#多主机模型"></a> 多主机模型</h3><p><strong>一主多从</strong></p><img src="/posts/5621/image-20240526163123491.png" class="" title="image-20240526163123491"><p><strong>多主多从</strong></p><p>固定多主机：</p><img src="/posts/5621/image-20240526163142347.png" class="" title="image-20240526163142347"><p>可变多主机：</p><img src="/posts/5621/image-20240526163226138.png" class="" title="image-20240526163226138"><p><strong>GPIO复用输入和复用输出</strong></p><img src="/posts/5621/image-20240526164412282.png" class="" title="image-20240526164412282"><p><strong>IIC主机发送流程图</strong></p><img src="/posts/5621/image-20240526165109626.png" class="" title="image-20240526165109626"><p><strong>IIC主机接收流程图</strong></p><img src="/posts/5621/image-20240526165718823.png" class="" title="image-20240526165718823"><h3 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h3><blockquote><p><strong>产生起始条件</strong></p><p>void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>生成终止条件</strong></p><p>void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>配置在收到一个字节后，是否给从机应答</strong></p><p>void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);</p><p><strong>写数据到数据寄存器DR</strong></p><p>void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);</p><p><strong>读取DR的数据，作为返回值</strong></p><p>uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);</p><p><strong>发送7位地址</strong></p><p>void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);</p></blockquote><p><strong>状态监控函数的官方说明</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> ****************************************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                         I2C State Monitoring Functions</span></span><br><span class="line"><span class="comment"> *                       </span></span><br><span class="line"><span class="comment"> ****************************************************************************************   </span></span><br><span class="line"><span class="comment"> * This I2C driver provides three different ways for I2C state monitoring</span></span><br><span class="line"><span class="comment"> *  depending on the application requirements and constraints:</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 1) Basic state monitoring:</span></span><br><span class="line"><span class="comment"> *    Using I2C_CheckEvent() function:</span></span><br><span class="line"><span class="comment"> *    It compares the status registers (SR1 and SR2) content to a given event</span></span><br><span class="line"><span class="comment"> *    (can be the combination of one or more flags).</span></span><br><span class="line"><span class="comment"> *    It returns SUCCESS if the current status includes the given flags </span></span><br><span class="line"><span class="comment"> *    and returns ERROR if one or more flags are missing in the current status.</span></span><br><span class="line"><span class="comment"> *    - When to use:</span></span><br><span class="line"><span class="comment"> *      - This function is suitable for most applications as well as for startup </span></span><br><span class="line"><span class="comment"> *      activity since the events are fully described in the product reference manual </span></span><br><span class="line"><span class="comment"> *      (RM0008).</span></span><br><span class="line"><span class="comment"> *      - It is also suitable for users who need to define their own events.</span></span><br><span class="line"><span class="comment"> *    - Limitations:</span></span><br><span class="line"><span class="comment"> *      - If an error occurs (ie. error flags are set besides to the monitored flags),</span></span><br><span class="line"><span class="comment"> *        the I2C_CheckEvent() function may return SUCCESS despite the communication</span></span><br><span class="line"><span class="comment"> *        hold or corrupted real state. </span></span><br><span class="line"><span class="comment"> *        In this case, it is advised to use error interrupts to monitor the error</span></span><br><span class="line"><span class="comment"> *        events and handle them in the interrupt IRQ handler.</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *        @note </span></span><br><span class="line"><span class="comment"> *        For error management, it is advised to use the following functions:</span></span><br><span class="line"><span class="comment"> *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).</span></span><br><span class="line"><span class="comment"> *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.</span></span><br><span class="line"><span class="comment"> *            Where x is the peripheral instance (I2C1, I2C2 ...)</span></span><br><span class="line"><span class="comment"> *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()</span></span><br><span class="line"><span class="comment"> *            in order to determine which error occurred.</span></span><br><span class="line"><span class="comment"> *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()</span></span><br><span class="line"><span class="comment"> *            and/or I2C_GenerateStop() in order to clear the error flag and source,</span></span><br><span class="line"><span class="comment"> *            and return to correct communication status.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  2) Advanced state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetLastEvent() which returns the image of both status </span></span><br><span class="line"><span class="comment"> *     registers in a single word (uint32_t) (Status Register 2 value is shifted left </span></span><br><span class="line"><span class="comment"> *     by 16 bits and concatenated to Status Register 1).</span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *       - This function is suitable for the same applications above but it allows to</span></span><br><span class="line"><span class="comment"> *         overcome the limitations of I2C_GetFlagStatus() function (see below).</span></span><br><span class="line"><span class="comment"> *         The returned value could be compared to events already defined in the </span></span><br><span class="line"><span class="comment"> *         library (stm32f10x_i2c.h) or to custom values defined by user.</span></span><br><span class="line"><span class="comment"> *       - This function is suitable when multiple flags are monitored at the same time.</span></span><br><span class="line"><span class="comment"> *       - At the opposite of I2C_CheckEvent() function, this function allows user to</span></span><br><span class="line"><span class="comment"> *         choose when an event is accepted (when all events flags are set and no </span></span><br><span class="line"><span class="comment"> *         other flags are set or just when the needed flags are set like </span></span><br><span class="line"><span class="comment"> *         I2C_CheckEvent() function).</span></span><br><span class="line"><span class="comment"> *     - Limitations:</span></span><br><span class="line"><span class="comment"> *       - User may need to define his own events.</span></span><br><span class="line"><span class="comment"> *       - Same remark concerning the error management is applicable for this </span></span><br><span class="line"><span class="comment"> *         function if user decides to check only regular communication flags (and </span></span><br><span class="line"><span class="comment"> *         ignores error flags).</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3) Flag-based state monitoring:</span></span><br><span class="line"><span class="comment"> *     Using the function I2C_GetFlagStatus() which simply returns the status of </span></span><br><span class="line"><span class="comment"> *     one single flag (ie. I2C_FLAG_RXNE ...). </span></span><br><span class="line"><span class="comment"> *     - When to use:</span></span><br><span class="line"><span class="comment"> *        - This function could be used for specific applications or in debug phase.</span></span><br><span class="line"><span class="comment"> *        - It is suitable when only one flag checking is needed (most I2C events </span></span><br><span class="line"><span class="comment"> *          are monitored through multiple flags).</span></span><br><span class="line"><span class="comment"> *     - Limitations: </span></span><br><span class="line"><span class="comment"> *        - When calling this function, the Status register is accessed. Some flags are</span></span><br><span class="line"><span class="comment"> *          cleared when the status register is accessed. So checking the status</span></span><br><span class="line"><span class="comment"> *          of one Flag, may clear other ones.</span></span><br><span class="line"><span class="comment"> *        - Function may need to be called twice or more in order to monitor one </span></span><br><span class="line"><span class="comment"> *          single event.</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="iic配置占空比的缘由"><a class="markdownIt-Anchor" href="#iic配置占空比的缘由"></a> #IIC配置占空比的缘由</h3><p><strong>上升沿变化较慢，下降沿比较迅速，标准速度下，时钟占空比接近1：1，快速状态，占空比接近2：1</strong></p><img src="/posts/5621/image-20240526174725131.png" class="" title="image-20240526174725131"><p>100KHZ</p><img src="/posts/5621/image-20240526174831972.png" class="" title="image-20240526174831972"><p>400KHZ</p><img src="/posts/5621/image-20240526174841651.png" class="" title="image-20240526174841651"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> *  <span class="number">1</span>) Basic state monitoring</span><br><span class="line"> *******************************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Checks whether the last I2Cx Event is equal to the one passed</span></span><br><span class="line"><span class="comment">  *   as parameter.</span></span><br><span class="line"><span class="comment">  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.</span></span><br><span class="line"><span class="comment">  * @param  I2C_EVENT: specifies the event to be checked. </span></span><br><span class="line"><span class="comment">  *   This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3</span></span><br><span class="line"><span class="comment">  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     </span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2</span></span><br><span class="line"><span class="comment">  *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9</span></span><br><span class="line"><span class="comment">  *     </span></span><br><span class="line"><span class="comment">  * @note: For detailed description of Events, please refer to section </span></span><br><span class="line"><span class="comment">  *    I2C_Events in stm32f10x_i2c.h file.</span></span><br><span class="line"><span class="comment">  *    </span></span><br><span class="line"><span class="comment">  * @retval An ErrorStatus enumeration value:</span></span><br><span class="line"><span class="comment">  * - SUCCESS: Last event is equal to the I2C_EVENT</span></span><br><span class="line"><span class="comment">  * - ERROR: Last event is different from the I2C_EVENT</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解决while死循环等待的问题"><a class="markdownIt-Anchor" href="#解决while死循环等待的问题"></a> 解决WHILE死循环等待的问题</h3><p><strong>多个while,比较危险，一旦通信出现问题，程序直接卡死</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*软件I2C，阻塞式程序</span></span><br><span class="line"><span class="comment">MyIIC_Start();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();//可以加判断，确保时序的正确</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(RegAddress);//指定要写入的寄存器</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_SendByte(Data);</span></span><br><span class="line"><span class="comment">MyIIC_ReceiveAck();</span></span><br><span class="line"><span class="comment">MyIIC_Stop();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//硬件IIC，非阻塞式程序</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT ) !=SUCCESS);<span class="comment">//事件监测</span></span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//选择I2C外设，从机地址，从机地址最低位。此函数自带接收应答的功能</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,RegAddress);<span class="comment">//写入DR，需要等待EV8事件</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) !=SUCCESS);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2,Data);</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) !=SUCCESS);<span class="comment">//发送完最后一个字节，需要监测EB8_1事件</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTOP(I2C2,ENABLE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>保护程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Timeout;</span><br><span class="line">Timeout= <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2Cx,I2C_EVENT) != SUCCESS)</span><br><span class="line">{</span><br><span class="line">Timeout--;</span><br><span class="line"><span class="keyword">if</span>(Timeout==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="dmp库"><a class="markdownIt-Anchor" href="#dmp库"></a> DMP库</h1><p>digital motion processor数字运动处理器，mpu6050自带的一个硬件，可以直接输出用于姿态结算的四元数</p><h1 id="卡尔曼滤波"><a class="markdownIt-Anchor" href="#卡尔曼滤波"></a> 卡尔曼滤波</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iic通信协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#iic通信协议&quot;&gt;&lt;/a&gt; IIC通信协议&lt;/h1&gt;
&lt;h2 id=&quot;基本功能&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本功能&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STM32" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STM32/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="IIC" scheme="https://szturin.github.io/tags/IIC/"/>
    
  </entry>
  
</feed>
