<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Turin&#39;s Blog</title>
  
  <subtitle>数理照亮世界</subtitle>
  <link href="https://szturin.github.io/atom.xml" rel="self"/>
  
  <link href="https://szturin.github.io/"/>
  <updated>2024-05-25T11:44:02.792Z</updated>
  <id>https://szturin.github.io/</id>
  
  <author>
    <name>Szturin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【stm32单片机】[11]IIC通信(mpu6050)</title>
    <link href="https://szturin.github.io/posts/5621/"/>
    <id>https://szturin.github.io/posts/5621/</id>
    <published>2024-05-24T12:55:20.000Z</published>
    <updated>2024-05-25T11:44:02.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iic通信协议"><a class="markdownIt-Anchor" href="#iic通信协议"></a> IIC通信协议</h1><h2 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h2><ul><li><p>同步时序的稳定性比异步时序更高</p></li><li><p>半双工</p></li><li><p>SCL、SDA两根通信线</p></li><li><p>支持总线挂载（一主多从，多主多从）</p></li></ul><h2 id="硬件电路"><a class="markdownIt-Anchor" href="#硬件电路"></a> 硬件电路</h2><ul><li>所有I2C设备的SCL连接在一起，SDA连接在一起</li><li>设备的SCL和SDA均要配置成开漏输出模式(防止形成短路电流，SDA要么<mark>被上拉</mark>，要么<mark>输出低电平</mark>)，会有“线与”的现象。在多主机的模式下，可以利用线与的特性，实现总线仲裁和时钟同步。</li><li>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</li></ul><img src="/posts/undefined/image-20240524211453559.png" class="" title="image-20240524211453559"><hr><img src="/posts/undefined/image-20240524212810776.png" class="" title="image-20240524212810776"><p><strong>PS：IIC时序是高位先行，串口是低位先行</strong></p><hr><img src="/posts/undefined/image-20240524212934134.png" class="" title="image-20240524212934134"><p><strong>PS：主机接收时，需要释放SDA，即输入模式</strong></p><hr><img src="/posts/undefined/image-20240524213709342.png" class="" title="image-20240524213709342"><p><strong>PS:从机的地址可以通过电路改变</strong></p><hr><img src="/posts/undefined/image-20240524214219090.png" class="" title="image-20240524214219090"><p><strong><mark>红线处，此时需要从机应答，这里如果但看主机的SDA，应该会释放SDA，即高电平，由于从机要发送应答，根据线与的特性，这里拉低了SDA，所以最后SDA呈现图中所示。</mark></strong></p><hr><img src="/posts/undefined/image-20240524214908190.png" class="" title="image-20240524214908190"><p><strong>IIC通信的设备中会有单独一个字节空间存储地址指针，当给IIC设备指定地址写时，地址指针会加一，这时如果使用当前地址读，就是读取指针地址指向的内存。此时序较为少用、</strong></p><hr><img src="/posts/undefined/image-20240524215204768.png" class="" title="image-20240524215204768"><p><strong><mark>指定地址读的实现原理：先调用指定地址写，但是不写数据。再次调用当前地址读，这样复合的时序就能完成指定地址读的功能了</mark></strong></p><h1 id="mpu6050"><a class="markdownIt-Anchor" href="#mpu6050"></a> MPU6050</h1><img src="/posts/undefined/image-20240524220155605.png" class="" title="image-20240524220155605"><h2 id="姿态角欧拉角"><a class="markdownIt-Anchor" href="#姿态角欧拉角"></a> 姿态角（欧拉角）</h2><img src="/posts/undefined/image-20240524220352017.png" class="" title="image-20240524220352017"><p><strong>飞机相对于初始三个轴的夹角：</strong></p><ul><li>俯仰角：Pitch</li><li>滚转：Roll</li><li>偏航：Yaw</li></ul><p>要想获得稳定的欧拉角，就需要进行数据融合，进一步得到姿态角。</p><p><strong>常见的数据融合算法：</strong></p><ul><li>互补滤波</li><li>卡尔曼滤波</li></ul><p>ps:惯性导航领域里，姿态解算</p><h2 id="加速度计结构"><a class="markdownIt-Anchor" href="#加速度计结构"></a> 加速度计结构</h2><img src="/posts/undefined/image-20240524220855509.png" class="" title="image-20240524220855509"><p><strong>F=ma(测力计)</strong></p><img src="/posts/undefined/image-20240524221000525.png" class="" title="image-20240524221000525"><p><strong><mark>加速度计测得的是静态加速度，只能在物体静止的时候使用</mark></strong></p><h2 id="陀螺仪传感器"><a class="markdownIt-Anchor" href="#陀螺仪传感器"></a> 陀螺仪传感器</h2><img src="/posts/undefined/image-20240524221506605.png" class="" title="image-20240524221506605"><p><strong>测得的是角速度，要想得到角度，可以进行求积分</strong></p><p><strong><mark>陀螺仪具有动态稳定性，不具有静态稳定性</mark></strong></p><p><strong><mark>对两种传感器进行互补滤波，就可以得到稳定的姿态角了</mark></strong></p><h2 id="mpu6050的参数"><a class="markdownIt-Anchor" href="#mpu6050的参数"></a> MPU6050的参数</h2><img src="/posts/undefined/image-20240524221944683.png" class="" title="image-20240524221944683">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iic通信协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#iic通信协议&quot;&gt;&lt;/a&gt; IIC通信协议&lt;/h1&gt;
&lt;h2 id=&quot;基本功能&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本功能&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="IIC" scheme="https://szturin.github.io/tags/IIC/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[9]DMA数据转运</title>
    <link href="https://szturin.github.io/posts/10712/"/>
    <id>https://szturin.github.io/posts/10712/</id>
    <published>2024-05-22T03:44:18.000Z</published>
    <updated>2024-05-25T11:44:00.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h1><blockquote><p><strong>恢复缺省配置</strong></p><p>void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>初始化DMA</strong></p><p>void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);</p><p><strong>DMA使能</strong></p><p>void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);</p><p><strong>中断输出使能</strong></p><p>void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);</p><p><strong>DMA设置当前数据寄存器</strong></p><p>void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);</p><p><strong>DMA获取当前数据寄存器</strong></p><p>uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);</p><p><strong>获取DMA标志位状态</strong></p><p>FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);</p><p><strong>清除DMA标志位</strong></p><p>void DMA_ClearFlag(uint32_t DMAy_FLAG);</p><p><strong>获取DMA中断标志位状态</strong></p><p>ITStatus DMA_GetITStatus(uint32_t DMAy_IT);</p><p><strong>清除DMA中断标志位</strong></p><p>void DMA_ClearITPendingBit(uint32_t DMAy_IT);</p><p><strong>开启ADC DMA触发信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p></blockquote><ul><li><p><strong><mark>DMA是AHB总线的设备</mark></strong></p></li><li><p><strong><mark>DMA软件触发和硬件触发不能同时使用，如果同时使用DMA就会连续触发</mark></strong></p></li><li><p>DMA转运有三个条件：1.传输计数器大于0 2.触发源有触发信号 3.DMA使能</p></li></ul><h1 id="一-dma数据转运"><a class="markdownIt-Anchor" href="#一-dma数据转运"></a> 一、DMA数据转运</h1><h2 id="1stm32单片机ram和rom"><a class="markdownIt-Anchor" href="#1stm32单片机ram和rom"></a> 1.stm32单片机RAM和ROM</h2><h3 id="不加const修饰"><a class="markdownIt-Anchor" href="#不加const修饰"></a> 不加const修饰</h3><img src="/posts/10712/image-20240522115326572.png" class="" title="image-20240522115326572"><h3 id="加上const修饰"><a class="markdownIt-Anchor" href="#加上const修饰"></a> 加上const修饰</h3><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> aa =<span class="number">0x66</span>;<span class="comment">//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,aa,<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;aa,<span class="number">8</span>);<span class="comment">//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>现象</strong></p><p>flash里面编译的代码部分，地址位于flah最前面，所以这里变量的显示在靠后的地址</p><img src="/posts/10712/image-20240522115450140.png" class="" title="image-20240522115450140"><h2 id="const关键字节省sram空间"><a class="markdownIt-Anchor" href="#const关键字节省sram空间"></a> const关键字节省SRAM空间</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED字模库，宽8像素，高16像素*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> OLED_F8x16[][<span class="number">16</span>]=</span><br><span class="line">{</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">//  0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="结构体访问寄存器ram地址"><a class="markdownIt-Anchor" href="#结构体访问寄存器ram地址"></a> 结构体访问寄存器RAM地址</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR,<span class="number">8</span>);</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522115913765.png" class="" title="image-20240522115913765"><p><strong><mark>外设的起始地址+寄存器的偏移地址=指定寄存器的地址</mark></strong></p><p><strong><mark>使用结构体访问，指定地址对应寄存器，这样，结构体访问就是寄存器的地址</mark></strong></p><h2 id="2dma转运数组"><a class="markdownIt-Anchor" href="#2dma转运数组"></a> 2.DMA转运数组</h2><p><strong>软件触发代码部分</strong></p> <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522143322783.png" class="" title="image-20240522143322783"><h2 id="3dma软件触发"><a class="markdownIt-Anchor" href="#3dma软件触发"></a> 3.DMA软件触发</h2><img src="/posts/10712/image-20240522144732279.png" class="" title="image-20240522144732279"><p><strong>DMA传输计数器软件重装</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyDMA_Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数DMA初始化配置</span></span><br><span class="line"><span class="comment">  * @参数要转运数据的首地址，存储器站点的起始地址，传输次数</span></span><br><span class="line"><span class="comment">  * @返回值</span></span><br><span class="line"><span class="comment">  * @特殊说明</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint16_t</span> Size)</span></span><br><span class="line">{</span><br><span class="line">MyDMA_Size=Size;</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=Size;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Enable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=AddrB;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;<span class="comment">//以字节传输</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;</span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=AddrA;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte;<span class="comment">//转运数据宽度为一个字节</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，所以通道可以任意选择</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,MyDMA_Size);</span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyDMA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const uint8_t aa =0x66;//使用const修饰完成的常变量，贮存在flash里面</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[]={<span class="number">0X01</span>,<span class="number">0X02</span>,<span class="number">0X03</span>,<span class="number">0X04</span>};</span><br><span class="line"><span class="type">uint8_t</span> DataB[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"><span class="comment">//OLED_ShowHexNum(1,1,aa,2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,1,(uint32_t)&amp;ADC1-&gt;DR,8);//stm32单片机为32位系统，地址为32位，需要加上强制类型转换，如果不加，相当于指针跨级赋值了</span></span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"DataA"</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">"DataB"</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataA,<span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataB,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">DataA[<span class="number">0</span>]++;</span><br><span class="line">DataA[<span class="number">1</span>]++;</span><br><span class="line">DataA[<span class="number">2</span>]++;</span><br><span class="line">DataA[<span class="number">3</span>]++;</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">MyDMA_Transfer();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/10712/image-20240522145131191.png" class="" title="image-20240522145131191"><p><strong>将DataA用const修饰</strong></p><p>DataA此时为flash里面的变量，所以地址为08开头</p><img src="/posts/10712/image-20240522145359406.png" class="" title="image-20240522145359406"><h1 id="adc-dma转运"><a class="markdownIt-Anchor" href="#adc-dma转运"></a> ADC+ DMA转运</h1><p><strong>ADC单次扫描，DMA单次转运+软件触发</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD_Value[<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=DISABLE;<span class="comment">//单次模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;<span class="comment">//传输模式，是否使用自动重装,这里选择正常模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);<span class="comment">//给DMA传输计数器赋值，需要关闭CMD</span></span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,<span class="number">4</span>);<span class="comment">//传输次数给4</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里选择了ADC触发DMA，标志位自动清零，所以不需要软件清零</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);//等待转换完成标志位置1</span></span><br><span class="line"><span class="comment">return ADC_GetConversionValue(ADC1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA转运完成总是在ADC完成之后的，所以这里等待DMA状态标志位即可*/</span></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除转运标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>ADC连续扫描+DMA循环转运模式</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AD_DMA_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*RCC时钟配置*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<span class="comment">//ADC属于APB2上的设备</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//最大频率14MHZ,所以选择6分频，12MHZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO配置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN;<span class="comment">//模拟输入模式，断开GPIO，防止GPIO的输入输出对模拟电压造成干扰</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第1个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第2个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第3个位置，写入通道</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);<span class="comment">//在规则组菜单列表第4个位置，写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*ADC相关寄存器配置*/</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);//在规则组菜单列表第一个位置，写入通道0</span></span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode=ENABLE;<span class="comment">//连续模式</span></span><br><span class="line">ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;<span class="comment">//不使用外部触发</span></span><br><span class="line">ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel=<span class="number">4</span>;<span class="comment">//仅在扫描模式下才需要大于1</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode=ENABLE;<span class="comment">//非扫描模式,这里改成扫描模式</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA结构体初始化*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外设站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr=(<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址填写ADC_DR的地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;<span class="comment">//转运数据宽度为一个字节,HalfWord表示半字16位选择DR寄存器低16位数据</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增,不自增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储器站点配置*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr=(<span class="type">uint32_t</span>)AD_Value;<span class="comment">//存储器站点的起始地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;<span class="comment">//半字16位</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;<span class="comment">//存储器地址自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;<span class="comment">//指定外设地址是源端还是目的地,这里将外设选择数据源</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize=<span class="number">4</span>;<span class="comment">//缓冲区大小，直接赋值给了传输计数器的寄存器，指定传输几次,取值0~65535</span></span><br><span class="line">DMA_InitStructure.DMA_Mode=DMA_Mode_Circular;<span class="comment">//传输模式，是否使用自动重装,DMA循环模式</span></span><br><span class="line">DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;<span class="comment">//选择是否是存储器到存储器，硬件触发/软件触发。这里选择硬件触发</span></span><br><span class="line">DMA_InitStructure.DMA_Priority=DMA_Priority_Medium;<span class="comment">//指定通道的软件优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把结构体的参数，配置到通道1中去*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);<span class="comment">//存储器到存储器，使用软件触发，ADC1对应DMA的通道1，这里必须选择通道1</span></span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//开启DMA触发信号</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);<span class="comment">//开启ADC电源</span></span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准,操作CR2_RSTCAL_Set</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//是否复位完成</span></span><br><span class="line">ADC_StartCalibration(ADC1);<span class="comment">//启动校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//校准标志位判断，等待校准完成</span></span><br><span class="line"></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思考：</strong></p><ul><li>定时器触发ADC单词转换后通过DMA转运？</li><li>串口发送的数据使用DMA进行存储器到外设的转运</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;相关库函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#相关库函数&quot;&gt;&lt;/a&gt; 相关库函数&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;恢复缺省配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void DMA_DeInit(DMA</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="DMA数据转运" scheme="https://szturin.github.io/tags/DMA%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[10]串口通信</title>
    <link href="https://szturin.github.io/posts/19202/"/>
    <id>https://szturin.github.io/posts/19202/</id>
    <published>2024-05-20T03:50:54.000Z</published>
    <updated>2024-05-25T11:43:40.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p><strong>结构体初始化配置</strong></p><p>void USART_DeInit(USART_TypeDef* USARTx);<br>void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);<br>void USART_StructInit(USART_InitTypeDef* USART_InitStruct);</p><p><strong>同步时钟配置</strong></p><p>void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);<br>void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);</p><p><strong>发送数据</strong></p><p>void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);</p><ul><li>写DR寄存器</li></ul><p><strong>接收数据</strong></p><p>uint16_t USART_ReceiveData(USART_TypeDef* USARTx);</p><ul><li>读DR寄存器</li></ul></blockquote><h1 id="microlib"><a class="markdownIt-Anchor" href="#microlib"></a> MicroLIB</h1><p><strong>MicroLIB是Keil为嵌入式平台优化的一个精简库</strong></p><img src="/posts/19202/image-20240520133336274.png" class="" title="image-20240520133336274"><h1 id="多个串口同时使用printf"><a class="markdownIt-Anchor" href="#多个串口同时使用printf"></a> 多个串口同时使用printf</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(String,<span class="string">"Num=%d\r\n"</span>,<span class="number">666</span>);<span class="comment">//sprintf.可以将指定的数据复制到数组中</span></span><br><span class="line">Serial_SendString(String);<span class="comment">//打印字符串</span></span><br></pre></td></tr></tbody></table></figure><h1 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_Prinf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="汉字编码发送"><a class="markdownIt-Anchor" href="#汉字编码发送"></a> 汉字编码发送</h1><img src="/posts/19202/image-20240520135012811.png" class="" title="image-20240520135012811"><p><strong>统一选定为UTF-8编码</strong></p><h1 id="串口接收"><a class="markdownIt-Anchor" href="#串口接收"></a> 串口接收</h1><h2 id="1查询方法"><a class="markdownIt-Anchor" href="#1查询方法"></a> 1.查询方法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">RXData=USART_ReceiveData(USART1);<span class="comment">//读DR可以自动清除标志位</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2中断方法"><a class="markdownIt-Anchor" href="#2中断方法"></a> 2.中断方法</h2><h3 id="子程序"><a class="markdownIt-Anchor" href="#子程序"></a> 子程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxData;</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GerRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> Serial_RxData;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line">Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2主程序"><a class="markdownIt-Anchor" href="#2主程序"></a> 2.主程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span> <span class="comment">//Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;OLED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Serial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RXData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"RxData:"</span>);</span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_GerRxFlag()==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RXData = Serial_GetRxData();</span><br><span class="line">Serial_SendByte(RXData);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,RXData,<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">RXData=USART_ReceiveData(USART1);//读DR可以自动清除标志位</span></span><br><span class="line"><span class="comment">OLED_ShowHexNum(1,1,RXData,2);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="串口数据包"><a class="markdownIt-Anchor" href="#串口数据包"></a> 串口数据包</h1><p><strong>打包多字节为一个数据包，方便发送多字节的数据。将同一批的数据进行打包和分割</strong></p><p><strong>包头、包尾：简易通信协议</strong></p><ul><li>文本数据包</li><li>Hex数据包</li></ul><h2 id="状态机的方法来接收数据包"><a class="markdownIt-Anchor" href="#状态机的方法来接收数据包"></a> 状态机的方法来接收数据包</h2><img src="/posts/19202/image-20240520150733732.png" class="" title="image-20240520150733732"><h2 id="1发送数据包"><a class="markdownIt-Anchor" href="#1发送数据包"></a> 1.发送数据包</h2><img src="/posts/19202/image-20240520152533465.png" class="" title="image-20240520152533465"><h2 id="2接收数据包"><a class="markdownIt-Anchor" href="#2接收数据包"></a> 2.接收数据包</h2><p><strong>串口中断子程序</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_TxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读后自动清零</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送数据包*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(<span class="number">0xFF</span>);</span><br><span class="line">Serial_SendArray(Serial_TxPacket,<span class="number">4</span>);</span><br><span class="line">Serial_SendByte(<span class="number">0xFE</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line"><span class="keyword">if</span>(++pRxState&gt;=<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">pRxState=<span class="number">0</span>;</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="number">0xFE</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Serial.h</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_TxPacket[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Serial_RxPacket[];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="小操作"><a class="markdownIt-Anchor" href="#小操作"></a> 小操作</h2><p><strong>按住alt选择一列进行修改</strong></p><img src="/posts/19202/image-20240520154534025.png" class="" title="image-20240520154534025"><h2 id="3文本收发数据包"><a class="markdownIt-Anchor" href="#3文本收发数据包"></a> 3.文本收发数据包</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">100</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//开启USART1的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置PA9为复用推挽输出，供USART1的TX使用*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口发送引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*串口接收引脚部分*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入模式</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*USART结构体初始化*/</span></span><br><span class="line">USART_InitTypeDef USART_InitStructrue;</span><br><span class="line">USART_InitStructrue.USART_BaudRate=<span class="number">9600</span>;<span class="comment">//直接写入设定的波特率，函数内部会自动算好9600对应的寄存器配置</span></span><br><span class="line">USART_InitStructrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//流控制关</span></span><br><span class="line">USART_InitStructrue.USART_Mode=USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//串口发送+接收</span></span><br><span class="line">USART_InitStructrue.USART_Parity=USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">USART_InitStructrue.USART_StopBits=USART_StopBits_1;<span class="comment">//1位停止位</span></span><br><span class="line">USART_InitStructrue.USART_WordLength=<span class="number">8</span>;<span class="comment">//字长8位</span></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStructrue);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断配置*/</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启RXNE的标志位到NVIC输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">{</span><br><span class="line">USART_SendData(USART1,Byte);<span class="comment">//写入DR寄存器</span></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);<span class="comment">//等待清空标志位为RESET,防止数据覆盖</span></span><br><span class="line"><span class="comment">//PS:这个标志位不需要手动清零，当检测到为RESET会触发中断，自动清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> * String)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">'\0'</span>;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Y--)</span><br><span class="line">{</span><br><span class="line">Result *=X;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">{</span><br><span class="line">Serial_SendByte(Number/Serial_Pow(<span class="number">10</span>,Length-i<span class="number">-1</span>)%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE * f)</span></span><br><span class="line">{</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> * format,...)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;<span class="comment">//参数列表变量</span></span><br><span class="line">va_start(arg,format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">va_end(arg);<span class="comment">//释放参数列表</span></span><br><span class="line">Serial_SendString(String);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//函数退出后下次不会初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxState = <span class="number">0</span>;<span class="comment">//表示当前接收的是第几个变量</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)==SET)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'@'</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">'\r'</span>)<span class="comment">//第一个包尾</span></span><br><span class="line">{</span><br><span class="line">RxState=<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Serial_RxPacket[pRxState]=RxData;</span><br><span class="line">pRxState++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)<span class="comment">//第二个包尾</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (RxData==<span class="string">'\n'</span>)</span><br><span class="line">{</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag=<span class="number">1</span>;</span><br><span class="line">Serial_RxPacket[pRxState]=<span class="string">'\0'</span>;<span class="comment">//字符串结束时加上\0,表示字符串的结束</span></span><br><span class="line">pRxState=<span class="number">0</span>;<span class="comment">//MARK:忘记清零</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="串口下载"><a class="markdownIt-Anchor" href="#串口下载"></a> #串口下载</h1><h2 id="boot引脚"><a class="markdownIt-Anchor" href="#boot引脚"></a> Boot引脚</h2><p>BootLoder的作用相当于刷机</p><h2 id="调试使用"><a class="markdownIt-Anchor" href="#调试使用"></a> 调试使用</h2><img src="/posts/19202/image-20240520163851412.png" class="" title="image-20240520163851412"><p>可以保持跳线帽置1，但是复位后程序丢失，所以仅用来调试</p><h2 id="读flash生成bin文件"><a class="markdownIt-Anchor" href="#读flash生成bin文件"></a> 读FLASH生成bin文件</h2><img src="/posts/19202/image-20240520164112095.png" class="" title="image-20240520164112095"><h2 id="读保护写保护"><a class="markdownIt-Anchor" href="#读保护写保护"></a> 读保护/写保护</h2><img src="/posts/19202/image-20240520164217951.png" class="" title="image-20240520164217951"><h1 id="蓝牙串口通信"><a class="markdownIt-Anchor" href="#蓝牙串口通信"></a> 蓝牙串口通信</h1><p><a href="https://blog.csdn.net/struggle_success/article/details/130440579">电赛|项目|课设：蓝牙模块HC05主从配置与连接_蓝牙 master和 slave 服务-CSDN博客</a></p><p><strong>AT指令集</strong></p><p>AT+NAME = xlg 设置蓝牙名称为xlg</p><p>AT+ROLE=0 蓝牙模式为从模式 AT+ROLE=1 蓝牙模式为主模式<br>AT+CMODE=0 蓝牙连接模式为任意地址连接模式<br>AT+PSWD=1234 蓝牙配对密码为1234<br>AT+UART=9600，0，0 蓝牙通信串口波特率为9600，停止位1位，无校验位<br>AT+RMAAD 清空配对列表</p><p>一、更改波特率<br>AT+UART=a,b,c<br>蓝牙通信串口波特率为a，<br>b:停止位1位，无校验位<br>返回响应为OK</p><p>二、修改蓝牙模块密码</p><p>修改密码的AT指令格式如下：（以修改后的密码为1314为例）</p><pre><code>        AT+PSWD=1314（这里加回车）</code></pre><p>1<br>三、修改蓝牙模块名字</p><p>修改模块名字的AT指令如下：</p><pre><code>            AT+NAME =</code></pre><p>1<br>1， AT+ROLE设置主从模式：<br>AT+ROLE=1是设成主，AT+ROLE=0是设成从，AT+ROLE=2设成回环模式Slave-Loop：被动连接，接收远程蓝 牙主设备数据并将数据原样返回给远程蓝牙<br>AT+ROLE?：查询主从状态<br>2， AT+RESET:HC-05复位</p><p>3， AT+VERSION?：获取HC-05的软件版本号，只能获取，不能修改。</p><p>4， AT+ORGL:恢复出厂默认设置，当把模块设置乱了，使用此命令进行恢复默认值。</p><p>5， AT+ADDR?：获取HC-05的蓝牙地址码，只能获取，不能修改。</p><p>6， AT+NAME？:获取HC-05的名字,AT+NAME=xlg，修改模块的名字为xlg，具体名字自行修改。</p><p>7， AT+CLASS?：设置查询设备的类型，尽量不要去修改此参数。默认是1F00。</p><p>8， AT+IAC?：查询设置查询访问码，默认是9E8B33，尽量不要去修改此参数。</p><p>9， AT+PSWD？:查询设置配对密码,AT+PSWD=”0000”,密码要有双引号,密码是四位数字.</p><p>10， AT+UART：AT+UART？是查询当前模块的波特率，AT+UART=波特率,0,0。</p><p>11， AT+CMODE：AT+CMODE？是查询当前连接模式。AT+CMODE=0，1，2(0——指定蓝牙地址连接模式（指定蓝牙地址由绑定指令设置）1——任意蓝牙地址连接模式（不受绑定指令设置地址的约束）2——回环角色（Slave-Loop）默认连接模式：0)。</p><p>12， AT+BIND:AT+BIND?查询当前绑定地址,AT+BIND=NAP，UAP，LAP(用逗号隔开)。</p><p>13， AT+RMADD:从蓝牙配对列表中删除所有认证设备.</p><p>14， AT+STATE？:获取蓝牙模块工作状态.</p><p>15， AT+LINK=NAP,UAP,LAP：与远程设备建立连接。</p><p>16， AT+DISC:断开连接.</p><p>17， AT+RNAME？NAP，UAP，LAP:获取远程蓝牙设备名称.</p><p>18， AT+ADCN?：获取蓝牙配对列表中认证设备数。</p><p>19， AT+MRAD？获取最近使用过的蓝牙认证设备地址。</p><p>20， AT+INQM:设置查询模式,AT+INQM=1，9，48(1-带RSSI信号强度指示,9-超过9个蓝牙设备响应则终止查询,48-设定超时为48*1.28=61.44秒)</p><p><strong>ps: HC05模块的AT指令，蓝牙命名AT+NAME= 以及密码设置AT+PSWD= 需要加双引号！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;库函数解释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#库函数解释&quot;&gt;&lt;/a&gt; 库函数解释&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;结构体初始化配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void USART_DeInit</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="串口" scheme="https://szturin.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="蓝牙" scheme="https://szturin.github.io/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>【Python学习】[1] 初识Python</title>
    <link href="https://szturin.github.io/posts/23330/"/>
    <id>https://szturin.github.io/posts/23330/</id>
    <published>2024-05-19T05:00:29.000Z</published>
    <updated>2024-05-25T11:45:00.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个python程序"><a class="markdownIt-Anchor" href="#第一个python程序"></a> 第一个Python程序</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\Users\123&gt;python</span><br><span class="line">Python 3.11.7 | packaged by Anaconda, Inc. | (main, Dec 15 2023, 18:05:47) [MSC v.1916 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">&gt;&gt;&gt; print('Hello world')</span><br><span class="line">Hello world</span><br><span class="line">&gt;&gt;&gt; print("Hello world")</span><br><span class="line">Hello world</span><br><span class="line">&gt;&gt;&gt; name = input('请输入你的名字')</span><br><span class="line">请输入你的名字'Turin'</span><br><span class="line">&gt;&gt;&gt; print(name)</span><br><span class="line">'Turin'</span><br><span class="line">&gt;&gt;&gt; print('Hello',name)</span><br><span class="line">Hello 'Turin'</span><br><span class="line">&gt;&gt;&gt; 2**10</span><br><span class="line">1024</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017063826246112">数据类型和变量 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h2 id="prompt运行py"><a class="markdownIt-Anchor" href="#prompt运行py"></a> <a href="http://xn--prompt-8w2r549b.py">prompt运行.py</a></h2><p><strong>prompt窗口1</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">please enter your name: Turin</span><br><span class="line">hello, Turin</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>.py文件</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>); <span class="comment">#Python中的分号可以省略，主要通过换行来识别语句的结束</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span><span class="string">"hello world"</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>,<span class="string">"hello world"</span>); <span class="comment">#print()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是拼起来的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> + <span class="number">200</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'1024*1024 ='</span>,<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">'please enter your name: '</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'hello,'</span>, name)</span><br></pre></td></tr></tbody></table></figure><p><strong>prompt窗口2</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">版权所有 (C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">尝试新的跨平台 PowerShell https://aka.ms/pscore6</span><br><span class="line"></span><br><span class="line">PS D:\7_python_project&gt; cd '.\1-1 python base\'</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">Turin</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">w</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">w</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt;</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt;</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python</span><br><span class="line">Python 3.10.2 (tags/v3.10.2:a58ebcc, Jan 17 2022, 14:12:15) [MSC v.1929 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">&gt;&gt;&gt; name = input()</span><br><span class="line">Turin</span><br><span class="line">&gt;&gt;&gt; print(name)</span><br><span class="line">Turin</span><br><span class="line">&gt;&gt;&gt; name = input('please enter your name: ')</span><br><span class="line">please enter your name: print('hello,', name)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">KeyboardInterrupt</span><br><span class="line"></span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python 1-1第一个python程序.py</span><br><span class="line">hello world</span><br><span class="line">hello worldhello world</span><br><span class="line">hello world hello world</span><br><span class="line">300</span><br><span class="line">1024*1024 = 1048576</span><br><span class="line">please enter your name: Turin</span><br><span class="line">hello, Turin</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; print('1024 * 768 ='1024 * 768 )</span><br><span class="line">所在位置 行:1 字符: 21</span><br><span class="line">+ print('1024 * 768 ='1024 * 768 )</span><br><span class="line">+                     ~~~~</span><br><span class="line">表达式或语句中包含意外的标记“1024”。</span><br><span class="line">所在位置 行:1 字符: 21</span><br><span class="line">+ print('1024 * 768 ='1024 * 768 )</span><br><span class="line">+                     ~</span><br><span class="line">表达式中缺少右“)”。</span><br><span class="line">所在位置 行:1 字符: 32</span><br><span class="line">+ print('1024 * 768 ='1024 * 768 )</span><br><span class="line">+                                ~</span><br><span class="line">表达式或语句中包含意外的标记“)”。</span><br><span class="line">    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException</span><br><span class="line">    + FullyQualifiedErrorId : UnexpectedToken</span><br><span class="line"></span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; print('1024 * 768 ='1024 * 768 ^C</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; print('1024 * 768 ='1024 * 768 ^C</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; ^C</span><br><span class="line">PS D:\7_python_project\1-1 python base&gt; python</span><br><span class="line">Python 3.10.2 (tags/v3.10.2:a58ebcc, Jan 17 2022, 14:12:15) [MSC v.1929 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">&gt;&gt;&gt; print('1024 * 768 ='1024 * 768 )</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    print('1024 * 768 ='1024 * 768 )</span><br><span class="line">          ^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">SyntaxError: invalid syntax. Perhaps you forgot a comma?</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt; print('\\\t\\')</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r'\\\t\\')</span><br><span class="line">\\\t\\</span><br><span class="line">&gt;&gt;&gt; print(''' line1</span><br><span class="line">... ...line2</span><br><span class="line">... ...line3''')</span><br><span class="line"> line1</span><br><span class="line">...line2</span><br><span class="line">...line3</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; print('''line1</span><br><span class="line">... line2</span><br><span class="line">... line3</span><br><span class="line">... '''</span><br><span class="line">... ^Z</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt; print('''line1</span><br><span class="line">... line2</span><br><span class="line">... line3''')</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 0</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; False or False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; not 1 = 1</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    not 1 = 1</span><br><span class="line">    ^^^^^</span><br><span class="line">SyntaxError: cannot assign to expression</span><br><span class="line">&gt;&gt;&gt; not 1==1</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; n = 123</span><br><span class="line">&gt;&gt;&gt; f = 456.789</span><br><span class="line">&gt;&gt;&gt; s1 = 'Hello, world'</span><br><span class="line">&gt;&gt;&gt; s2 = 'Hello, \'Adam\''</span><br><span class="line">&gt;&gt;&gt; s3 = r'Hello, "Bart"'</span><br><span class="line">&gt;&gt;&gt; s4 = r'''Hello,</span><br><span class="line">... Lisa!'''</span><br><span class="line">&gt;&gt;&gt; print(n\n,f,s1,s2,s3,s4)</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    print(n\n,f,s1,s2,s3,s4)</span><br><span class="line">            ^</span><br><span class="line">SyntaxError: unexpected character after line continuation character</span><br><span class="line">&gt;&gt;&gt; n = 123</span><br><span class="line">&gt;&gt;&gt; f = 456.789</span><br><span class="line">&gt;&gt;&gt; s1 = 'Hello, world'</span><br><span class="line">&gt;&gt;&gt; s2 = 'Hello, \'Adam\''</span><br><span class="line">&gt;&gt;&gt; s3 = r'Hello, "Bart"'</span><br><span class="line">&gt;&gt;&gt; s4 = r'''Hello,</span><br><span class="line">... Lisa!'''</span><br><span class="line">&gt;&gt;&gt; print(n\t,f,s1,s2,s3,s4)</span><br><span class="line">  File "&lt;stdin&gt;", line 1</span><br><span class="line">    print(n\t,f,s1,s2,s3,s4)</span><br><span class="line">            ^</span><br><span class="line">SyntaxError: unexpected character after line continuation character</span><br><span class="line">&gt;&gt;&gt; n = 123</span><br><span class="line">&gt;&gt;&gt; f = 456.789</span><br><span class="line">&gt;&gt;&gt; s1 = 'Hello, world'</span><br><span class="line">&gt;&gt;&gt; s2 = 'Hello, \'Adam\''</span><br><span class="line">&gt;&gt;&gt; s3 = r'Hello, "Bart"'</span><br><span class="line">&gt;&gt;&gt; s4 = r'''Hello,</span><br><span class="line">... Lisa!'''</span><br><span class="line">&gt;&gt;&gt; print('n\n,f,s1,s2,s3,s4')</span><br><span class="line">n</span><br><span class="line">,f,s1,s2,s3,s4</span><br><span class="line">&gt;&gt;&gt; ord('A')</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord('中')</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">'B'</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">'B'</span><br><span class="line">&gt;&gt;&gt; '\u4e2d\u6587'</span><br><span class="line">'中文'</span><br><span class="line">&gt;&gt;&gt; x = b'ABC'</span><br><span class="line">&gt;&gt;&gt; 'ABC'.encode('ascii')</span><br><span class="line">b'ABC'</span><br><span class="line">&gt;&gt;&gt; '中文'.encode('UTF-8')</span><br><span class="line">b'\xe4\xb8\xad\xe6\x96\x87'</span><br><span class="line">&gt;&gt;&gt; '中文'.encode('ascii')</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)</span><br><span class="line">&gt;&gt;&gt; b'ABC'.decode('UTF-8')</span><br><span class="line">'ABC'</span><br><span class="line">&gt;&gt;&gt; len('中文')</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; len('中文'.encode('utf-8'))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; 'Hello, %s' % 'world'</span><br><span class="line">'Hello, world'</span><br><span class="line">&gt;&gt;&gt; 'Hello,%s' &amp; 'world'</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) for &amp;: 'str' and 'str'</span><br><span class="line">&gt;&gt;&gt; 'Hello,%s' %'world'</span><br><span class="line">'Hello,world'</span><br><span class="line">&gt;&gt;&gt; 'Hi,&amp;s,You have %d$' %('Meter',100000)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">TypeError: %d format: a real number is required, not str</span><br><span class="line">&gt;&gt;&gt; 'Hi,%s,You have %d$' %('Meter',100000)</span><br><span class="line">'Hi,Meter,You have 100000$'</span><br><span class="line">&gt;&gt;&gt; 'Hi,&amp;s,You have %d$' %('Meter',100000)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">TypeError: %d format: a real number is required, not str</span><br><span class="line">&gt;&gt;&gt; print('%2d-%02d' % (3, 1))</span><br><span class="line"> 3-01</span><br><span class="line">&gt;&gt;&gt; print('%.2f' % 3.1415926)</span><br><span class="line">3.14</span><br><span class="line">&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)</span><br><span class="line">'Age: 25. Gender: True'</span><br><span class="line">&gt;&gt;&gt; 'growth rate: %d %%' % 7</span><br><span class="line">'growth rate: 7 %'</span><br><span class="line">&gt;&gt;&gt; '中文'.encode('gb2312')</span><br><span class="line">b'\xd6\xd0\xce\xc4'</span><br><span class="line">&gt;&gt;&gt; 'Hello,{0}的成绩提高了{1:.1f}'.format('小明',17.125)</span><br><span class="line">'Hello,小明的成绩提高了17.1'</span><br><span class="line">&gt;&gt;&gt; print(f'^Z')</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt; s = '小明'</span><br><span class="line">&gt;&gt;&gt; a = '85'</span><br><span class="line">&gt;&gt;&gt; print(f'Hello,{s}的成绩为{a}')</span><br><span class="line">Hello,小明的成绩为85</span><br><span class="line">&gt;&gt;&gt; s1=72</span><br><span class="line">&gt;&gt;&gt; s2=85</span><br><span class="line">&gt;&gt;&gt; rate = s1/85</span><br><span class="line">&gt;&gt;&gt; print(f'小明的成绩从去年的{s1}分提升到了今年的{s2}分，提升了{rate}%')</span><br><span class="line">小明的成绩从去年的72分提升到了今年的85分，提升了0.8470588235294118%</span><br><span class="line">&gt;&gt;&gt; s1=72</span><br><span class="line">&gt;&gt;&gt; s2=85</span><br><span class="line">&gt;&gt;&gt; rate = s1/85</span><br><span class="line">&gt;&gt;&gt; s2=85^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z^Z</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>PS:当<code>str</code>和<code>bytes</code>互相转换时,没有特殊要求，指定使用UTF-8编码</strong></p><h1 id="问题及解决方案"><a class="markdownIt-Anchor" href="#问题及解决方案"></a> 问题及解决方案</h1><ul><li><a href="https://blog.csdn.net/m0_52592128/article/details/120798138">Vscode提示“无法在只读编辑器中编辑”解决方法_vscode编辑器关闭只读模式-CSDN博客</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一个python程序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一个python程序&quot;&gt;&lt;/a&gt; 第一个Python程序&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbod</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python/"/>
    
    <category term="人工智能" scheme="https://szturin.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="编程" scheme="https://szturin.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Python" scheme="https://szturin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【pid算法】[入门篇] 1-深入浅出pid控制算法原理</title>
    <link href="https://szturin.github.io/posts/34110/"/>
    <id>https://szturin.github.io/posts/34110/</id>
    <published>2024-05-12T06:55:23.000Z</published>
    <updated>2024-05-22T07:53:39.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pid模拟调参无人机"><a class="markdownIt-Anchor" href="#pid模拟调参无人机"></a> pid模拟调参（无人机）</h2><p><a href="https://rossning92.github.io/pid-simulation/">Webpack App (rossning92.github.io)</a></p><img src="/posts/34110/image-20240512152800666.png" class="" title="image-20240512152800666"><h2 id="多环平衡小车"><a class="markdownIt-Anchor" href="#多环平衡小车"></a> 多环(平衡小车)</h2><img src="/posts/34110/image-20240512154358581.png" class="" title="image-20240512154358581"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Kp,Ki,Kd;</span><br><span class="line"><span class="type">int</span> Error;</span><br><span class="line"><span class="type">int</span> Error_old;</span><br><span class="line"><span class="type">int</span> Error_difference;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> Error_sum;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I_amplitude_limiting</span><span class="params">(<span class="type">int</span> number)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Error_sum&gt;number)</span><br><span class="line">{</span><br><span class="line">Error_sum=number;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//PID控制系统:P、I、D共同作用</span></span><br><span class="line"><span class="comment">//measure,calcu:系统的输入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PID_control</span><span class="params">(<span class="type">float</span> measure,<span class="type">float</span> calcu)</span></span><br><span class="line">{</span><br><span class="line">Error = measure - calcu;<span class="comment">//误差值</span></span><br><span class="line"></span><br><span class="line">Error_sum += Error;<span class="comment">//误差累加</span></span><br><span class="line">I_amplitude_limiting(<span class="number">2000</span>);<span class="comment">//限幅函数</span></span><br><span class="line"></span><br><span class="line">Error_difference = Error- Error_old;<span class="comment">//误差变化率(近似于对时间的微分)</span></span><br><span class="line">Error_old = Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(Kp*Error+Kd*Error_difference+Ki*Error_sum);<span class="comment">//PID控制器响应结果</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;pid模拟调参无人机&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pid模拟调参无人机&quot;&gt;&lt;/a&gt; pid模拟调参（无人机）&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://rossning92.github.io/pid-simu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【微机原理】红外通信系统</title>
    <link href="https://szturin.github.io/posts/29338/"/>
    <id>https://szturin.github.io/posts/29338/</id>
    <published>2024-05-11T06:32:46.000Z</published>
    <updated>2024-05-22T07:53:39.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> # 前言</h1><h2 id="一-红外通信系统"><a class="markdownIt-Anchor" href="#一-红外通信系统"></a> 一、红外通信系统</h2><h3 id="二-红外调制解调的原理"><a class="markdownIt-Anchor" href="#二-红外调制解调的原理"></a> 二、红外调制解调的原理</h3><ul><li>空闲状态：红外LED不亮，接收头输出高电平</li><li>发送低电平：红外LED以38KHz频率闪烁发光，接收头输出低电平</li><li>发送高电平：红外LED不亮，接收头输出高电平<br>总而言之，只有红外LED发送38KHZ的闪烁信号时，红外接收头OUT引脚才会对外输出低电平信号<br>红外发送–红外接收的本质是<mark>调制</mark>和<mark>解调</mark>，在这种条件下，可以过滤掉自然界中的“噪声信号”，只有38KHZ附近的红外信号才能被红外接收头识别转换为对应的低电平。</li></ul><p><strong>转换示意图：</strong><br>1.红外LED发出的信号</p><img src="/posts/29338/c97d453d8866482a8bc0a2191a565288.png" class="" title="在这里插入图片描述"><p>2.红外接收头发出的信号</p><img src="/posts/29338/3d972def937345fdb73a96eb875114b8.png" class="" title="在这里插入图片描述"><p>其中，红外接收头发出的低电平信号的宽度等价于红外LED发送的38KHz信号的时间。</p><h1 id="一-基于ccp1输入捕获模式的解调电路"><a class="markdownIt-Anchor" href="#一-基于ccp1输入捕获模式的解调电路"></a> 一、基于CCP1输入捕获模式的解调电路</h1><h2 id="1-proteus生成基带信号"><a class="markdownIt-Anchor" href="#1-proteus生成基带信号"></a> 1. Proteus生成基带信号</h2><img src="/posts/29338/image-20240511143825355.png" class="" title="image-20240511143825355"><h3 id="11脉冲最小单位"><a class="markdownIt-Anchor" href="#11脉冲最小单位"></a> 1.1脉冲最小单位</h3><img src="/posts/29338/image-20240511143912266.png" class="" title="image-20240511143912266"><h3 id="12特定脉冲序列"><a class="markdownIt-Anchor" href="#12特定脉冲序列"></a> 1.2特定脉冲序列</h3><img src="/posts/29338/image-20240511143937021.png" class="" title="image-20240511143937021"><img src="/posts/29338/image-20240519153450824.png" class="" title="image-20240519153450824"><p><strong>从左往右表示数据从高位到低位，如图所示为01001101</strong></p><h3 id="13仿真结果"><a class="markdownIt-Anchor" href="#13仿真结果"></a> 1.3仿真结果</h3><img src="/posts/29338/image-20240519153542254.png" class="" title="image-20240519153542254"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;<span class="comment">//接收数据储存变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获模式接收信号跳变*/</span></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次接收信号为下跳变</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;</span><br><span class="line">CCP1CON=<span class="number">0X05</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//本次接收信号为上跳变</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0</span> &amp;&amp; CCPR1H == <span class="number">0X00</span>){B=B&lt;&lt;<span class="number">1</span>;}<span class="comment">//'0'</span></span><br><span class="line"><span class="keyword">if</span>(CCPR1L &lt; <span class="number">0X50</span> &amp;&amp; CCPR1H == <span class="number">0X01</span>){B=B&lt;&lt;<span class="number">1</span>;B=B+<span class="number">1</span>;}  <span class="comment">//'1'</span></span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0XA0</span> &amp;&amp; CCPR1H == <span class="number">0X01</span>){PORTB = B;}  <span class="comment">//结束信号，电平宽度匹配时表示完整接收到1Byte数据</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;<span class="comment">//清空寄存器</span></span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;<span class="comment">//中断相关寄存器配置</span></span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line">B=<span class="number">0</span>;TRISB=<span class="number">0</span>; PORTB=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//开启定时器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二-基于ccp1输出比较模式的基带信号生成电路"><a class="markdownIt-Anchor" href="#二-基于ccp1输出比较模式的基带信号生成电路"></a> 二、基于CCP1输出比较模式的基带信号生成电路</h1><h2 id="1mpalb波形显示窗口显示rc2产生的基带信号"><a class="markdownIt-Anchor" href="#1mpalb波形显示窗口显示rc2产生的基带信号"></a> 1.MPALB波形显示窗口，显示RC2产生的基带信号</h2><img src="/posts/29338/image-20240519155221573.png" class="" title="image-20240519155221573"><h2 id="2代码解释"><a class="markdownIt-Anchor" href="#2代码解释"></a> 2.代码解释</h2><p><strong>CCP1模块每次发送1位二进制的负脉冲宽度，每次循环从data左移一位。PIC单片机C语言循环移位语句用汇编语句asm(“rlf _data,f”)，每次将最高位移入CARRY寄存器中，以最高的程序执行效率进行数据移位并生成基带信号的操作，并且每次发送1位二进制负脉冲宽度之后，会发送1位同步头的正脉冲宽度。发送完所有二进制数据之后，发送1位结束头低电平宽度</strong></p><img src="/posts/29338/image-20240519155522173.png" class="" title="image-20240519155522173"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data,data_cnt;<span class="comment">//发送的二进制代码，代码长度</span></span><br><span class="line"><span class="type">char</span> IR_SendSelect;</span><br><span class="line">bit a;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a=!a;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RC7=<span class="number">0</span>;</span><br><span class="line">data_cnt--;<span class="comment">//低电平。二进制代码位数减1</span></span><br><span class="line"><span class="keyword">if</span>(data_cnt == <span class="number">0</span>) <span class="keyword">goto</span> period_delty;<span class="comment">//位数为0，全部发送完，转624us延时</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"rlf _data,f"</span>);<span class="comment">//未发送完，取下一位待发送数据（数据移入CARRY中）</span></span><br><span class="line"><span class="keyword">if</span>(CARRY == <span class="number">1</span>) <span class="keyword">goto</span> data_5eh;<span class="comment">//待发送数据=1</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//待发送数据=0,叠加低电平时长68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;</span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">data_5eh:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X38</span>;<span class="comment">//待发送数据=1,叠加低电平时长138H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">1</span>;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">period_delty:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X70</span>;<span class="comment">//叠加624us的延时参数270H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">2</span>;<span class="comment">//高位字节加2及低位叠加时的进位和</span></span><br><span class="line">data=<span class="number">0B</span>01001101;<span class="comment">//=PORTB //从PORTB取数据</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;</span><br><span class="line">ret_fie:</span><br><span class="line">CCP1M0=<span class="number">0</span>;<span class="comment">//下次匹配时输出高电平</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//叠加同步头的延时参数68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line">CCP1M0=<span class="number">1</span>;<span class="comment">//下次匹配时输出低电平</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">nRBPU=<span class="number">0</span>;<span class="comment">//启用RB弱上拉</span></span><br><span class="line">TRISB=<span class="number">0xFF</span>;<span class="comment">//作输入口</span></span><br><span class="line">TRISC2=<span class="number">0</span>;<span class="comment">//C口定义为输入口，只定义RC2作为输出</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;<span class="comment">//设置预分频比为 = 1:1,开中断</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;<span class="comment">//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line">CCP1CON = <span class="number">0X08</span>;<span class="comment">//CCP1设为匹配时令CCP1/RC2引脚输出高电平</span></span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//启动TMR1</span></span><br><span class="line">data = <span class="number">0B</span>01001101;<span class="comment">//=PORTB;从PORTB取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三-将基带电路与调制电路配合组成简易的红外通信系统"><a class="markdownIt-Anchor" href="#三-将基带电路与调制电路配合组成简易的红外通信系统"></a> 三、将基带电路与调制电路配合，组成简易的红外通信系统</h1><p><strong>如图所示，因为RC2输出的红外基带信号带有毛刺，所以这里改为RC7引脚输出基带信号，这样，就能组成一个完整的红外发送-接收系统，运行仿真，此时红外接收端的LED同与发送端PORTB的逻辑</strong></p><img src="/posts/29338/image-20240519161843951.png" class="" title="image-20240519161843951"><h1 id="四-配合ccp1输出比较和ccp2-pwm输出模式构成载波-调制信号"><a class="markdownIt-Anchor" href="#四-配合ccp1输出比较和ccp2-pwm输出模式构成载波-调制信号"></a> 四、配合CCP1输出比较和CCP2 PWM输出模式，构成载波-调制信号</h1><p><strong>MPLAB仿真观测调制信号，与原基带信号进行对比，验证代码现象</strong></p><p><strong>调制信号在图像上有些地方在同步头结束后为高电平，但在经过红外发送管之后，发送的信号依然对应者基带信号的波形，所以实际上并没有影响</strong></p><img src="/posts/29338/image-20240514130203460.png" class="" title="image-20240514130203460"><h1 id="五-实物测试部分"><a class="markdownIt-Anchor" href="#五-实物测试部分"></a> 五、实物测试部分</h1><h2 id="1红外二极管收发"><a class="markdownIt-Anchor" href="#1红外二极管收发"></a> 1.红外二极管收发</h2><h3 id="使用电压表测试红外接收管压降"><a class="markdownIt-Anchor" href="#使用电压表测试红外接收管压降"></a> <mark>使用电压表测试红外接收管压降</mark></h3><img src="/posts/29338/b8287e8289bf096bd5da1196ff211612.jpg" class="" title="b8287e8289bf096bd5da1196ff211612"><h2 id="2测试红外接收模块是否能被触发"><a class="markdownIt-Anchor" href="#2测试红外接收模块是否能被触发"></a> 2.测试红外接收模块是否能被触发</h2><ul><li><mark><strong>首先测试能否顺利进入中断，用PIC板载LED进行观测，每次进入中断，代表接收到一次38KHZ的红外信号，同时PIC板的八位LED进行取反闪烁</strong></mark></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;</span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line">PORTD^=<span class="number">0xFF</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">if(CCPR1L &gt; 0 &amp;&amp; CCPR1H == 0X00){B=B&lt;&lt;1;}//'0'==0x685</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X01){B=B&lt;&lt;1;B=B+1;}  //'1'==0x12C</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X02){PORTD = B;}  //结束信号==0x270</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;</span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;</span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line">B=<span class="number">0</span>;TRISD=<span class="number">0</span>; PORTD=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3仿真软件测量接收信号时选定捕捉每个bit数据的范围"><a class="markdownIt-Anchor" href="#3仿真软件测量接收信号时选定捕捉每个bit数据的范围"></a> 3.仿真软件测量接收信号时，选定捕捉每个bit数据的范围</h2><h3 id="31-程序调试使得红外传输系统更加精确稳定"><a class="markdownIt-Anchor" href="#31-程序调试使得红外传输系统更加精确稳定"></a> 3.1 程序调试，使得红外传输系统更加精确稳定</h3><p><mark><strong>虽然在红外调制电路代码中，我们指定了每个二进制数据，停止位，起始位的电平长度，但是，因为程序设计以及单片机响应速度的原因，我们并不知道它最终生成信号各个部分的电平宽度具体值，如果将编写好的程序直接拿来用，可能得不到任何想要的现象。因此，要通过测量红外解调电路实际获取到的各个二进制电平的长度（通过LCD1602显示），然后再修改程序，使得红外接收单片机能够稳定接收红外发送单片机发送的信号。</strong></mark></p><p><strong>下面为用于测试接收端接收到各个bit数据电平宽度的代码，如：控制发送端发送的数据为0x00，然后接收端这边进行对’0’的电平宽度测量，显示在LCD1602上，其他任意宽度的bit位也是同理</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> B;</span><br><span class="line"><span class="type">int</span> Time_Data;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//PORTD^=0xFF;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次捕捉下降沿</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;</span><br><span class="line">CCP1CON=<span class="number">0X05</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;</span><br><span class="line">CCP1IF=<span class="number">0</span>; Time_Data = CCPR1H &lt;&lt; <span class="number">8</span> | CCPR1L;</span><br><span class="line"><span class="keyword">if</span>(CCPR1L &gt; <span class="number">0</span> &amp;&amp; CCPR1H == <span class="number">0X00</span>){LCD1602_WriteNum(<span class="number">1</span>,<span class="number">0</span>,Time_Data,<span class="number">5</span>);CCP1IE=<span class="number">0</span>;}<span class="comment">//55</span></span><br><span class="line"><span class="comment">//if(CCPR1H == 0X01){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//263</span></span><br><span class="line"><span class="comment">//if(CCPR1H == 0X02){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)//本次捕捉下降沿</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;//清零TMR1寄存器值</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//下一次捕捉上升沿</span></span><br><span class="line"><span class="comment">CCP1IF=0;//清除输入捕捉标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;//下一次捕捉下降沿</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">if(CCPR1L &gt; 0 &amp;&amp; CCPR1H == 0X00){B=B&lt;&lt;1;}//0'068</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X01){B=B&lt;&lt;1;B=B+1;}  //'1'==0x12C</span></span><br><span class="line"><span class="comment">if(CCPR1H == 0X02){PORTD = B;}  //结束信号==0x270</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">TRISD=<span class="number">0X00</span>;<span class="comment">//数据口</span></span><br><span class="line">    TRISA=<span class="number">0x00</span>;<span class="comment">//RA0配置为输出模式</span></span><br><span class="line">ADCON1=<span class="number">0X07</span>;<span class="comment">//RA端口与AD转换有关！！！，不然无法正常显示LCD1602</span></span><br><span class="line">LCD1602_Init();</span><br><span class="line">LCD1602_WriteString(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"OK"</span>);</span><br><span class="line">CCPR1H=CCPR1L=<span class="number">0</span>;</span><br><span class="line">INTCON=<span class="number">0</span>;</span><br><span class="line">PIR1=<span class="number">0</span>;PIR2=<span class="number">0</span>;</span><br><span class="line">PIE1=<span class="number">0</span>;PIE2=<span class="number">0</span>;</span><br><span class="line">TRISC=<span class="number">0X04</span>; <span class="comment">// C口定义为输出口，只定义RC2/CCP1作为输入</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;T1CON=<span class="number">0</span>;PEIE=<span class="number">1</span>;GIE=<span class="number">1</span>;</span><br><span class="line">PORTC = <span class="number">0X80</span>;</span><br><span class="line"></span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//CCP1设置为捕捉模式，捕捉下降沿</span></span><br><span class="line"></span><br><span class="line">B=<span class="number">0</span>;TRISD=<span class="number">0</span>; PORTD=<span class="number">0X22</span>;</span><br><span class="line">TMR1ON=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/posts/29338/image-20240514001540423.png" class="" title="image-20240514001540423"><h2 id="发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据"><a class="markdownIt-Anchor" href="#发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据"></a> 发送端和接收端的红外传续协议定义为每次收发24位bit的连续数据</h2><p><strong>如图所示，发送连续三个Byte的一帧数据</strong></p><img src="/posts/29338/image-20240514015916078.png" class="" title="image-20240514015916078"><p><strong>代码部分</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line">__CONFIG(<span class="number">0xFF29</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data,data_cnt;<span class="comment">//发送的二进制代码，代码长度</span></span><br><span class="line"><span class="type">char</span> IR_SendSelect;</span><br><span class="line"><span class="type">char</span> measure_Flag;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1_HighByte;<span class="comment">//CCP1高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1_LowByte;<span class="comment">//CCP1低字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Over_Counter=<span class="number">0</span>;<span class="comment">//溢出计数值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Over_Counter_temp;<span class="comment">//溢出计数暂存值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> CCP1IF_TriggerFlag;<span class="comment">//CCP1中断触发标志位</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> TABLE[<span class="number">16</span>]={<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>,<span class="number">0x46</span>};</span><br><span class="line"><span class="type">char</span> Send_Counter;<span class="comment">//发送字节次数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Cycle;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data_new;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Cycle;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">long</span> Data[<span class="number">3</span>];</span><br><span class="line">}T_data_M;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稳定数据滤波器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">data_filter</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">T_data_new.Data[<span class="number">0</span>]=Over_Counter;</span><br><span class="line">T_data_new.Data[<span class="number">1</span>]=CCP1_HighByte;</span><br><span class="line">T_data_new.Data[<span class="number">2</span>]=CCP1_LowByte;</span><br><span class="line"></span><br><span class="line">T_data_M.Data[i++]= T_data_new.Cycle;</span><br><span class="line">i%=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T_data_M.Data[<span class="number">0</span>]==T_data_M.Data[<span class="number">1</span>] &amp;&amp; T_data_M.Data[<span class="number">1</span>] == T_data_M.Data[<span class="number">2</span>])<span class="comment">//当三次取值相等时，才为有效值</span></span><br><span class="line">{</span><br><span class="line">T_data.Cycle=T_data_new.Cycle;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(measure_Flag == 0)//为周期测量模式</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">if(TMR1IF==1)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">Over_Counter_temp++;//累加TMR1的溢出次数</span></span><br><span class="line"><span class="comment">TMR1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else if(CCP1IF==1)//判断是不是由CCP1引起的中断</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1IF_TriggerFlag^=1;//标志位取反</span></span><br><span class="line"><span class="comment">if(CCP1IF_TriggerFlag==1)//第一次捕捉到跳变</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;//清除定时器0计数寄存器值</span></span><br><span class="line"><span class="comment">TMR1L=0;</span></span><br><span class="line"><span class="comment">TMR1ON=1;//定时器1开始计时</span></span><br><span class="line"><span class="comment">CCP1IF=0;//清除中断标志位</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else//第二次捕捉到跳变</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CCP1_LowByte=CCPR1L+31;//校准值</span></span><br><span class="line"><span class="comment">CCP1_HighByte=CCPR1H+CARRY;//加上进位标志位</span></span><br><span class="line"><span class="comment">Over_Counter=Over_Counter_temp;//将计数溢出暂存值赋值给显示值</span></span><br><span class="line"><span class="comment">data_filter();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Over_Counter_temp=0;//清除计数溢出暂存值</span></span><br><span class="line"><span class="comment">TMR1H=0;//清除定时器0计数寄存器值</span></span><br><span class="line"><span class="comment">TMR1L=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">LCD1602_WriteCommand(0x80);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[0]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[0]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[1]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[1]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[2]&gt;&gt;4]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData(TABLE[T_data_new.Data[2]&amp;0x0F]);</span></span><br><span class="line"><span class="comment">LCD1602_WriteData('H');</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TMR1ON=0;//定时器1停止计时</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*PWM,输出比较配置</span></span><br><span class="line"><span class="comment">T2CON=0;PR2=25;TMR2=0;//TMR2初始化，周期26us</span></span><br><span class="line"><span class="comment">CCP2CON=0X0C;</span></span><br><span class="line"><span class="comment">CCPR2L=13;//CCP2初始化，脉宽13us</span></span><br><span class="line"><span class="comment">T1CON=0;//设置预分频比为 = 1:1,开中断</span></span><br><span class="line"><span class="comment">data_cnt = 0x09;//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line"><span class="comment">CCP1CON = 0X08;//CCP1设为匹配时令CCP1/RC2引脚输出电平不变</span></span><br><span class="line"><span class="comment">TMR1ON=1;//启动TMR1</span></span><br><span class="line"><span class="comment">measure_Flag=1;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(measure_Flag == <span class="number">0</span>)<span class="comment">//将测量值发送(PWM(CCP2),输出比较(CCP1))</span></span><br><span class="line">{</span><br><span class="line">CCP1IF=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(CCP1M0==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">RC7=<span class="number">0</span>;</span><br><span class="line">CCP2CON=<span class="number">0x00</span>;</span><br><span class="line">data_cnt--;<span class="comment">//低电平。二进制代码位数减1</span></span><br><span class="line"><span class="keyword">if</span>(data_cnt == <span class="number">0</span>){<span class="keyword">goto</span> period_delty;} <span class="comment">//位数为0，全部发送完，转624us延时</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"rlf _data,f"</span>);<span class="comment">//未发送完，取下一位待发送数据（数据移入CARRY中）</span></span><br><span class="line"><span class="keyword">if</span>(CARRY == <span class="number">1</span>) <span class="keyword">goto</span> data_5eh;<span class="comment">//待发送数据=1</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X04</span>;<span class="comment">//待发送数据=0,叠加低电平时长68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">data_5eh:</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X18</span>;<span class="comment">//待发送数据=1,叠加低电平时长138H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">4</span>;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line"><span class="keyword">goto</span> ret_fie;<span class="comment">//转到中断出口</span></span><br><span class="line">period_delty:</span><br><span class="line">Send_Counter++;</span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0XC0</span>;<span class="comment">//叠加624us的延时参数270H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY+<span class="number">9</span>;<span class="comment">//高位字节加2及低位叠加时的进位和</span></span><br><span class="line">data=<span class="number">0B</span>10101001;<span class="comment">//=PORTB //从PORTB取数据</span></span><br><span class="line">data_cnt = <span class="number">9</span>;</span><br><span class="line">ret_fie:</span><br><span class="line">CCP1M0=<span class="number">0</span>;<span class="comment">//下次匹配时输出高电平</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">CCP2CON=<span class="number">0X0C</span>;</span><br><span class="line">RC7=<span class="number">1</span>;TMR2ON=<span class="number">1</span>;<span class="comment">//同步头时间，启动PWM信号输出</span></span><br><span class="line">CCPR1L=CCPR1L+<span class="number">0X68</span>;<span class="comment">//叠加同步头的延时参数68H</span></span><br><span class="line">CCPR1H=CCPR1H+CARRY;<span class="comment">//高位字节加上低位叠加时的进位</span></span><br><span class="line">CCP1M0=<span class="number">1</span>;<span class="comment">//下次匹配时输出低电平</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Send_Counter &gt;= <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">Send_Counter=<span class="number">0</span>;</span><br><span class="line">measure_Flag = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CCP1IF=0;//CCP标志位清零</span></span><br><span class="line"><span class="comment">TMR1IE=1;//定时器1中断使能</span></span><br><span class="line"><span class="comment">TMR1IF=0;//定时器1中断标志位清零</span></span><br><span class="line"><span class="comment">T1CON=0B00000000;//TMR1为定时器，预分频比1:1,不启动定时器1</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//使能CCP1捕捉每一个输入信号的上升沿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">TMR1ON=<span class="number">0</span>;<span class="comment">//关闭定时器1</span></span><br><span class="line">CCP2CON=<span class="number">0X00</span>;<span class="comment">//关闭PWM</span></span><br><span class="line">CCP1CON=<span class="number">0X00</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Send_Counter=<span class="number">0</span>;</span><br><span class="line">nRBPU=<span class="number">0</span>;<span class="comment">//启用RB弱上拉</span></span><br><span class="line">TRISB=<span class="number">0xFF</span>;<span class="comment">//作输入口</span></span><br><span class="line">TRISC7=<span class="number">0</span>;</span><br><span class="line">TRISC1=<span class="number">0</span>;<span class="comment">//PWM信号（载波）输出引脚</span></span><br><span class="line">TRISC2=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">TRISD=<span class="number">0X00</span>;<span class="comment">//数据口</span></span><br><span class="line">    TRISA=<span class="number">0x00</span>;<span class="comment">//RA0配置为输出模式</span></span><br><span class="line">ADCON1=<span class="number">0X07</span>;<span class="comment">//RA端口与AD转换有关！！！，不然无法正常显示LCD1602 </span></span><br><span class="line">LCD1602_Init();</span><br><span class="line">LCD1602_WriteString(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CCP中断配置*/</span></span><br><span class="line">GIE=<span class="number">1</span>;<span class="comment">//总中断打开</span></span><br><span class="line">PEIE=<span class="number">1</span>;<span class="comment">//第二梯队中断打开</span></span><br><span class="line">CCP1IE=<span class="number">1</span>;<span class="comment">//CCP中断打开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*周期测量</span></span><br><span class="line"><span class="comment">CCP1IF=0;//CCP标志位清零</span></span><br><span class="line"><span class="comment">TMR1IE=1;//定时器1中断使能</span></span><br><span class="line"><span class="comment">TMR1IF=0;//定时器1中断标志位清零</span></span><br><span class="line"><span class="comment">T1CON=0B00000000;//TMR1为定时器，预分频比1:1,不启动定时器1</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;//使能CCP1捕捉每一个输入信号的上升沿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">T2CON=<span class="number">0</span>;PR2=<span class="number">25</span>;TMR2=<span class="number">0</span>;<span class="comment">//TMR2初始化，周期26us</span></span><br><span class="line">CCP2CON=<span class="number">0X0C</span>;</span><br><span class="line">CCPR2L=<span class="number">13</span>;<span class="comment">//CCP2初始化，脉宽13us</span></span><br><span class="line">T1CON=<span class="number">0</span>;<span class="comment">//设置预分频比为 = 1:1,开中断</span></span><br><span class="line">data_cnt = <span class="number">0x09</span>;<span class="comment">//每组数据位数=9 - 1 = 8 .因为子程序是减1后判断</span></span><br><span class="line">CCP1CON = <span class="number">0X08</span>;<span class="comment">//CCP1设为匹配时令CCP1/RC2引脚输出电平不变</span></span><br><span class="line">TMR1ON=<span class="number">1</span>;<span class="comment">//启动TMR1</span></span><br><span class="line"></span><br><span class="line">data = PORTB;<span class="comment">//=PORTB;从PORTB取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="猜测同步头的宽窄导致信号处理出现错误数据"><a class="markdownIt-Anchor" href="#猜测同步头的宽窄导致信号处理出现错误数据"></a> 猜测：同步头的宽窄，导致信号处理出现错误数据</h2><img src="/posts/29338/image-20240514130203460.png" class="" title="image-20240514130203460"><p><strong>解决方案：<mark>调整同步头宽度。每Byte数据需要等待一定的时间</mark></strong></p><h2 id="仿真测试结果没有完整移入数据实际上只接收到了7位"><a class="markdownIt-Anchor" href="#仿真测试结果没有完整移入数据实际上只接收到了7位"></a> 仿真测试结果：没有完整移入数据，实际上只接收到了7位</h2><img src="/posts/29338/image-20240514160814051.png" class="" title="image-20240514160814051"><p><strong>更改输入捕获中断内对各个二进制捕获的电平时间范围，使得红外解调的容允值更大，修改后，代码如下</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"..\Driver\LCD1602.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data_RecByte;</span><br><span class="line"><span class="type">int</span> Time_Data;</span><br><span class="line">bit Data_RecFlag;</span><br><span class="line"><span class="type">char</span> i;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> TABLE[<span class="number">16</span>]={<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>,<span class="number">0x46</span>};</span><br><span class="line">bit Start_Flag;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">5</span>];</span><br><span class="line">}T_Data_Rec;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> interrupt <span class="title function_">ccp1_int</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">CCP1IF = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//PORTD^=0xFF;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(CCP1M0 == 0)//本次捕捉下降沿</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">TMR1H=0;TMR1L=0;</span></span><br><span class="line"><span class="comment">CCP1CON=0X05;</span></span><br><span class="line"><span class="comment">CCP1IF=0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">CCP1CON=0X04;</span></span><br><span class="line"><span class="comment">CCP1IF=0; Time_Data = CCPR1H &lt;&lt; 8 | CCPR1L;</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 400  &amp;&amp; Time_Data&lt; 500){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//55</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 800  &amp;&amp; Time_Data&lt; 1000){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//263</span></span><br><span class="line"><span class="comment">//if(Time_Data &gt; 2300  &amp;&amp; Time_Data&lt; 2600){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line"><span class="comment">if(Time_Data &gt; 2900 ){LCD1602_WriteNum(1,0,Time_Data,5);CCP1IE=0;}//575</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CCP1M0 == <span class="number">0</span>)<span class="comment">//本次捕捉下降沿</span></span><br><span class="line">{</span><br><span class="line">TMR1H=<span class="number">0</span>;TMR1L=<span class="number">0</span>;<span class="comment">//清零TMR1寄存器值</span></span><br><span class="line">CCP1CON=<span class="number">0X05</span>;<span class="comment">//下一次捕捉上升沿</span></span><br><span class="line">CCP1IF=<span class="number">0</span>;<span class="comment">//清除输入捕捉标志位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//本次捕捉上升沿</span></span><br><span class="line">{</span><br><span class="line">CCP1CON=<span class="number">0X04</span>;<span class="comment">//下一次捕捉下降沿</span></span><br><span class="line">CCP1IF=<span class="number">0</span>;Time_Data = CCPR1H &lt;&lt; <span class="number">8</span> | CCPR1L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;<span class="number">3200</span>){Start_Flag=<span class="number">1</span>;}  <span class="comment">//开始信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Start_Flag)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">400</span>  &amp;&amp; Time_Data &lt;= <span class="number">500</span>){Data_RecByte=Data_RecByte&lt;&lt;<span class="number">1</span>;}<span class="comment">//0'068</span></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">800</span>  &amp;&amp; Time_Data&lt;= <span class="number">1200</span>){Data_RecByte=Data_RecByte&lt;&lt;<span class="number">1</span>;Data_RecByte=Data_RecByte+<span class="number">1</span>;} <span class="comment">//'1'</span></span><br><span class="line"><span class="keyword">if</span>(Time_Data &gt;= <span class="number">2200</span>  &amp;&amp; Time_Data&lt;= <span class="number">2500</span>){T_Data_Rec.Data[i++] = Data_RecByte;Start_Flag=<span class="number">0</span>;}  <span class="comment">//结束信号</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">{</span><br><span class="line">LCD1602_WriteNum(<span class="number">2</span>,<span class="number">0</span>,Time_Data,<span class="number">5</span>);</span><br><span class="line">LCD1602_WriteCommand(<span class="number">0x80</span>);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">0</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">0</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">1</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">1</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">2</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">2</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">3</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">3</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">4</span>]&gt;&gt;<span class="number">4</span>]);</span><br><span class="line">LCD1602_WriteData(TABLE[T_Data_Rec.Data[<span class="number">4</span>]&amp;<span class="number">0x0F</span>]);</span><br><span class="line">LCD1602_WriteData(<span class="string">'H'</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>最终结果：实现了连续5Byte数据的接收</strong></p><img src="/posts/29338/image-20240514160944486.png" class="" title="image-20240514160944486"><h1 id="自定义通信协议"><a class="markdownIt-Anchor" href="#自定义通信协议"></a> 自定义通信协议</h1><p><strong><mark>在完整的红外传输系统工作在稳定可靠的状态后，我们可以拓展一些功能，如自己定义一个红外传输协议，使得单片机之间的红外通信能够实现更加复杂的功能，一次性能够传输更多的数据。</mark></strong></p><ul><li><p>添加一个起始位，长度位结束位的两倍</p></li><li><p>修改全部所有数据位对应的电平宽度，增加各自的比例。</p><ul><li>起始位：0xC30</li><li>‘0’: 0x204</li><li>‘1’:0x418</li><li>结束位:0x9C0</li></ul></li><li><p>修改同步头宽度，因为在实际使用红外通信时，单片机产生的红外信号可能没有那么理想，红外发射头发送出去的信号会衰减，因此我们可以适当增加同步头宽度，提高红外调制信号的“功率”，使得红外接收头能够正常接收到红外信号</p></li></ul><h1 id="周期信号测量红外收发系统"><a class="markdownIt-Anchor" href="#周期信号测量红外收发系统"></a> 周期信号测量+红外收发系统</h1><img src="/posts/29338/image-20240519165157774.png" class="" title="image-20240519165157774"><h1 id="红外双发双收双工系统"><a class="markdownIt-Anchor" href="#红外双发双收双工系统"></a> 红外双发双收（双工系统）</h1><img src="/posts/29338/image-20240519170223726.png" class="" title="image-20240519170223726"><h1 id="红外双工中继基站系统"><a class="markdownIt-Anchor" href="#红外双工中继基站系统"></a> 红外双工+中继基站系统</h1><p><strong><mark>如图所示，红外收发装置通过中继系统进行数据通信</mark></strong></p><img src="/posts/29338/image-20240519173118590.png" class="" title="image-20240519173118590"><h1 id="心得体会"><a class="markdownIt-Anchor" href="#心得体会"></a> 心得体会</h1><p>我在本次小组任务中，首先学习了红外通信系统的基本组成结构，了解了通信系统中调制/解调的原理以及实现方法。基于对第九章各个例子以及习题的学习以及编写相关代码，我熟悉了CCP模块的输入捕获、输出比较、PWM模式的工作原理。通过将这些模块组合，协同工作，在代码中利用定义的各个“标志位"，配置好了这些CCP各个功能模块协同工作的代码结构。</p><p>在准备进行本次小组任务的工作前，我们首先大概预览了一下本次小组任务需要用到的知识点，因为整个红外通信系统的构成需要多个单片机协同工作，所以必须要循循渐进地进行代码的编写、调试、验证。为了设计出最终包含红外双工通信+中继器的复杂系统，我们首先编写完成了一个简易的红外通信系统，不过这个系统的信号发送端发送的是基带信号，没有经过红外管，直接送给接收端单片机进行信号的解调。虽然我们在发送端设置好了各个不同数据位的电平宽度，比如’0‘，’1‘，’停止位‘的电平宽度有按照一定的比例用于区分，但课本上一开始给的例子，各个数据位电平宽度仅仅在微妙级，不管是仿真还是实物验证接收端都有可能无法解调出正确的信号，因为这些数据位的电平宽度太短，没有明显的区分度，一旦程序运行效率不行或者单片机电路上的微小延迟都有可能造成数据读取的错误。因此，我们等比例放大了每个数据位的电平宽度，以及同步头的宽度（保证调制信号的功率）。这样的话，不同bit的区分度就大大提高了。然后，我们自己再编写一段调试代码，即接收到任意的上边沿+下边沿的输入捕获，输出端改为固定指定的数据位发送，然后在接收端那边通过LCD1602显示实际上捕获到的电平宽度，这样就能知道红外接收端实际容允的电平宽度范围，确保整个红外通信系统的稳定性。</p><p>本次小组任务，更像一个小课程设计，我们设计出了一个功能完备的红外通信系统，在每个阶段的调试过程中，我们遇到了很多的问题，这些问题大多数是由于寄存器的配置引起的（因为单片机中CCP各个模块要协同工作，这就涉及到大量寄存器的状态切换），一旦寄存器配置冲突，而我们又不熟悉寄存器，就无法认识到代码的问题所在。我们通过MPLAB强大轻量化的Debug窗口，以及Proteus的调试功能，反复验证，循序渐进，最终设计出来了一个具备双工通信+中继器（基站）的完备通信系统，并且我们的通信系统可以通过修改代码中的参数实现连续任意位Byte的收发。</p><p>本次小组任务是有挑战性的，但是这也为我们后续学习更多复杂的通信系统打下基础。我们学会了化繁为简，分模块和层次，熟练配置单片机上所有相关功能寄存器的技巧，这不仅是我们单片机编程、电路系统设计技术上的显著提升，也是对理论基础是否扎实的考验。我想，通过本次小组任务，我们可以设计出各种功能强大，效率高的通信系统，利用自身专业编写出完备的通信协议等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; # 前言&lt;/h1&gt;
&lt;h2 id=&quot;一-红外通信系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-红外通信系统&quot;&gt;&lt;/a&gt; 一、红外</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【HEXO】[2] 多线程部署常见问题</title>
    <link href="https://szturin.github.io/posts/45608/"/>
    <id>https://szturin.github.io/posts/45608/</id>
    <published>2024-05-03T05:10:37.000Z</published>
    <updated>2024-05-21T12:12:43.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo更新日志"><a class="markdownIt-Anchor" href="#hexo更新日志"></a> HEXO更新日志</h1><p><strong>2024.5.3</strong></p><ul><li>重要更新：将HEXO博客部署到腾讯云轻量化服务器，极大提升国内访问速度，访问ip地址：<a href="http://122.51.23.7/">Turin’s Blog - 数理照亮世界</a></li><li>优化主页文章卡片界面，参考文章：<a href="https://butterfly.zhheo.com/home.html">首页 | Butterfly主题美化教程 (zhheo.com)</a></li><li>优化网站页面显示效果：透明度。<a href="https://qianchenggit.github.io/2021/10/06/%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E4%BD%BF%E7%94%A8%E4%B8%80%E5%9B%BE%E6%B5%81/">博客背景使用一图流 | QianChengGit の小森林</a></li></ul><hr><p>xxxxxxxxxx&nbsp;git remote add [alias] [url]//参数[alias]为别名， [url]为远程仓库的地址bash</p><h1 id="一-hexo部署到云服务器ubuntu系统"><a class="markdownIt-Anchor" href="#一-hexo部署到云服务器ubuntu系统"></a> 一、HEXO部署到云服务器(Ubuntu系统)</h1><p><strong><a href="https://cloud.tencent.com/developer/article/1945550">Hexo部署至服务器（Ubuntu 20.04）-腾讯云开发者社区-腾讯云 (tencent.com)</a></strong></p><p><strong><a href="https://blog.cpen.top/posts/38874.html">04_Hexo-多平台部署-云服务器-GitHub-Gitee | Mycpen</a></strong></p><h1 id="二-ubuntu允许root连接服务器"><a class="markdownIt-Anchor" href="#二-ubuntu允许root连接服务器"></a> 二、Ubuntu允许root连接服务器</h1><p><a href="https://blog.csdn.net/crayon0/article/details/122272001">Linux开启ssh并允许root登录（ubuntu、centos、kalilinux）_ssh允许root远程登录-CSDN博客</a></p><blockquote><p>报错信息 “E45: ‘readonly’ option is set (add ! to override)” 是在使用 Vim 或 Neovim 文本编辑器时可能遇到的一个错误信息。当您尝试将更改写入以只读模式打开的文件时，就会出现这条信息。这种情况可能由几个原因引起，例如，您正在编辑的文件在文件系统级别启用了写保护，或者 Vim 打开了一个它认为不应该修改的文件（例如，系统配置文件或标记为“只读”的文件）。</p><p>要解决这个问题并强制 Vim 或 Neovim 尽管文件处于只读状态也要写入更改，您可以使用 <code>:w!</code> 命令，其中 <code>w</code> 代表“写入”，<code>!</code> 实际上意味着“强制”或“覆盖”。</p><p>下面是如何处理这种情况：</p><h3 id="如果您打算修改文件"><a class="markdownIt-Anchor" href="#如果您打算修改文件"></a> 如果您打算修改文件</h3><ol><li><p><strong>强制保存更改</strong>：如果您知道文件是安全可编辑的，且打算保存更改，可以使用 <code>:w!</code> 命令强制保存更改。这告诉 Vim 覆盖只读限制。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w!</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>更改文件权限</strong>：如果文件是只读的是因为文件系统权限，您可能需要在 Vim 外部更改其权限。例如，在类 Unix 系统（Linux、macOS）上，您可以使用 <code>chmod</code> 命令使文件可写。假设文件名为 <code>example.txt</code>；您可以使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +w example.txt</span><br></pre></td></tr></tbody></table></figure><p>然后，在 Vim 内尝试再次保存文件。</p></li></ol><h3 id="如果文件应保持不变"><a class="markdownIt-Anchor" href="#如果文件应保持不变"></a> 如果文件应保持不变</h3><p>如果文件应该是只读的，且您不小心做了更改或重新考虑了您的编辑，有几个操作您可以执行：</p><ol><li><p><strong>撤销更改</strong>：通过使用 Vim 中的撤销命令 <code>u</code> 手动撤销更改，直到您恢复到文件的原始状态。</p></li><li><p><strong>不保存并退出</strong>：如果您想退出 Vim 而不保存任何更改，可以使用 <code>:q!</code> 命令，它退出 Vim 且不保存。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="理解只读文件"><a class="markdownIt-Anchor" href="#理解只读文件"></a> 理解只读文件</h3><p>在决定覆盖其只读状态之前，了解文件为什么可能处于只读模式是很重要的。文件可以因各种原因而被设置为只读：</p><ul><li>文件可能在文件系统级别被标记为只读，以防止意外更改。</li><li>文件可能属于另一个用户或需要管理员权限才能修改。</li><li>Vim 可能会在检测到文件正在被另一个进程使用时，以只读模式打开文件。</li><li>某些配置或命令（如使用 <code>vim -R &lt;filename&gt;</code> 打开文件）可以指示 Vim 以只读模式打开文件。</li></ul><p>在尝试覆盖文件的只读状态之前，始终确保修改文件是恰当的。</p></blockquote><p><strong>root终端连接效果</strong></p><img src="/posts/45608/image-20240503134748284.png" class="" title="image-20240503134748284"><h2 id="公网ip访问blog网站"><a class="markdownIt-Anchor" href="#公网ip访问blog网站"></a> 公网ip访问Blog网站</h2><img src="/posts/45608/image-20240503135033425.png" class="" title="image-20240503135033425"><p><strong>总结：使用腾讯云服务器（Unbuntu系统）部署Hexo博客，踩雷无数。此次部署博主理解了Linux服务器的详细配置流程，blog网站的访问速度得到了大幅度的提升，免受”科学上网“之苦</strong></p><h1 id="三-问题待解决"><a class="markdownIt-Anchor" href="#三-问题待解决"></a> 三、问题（待解决）</h1><h2 id="一-每次deploy需要输入服务器root密码"><a class="markdownIt-Anchor" href="#一-每次deploy需要输入服务器root密码"></a> 一、每次deploy需要输入服务器root密码</h2><ul><li><p><strong>解决方案：配置SSH公钥</strong></p></li><li><p><strong>参考文章：</strong><a href="https://zhuanlan.zhihu.com/p/549151974">Hexo历险记之八SSH远程链接服务器 - 知乎 (zhihu.com)</a></p></li></ul><p><strong>将git环境下的ssh公钥配置到服务器中的authorized_keys，并且修改sshd_config文件，配置好ssh各项权限</strong></p><img src="/posts/45608/image-20240503153851704.png" class="" title="image-20240503153851704"><p>**最终效果：**免密连接</p><img src="/posts/45608/image-20240503154119191.png" class="" title="image-20240503154119191"><p><strong>PS: 允许不同环境的终端配对的公钥可能不一样，这里使用git bash，要连接的服务器那边就需要使用git bash生成的公钥，才能实现免密登录，这样每次deploy时无需输入密码</strong></p><h2 id="二-blog域名"><a class="markdownIt-Anchor" href="#二-blog域名"></a> 二、Blog域名</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo更新日志&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hexo更新日志&quot;&gt;&lt;/a&gt; HEXO更新日志&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;2024.5.3&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重要更新：将HEXO博客部署到</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="博客搭建" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/categories/Linux/Ubuntu/"/>
    
    
    <category term="HEXO" scheme="https://szturin.github.io/tags/HEXO/"/>
    
    <category term="博客" scheme="https://szturin.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="github" scheme="https://szturin.github.io/tags/github/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/tags/Ubuntu/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【ROS2】“人在回路”---与生成式人工智能交互的视觉医疗机器人</title>
    <link href="https://szturin.github.io/posts/17498/"/>
    <id>https://szturin.github.io/posts/17498/</id>
    <published>2024-04-27T16:39:25.000Z</published>
    <updated>2024-05-18T03:36:16.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人在回路与生成式人工智能交互的视觉服务机器人"><a class="markdownIt-Anchor" href="#人在回路与生成式人工智能交互的视觉服务机器人"></a> “人在回路”—与生成式人工智能交互的视觉服务机器人</h1><p><strong>第一次更新：2024.4.28</strong></p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><ul><li>人在回路（Human-in-the-loop）是一种模式，类似于人机闭环系统或人机互助系统。这种模式被认为是机器学习、人工智能和机器智能的一种可行发展模式，需要人与机器之间的相互作用。在这种模式下，人类始终是模型的一部分，影响着模型的结果，并且需要人类的智能来帮助机器更加智能化。</li><li>ChatGPT是一款强大的基于深度学习的自然语言处理模型，能够生成高质量的自然语言文本。使用ChatGPT+TogetheROS，即ChatRobot将文字描述转化为小车控制指令，根据描述生成特定功能的代码，使机器人按照描述执行相应的任务。–转自NodeHube社区。–转自NobeHube</li></ul><h2 id="项目信息"><a class="markdownIt-Anchor" href="#项目信息"></a> 项目信息：</h2><p><strong>我们的机器人定位为医疗看护机器人（无人车），使用RDK X3 嵌入式AI开发板作为主控，通过Opencv等进行视觉识别，基于类似激光雷达测距的方法实现自主导航运动，满足不同场景下的控制需求。通过ROS2系统使小车与计算机进行通信。</strong></p><p><strong>我们计划使用OpenAI提供的API接口写入小车系统，实现初步的语音交互到控制的过程。基于搭载ROS2系统的RDK X3开发板，使用"人在回路"的模型训练方法，完善机器人行为模型的逻辑，提升机器学习的算法和模型的zhi在后续对GPT接口的开发中，我们设想可以与Chatgpt进行“人在回路”的系统训练，基本实现我们的设想目标。</strong></p><p>基于"人在回路"的模型训练：</p><p><strong>传统的机器人设计，往往是按照设定好的行为逻辑，这种设计过于机械化。而在医疗领域，传统的机器人显然不足以应对以人为核心的服务化需要。所以我们设想，利用“人在回路“的人机闭环互助系统对机器人进行训练，是否可以使得机器人简单地接近于人类的思维模式。应用在医疗服务等领域</strong></p><p><strong>人类能够根据实际情况灵活调整策略和方法，这种能力是当前机器人或人工智能难以完全实现的。通过人在回路，机器人在执行任务时可以依据人类的指示灵活调整其行为和策略，更好地适应复杂多变的环境，这就是我们设计的初步思想，虽然从技术的角度出发还有非常遥远的距离，但是我们可以通过这种方法和思想，逐步完善机器人的基本功能。</strong></p><p><mark><strong>我们将搭载地平线公司的RDK X3作为主控， 配合32位单片机与各类传感器模块进行数据交互，制作一个能够应用于医疗、后勤等领域的复杂多场景的无人车型机器人，能够先实现以下的基本功能：</strong></mark></p><ul><li><p>送药：前期阶段实现小车的所有控制部分，通过Opencv，Openmv组成双摄系统。Opencv负责深度学习相关的视觉识别，Openmv通过SPI协议与单片机进行通信，搭建基础的路径检测控制功能。==实现房号识别，自动药物配送。==中期阶段部署利用Simulink或者Gazebo进行小车的运动仿真。</p></li><li><p>自主导航：通过激光雷达进行SLAM建图，使得机器人具备在不同地环境下进行路径规划避障的功能。</p></li><li><p>语言交互：通过API接口与ChatGPT初步实现计算机的文字交互-&gt;控制小车基本运动-&gt;搭载语音模块控制ChatGPT-&gt;完成更复杂的人机交互系统（图像识别+传感器+语音模块）。</p></li><li><p>环境检测：实现小车上述的基本功能后，进行深度学习相关的视觉开发，使用时下热门的YOLO目标检测算法。能够实现对病人如：跌倒检测（识别人体关节点）等视觉应用。</p></li></ul><h2 id="队伍信息"><a class="markdownIt-Anchor" href="#队伍信息"></a> 队伍信息</h2><p><strong>我们队伍命名为FFT队，FFT即为快速傅立叶变换（Fast Fourier Transform），它是一种算法，在信号处理、图像处理、音频处理等领域广泛使用的技术，在如今5G大规模普及的时代，5G具有mMTC(超大规模机器连接)，eMBB(超低延时)的特点，”物联网“，“边缘计算”，“自动驾驶”等技术得到显著的发展。队伍成员基本为为通信系学生。FFT意为我们队伍追求高效、灵活、准确的开发学习，秉持创新思维、以赛促学的思想，能够将创意与专业知识运用在前沿领域。我们希望基于RDK X3 实现一些基于AI与物联网的idea，利用自身的专业知识，能够在本次项目中通信部分进行着重地设计，提高云平台与机器人的通信效率与可靠性。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人在回路与生成式人工智能交互的视觉服务机器人&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#人在回路与生成式人工智能交互的视觉服务机器人&quot;&gt;&lt;/a&gt; “人在回路”—与生成式人工智能交互的视觉服务机器人&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;第</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="ROS2" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ROS2/"/>
    
    <category term="Linux" scheme="https://szturin.github.io/categories/Linux/"/>
    
    <category term="人工智能" scheme="https://szturin.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="RDK X3" scheme="https://szturin.github.io/categories/RDK-X3/"/>
    
    <category term="Ubuntu" scheme="https://szturin.github.io/categories/Linux/Ubuntu/"/>
    
    <category term="ROS2" scheme="https://szturin.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/ROS2/"/>
    
    
    <category term="ROS2" scheme="https://szturin.github.io/tags/ROS2/"/>
    
    <category term="linux" scheme="https://szturin.github.io/tags/linux/"/>
    
    <category term="操作系统" scheme="https://szturin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="RDK X3" scheme="https://szturin.github.io/tags/RDK-X3/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[软件操作]仿真调试</title>
    <link href="https://szturin.github.io/posts/45531/"/>
    <id>https://szturin.github.io/posts/45531/</id>
    <published>2024-04-27T07:26:45.000Z</published>
    <updated>2024-05-19T07:28:04.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软键盘"><a class="markdownIt-Anchor" href="#软键盘"></a> 软键盘</h1><img src="/posts/45531/image-20240427152809497.png" class="" title="image-20240427152809497"><h1 id="选择使用按键的属性"><a class="markdownIt-Anchor" href="#选择使用按键的属性"></a> 选择使用按键的属性</h1><img src="/posts/45531/image-20240427152840915.png" class="" title="image-20240427152840915">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软键盘&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软键盘&quot;&gt;&lt;/a&gt; 软键盘&lt;/h1&gt;
&lt;img src=&quot;/posts/45531/image-20240427152809497.png&quot; class=&quot;&quot; title=&quot;imag</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MPLAB" scheme="https://szturin.github.io/tags/MPLAB/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[8]AD/DA转换</title>
    <link href="https://szturin.github.io/posts/56223/"/>
    <id>https://szturin.github.io/posts/56223/</id>
    <published>2024-04-23T13:49:05.000Z</published>
    <updated>2024-05-09T11:10:24.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库函数解释"><a class="markdownIt-Anchor" href="#库函数解释"></a> 库函数解释</h1><blockquote><p>xxxxxxxxxx&nbsp;$ tags: -数字电路与VHDL设计"bash</p><p>void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);</p><p><strong>恢复缺省配置</strong></p><p>void ADC_DeInit(ADC_TypeDef* ADCx);</p><p><strong>ADC初始化</strong></p><p>void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>结构体初始化</strong></p><p>void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);</p><p><strong>ADC上电</strong></p><p>void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>开启DMA输出信号</strong></p><p>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>中断输出控制</strong></p><p>void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);</p><ul><li>用于控制某个中断能否通往NVIC</li></ul><p><strong>复位校准</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取复位校准状态</strong></p><p>void ADC_ResetCalibration(ADC_TypeDef* ADCx);</p><p><strong>开始校准</strong></p><p>void ADC_StartCalibration(ADC_TypeDef* ADCx);</p><p><strong>获取开始校准状态</strong></p><p>FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);</p><p><strong>ADC软件触发的函数</strong></p><p>void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><strong>ADC获取软件转换状态</strong></p><p>FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);</p><ul><li><p>实际上是获取CR2的SWSTART这一位,但是SWSTART在开始ADC转换后直接清除，所以并不能通过这个函数获得是否开始转换的信息</p><img src="/posts/56223/image-20240423220300035.png" class="" title="image-20240423220300035"></li></ul><p><strong><mark>如何获取ADC是否开启的状态？</mark></strong></p><p><strong>获取标志位状态</strong></p><p>FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);</p><ul><li>可以调用这个函数,ADC_FLAG选择EOC,判断EOC标志位是否置1</li></ul><p><strong>每隔几个通道间断一次</strong></p><p>void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);</p><p><strong>是否启动间断模式</strong></p><p>void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC规则组通道配置</strong></mark></p><p>void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);</p><ul><li>ADCx</li><li>ADC_Channel：指定的通道</li><li>Rank：序列的位置</li><li>ADC_SampleTime：指定通道的采样时间</li></ul><p><strong>ADC外部触发转换控制（是否允许外部触发转换）</strong></p><p>void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</p><p><mark><strong>ADC获取转换值</strong></mark></p><p>uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);</p><ul><li>获取AD转换的数据寄存器，读取转换结果</li></ul><p><strong>ADC获取双模式转换值</strong></p><p>uint32_t ADC_GetDualModeConversionValue(void);</p><p><strong>是否启动模拟看门狗</strong></p><p>void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);</p><p><strong>配置高低阈值</strong></p><p>void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);</p><p><strong>配置看门的通道</strong></p><p>void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);</p><p><strong>ADC温度传感器、内部参考电压控制</strong></p><p>void ADC_TempSensorVrefintCmd(FunctionalState NewState);</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;库函数解释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#库函数解释&quot;&gt;&lt;/a&gt; 库函数解释&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;xxxxxxxxxx&amp;nbsp;$ tags: -数字电路与VHDL设计&quot;bash&lt;/p&gt;
&lt;p&gt;v</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="AD/DA转换" scheme="https://szturin.github.io/tags/AD-DA%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[7]编码器接口测速</title>
    <link href="https://szturin.github.io/posts/37664/"/>
    <id>https://szturin.github.io/posts/37664/</id>
    <published>2024-04-20T14:16:11.000Z</published>
    <updated>2024-05-02T12:05:41.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关库函数"><a class="markdownIt-Anchor" href="#相关库函数"></a> 相关库函数</h2><blockquote><p><strong>定时器编码器配置</strong></p><p>void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,<br>uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);</p><ul><li>TIMx:选择定时器</li><li>TIM_EncoderMode: 选择编码器模式，T1单独计数，T2单独计数，T1/T2同时计数</li></ul><img src="/posts/37664/image-20240420235549817.png" class="" title="image-20240420235549817"><ul><li>TIM_IC1Polarity：电平极性</li><li>TIM_IC2Polarity：电平极性  可以通过配置这两个参数，设置正相和反相</li></ul><img src="/posts/37664/image-20240420235814820.png" class="" title="image-20240420235814820"></blockquote><h2 id="编码器测计数"><a class="markdownIt-Anchor" href="#编码器测计数"></a> 编码器测计数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//结构体类型(已经定义好的） 结构体变量名 -&gt;结构体变量的定义</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时基单元初始化配置*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM3);<span class="comment">//定时器上电后默认使用内部时钟,此语句也可以不写</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision =  TIM_CKD_DIV1 ;<span class="comment">//1分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler= <span class="number">1</span><span class="number">-1</span>;<span class="comment">//PSC 不分频</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period= <span class="number">65536</span> - <span class="number">1</span>;<span class="comment">//ARR </span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="number">0</span>;<span class="comment">//重复计数器，高级定时器钟存在，这里不需要用</span></span><br><span class="line">TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<span class="comment">//时基单元初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入捕获单元配置*/</span></span><br><span class="line"><span class="comment">/**通道1配置**/</span></span><br><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">    TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="comment">//给结构体赋初始值，防止出现不确定的状态</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发  TIM_EncoderInterfaceConfig重复配置了相同的寄存器</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line">    <span class="comment">/**通道2配置**/</span> <span class="comment">//注意：这里不需要再定义新的结构体。因为上一次的值已经写入硬件寄存器</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel=TIM_Channel_2;<span class="comment">//输入捕获通道选择</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter=<span class="number">0XF</span>;<span class="comment">//输入捕获滤波器</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;//极性，上升沿触发</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置编码器接口*/</span></span><br><span class="line">    TIM_EncoderInterfaceConfig(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//定时器3 ，T1T2同时使用，极性相同(上升沿/下降沿两个都是有效的)，即为正相</span></span><br><span class="line">    <span class="comment">//若要反相，那么一个配置位上升沿，一个配置为下降沿有效</span></span><br><span class="line">TIM_Cmd(TIM3,ENABLE);<span class="comment">//启动定时器</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//int16_t 表示有符号数，能把unint16_相比最高位变为了符号位,这里利用到了补码的特性</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> TIM_GetCounter(TIM3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="编码器测速"><a class="markdownIt-Anchor" href="#编码器测速"></a> 编码器测速</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关库函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#相关库函数&quot;&gt;&lt;/a&gt; 相关库函数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定时器编码器配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;void TIM_EncoderI</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="输入捕获" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/"/>
    
    <category term="输出比较" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】方波发生器-电子琴</title>
    <link href="https://szturin.github.io/posts/46544/"/>
    <id>https://szturin.github.io/posts/46544/</id>
    <published>2024-04-16T10:23:27.000Z</published>
    <updated>2024-05-22T07:52:59.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何得到精准的250us定时"><a class="markdownIt-Anchor" href="#如何得到精准的250us定时"></a> 如何得到精准的250us定时？</h1><p><strong>先确认大概的定时器计数器值，再利用跑马表调整误差</strong></p><img src="/posts/46544/image-20240416182439723.png" class="" title="image-20240416182439723">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何得到精准的250us定时&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何得到精准的250us定时&quot;&gt;&lt;/a&gt; 如何得到精准的250us定时？&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;先确认大概的定时器计数器值，再利用跑马表调整误差&lt;/s</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="项目设计学习" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MPLAB" scheme="https://szturin.github.io/tags/MPLAB/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[软件操作]-跑马表</title>
    <link href="https://szturin.github.io/posts/15341/"/>
    <id>https://szturin.github.io/posts/15341/</id>
    <published>2024-04-05T07:21:38.000Z</published>
    <updated>2024-05-02T11:57:14.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何打开stop-watch窗口"><a class="markdownIt-Anchor" href="#如何打开stop-watch窗口"></a> 如何打开Stop Watch窗口？</h1><blockquote><p><strong>在DEBUG下选mplab sim后，再点DEBUGSETTING来设好频率，设好后点stopwatch</strong></p></blockquote><h1 id="跑马表仿真测试"><a class="markdownIt-Anchor" href="#跑马表仿真测试"></a> 跑马表仿真测试</h1><p><mark>在中断<strong>对应</strong>的位置打上断点，点击仿真运行，即可通过跑马表查看每次进中断的运行时间</mark></p><img src="/posts/15341/image-20240405155601030.png" class="" title="image-20240405155601030"><h1 id="车辆里程表"><a class="markdownIt-Anchor" href="#车辆里程表"></a> 车辆里程表</h1><h2 id="proteus仿真"><a class="markdownIt-Anchor" href="#proteus仿真"></a> proteus仿真</h2><p><mark>可以通过工具栏<strong>调试</strong>选项</mark>，查看各个所需的调试窗口，运行调试工具。</p><p>ps:<strong>step into</strong>可以跳过断点</p><img src="/posts/15341/image-20240405170845407.png" class="" title="image-20240405170845407"><p>第二次进中断，LED灯点亮</p><img src="/posts/15341/image-20240405171351683.png" class="" title="image-20240405171351683"><p>ps:<strong>cof为仿真文件,hex为下载文件</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何打开stop-watch窗口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何打开stop-watch窗口&quot;&gt;&lt;/a&gt; 如何打开Stop Watch窗口？&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在DEBUG下选</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MPLAB" scheme="https://szturin.github.io/tags/MPLAB/"/>
    
  </entry>
  
  <entry>
    <title>【微机原理】[2]中断系统</title>
    <link href="https://szturin.github.io/posts/18816/"/>
    <id>https://szturin.github.io/posts/18816/</id>
    <published>2024-03-27T13:27:47.000Z</published>
    <updated>2024-05-10T05:21:04.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="保护现场"><a class="markdownIt-Anchor" href="#保护现场"></a> 保护现场</h2><img src="/posts/18816/image-20240327212904491.png" class="" title="image-20240327212904491">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;保护现场&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#保护现场&quot;&gt;&lt;/a&gt; 保护现场&lt;/h2&gt;
&lt;img src=&quot;/posts/18816/image-20240327212904491.png&quot; class=&quot;&quot; title=&quot;i</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/categories/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PIC单片机" scheme="https://szturin.github.io/tags/PIC%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【单片机】串口通信</title>
    <link href="https://szturin.github.io/posts/25165/"/>
    <id>https://szturin.github.io/posts/25165/</id>
    <published>2024-03-23T11:29:59.000Z</published>
    <updated>2024-05-02T08:02:59.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯部分"><a class="markdownIt-Anchor" href="#蓝桥杯部分"></a> 蓝桥杯部分</h1><h2 id="1串口底层"><a class="markdownIt-Anchor" href="#1串口底层"></a> 1.串口底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字节发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line">SBUF=dat;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Send_String</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(*dat != <span class="string">'\0'</span>)<span class="comment">//当字符不为空时，继续发送</span></span><br><span class="line">SendByte(*dat++);<span class="comment">//发送后指针dat加1，指向下一个字节</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2单片机发送字符串给上位机"><a class="markdownIt-Anchor" href="#2单片机发送字符串给上位机"></a> 2.单片机发送字符串给上位机</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0x7F</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0xF0</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL0 = <span class="number">0x18</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF0 = <span class="number">0</span>;<span class="comment">//清除TF0标志</span></span><br><span class="line">TR0 = <span class="number">1</span>;<span class="comment">//定时器0开始计时</span></span><br><span class="line">ET0 = <span class="number">1</span>;    <span class="comment">//定时器中断0打开</span></span><br><span class="line">EA = <span class="number">1</span>;     <span class="comment">//总中断打开</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay500ms</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">23</span>;</span><br><span class="line">j = <span class="number">205</span>;</span><br><span class="line">k = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (--k);</span><br><span class="line">} <span class="keyword">while</span> (--j);</span><br><span class="line">} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"></span><br><span class="line">Uart1_Init();</span><br><span class="line"></span><br><span class="line">Delay500ms();<span class="comment">//mark:初始化后若立即发送数据，第一个字节会重复发送，所以先延时500ms,等待UART稳定工作，再发送字符串</span></span><br><span class="line"></span><br><span class="line">Uart1_SendString(<span class="string">"Hello UART"</span>);<span class="comment">//字符串发送数据在开启定时器中断时容易被打断,第一个字节刚好卡在没发完的时刻,造成死循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行任务</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//Key_Proc();</span></span><br><span class="line"><span class="comment">//Nixie_Proc();</span></span><br><span class="line"><span class="comment">//LED_Proc();</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3上位机发送字符串给单片机"><a class="markdownIt-Anchor" href="#3上位机发送字符串给单片机"></a> 3.上位机发送字符串给单片机</h2><p><strong><mark>PS:按键4可发送单片机接收到的字符串给上位机</mark></strong></p><h3 id="串口处理模块"><a class="markdownIt-Anchor" href="#串口处理模块"></a> 串口处理模块</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData[Uart_RecData_Index]=SBUF;</span><br><span class="line">Uart_RecData_Index++;</span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="按键程序"><a class="markdownIt-Anchor" href="#按键程序"></a> 按键程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//按键扫描部分//</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(Key_Down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">Uart_SendDataFlag=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中断程序"><a class="markdownIt-Anchor" href="#中断程序"></a> 中断程序</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart1_Server</span><span class="params">(<span class="type">void</span>)</span> interrupt 4</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData[Uart_RecData_Index]=SBUF;</span><br><span class="line">Uart_RecData_Index++;</span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Uart_Timer==<span class="number">100</span>){Uart_Timer=<span class="number">0</span>;}</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">500</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">10</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">LED_Disp(Nixie_Pos,ucLED[Nixie_Pos]);<span class="comment">//LED，一轮即可点亮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Uart_SendDataFlag==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">Uart_SendDataFlag=<span class="number">0</span>;</span><br><span class="line">Uart1_SendString(Uart_RecData);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4上位机发送数据控制单片机led"><a class="markdownIt-Anchor" href="#4上位机发送数据控制单片机led"></a> 4.上位机发送数据控制单片机LED</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Uart_Timer)<span class="keyword">return</span>;</span><br><span class="line">Uart_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if(Uart_RecData[Uart_RecData_Index-1]==0x0a &amp;&amp; Uart_RecData[Uart_RecData_Index-2]==0x0d) //0x0a--&gt;'\n' 0x0d--&gt;'\r'</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//if(Uart_RecData_Index==9 &amp;&amp; Uart_RecData[0]=='L' &amp;&amp; Uart_RecData[1]=='E' &amp;&amp; Uart_RecData[2]=='D' &amp;&amp; Uart_RecData[3]=='1' &amp;&amp; Uart_RecData[4]=='='&amp;&amp;Uart_RecData[5]=='1')</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//ucLED[0]=1;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="keyword">if</span>(Uart_RecData[Uart_RecData_Index<span class="number">-1</span>]==<span class="number">0x0a</span> &amp;&amp; Uart_RecData[Uart_RecData_Index<span class="number">-2</span>]==<span class="number">0x0d</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Uart_RecData_Index==<span class="number">8</span> &amp;&amp; Uart_RecData[<span class="number">0</span>]==<span class="string">'L'</span> &amp;&amp; Uart_RecData[<span class="number">1</span>]==<span class="string">'E'</span> &amp;&amp; Uart_RecData[<span class="number">2</span>]==<span class="string">'D'</span> &amp;&amp; Uart_RecData[<span class="number">3</span>]==<span class="string">'1'</span> &amp;&amp; Uart_RecData[<span class="number">4</span>]==<span class="string">'='</span>&amp;&amp;Uart_RecData[<span class="number">5</span>]==<span class="string">'1'</span>)</span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Uart_RecData_Index=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2串口优化"><a class="markdownIt-Anchor" href="#2串口优化"></a> 2.串口优化</h2><h3 id="putchar重定向"><a class="markdownIt-Anchor" href="#putchar重定向"></a> putchar重定向</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//8位数据,可变波特率</span></span><br><span class="line">AUXR |= <span class="number">0x01</span>;<span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">AUXR |= <span class="number">0x04</span>;<span class="comment">//定时器时钟1T模式</span></span><br><span class="line">T2L = <span class="number">0xC7</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">T2H = <span class="number">0xFE</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">AUXR |= <span class="number">0x10</span>;<span class="comment">//定时器2开始计时</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串口中断</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//总中断开启</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> <span class="title function_">putchar</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">    SBUF=ch; <span class="comment">///将dat数据</span></span><br><span class="line">    <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">    TI=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>(ch);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;蓝桥杯部分&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#蓝桥杯部分&quot;&gt;&lt;/a&gt; 蓝桥杯部分&lt;/h1&gt;
&lt;h2 id=&quot;1串口底层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1串口底层&quot;&gt;&lt;/a&gt; 1.串</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯单片机】考点复盘1</title>
    <link href="https://szturin.github.io/posts/5903/"/>
    <id>https://szturin.github.io/posts/5903/</id>
    <published>2024-03-23T08:33:10.000Z</published>
    <updated>2024-05-02T08:08:15.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-led模块"><a class="markdownIt-Anchor" href="#一-led模块"></a> 一、LED模块</h1><h2 id="1led底层代码"><a class="markdownIt-Anchor" href="#1led底层代码"></a> 1.LED底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Led_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr, enable)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp = <span class="number">0x00</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span> (enable)</span><br><span class="line">        temp |= <span class="number">0x01</span> &lt;&lt; addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp &amp;= ~(<span class="number">0x01</span> &lt;&lt; addr);</span><br><span class="line">   <span class="keyword">if</span> (temp != temp_old)</span><br><span class="line">    {</span><br><span class="line">        P0 = ~temp;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0x80</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式"><a class="markdownIt-Anchor" href="#2基本调用方式"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ucLED[n]=x;</span><br><span class="line"></span><br><span class="line">中断程序</span><br><span class="line">{</span><br><span class="line">    Led_Disp(Nixie_Pos,ucLED[Nixie_Pos]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二-按键模块"><a class="markdownIt-Anchor" href="#二-按键模块"></a> 二、按键模块</h1><h2 id="1按键底层代码"><a class="markdownIt-Anchor" href="#1按键底层代码"></a> 1.按键底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Read</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp = <span class="number">0</span>;</span><br><span class="line">    ET0 = <span class="number">0</span>;</span><br><span class="line">    P44 = <span class="number">0</span>;P42 = <span class="number">1</span>;P35 = <span class="number">1</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">7</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">0</span>;P35 = <span class="number">1</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">11</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">1</span>;P35 = <span class="number">0</span>;P34 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">15</span>;</span><br><span class="line">    P44 = <span class="number">1</span>;P42 = <span class="number">1</span>;P35 = <span class="number">1</span>;P34 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(P33 == <span class="number">0</span>) temp = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span>(P32 == <span class="number">0</span>) temp = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span>(P31 == <span class="number">0</span>) temp = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span>(P30 == <span class="number">0</span>) temp = <span class="number">19</span>;</span><br><span class="line">    P3 = <span class="number">0xff</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式-2"><a class="markdownIt-Anchor" href="#2基本调用方式-2"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(Key_Down)<span class="comment">//下降沿</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">case</span> X:</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="23-模式切换"><a class="markdownIt-Anchor" href="#23-模式切换"></a> <strong>2.3</strong> <strong>模式切换</strong></h4><img src="/posts/5903/clip_image002.jpg" class="" title="img"><p>第十届省赛真题</p><img src="/posts/5903/clip_image004.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="24-参数设置"><a class="markdownIt-Anchor" href="#24-参数设置"></a> <strong>2.4</strong> <strong>参数设置</strong></h4><img src="/posts/5903/clip_image006.jpg" class="" title="img"><p>第九届省赛真题</p><img src="/posts/5903/clip_image008.jpg" class="" title="img"><p>第八届省赛真题</p><h4 id="25-参数保存"><a class="markdownIt-Anchor" href="#25-参数保存"></a> <strong>2.5</strong> <strong>参数保存</strong></h4><img src="/posts/5903/clip_image010.jpg" class="" title="img"><p>第五届省赛真题</p><img src="/posts/5903/clip_image012.jpg" class="" title="img"><p>第十一届省赛真题</p><h4 id="26-特定使能"><a class="markdownIt-Anchor" href="#26-特定使能"></a> <strong>2.6</strong> <strong>特定使能</strong></h4><img src="/posts/5903/clip_image014.jpg" class="" title="img"><p>第十一届省赛真题</p><h4 id="27-长按跳转-松手返回"><a class="markdownIt-Anchor" href="#27-长按跳转-松手返回"></a> <strong>2.7</strong> <strong>长按跳转 松手返回</strong></h4><img src="/posts/5903/clip_image016.jpg" class="" title="img"><p>第八届省赛真题</p><h4 id="28-键盘输入"><a class="markdownIt-Anchor" href="#28-键盘输入"></a> <strong>2.8</strong> <strong>键盘输入</strong></h4><img src="/posts/5903/clip_image017.png" class="" title="img"><p>模拟训练二</p><h4 id="29-长按短按-效果不同"><a class="markdownIt-Anchor" href="#29-长按短按-效果不同"></a> <strong>2.9</strong> <strong>长按短按 效果不同</strong></h4><img src="/posts/5903/clip_image019.jpg" class="" title="img"><h1 id="三-数码管模块"><a class="markdownIt-Anchor" href="#三-数码管模块"></a> 三、数码管模块</h1><h2 id="1数码管底层代码"><a class="markdownIt-Anchor" href="#1数码管底层代码"></a> 1.数码管底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg_dula[] = {<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0xff</span>};</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> seg_wela[] = {<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Seg_Disp</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> wela,dula,point)</span></span><br><span class="line">{</span><br><span class="line">    P0 = <span class="number">0xff</span>;</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xe0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line"></span><br><span class="line">    P0 = seg_wela[wela];</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xc0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">    </span><br><span class="line">    P0 = seg_dula[dula];</span><br><span class="line">    <span class="keyword">if</span>(point)</span><br><span class="line">        P0 &amp;= <span class="number">0x7f</span>;</span><br><span class="line">    P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xe0</span>;</span><br><span class="line">    P2 &amp;= <span class="number">0x1f</span>; </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2基本调用方式-3"><a class="markdownIt-Anchor" href="#2基本调用方式-3"></a> 2.基本调用方式</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Seg_Buf[X] = Y;</span><br><span class="line">Seg_Point[X] = Y;</span><br></pre></td></tr></tbody></table></figure><h4 id="33-显示整数变量"><a class="markdownIt-Anchor" href="#33-显示整数变量"></a> <strong>3.3</strong> <strong>显示整数变量</strong></h4><img src="/posts/5903/clip_image002-1711183567913-109.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="34-显示小数点变量"><a class="markdownIt-Anchor" href="#34-显示小数点变量"></a> <strong>3.4</strong> <strong>显示小数点变量</strong></h4><img src="/posts/5903/clip_image004-1711183567913-110.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="35-不同状态显示不同内容"><a class="markdownIt-Anchor" href="#35-不同状态显示不同内容"></a> <strong>3.5</strong> <strong>不同状态显示不同内容</strong></h4><img src="/posts/5903/clip_image006-1711183567914-112.jpg" class="" title="img"><p>第十二届省赛真题</p><h4 id="36-高位熄灭"><a class="markdownIt-Anchor" href="#36-高位熄灭"></a> <strong>3.6</strong> <strong>高位熄灭</strong></h4><img src="/posts/5903/clip_image008-1711183567913-111.jpg" class="" title="img"><p>第十届省赛真题</p><h4 id="37-选中单元闪烁"><a class="markdownIt-Anchor" href="#37-选中单元闪烁"></a> <strong>3.7</strong> <strong>选中单元闪烁</strong></h4><img src="/posts/5903/clip_image010-1711183567914-113.jpg" class="" title="img"><p>第八届省赛真题</p><h1 id="四-继电器蜂鸣器"><a class="markdownIt-Anchor" href="#四-继电器蜂鸣器"></a> 四、继电器蜂鸣器</h1><h2 id="1底层代码"><a class="markdownIt-Anchor" href="#1底层代码"></a> 1.底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_1 = <span class="number">0x00</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> temp_old_1 = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Beep</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        temp_1 |= <span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp_1 &amp;= ~<span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">    {</span><br><span class="line">        P0 = temp_1;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old_1 = temp_1;        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Relay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> flag)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        temp_1 |= <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp_1 &amp;= ~<span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp_1 != temp_old_1)</span><br><span class="line">    {</span><br><span class="line">        P0 = temp_1;</span><br><span class="line">        P2 = P2 &amp; <span class="number">0x1f</span> | <span class="number">0xa0</span>;</span><br><span class="line">        P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line">        temp_old_1 = temp_1;        </span><br><span class="line">    }   </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>…</p><h1 id="ne555"><a class="markdownIt-Anchor" href="#ne555"></a> NE555</h1><p>绑定定时器0，应采用计数器模式</p><h1 id="超声波"><a class="markdownIt-Anchor" href="#超声波"></a> #超声波</h1><h2 id="1超声波底层代码"><a class="markdownIt-Anchor" href="#1超声波底层代码"></a> 1.超声波底层代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">()</span>        <span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">()</span> <span class="comment">//超声波初始化函数 产生8个40Mhz的方波信号</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        Tx = <span class="number">1</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">        Tx = <span class="number">0</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0f</span>;<span class="comment">//配置定时器1计时模式</span></span><br><span class="line">    TH1 = TL1 = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    TR1 = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (TF1 == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    TR1 = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(TF1 == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = TH1 &lt;&lt; <span class="number">8</span> | TL1;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        TF1 = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2pca写法"><a class="markdownIt-Anchor" href="#2pca写法"></a> 2.PCA写法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span> <span class="comment">//超声波距离读取函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;<span class="comment">//时间储存变量</span></span><br><span class="line">    CMOD =  <span class="number">0x00</span>;<span class="comment">//配置PCA工作模式</span></span><br><span class="line">    CH = CL = <span class="number">0</span>;<span class="comment">//复位计数值 等待超声波信号发出</span></span><br><span class="line">    Ut_Wave_Init();<span class="comment">//发送超声波信号</span></span><br><span class="line">    CR = <span class="number">1</span>;<span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((Rx == <span class="number">1</span>) &amp;&amp; (CF == <span class="number">0</span>));<span class="comment">//等待接受返回信号或者定时器溢出</span></span><br><span class="line">    CR = <span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(CF == <span class="number">0</span>) <span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = CH &lt;&lt; <span class="number">8</span> | CL;<span class="comment">//读取当前时间</span></span><br><span class="line">        <span class="keyword">return</span> (time * <span class="number">0.017</span>);<span class="comment">//返回距离值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        CF = <span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="串口"><a class="markdownIt-Anchor" href="#串口"></a> #串口</h1><h2 id="1串口底层"><a class="markdownIt-Anchor" href="#1串口底层"></a> 1.串口底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartInit</span><span class="params">(<span class="type">void</span>)</span>     <span class="comment">//9600bps@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">    SCON = <span class="number">0x50</span>;        <span class="comment">//8位数据,可变波特率</span></span><br><span class="line">    AUXR |= <span class="number">0x01</span>;       <span class="comment">//串口1选择定时器2为波特率发生器</span></span><br><span class="line">    AUXR |= <span class="number">0x04</span>;       <span class="comment">//定时器时钟1T模式</span></span><br><span class="line">    T2L = <span class="number">0xC7</span>;     <span class="comment">//设置定时初始值</span></span><br><span class="line">    T2H = <span class="number">0xFE</span>;     <span class="comment">//设置定时初始值</span></span><br><span class="line">    AUXR |= <span class="number">0x10</span>;       <span class="comment">//定时器2开始计时</span></span><br><span class="line">    ES = <span class="number">1</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字节发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line">    SBUF=dat;<span class="comment">//将dat数据赋给SBUF，将数据发送出去</span></span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);<span class="comment">//等待数据发送</span></span><br><span class="line">    TI = <span class="number">0</span>;<span class="comment">//将发送标志位清零</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串发送函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Send_String</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(*dat != <span class="string">'\0'</span>)<span class="comment">//当字符不为空时，继续发送</span></span><br><span class="line">        SendByte(*dat++);<span class="comment">//发送后指针dat加1，指向下一个字节</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口1中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1Server</span><span class="params">()</span> interrupt 4</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(RI == <span class="number">1</span>) <span class="comment">//串口接收数据</span></span><br><span class="line">    {</span><br><span class="line">        Uart_Recv[Uart_Recv_Index] = SBUF;</span><br><span class="line">        Uart_Recv_Index++;</span><br><span class="line">        RI = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-串口接收数据"><a class="markdownIt-Anchor" href="#2-串口接收数据"></a> **2. **串口接收数据</h2><p><strong>模拟题</strong></p><hr><img src="/posts/5903/clip_image002-1711190784499-119.jpg" class="" title="img"><hr><img src="/posts/5903/clip_image004-1711190784499-120.jpg" class="" title="img"><h2 id="3-串口发送数据"><a class="markdownIt-Anchor" href="#3-串口发送数据"></a> **3. **串口发送数据</h2><p><strong>模拟题</strong></p><hr><img src="/posts/5903/clip_image005.jpg" class="" title="img"><hr><img src="/posts/5903/clip_image006-1711190784499-121.jpg" class="" title="img"><ul><li><strong>内存溢出：idata/xdata/data/code</strong></li></ul><h2 id="第三部分-大模板"><a class="markdownIt-Anchor" href="#第三部分-大模板"></a> <mark>第三部分 大模板</mark></h2><h3 id="一-头文件声明区域"><a class="markdownIt-Anchor" href="#一-头文件声明区域"></a> 一、头文件声明区域</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件声明区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC15F2K60S2.H&gt;</span><span class="comment">//单片机寄存器专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span><span class="comment">//初始化底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Led.h&gt;</span><span class="comment">//Led底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span><span class="comment">//按键底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Seg.h&gt;</span><span class="comment">//数码管底层驱动专用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uart.h&gt;</span><span class="comment">//串口底层驱动专用头文件</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="二-变量声明区域"><a class="markdownIt-Anchor" href="#二-变量声明区域"></a> 二、变量声明区域</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 变量声明区 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Val,Key_Down,Key_Old,Key_Up;<span class="comment">//按键专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Slow_Down;<span class="comment">//按键减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Buf[<span class="number">8</span>] = {<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Point[<span class="number">8</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管小数点数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Seg_Pos;<span class="comment">//数码管扫描专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Seg_Slow_Down;<span class="comment">//数码管减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLed[<span class="number">8</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//Led显示数据存放数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Slow_Down;<span class="comment">//串口减速专用变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Recv[<span class="number">10</span>];<span class="comment">//串口接收数据储存数组 默认10个字节 若接收数据较长 可更改最大字节数</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Recv_Index;<span class="comment">//串口接收数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Uart_Send[<span class="number">10</span>];<span class="comment">//串口接收数据储存数组 默认10个字节 若发送数据较长 可更改最大字节数</span></span><br></pre></td></tr></tbody></table></figure><h3 id="三-按键处理函数"><a class="markdownIt-Anchor" href="#三-按键处理函数"></a> 三、按键处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 键盘处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Key_Slow_Down) <span class="keyword">return</span>;<span class="comment">//作用：使得程序在每次定时扫描过程只执行一次，即Key_Slow_Down=0时立即置1，向下执行。</span></span><br><span class="line"></span><br><span class="line">  Key_Slow_Down = <span class="number">1</span>;<span class="comment">//键盘减速程序</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  Key_Val = Key_Read();<span class="comment">//实时读取键码值</span></span><br><span class="line"></span><br><span class="line">  Key_Down = Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//捕捉按键下降沿</span></span><br><span class="line"></span><br><span class="line">  Key_Up = ~Key_Val &amp; (Key_Old ^ Key_Val);<span class="comment">//捕捉按键上降沿</span></span><br><span class="line"></span><br><span class="line">  Key_Old = Key_Val;<span class="comment">//辅助扫描变量</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="四-信息处理函数"><a class="markdownIt-Anchor" href="#四-信息处理函数"></a> 四、信息处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信息处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Seg_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Seg_Slow_Down) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Seg_Slow_Down = <span class="number">1</span>;<span class="comment">//数码管减速程序</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="五-其他显示函数"><a class="markdownIt-Anchor" href="#五-其他显示函数"></a> 五、其他显示函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 其他显示函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Led_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="六-串口处理函数"><a class="markdownIt-Anchor" href="#六-串口处理函数"></a> 六、串口处理函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Proc</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Uart_Slow_Down) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Uart_Slow_Down = <span class="number">1</span>;<span class="comment">//串口减速程序 </span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="七-定时器初始化函数"><a class="markdownIt-Anchor" href="#七-定时器初始化函数"></a> 七、定时器初始化函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器0中断初始化函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0Init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//1毫秒@12.000MHz</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  AUXR &amp;= <span class="number">0x7F</span>;    <span class="comment">//定时器时钟12T模式</span></span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;    <span class="comment">//设置定时器模式</span></span><br><span class="line"></span><br><span class="line">  TL0 = <span class="number">0x18</span>;   <span class="comment">//设置定时初始值</span></span><br><span class="line"></span><br><span class="line">  TH0 = <span class="number">0xFC</span>;   <span class="comment">//设置定时初始值</span></span><br><span class="line"></span><br><span class="line">  TF0 = <span class="number">0</span>;     <span class="comment">//清除TF0标志</span></span><br><span class="line"></span><br><span class="line">  TR0 = <span class="number">1</span>;     <span class="comment">//定时器0开始计时</span></span><br><span class="line"></span><br><span class="line">  ET0 = <span class="number">1</span>;   <span class="comment">//定时器中断0打开</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;   <span class="comment">//总中断打开</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="八-中断服务函数"><a class="markdownIt-Anchor" href="#八-中断服务函数"></a> 八、中断服务函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器0中断服务函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0Server</span><span class="params">()</span> interrupt 1</span><br><span class="line"></span><br><span class="line">{  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Key_Slow_Down == <span class="number">10</span>) Key_Slow_Down = <span class="number">0</span>;<span class="comment">//键盘减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Seg_Slow_Down == <span class="number">500</span>) Seg_Slow_Down = <span class="number">0</span>;<span class="comment">//数码管减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Uart_Slow_Down == <span class="number">200</span>) Uart_Slow_Down = <span class="number">0</span>;<span class="comment">//串口减速专用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++Seg_Pos == <span class="number">8</span>) Seg_Pos = <span class="number">0</span>;<span class="comment">//数码管显示专用</span></span><br><span class="line"></span><br><span class="line">  Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">  Led_Disp(Seg_Pos,ucLed[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="九-串口服务函数"><a class="markdownIt-Anchor" href="#九-串口服务函数"></a> 九、串口服务函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口1中断服务函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart1Server</span><span class="params">()</span> interrupt 4</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(RI == <span class="number">1</span>) <span class="comment">//串口接收数据</span></span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line">      Uart_Recv[Uart_Recv_Index] = SBUF;</span><br><span class="line">  Uart_Recv_Index++;</span><br><span class="line">      RI = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="十-主函数"><a class="markdownIt-Anchor" href="#十-主函数"></a> 十、主函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  System_Init();</span><br><span class="line"></span><br><span class="line">  Timer0Init();</span><br><span class="line"></span><br><span class="line">  UartInit();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    Key_Proc();</span><br><span class="line"></span><br><span class="line">    Seg_Proc();</span><br><span class="line"></span><br><span class="line">    Led_Proc();</span><br><span class="line"></span><br><span class="line">    Uart_Proc();</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-led模块&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-led模块&quot;&gt;&lt;/a&gt; 一、LED模块&lt;/h1&gt;
&lt;h2 id=&quot;1led底层代码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1led底层</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="蓝桥杯" scheme="https://szturin.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="C语言" scheme="https://szturin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="STC15" scheme="https://szturin.github.io/tags/STC15/"/>
    
    <category term="蓝桥杯" scheme="https://szturin.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="数字电路" scheme="https://szturin.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>【stm32单片机】[6]输入捕获和输出比较</title>
    <link href="https://szturin.github.io/posts/64385/"/>
    <id>https://szturin.github.io/posts/64385/</id>
    <published>2024-03-17T04:39:49.000Z</published>
    <updated>2024-05-03T07:53:37.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><p>xxxxxxxxxx&nbsp;$ tags: -数字电路与VHDL设计"bash</p><p>另外它们的CH1到CH4，4个通道的引脚，也是公用的</p><p>所以对于同一个定时器，输入捕获和输出比较只能用其中一个。</p><h2 id="一-输出比较"><a class="markdownIt-Anchor" href="#一-输出比较"></a> 一、输出比较</h2><img src="/posts/64385/image-20240317124437632.png" class="" title="image-20240317124437632"><img src="/posts/64385/image-20240317124510956.png" class="" title="image-20240317124510956"><p><strong>根据CNT和CCR的大小关系，从通道引脚输出高低电平</strong></p><h2 id="二-输入捕获"><a class="markdownIt-Anchor" href="#二-输入捕获"></a> 二、输入捕获</h2><img src="/posts/64385/image-20240317124716864.png" class="" title="image-20240317124716864"><img src="/posts/64385/image-20240317124815682.png" class="" title="image-20240317124815682"><p>输入滤波器：可以对毛刺信号进行滤波</p><p>交叉输入的作用？</p><p>TRC?</p><p>CNT计数器是由内部的标准时钟进行驱动的，可以用于测量外部检测两个上升沿的时间间隔，</p><p>所以需要在检测到一个上升沿过后，清零CNT，这样在第二次上升沿后，CNT值就是测周法的N，可以通过主从触发模式，自动完成。</p><p><strong>总结：</strong></p><p>输入捕获类似于外部中断。都是检测边沿，然后执行相应的动嘴，而在输入捕获中。检测到指定电平跳变后，CNT的值所存到CCR中。</p><ul><li><p>输出比较。引脚是输出端口，根据CNT和CCR的大小关系执行输出的动作。</p></li><li><p>输入捕获。引脚是输入端口，接收到输入信号，执行锁存的动作。</p></li></ul><p><strong>#主从触发模式：</strong></p><p>将主从触发模式和PWMI模式相结合，可以让硬件自动测量频率和占空比，软件无需进行干预。</p><h2 id="三-频率测量"><a class="markdownIt-Anchor" href="#三-频率测量"></a> 三、频率测量</h2><img src="/posts/64385/image-20240317125647320.png" class="" title="image-20240317125647320"><p><strong>PS：STM32测频率只能测量数字信号，若测量正选波，可以用运放电路搭建一个比较器。若测量的信号电压较高，需要考虑隔离的问题，比如隔离放大器，电压互感器等元件。总而言之，要用STM32测量频率，只能用数字信号，高电平3.3V，低电平0V</strong></p><p><strong>#区别</strong></p><ul><li><p>测频法：规定时间，记录上升沿次数，<mark>适合测量高频信号</mark>。在计次N过少时，误差会比较大。</p><p>​测频法自带均值滤波，得到的其实是平均频率。</p></li><li><p>测周法：从待测频率的第一个上升沿开始，以一个标准的频率计次，记录计数器的次数，直到检测到待测频率信号的第二个上升沿。<mark>适合测量低频信号</mark>，低频信号，周期长，计次多，有利于减小误差。</p><p>一般情况下，待测信号几百几千HZ以上，测周法更新更快，又因为测周法只测量一个周期，所以结果容易收到噪声的影响，波动较大。</p></li><li><p>两种方法都会出现正负1误差</p></li></ul><p>#<strong>中界频率</strong></p><ul><li>用于界定选用测频法还是测周法的频率</li></ul><h2 id="四-输入捕获通道"><a class="markdownIt-Anchor" href="#四-输入捕获通道"></a> 四、输入捕获通道</h2><img src="/posts/64385/image-20240317133236546.png" class="" title="image-20240317133236546"><p><mark>fDTS是滤波器的采样时钟来源。TI1是输入信号，TI1F是滤波后的信号，CCMR1寄存器中的ICF位可以控制滤波器的参数</mark></p><p>​ICF相关定义</p><img src="/posts/64385/image-20240317133728716.png" class="" title="image-20240317133728716"><p>滤波之后的信号通过后续的边沿检测器，并且可以通过CCIP选择极性。最终得到TI1FP1的触发信号，进入通道1后续的捕获电路。同样的，通道2也是一样的流程，不过图中省略了。</p><p>CC1E位，控制输出使能或失能。</p><p><strong>如何自动清零CNT？</strong></p><h3 id="主从触发模式"><a class="markdownIt-Anchor" href="#主从触发模式"></a> 主从触发模式</h3><img src="/posts/64385/image-20240317134635166.png" class="" title="image-20240317134635166"><ul><li><p>主模式可以将定时器内部的信号，映射到TRGO引脚，用于触发别的外设</p></li><li><p>从模式接收其他外设或者自身外设的一些信号，用于控制自身定时器的运行。</p></li></ul><p><strong>这里将TI1FP1作为触发源，从模式执行Reset操作，这样就可以实现CNT自动清零。</strong></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><h3 id="输入捕获基本结构"><a class="markdownIt-Anchor" href="#输入捕获基本结构"></a> 输入捕获基本结构</h3><img src="/posts/64385/image-20240317135641144.png" class="" title="image-20240317135641144"><p>这个结构只使用了一个通道，只能用于测量频率。</p><p>先转运CNT，再对CNT进行清零。</p><p>使用从模式自动清零CNT，只能用通道1和通道2。</p><h3 id="pwmi基本结构"><a class="markdownIt-Anchor" href="#pwmi基本结构"></a> PWMI基本结构</h3><img src="/posts/64385/image-20240317140209540.png" class="" title="image-20240317140209540"><p>开始，第一个上升沿，CCR1捕获并且清零CNT，CNT++。第一个下降沿，CCR2捕获CNT，但不会执行CNT清零。第二个上升沿，CCR1捕获CNT，同时CNT清零。</p><p>这样CCR1值就是整个周期的计数值，CCR2就是高电平期间的计数值。这样可以同时得到PWM的频率和占空比。</p><p>这里也可以配置两个通道同时捕获第二个引脚的输入，使用TI2FP1和TI2FP2两个引脚。</p><h1 id="代码部分"><a class="markdownIt-Anchor" href="#代码部分"></a> 代码部分</h1><blockquote><hr><p><strong>单独修改PSR值</strong></p><p>void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)</p><ul><li>TIMx：定时器</li><li>Prescaler：PSR值</li><li>TIM_PSCReloadMode：指定定时器预分频器的重装模式<ul><li>@arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event. 在更新事件中 重装<ul><li><pre><code>@arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately. 立即重装</code></pre></li></ul></li></ul></li></ul><hr><p><strong>输入捕获</strong></p><p>void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);</p><p>输入捕获函数，4个通道共用一个函数</p><hr><p><strong>给输入捕获结构体赋初值</strong></p><p>void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);</p><hr><p><strong>选择输入触发源TIGI</strong></p><p>void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><p>配置从模式的输入触发源</p><hr><p><strong>选择输出触发源TRGO</strong></p><p>void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);</p><p>配置主模式的输出触发源</p><hr><p><strong>配置从模式</strong></p><p>void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);</p><img src="/posts/64385/image-20240317150206255.png" class="" title="image-20240317150206255"><p><mark>ps:这三个从模式是给编码器接口用的，会有另外的函数进行配置</mark></p><hr><p><strong>配置通道1234的定时器</strong></p><p>void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);<br>void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);</p><hr><p><strong>读取4个通道的CCR</strong></p><p>uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);<br>uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);</p><p><strong>对于写4个通道CCR的函数</strong></p><p>void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);<br>void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);<br>void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);<br>void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);</p><p><mark>输入捕获模式下，CCR是只读的，要用GetCapture读出</mark></p><hr><p><strong><mark>TIM_PWMIConfig(TIM3,&amp;TIM_ICInitStructure);//标准库中已将上述注释部分封装好,即会将以及配置号的部分，再配置另外的通道将参数进行相反的设置</mark></strong></p><hr></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本概念&quot;&gt;&lt;/a&gt; 基本概念&lt;/h1&gt;
&lt;p&gt;xxxxxxxxxx&amp;nbsp;$ tags: -数字电路与VHDL设计&quot;bash&lt;/p&gt;
&lt;p&gt;另外它们的CH1到CH4，4个通道</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/categories/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="stm32单片机" scheme="https://szturin.github.io/tags/stm32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="输入捕获" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/"/>
    
    <category term="输出比较" scheme="https://szturin.github.io/tags/%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯单片机】第九届省赛题</title>
    <link href="https://szturin.github.io/posts/25039/"/>
    <id>https://szturin.github.io/posts/25039/</id>
    <published>2024-03-08T15:51:48.000Z</published>
    <updated>2024-03-08T16:22:45.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1><img src="/posts/25039/image-20240308235630315.png" class="" title="image-20240308235630315"><h2 id="题目分析思路"><a class="markdownIt-Anchor" href="#题目分析思路"></a> 题目分析（思路）</h2><ol><li><p>首先，定义按键所控制的相关变量</p></li><li><p>编写数码管显示的逻辑，以”设置状态为准“，测试按键是否能正常控制相关参数(工作模式、流转间隔)</p><ul><li>因为一共有四个工作模式，流转间隔定义为一个数组，存放各个元素的流转时长</li></ul></li><li><p>将工作模式1的相关逻辑（LED流转方式）编写出来</p><ul><li>这里使用一个指针用于LED的点亮(LED_OFF)，另一个用于LED的熄灭(LED_ON)</li></ul></li><li><p>将工作模式，流转间隔的逻辑与LED工作模式1关联，测试按键功能是否正常，LED是否能被流转间隔控制</p></li><li><p>如果以上程序测试正确，编写其他三个工作模式的LED模块</p><ul><li>此时进行程序测试，功能正常，但是切换其他流转模式会有上一个模式的LED”残留“ (如双LED模式切换到单LED模式时)，因此需要进行LED的复位（在按键控制模块中编写）</li></ul></li><li><p>修改完毕后，编写亮度控制，此时注意到，一个定时器0无法满足对LED扫描的同时进行亮度控制，因此再调用定时器1，用于LED的<strong>扫描指针偏移</strong>，以及LED的<strong>PWM控制亮度</strong>。</p><ul><li>这里修改完程序后，发现数码管闪烁，这是因为定时器1的频率较高，会打断主函数中数码管显示模块，因此将Nixie_Proc()函数放入定时器1中进行运行</li></ul></li><li><p>当以上各个功能全部测试完毕后，调用EEPROM模块，保存流转间隔</p></li></ol><h1 id="程序部分"><a class="markdownIt-Anchor" href="#程序部分"></a> 程序部分</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Nixie.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Timer0.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Buf[<span class="number">8</span>]={<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>};<span class="comment">//数码管显示数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Pos;<span class="comment">//数码管数据数组位下标</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_Point[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//数码管每一段的“点”数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key;<span class="comment">//键值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Key_Up,Key_Down,Key_Val,Key_Old;<span class="comment">//按键扫描变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucLED[<span class="number">8</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//LED显示数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Nixie_Timer;<span class="comment">//数码管定时更新</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Key_Timer;<span class="comment">//按键定时扫描</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Work_Mode;<span class="comment">//工作模式参数 0-模式1 1-模式2 2-模式3 3-模式4</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Set_Mode;<span class="comment">// 0-数码管熄灭 1-模式编号 2-流转间隔</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Nixie_FlashFlag;<span class="comment">//闪烁标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Timer_800ms;<span class="comment">//0.8s定时（闪烁用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> LED_Flow_Timer_Set[]={<span class="number">400</span>,<span class="number">400</span>,<span class="number">400</span>,<span class="number">400</span>};<span class="comment">//流转间隔参数,控制流转速度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> LED_Flow_Timer;<span class="comment">//流转定时</span></span><br><span class="line">bit LED_Enable=<span class="number">0</span>;<span class="comment">//LED流转使能位，1时LED流转使能，默认LED流转启动</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Level_ShowFlag;<span class="comment">//按下按键4显示LED亮度等级</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_OFF=<span class="number">7</span>;<span class="comment">//LED熄灭指针</span></span><br><span class="line"><span class="comment">/*LED亮度控制相关参数*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Count;<span class="comment">//LED显示周期</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Level;<span class="comment">//LED等级</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Pos;<span class="comment">//LED扫描位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//按键检测程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Key_Timer) <span class="keyword">return</span>;<span class="comment">//Key_Timer=0时执行下面的语句</span></span><br><span class="line">Key_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键扫描模块*/</span></span><br><span class="line">Key_Val=Key_Read();</span><br><span class="line">Key_Down=Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Up=~Key_Val &amp; (Key_Old ^ Key_Val);</span><br><span class="line">Key_Old=Key_Val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键4按下*/</span></span><br><span class="line"><span class="keyword">if</span>(Key_Old==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">LED_Level_ShowFlag=<span class="number">1</span>;<span class="comment">//显示LED亮度等级</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_Level_ShowFlag=<span class="number">0</span>;<span class="comment">//松开，LED亮度等级标志位失效</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按键控制模块*/</span></span><br><span class="line"><span class="keyword">switch</span>(Key_Down)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:<span class="comment">//按键7，用于控制LED的启动和暂停</span></span><br><span class="line">LED_Enable^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:<span class="comment">//按键6，控制设置界面</span></span><br><span class="line"><span class="keyword">if</span>(++Set_Mode==<span class="number">3</span>)</span><br><span class="line">Set_Mode=<span class="number">0</span>;</span><br><span class="line">EEPROM_Write(LED_Flow_Timer_Set,<span class="number">0x00</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//按键5</span></span><br><span class="line"><span class="keyword">if</span>(Set_Mode==<span class="number">2</span>)<span class="comment">//设置界面位于“流转间隔“对应”运行模式“的流转间隔+100ms</span></span><br><span class="line">{</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]+=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer_Set[Work_Mode]&gt;=<span class="number">1300</span>)</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]=<span class="number">400</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Set_Mode==<span class="number">1</span>)<span class="comment">//设置界面位于“运行模式”运行模式切换</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Work_Mode==<span class="number">4</span>)</span><br><span class="line">Work_Mode=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每次模式切换，对LED指针进行复位*/</span></span><br><span class="line"><span class="keyword">if</span>(Work_Mode==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为4</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为1</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">7</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为2</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">0</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//上一个模式为3</span></span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;<span class="comment">//控制熄灭的LED指针</span></span><br><span class="line">LED_ON=<span class="number">3</span>;<span class="comment">//LED点亮指针复位</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span>(Set_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]-=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer_Set[Work_Mode]&lt;=<span class="number">300</span>)</span><br><span class="line">LED_Flow_Timer_Set[Work_Mode]=<span class="number">1200</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Set_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--Work_Mode==<span class="number">255</span>)</span><br><span class="line">Work_Mode=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每次模式切换，对LED指针进行复位*/</span></span><br><span class="line"><span class="keyword">if</span>(Work_Mode==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">7</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Work_Mode==<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">LED_ON=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//信息处理/显示程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Nixie_Timer) <span class="keyword">return</span>;<span class="comment">//Nixie_Timer=0时执行下面的语句</span></span><br><span class="line">Nixie_Timer=<span class="number">1</span>;</span><br><span class="line">LED_Level=<span class="number">4</span>-((AD_Read(<span class="number">0x01</span>))/<span class="number">64</span>);</span><br><span class="line"><span class="keyword">switch</span>(Set_Mode)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Level_ShowFlag)</span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Level;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">17</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=Nixie_FlashFlag?Work_Mode:<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=(LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>)?LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>:<span class="number">10</span>;<span class="comment">//高位熄灭</span></span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Flow_Timer_Set[Work_Mode]%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Nixie_Buf[<span class="number">0</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">1</span>]=Work_Mode;</span><br><span class="line">Nixie_Buf[<span class="number">2</span>]=<span class="number">17</span>;</span><br><span class="line">Nixie_Buf[<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(Nixie_FlashFlag)</span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=(LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>)?LED_Flow_Timer_Set[Work_Mode]/<span class="number">1000</span>:<span class="number">10</span>;<span class="comment">//高位熄灭</span></span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=LED_Flow_Timer_Set[Work_Mode]/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=LED_Flow_Timer_Set[Work_Mode]%<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">Nixie_Buf[<span class="number">4</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">5</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">6</span>]=<span class="number">10</span>;</span><br><span class="line">Nixie_Buf[<span class="number">7</span>]=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Proc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//LED“报警”程序</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">if</span>(LED_Flow_Timer)<span class="keyword">return</span>;</span><br><span class="line">LED_Flow_Timer=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*LED工作模式控制模块*/</span></span><br><span class="line"><span class="keyword">switch</span>(Work_Mode)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)<span class="comment">//LED流转使能位有效</span></span><br><span class="line">{</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(++LED_ON==<span class="number">8</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">0</span>;LED_OFF=<span class="number">7</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--LED_ON==<span class="number">255</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">7</span>;LED_OFF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++LED_ON==<span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">0</span>;LED_OFF=<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">ucLED[LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_ON]=<span class="number">1</span>;</span><br><span class="line">ucLED[LED_OFF]=<span class="number">0</span>;</span><br><span class="line">ucLED[<span class="number">7</span>-LED_OFF]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(LED_Enable)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(--LED_ON==<span class="number">255</span>)</span><br><span class="line">{</span><br><span class="line">LED_ON=<span class="number">3</span>;LED_OFF=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_OFF=LED_ON+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer1_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//125微秒@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">AUXR &amp;= <span class="number">0xBF</span>;<span class="comment">//定时器时钟12T模式</span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL1 = <span class="number">0x83</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH1 = <span class="number">0xFF</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TF1 = <span class="number">0</span>;<span class="comment">//清除TF1标志</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">ET1 = <span class="number">1</span>; <span class="comment">//定时器i打开</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">EEPROM_Read(LED_Flow_Timer_Set,<span class="number">0x00</span>,<span class="number">4</span>);<span class="comment">//读取AT24C02中的数据</span></span><br><span class="line">Timer0_Init();<span class="comment">//定时器初始化</span></span><br><span class="line">Timer1_Init();</span><br><span class="line">System_Init();<span class="comment">//系统板初始化</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//循环执行任务</span></span><br><span class="line">{</span><br><span class="line">Key_Proc();</span><br><span class="line"><span class="comment">//Nixie_Proc();</span></span><br><span class="line">LED_Proc();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 1<span class="comment">//中断服务程序</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++Nixie_Timer==<span class="number">300</span>){Nixie_Timer=<span class="number">0</span>;}<span class="comment">//500ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Key_Timer==<span class="number">20</span>){Key_Timer=<span class="number">0</span>;}<span class="comment">//20ms定时长度</span></span><br><span class="line"><span class="keyword">if</span>(++Nixie_Pos==<span class="number">8</span>){Nixie_Pos=<span class="number">0</span>;}<span class="comment">//数码管动态显示</span></span><br><span class="line"><span class="keyword">if</span>(++LED_Flow_Timer&gt;=LED_Flow_Timer_Set[Work_Mode]){LED_Flow_Timer=<span class="number">0</span>;}<span class="comment">//控制LED流转速度</span></span><br><span class="line"><span class="keyword">if</span>(++LED_Count==<span class="number">13</span>){LED_Count=<span class="number">0</span>;}<span class="comment">//LED亮起的周期（PWM周期），12MS</span></span><br><span class="line"><span class="keyword">if</span>(++Timer_800ms==<span class="number">800</span>){Timer_800ms=<span class="number">0</span>;Nixie_FlashFlag^=<span class="number">1</span>;}</span><br><span class="line">Nixie_Disp(Nixie_Pos,Nixie_Buf[Nixie_Pos],Nixie_Point[Nixie_Pos]);<span class="comment">//数码管动态显示</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer1_Server</span><span class="params">(<span class="type">void</span>)</span>  interrupt 3</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(++LED_Pos==<span class="number">8</span>){LED_Pos=<span class="number">0</span>;}<span class="comment">//LED每1ms完成一次扫描</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(LED_Count&lt;((LED_Level<span class="number">-1</span>)*<span class="number">3</span>))<span class="comment">//LED占空比</span></span><br><span class="line">{</span><br><span class="line">LED_Disp(LED_Pos,ucLED[LED_Pos]);<span class="comment">//LED点亮，1ms</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">LED_Disp(LED_Pos,<span class="number">0</span>);<span class="comment">//LED熄灭,1ms</span></span><br><span class="line">}</span><br><span class="line">Nixie_Proc();<span class="comment">//如果数码管放置在主程序中，由于定时器1频率高，优先级高，主函数会被频繁打断出现闪烁现象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目要求&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目要求&quot;&gt;&lt;/a&gt; 题目要求&lt;/h1&gt;
&lt;img src=&quot;/posts/25039/image-20240308235630315.png&quot; class=&quot;&quot; title=&quot;i</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="蓝桥杯" scheme="https://szturin.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="51单片机" scheme="https://szturin.github.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="C语言" scheme="https://szturin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="STC15" scheme="https://szturin.github.io/tags/STC15/"/>
    
    <category term="蓝桥杯" scheme="https://szturin.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="数字电路" scheme="https://szturin.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>【单片机】SPI协议</title>
    <link href="https://szturin.github.io/posts/23815/"/>
    <id>https://szturin.github.io/posts/23815/</id>
    <published>2024-03-08T15:27:37.000Z</published>
    <updated>2024-05-02T08:08:14.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h1><h3 id="什么是spi"><a class="markdownIt-Anchor" href="#什么是spi"></a> 什么是SPI？</h3><p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一 种同步串行接口技术，是一种高速的，全双工，同步的通信总线。</p><p><strong>SPI优点</strong>:支持全双工通信 通信简单 数据传输速率块</p><p><strong>缺点</strong> :没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据 可靠性上有一定的缺陷。</p><p><strong>特点</strong>:</p><ol><li>高速、同步、全双工、非差分、总线式</li><li>主从机通信模式</li></ol><h1 id="蓝桥杯相关暂未使用spi"><a class="markdownIt-Anchor" href="#蓝桥杯相关暂未使用spi"></a> 蓝桥杯相关（暂未使用SPI）</h1><h2 id="ds1302时钟芯片底层"><a class="markdownIt-Anchor" href="#ds1302时钟芯片底层"></a> DS1302（时钟芯片）底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ds1302.h"</span></span></span><br><span class="line">sbit SCK=P1^<span class="number">7</span>;</span><br><span class="line">sbit SDA=P2^<span class="number">3</span>;</span><br><span class="line">sbit RST = P1^<span class="number">3</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302</span><span class="params">(<span class="type">unsigned</span>  <span class="type">char</span> temp)</span> </span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)     </span><br><span class="line">{ </span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">SDA=temp&amp;<span class="number">0x01</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">SCK=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302_Byte</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address,<span class="type">unsigned</span> <span class="type">char</span> dat )</span>     </span><br><span class="line">{</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>; _nop_();  </span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> Write_Ds1302(dat);</span><br><span class="line"> RST=<span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_Ds1302_Byte</span> <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address )</span></span><br><span class="line">{</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> i,temp=<span class="number">0x00</span>;</span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line"> RST=<span class="number">1</span>;_nop_();</span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) </span><br><span class="line"> {</span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(SDA)</span><br><span class="line"> temp|=<span class="number">0x80</span>;</span><br><span class="line"> SCK=<span class="number">1</span>;</span><br><span class="line">} </span><br><span class="line"> RST=<span class="number">0</span>;_nop_();</span><br><span class="line"> SCK=<span class="number">0</span>;_nop_();</span><br><span class="line">SCK=<span class="number">1</span>;_nop_();</span><br><span class="line">SDA=<span class="number">0</span>;_nop_();</span><br><span class="line">SDA=<span class="number">1</span>;_nop_();</span><br><span class="line"><span class="keyword">return</span> (temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写"><a class="markdownIt-Anchor" href="#基于底层的时序编写"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Set_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0</span>);<span class="comment">//关闭写保护</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x84</span>-i*<span class="number">2</span>,ucRtc[i]);<span class="comment">//给ds1302写入数据,0x84时 0x82分 0x80秒</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">1</span>);<span class="comment">//打开写保护</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Rtc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucRtc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">ucRtc[i] = Read_Ds1302_Byte(<span class="number">0x85</span>-i*<span class="number">2</span>);<span class="comment">//读取ds1302的数据</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Set_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">0</span>);<span class="comment">//关闭写保护</span></span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8c</span>,ucDate[<span class="number">0</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x88</span>,ucDate[<span class="number">1</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x86</span>,ucDate[<span class="number">2</span>]);</span><br><span class="line">Write_Ds1302_Byte(<span class="number">0x8e</span>,<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_Date</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* ucDate)</span></span><br><span class="line">{</span><br><span class="line">ucDate[<span class="number">0</span>] = Read_Ds1302_Byte(<span class="number">0x8d</span>);</span><br><span class="line">ucDate[<span class="number">1</span>] = Read_Ds1302_Byte(<span class="number">0x89</span>);</span><br><span class="line">ucDate[<span class="number">2</span>] = Read_Ds1302_Byte(<span class="number">0x87</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="超声波底层"><a class="markdownIt-Anchor" href="#超声波底层"></a> 超声波底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ultrasonic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit TX = P1^<span class="number">0</span>;</span><br><span class="line">sbit RX = P1^<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//超声波初始化函数 产生8个40Mhz的方波信号</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        TX=<span class="number">1</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">        TX=<span class="number">0</span>;</span><br><span class="line">        Delay12us();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基于底层的时序编写-2"><a class="markdownIt-Anchor" href="#基于底层的时序编写-2"></a> 基于底层的时序编写</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Ut_Wave_Data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;</span><br><span class="line">    TL1=TH1=<span class="number">0</span>;</span><br><span class="line">    Ut_Wave_Init();</span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">while</span>((RX==<span class="number">1</span>) &amp;&amp; (TF1==<span class="number">0</span>));<span class="comment">//等待超声波返回或定时器溢出</span></span><br><span class="line"></span><br><span class="line">    TR1=<span class="number">0</span>;<span class="comment">//停止计时</span></span><br><span class="line">    <span class="keyword">if</span>(TF1==<span class="number">0</span>)<span class="comment">//定时器没有溢出</span></span><br><span class="line">    {</span><br><span class="line">        time = TH1&lt;&lt;<span class="number">8</span> | TL1;</span><br><span class="line">        <span class="keyword">return</span> (time *<span class="number">0.017</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        TF1=<span class="number">0</span>;<span class="comment">//清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础概念&quot;&gt;&lt;/a&gt; 基础概念&lt;/h1&gt;
&lt;h3 id=&quot;什么是spi&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是spi&quot;&gt;&lt;/a&gt; 什么是S</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【单片机】OneWire通信协议</title>
    <link href="https://szturin.github.io/posts/46163/"/>
    <id>https://szturin.github.io/posts/46163/</id>
    <published>2024-03-08T15:13:29.000Z</published>
    <updated>2024-05-02T08:08:13.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-onewire单总线协议"><a class="markdownIt-Anchor" href="#一-onewire单总线协议"></a> 一、OneWire（单总线）协议</h3><p>•单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线</p><p>•一根通信线：DQ</p><p>•异步、半双工</p><p>•单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线</p><h3 id="二-单总线电路规范"><a class="markdownIt-Anchor" href="#二-单总线电路规范"></a> 二、单总线电路规范</h3><p>•设备的DQ均要配置成开漏输出模式</p><p>•DQ添加一个上拉电阻，阻值一般为4.7KΩ左右</p><p>•若此总线的从机采取寄生供电，则主机还应配一个强上拉输出电路</p><img src="/posts/46163/image-20240302232447437.png" class="" title="image-20240302232447437"><h3 id="三-单总线的时序结构"><a class="markdownIt-Anchor" href="#三-单总线的时序结构"></a> 三、单总线的时序结构</h3><img src="/posts/46163/image-20240302232633388.png" class="" title="image-20240302232633388"><img src="/posts/46163/image-20240302232648244.png" class="" title="image-20240302232648244"><img src="/posts/46163/image-20240302232700200.png" class="" title="image-20240302232700200"><img src="/posts/46163/image-20240302232708528.png" class="" title="image-20240302232708528"><hr><h1 id="蓝桥杯相关"><a class="markdownIt-Anchor" href="#蓝桥杯相关"></a> 蓝桥杯相关</h1><h2 id="onewire底层"><a class="markdownIt-Anchor" href="#onewire底层"></a> OneWire底层</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"onewire.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"reg52.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit DQ = P1^<span class="number">4</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线内部延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_OneWire</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>  </span><br><span class="line">{</span><br><span class="line">t *= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线写操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_DS18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">DQ = dat&amp;<span class="number">0x01</span>;</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单总线读操作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_DS18B20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">{</span><br><span class="line">DQ = <span class="number">0</span>;</span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">DQ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(DQ)</span><br><span class="line">{</span><br><span class="line">dat |= <span class="number">0x80</span>;</span><br><span class="line">}    </span><br><span class="line">Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//DS18B20初始化</span></span><br><span class="line">bit <span class="title function_">init_ds18b20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  bit initflag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">12</span>);</span><br><span class="line">  DQ = <span class="number">0</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">80</span>);</span><br><span class="line">  DQ = <span class="number">1</span>;</span><br><span class="line">  Delay_OneWire(<span class="number">10</span>); </span><br><span class="line">    initflag = DQ;     </span><br><span class="line">  Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> initflag;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ds18b20温度读取时序"><a class="markdownIt-Anchor" href="#ds18b20温度读取时序"></a> DS18B20温度读取时序</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基于底层编写*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">ds18b20_read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> low,high;<span class="comment">//高八位，低八位，DS18B20温度数据是十六位二进制</span></span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0x44</span>);<span class="comment">//ds18b20开始温度转换</span></span><br><span class="line">    </span><br><span class="line">init_ds18b20();<span class="comment">//ds18b20初始化时序</span></span><br><span class="line">Write_DS18B20(<span class="number">0xcc</span>);<span class="comment">//ds18b20跳过rom指令</span></span><br><span class="line">Write_DS18B20(<span class="number">0xbe</span>);<span class="comment">//ds18b20开始温度读取</span></span><br><span class="line">low=Read_DS18B20();</span><br><span class="line">high=Read_DS18B20();</span><br><span class="line"><span class="keyword">return</span>((high &lt;&lt; <span class="number">8</span> )| low) /<span class="number">16.0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一-onewire单总线协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-onewire单总线协议&quot;&gt;&lt;/a&gt; 一、OneWire（单总线）协议&lt;/h3&gt;
&lt;p&gt;•单总线（1-Wire BUS）是由Dallas公司开发的一种通用数</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单片机" scheme="https://szturin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="https://szturin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
</feed>
